module.exports = {

"[project]/node_modules/@tldraw/store/dist-esm/lib/ImmutableMap.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/*!
 * This file was lovingly and delicately extracted from Immutable.js
 * MIT License: https://github.com/immutable-js/immutable-js/blob/main/LICENSE
 * Copyright (c) 2014-present, Lee Byron and other contributors.
 */ __turbopack_context__.s({
    "ImmutableMap": (()=>ImmutableMap),
    "emptyMap": (()=>emptyMap),
    "iteratorDone": (()=>iteratorDone)
});
function smi(i32) {
    return i32 >>> 1 & 1073741824 | i32 & 3221225471;
}
const defaultValueOf = Object.prototype.valueOf;
function hash(o) {
    if (o == null) {
        return hashNullish(o);
    }
    if (typeof o.hashCode === "function") {
        return smi(o.hashCode(o));
    }
    const v = valueOf(o);
    if (v == null) {
        return hashNullish(v);
    }
    switch(typeof v){
        case "boolean":
            return v ? 1108378657 : 1108378656;
        case "number":
            return hashNumber(v);
        case "string":
            return v.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(v) : hashString(v);
        case "object":
        case "function":
            return hashJSObj(v);
        case "symbol":
            return hashSymbol(v);
        default:
            if (typeof v.toString === "function") {
                return hashString(v.toString());
            }
            throw new Error("Value type " + typeof v + " cannot be hashed.");
    }
}
function hashNullish(nullish) {
    return nullish === null ? 1108378658 : 1108378659;
}
function hashNumber(n) {
    if (n !== n || n === Infinity) {
        return 0;
    }
    let hash2 = n | 0;
    if (hash2 !== n) {
        hash2 ^= n * 4294967295;
    }
    while(n > 4294967295){
        n /= 4294967295;
        hash2 ^= n;
    }
    return smi(hash2);
}
function cachedHashString(string) {
    let hashed = stringHashCache[string];
    if (hashed === void 0) {
        hashed = hashString(string);
        if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
            STRING_HASH_CACHE_SIZE = 0;
            stringHashCache = {};
        }
        STRING_HASH_CACHE_SIZE++;
        stringHashCache[string] = hashed;
    }
    return hashed;
}
function hashString(string) {
    let hashed = 0;
    for(let ii = 0; ii < string.length; ii++){
        hashed = 31 * hashed + string.charCodeAt(ii) | 0;
    }
    return smi(hashed);
}
function hashSymbol(sym) {
    let hashed = symbolMap[sym];
    if (hashed !== void 0) {
        return hashed;
    }
    hashed = nextHash();
    symbolMap[sym] = hashed;
    return hashed;
}
function hashJSObj(obj) {
    let hashed = weakMap.get(obj);
    if (hashed !== void 0) {
        return hashed;
    }
    hashed = nextHash();
    weakMap.set(obj, hashed);
    return hashed;
}
function valueOf(obj) {
    return obj.valueOf !== defaultValueOf && typeof obj.valueOf === "function" ? obj.valueOf(obj) : obj;
}
function nextHash() {
    const nextHash2 = ++_objHashUID;
    if (_objHashUID & 1073741824) {
        _objHashUID = 0;
    }
    return nextHash2;
}
const weakMap = /* @__PURE__ */ new WeakMap();
const symbolMap = /* @__PURE__ */ Object.create(null);
let _objHashUID = 0;
const STRING_HASH_CACHE_MIN_STRLEN = 16;
const STRING_HASH_CACHE_MAX_SIZE = 255;
let STRING_HASH_CACHE_SIZE = 0;
let stringHashCache = {};
const SHIFT = 5;
const SIZE = 1 << SHIFT;
const MASK = SIZE - 1;
const NOT_SET = {};
function MakeRef() {
    return {
        value: false
    };
}
function SetRef(ref) {
    if (ref) {
        ref.value = true;
    }
}
function arrCopy(arr, offset) {
    offset = offset || 0;
    const len = Math.max(0, arr.length - offset);
    const newArr = new Array(len);
    for(let ii = 0; ii < len; ii++){
        newArr[ii] = arr[ii + offset];
    }
    return newArr;
}
const is = Object.is;
class OwnerID {
}
class ImmutableMap {
    // @pragma Construction
    // @ts-ignore
    _root;
    // @ts-ignore
    size;
    // @ts-ignore
    __ownerID;
    // @ts-ignore
    __hash;
    // @ts-ignore
    __altered;
    constructor(value){
        return value === void 0 || value === null ? emptyMap() : value instanceof ImmutableMap ? value : emptyMap().withMutations((map)=>{
            for (const [k, v] of value){
                map.set(k, v);
            }
        });
    }
    get(k, notSetValue) {
        return this._root ? this._root.get(0, void 0, k, notSetValue) : notSetValue;
    }
    set(k, v) {
        return updateMap(this, k, v);
    }
    delete(k) {
        return updateMap(this, k, NOT_SET);
    }
    deleteAll(keys) {
        return this.withMutations((map)=>{
            for (const key of keys){
                map.delete(key);
            }
        });
    }
    __ensureOwner(ownerID) {
        if (ownerID === this.__ownerID) {
            return this;
        }
        if (!ownerID) {
            if (this.size === 0) {
                return emptyMap();
            }
            this.__ownerID = ownerID;
            this.__altered = false;
            return this;
        }
        return makeMap(this.size, this._root, ownerID, this.__hash);
    }
    withMutations(fn) {
        const mutable = this.asMutable();
        fn(mutable);
        return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
    }
    wasAltered() {
        return this.__altered;
    }
    asMutable() {
        return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
    }
    [Symbol.iterator]() {
        return this.entries()[Symbol.iterator]();
    }
    entries() {
        return new MapIterator(this, ITERATE_ENTRIES, false);
    }
    keys() {
        return new MapIterator(this, ITERATE_KEYS, false);
    }
    values() {
        return new MapIterator(this, ITERATE_VALUES, false);
    }
}
class ArrayMapNode {
    constructor(ownerID, entries){
        this.ownerID = ownerID;
        this.entries = entries;
    }
    get(_shift, _keyHash, key, notSetValue) {
        const entries = this.entries;
        for(let ii = 0, len = entries.length; ii < len; ii++){
            if (is(key, entries[ii][0])) {
                return entries[ii][1];
            }
        }
        return notSetValue;
    }
    update(ownerID, _shift, _keyHash, key, value, didChangeSize, didAlter) {
        const removed = value === NOT_SET;
        const entries = this.entries;
        let idx = 0;
        const len = entries.length;
        for(; idx < len; idx++){
            if (is(key, entries[idx][0])) {
                break;
            }
        }
        const exists = idx < len;
        if (exists ? entries[idx][1] === value : removed) {
            return this;
        }
        SetRef(didAlter);
        (removed || !exists) && SetRef(didChangeSize);
        if (removed && entries.length === 1) {
            return;
        }
        if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
            return createNodes(ownerID, entries, key, value);
        }
        const isEditable = ownerID && ownerID === this.ownerID;
        const newEntries = isEditable ? entries : arrCopy(entries);
        if (exists) {
            if (removed) {
                idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
            } else {
                newEntries[idx] = [
                    key,
                    value
                ];
            }
        } else {
            newEntries.push([
                key,
                value
            ]);
        }
        if (isEditable) {
            this.entries = newEntries;
            return this;
        }
        return new ArrayMapNode(ownerID, newEntries);
    }
}
class BitmapIndexedNode {
    constructor(ownerID, bitmap, nodes){
        this.ownerID = ownerID;
        this.bitmap = bitmap;
        this.nodes = nodes;
    }
    get(shift, keyHash, key, notSetValue) {
        if (keyHash === void 0) {
            keyHash = hash(key);
        }
        const bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);
        const bitmap = this.bitmap;
        return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & bit - 1)].get(shift + SHIFT, keyHash, key, notSetValue);
    }
    update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
        if (keyHash === void 0) {
            keyHash = hash(key);
        }
        const keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
        const bit = 1 << keyHashFrag;
        const bitmap = this.bitmap;
        const exists = (bitmap & bit) !== 0;
        if (!exists && value === NOT_SET) {
            return this;
        }
        const idx = popCount(bitmap & bit - 1);
        const nodes = this.nodes;
        const node = exists ? nodes[idx] : void 0;
        const newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
        if (newNode === node) {
            return this;
        }
        if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
            return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
        }
        if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
            return nodes[idx ^ 1];
        }
        if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
            return newNode;
        }
        const isEditable = ownerID && ownerID === this.ownerID;
        const newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
        const newNodes = exists ? newNode ? setAt(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);
        if (isEditable) {
            this.bitmap = newBitmap;
            this.nodes = newNodes;
            return this;
        }
        return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
    }
}
class HashArrayMapNode {
    constructor(ownerID, count, nodes){
        this.ownerID = ownerID;
        this.count = count;
        this.nodes = nodes;
    }
    get(shift, keyHash, key, notSetValue) {
        if (keyHash === void 0) {
            keyHash = hash(key);
        }
        const idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
        const node = this.nodes[idx];
        return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
    }
    update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
        if (keyHash === void 0) {
            keyHash = hash(key);
        }
        const idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
        const removed = value === NOT_SET;
        const nodes = this.nodes;
        const node = nodes[idx];
        if (removed && !node) {
            return this;
        }
        const newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
        if (newNode === node) {
            return this;
        }
        let newCount = this.count;
        if (!node) {
            newCount++;
        } else if (!newNode) {
            newCount--;
            if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
                return packNodes(ownerID, nodes, newCount, idx);
            }
        }
        const isEditable = ownerID && ownerID === this.ownerID;
        const newNodes = setAt(nodes, idx, newNode, isEditable);
        if (isEditable) {
            this.count = newCount;
            this.nodes = newNodes;
            return this;
        }
        return new HashArrayMapNode(ownerID, newCount, newNodes);
    }
}
class HashCollisionNode {
    constructor(ownerID, keyHash, entries){
        this.ownerID = ownerID;
        this.keyHash = keyHash;
        this.entries = entries;
    }
    get(shift, keyHash, key, notSetValue) {
        const entries = this.entries;
        for(let ii = 0, len = entries.length; ii < len; ii++){
            if (is(key, entries[ii][0])) {
                return entries[ii][1];
            }
        }
        return notSetValue;
    }
    update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
        if (keyHash === void 0) {
            keyHash = hash(key);
        }
        const removed = value === NOT_SET;
        if (keyHash !== this.keyHash) {
            if (removed) {
                return this;
            }
            SetRef(didAlter);
            SetRef(didChangeSize);
            return mergeIntoNode(this, ownerID, shift, keyHash, [
                key,
                value
            ]);
        }
        const entries = this.entries;
        let idx = 0;
        const len = entries.length;
        for(; idx < len; idx++){
            if (is(key, entries[idx][0])) {
                break;
            }
        }
        const exists = idx < len;
        if (exists ? entries[idx][1] === value : removed) {
            return this;
        }
        SetRef(didAlter);
        (removed || !exists) && SetRef(didChangeSize);
        if (removed && len === 2) {
            return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
        }
        const isEditable = ownerID && ownerID === this.ownerID;
        const newEntries = isEditable ? entries : arrCopy(entries);
        if (exists) {
            if (removed) {
                idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
            } else {
                newEntries[idx] = [
                    key,
                    value
                ];
            }
        } else {
            newEntries.push([
                key,
                value
            ]);
        }
        if (isEditable) {
            this.entries = newEntries;
            return this;
        }
        return new HashCollisionNode(ownerID, this.keyHash, newEntries);
    }
}
class ValueNode {
    constructor(ownerID, keyHash, entry){
        this.ownerID = ownerID;
        this.keyHash = keyHash;
        this.entry = entry;
    }
    get(shift, keyHash, key, notSetValue) {
        return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
    }
    update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
        const removed = value === NOT_SET;
        const keyMatch = is(key, this.entry[0]);
        if (keyMatch ? value === this.entry[1] : removed) {
            return this;
        }
        SetRef(didAlter);
        if (removed) {
            SetRef(didChangeSize);
            return;
        }
        if (keyMatch) {
            if (ownerID && ownerID === this.ownerID) {
                this.entry[1] = value;
                return this;
            }
            return new ValueNode(ownerID, this.keyHash, [
                key,
                value
            ]);
        }
        SetRef(didChangeSize);
        return mergeIntoNode(this, ownerID, shift, hash(key), [
            key,
            value
        ]);
    }
}
class MapIterator {
    constructor(map, _type, _reverse){
        this._type = _type;
        this._reverse = _reverse;
        this._stack = map._root && mapIteratorFrame(map._root);
    }
    _stack;
    [Symbol.iterator]() {
        return this;
    }
    next() {
        const type = this._type;
        let stack = this._stack;
        while(stack){
            const node = stack.node;
            const index = stack.index++;
            let maxIndex;
            if (node.entry) {
                if (index === 0) {
                    return mapIteratorValue(type, node.entry);
                }
            } else if ("entries" in node && node.entries) {
                maxIndex = node.entries.length - 1;
                if (index <= maxIndex) {
                    return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
                }
            } else {
                maxIndex = node.nodes.length - 1;
                if (index <= maxIndex) {
                    const subNode = node.nodes[this._reverse ? maxIndex - index : index];
                    if (subNode) {
                        if (subNode.entry) {
                            return mapIteratorValue(type, subNode.entry);
                        }
                        stack = this._stack = mapIteratorFrame(subNode, stack);
                    }
                    continue;
                }
            }
            stack = this._stack = this._stack.__prev;
        }
        return iteratorDone();
    }
}
function mapIteratorValue(type, entry) {
    return iteratorValue(type, entry[0], entry[1]);
}
function mapIteratorFrame(node, prev) {
    return {
        node,
        index: 0,
        __prev: prev
    };
}
const ITERATE_KEYS = 0;
const ITERATE_VALUES = 1;
const ITERATE_ENTRIES = 2;
function iteratorValue(type, k, v, iteratorResult) {
    const value = type === ITERATE_KEYS ? k : type === ITERATE_VALUES ? v : [
        k,
        v
    ];
    iteratorResult ? iteratorResult.value = value : iteratorResult = {
        value,
        done: false
    };
    return iteratorResult;
}
function iteratorDone() {
    return {
        value: void 0,
        done: true
    };
}
function makeMap(size, root, ownerID, hash2) {
    const map = Object.create(ImmutableMap.prototype);
    map.size = size;
    map._root = root;
    map.__ownerID = ownerID;
    map.__hash = hash2;
    map.__altered = false;
    return map;
}
let EMPTY_MAP;
function emptyMap() {
    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
}
function updateMap(map, k, v) {
    let newRoot;
    let newSize;
    if (!map._root) {
        if (v === NOT_SET) {
            return map;
        }
        newSize = 1;
        newRoot = new ArrayMapNode(map.__ownerID, [
            [
                k,
                v
            ]
        ]);
    } else {
        const didChangeSize = MakeRef();
        const didAlter = MakeRef();
        newRoot = updateNode(map._root, map.__ownerID, 0, void 0, k, v, didChangeSize, didAlter);
        if (!didAlter.value) {
            return map;
        }
        newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
    }
    if (map.__ownerID) {
        map.size = newSize;
        map._root = newRoot;
        map.__hash = void 0;
        map.__altered = true;
        return map;
    }
    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
}
function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
    if (!node) {
        if (value === NOT_SET) {
            return node;
        }
        SetRef(didAlter);
        SetRef(didChangeSize);
        return new ValueNode(ownerID, keyHash, [
            key,
            value
        ]);
    }
    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
}
function isLeafNode(node) {
    return node.constructor === ValueNode || node.constructor === HashCollisionNode;
}
function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
    if (node.keyHash === keyHash) {
        return new HashCollisionNode(ownerID, keyHash, [
            node.entry,
            entry
        ]);
    }
    const idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
    const idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
    let newNode;
    const nodes = idx1 === idx2 ? [
        mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)
    ] : (newNode = new ValueNode(ownerID, keyHash, entry), idx1 < idx2 ? [
        node,
        newNode
    ] : [
        newNode,
        node
    ]);
    return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);
}
function createNodes(ownerID, entries, key, value) {
    if (!ownerID) {
        ownerID = new OwnerID();
    }
    let node = new ValueNode(ownerID, hash(key), [
        key,
        value
    ]);
    for(let ii = 0; ii < entries.length; ii++){
        const entry = entries[ii];
        node = node.update(ownerID, 0, void 0, entry[0], entry[1]);
    }
    return node;
}
function packNodes(ownerID, nodes, count, excluding) {
    let bitmap = 0;
    let packedII = 0;
    const packedNodes = new Array(count);
    for(let ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1){
        const node = nodes[ii];
        if (node !== void 0 && ii !== excluding) {
            bitmap |= bit;
            packedNodes[packedII++] = node;
        }
    }
    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
}
function expandNodes(ownerID, nodes, bitmap, including, node) {
    let count = 0;
    const expandedNodes = new Array(SIZE);
    for(let ii = 0; bitmap !== 0; ii++, bitmap >>>= 1){
        expandedNodes[ii] = bitmap & 1 ? nodes[count++] : void 0;
    }
    expandedNodes[including] = node;
    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
}
function popCount(x) {
    x -= x >> 1 & 1431655765;
    x = (x & 858993459) + (x >> 2 & 858993459);
    x = x + (x >> 4) & 252645135;
    x += x >> 8;
    x += x >> 16;
    return x & 127;
}
function setAt(array, idx, val, canEdit) {
    const newArray = canEdit ? array : arrCopy(array);
    newArray[idx] = val;
    return newArray;
}
function spliceIn(array, idx, val, canEdit) {
    const newLen = array.length + 1;
    if (canEdit && idx + 1 === newLen) {
        array[idx] = val;
        return array;
    }
    const newArray = new Array(newLen);
    let after = 0;
    for(let ii = 0; ii < newLen; ii++){
        if (ii === idx) {
            newArray[ii] = val;
            after = -1;
        } else {
            newArray[ii] = array[ii + after];
        }
    }
    return newArray;
}
function spliceOut(array, idx, canEdit) {
    const newLen = array.length - 1;
    if (canEdit && idx === newLen) {
        array.pop();
        return array;
    }
    const newArray = new Array(newLen);
    let after = 0;
    for(let ii = 0; ii < newLen; ii++){
        if (ii === idx) {
            after = 1;
        }
        newArray[ii] = array[ii + after];
    }
    return newArray;
}
const MAX_ARRAY_MAP_SIZE = SIZE / 4;
const MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
const MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;
;
 //# sourceMappingURL=ImmutableMap.mjs.map
}}),
"[project]/node_modules/@tldraw/store/dist-esm/lib/AtomMap.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "AtomMap": (()=>AtomMap)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/state/dist-esm/index.mjs [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$Atom$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/state/dist-esm/lib/Atom.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$transactions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/state/dist-esm/lib/transactions.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$Computed$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/state/dist-esm/lib/Computed.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/index.mjs [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/lib/control.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$ImmutableMap$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/store/dist-esm/lib/ImmutableMap.mjs [app-ssr] (ecmascript)");
;
;
;
class AtomMap {
    constructor(name, entries){
        this.name = name;
        let atoms = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$ImmutableMap$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["emptyMap"])();
        if (entries) {
            atoms = atoms.withMutations((atoms2)=>{
                for (const [k, v] of entries){
                    atoms2.set(k, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$Atom$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["atom"])(`${name}:${String(k)}`, v));
                }
            });
        }
        this.atoms = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$Atom$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["atom"])(`${name}:atoms`, atoms);
    }
    atoms;
    /** @internal */ getAtom(key) {
        const valueAtom = this.atoms.__unsafe__getWithoutCapture().get(key);
        if (!valueAtom) {
            this.atoms.get();
            return void 0;
        }
        return valueAtom;
    }
    get(key) {
        const value = this.getAtom(key)?.get();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(value !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$Computed$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UNINITIALIZED"]);
        return value;
    }
    __unsafe__getWithoutCapture(key) {
        const valueAtom = this.atoms.__unsafe__getWithoutCapture().get(key);
        if (!valueAtom) return void 0;
        const value = valueAtom.__unsafe__getWithoutCapture();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(value !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$Computed$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UNINITIALIZED"]);
        return value;
    }
    has(key) {
        const valueAtom = this.getAtom(key);
        if (!valueAtom) {
            return false;
        }
        return valueAtom.get() !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$Computed$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UNINITIALIZED"];
    }
    __unsafe__hasWithoutCapture(key) {
        const valueAtom = this.atoms.__unsafe__getWithoutCapture().get(key);
        if (!valueAtom) return false;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(valueAtom.__unsafe__getWithoutCapture() !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$Computed$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UNINITIALIZED"]);
        return true;
    }
    set(key, value) {
        const existingAtom = this.atoms.__unsafe__getWithoutCapture().get(key);
        if (existingAtom) {
            existingAtom.set(value);
        } else {
            this.atoms.update((atoms)=>{
                return atoms.set(key, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$Atom$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["atom"])(`${this.name}:${String(key)}`, value));
            });
        }
        return this;
    }
    update(key, updater) {
        const valueAtom = this.atoms.__unsafe__getWithoutCapture().get(key);
        if (!valueAtom) {
            throw new Error(`AtomMap: key ${key} not found`);
        }
        const value = valueAtom.__unsafe__getWithoutCapture();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(value !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$Computed$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UNINITIALIZED"]);
        valueAtom.set(updater(value));
    }
    delete(key) {
        const valueAtom = this.atoms.__unsafe__getWithoutCapture().get(key);
        if (!valueAtom) {
            return false;
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$transactions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["transact"])(()=>{
            valueAtom.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$Computed$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UNINITIALIZED"]);
            this.atoms.update((atoms)=>{
                return atoms.delete(key);
            });
        });
        return true;
    }
    deleteMany(keys) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$transactions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["transact"])(()=>{
            const deleted = [];
            const newAtoms = this.atoms.get().withMutations((atoms)=>{
                for (const key of keys){
                    const valueAtom = atoms.get(key);
                    if (!valueAtom) continue;
                    const oldValue = valueAtom.get();
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(oldValue !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$Computed$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UNINITIALIZED"]);
                    deleted.push([
                        key,
                        oldValue
                    ]);
                    atoms.delete(key);
                    valueAtom.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$Computed$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UNINITIALIZED"]);
                }
            });
            if (deleted.length) {
                this.atoms.set(newAtoms);
            }
            return deleted;
        });
    }
    clear() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$transactions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["transact"])(()=>{
            for (const valueAtom of this.atoms.__unsafe__getWithoutCapture().values()){
                valueAtom.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$Computed$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UNINITIALIZED"]);
            }
            this.atoms.set((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$ImmutableMap$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["emptyMap"])());
        });
    }
    *entries() {
        for (const [key, valueAtom] of this.atoms.get()){
            const value = valueAtom.get();
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(value !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$Computed$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UNINITIALIZED"]);
            yield [
                key,
                value
            ];
        }
    }
    *keys() {
        for (const key of this.atoms.get().keys()){
            yield key;
        }
    }
    *values() {
        for (const valueAtom of this.atoms.get().values()){
            const value = valueAtom.get();
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(value !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$Computed$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UNINITIALIZED"]);
            yield value;
        }
    }
    // eslint-disable-next-line no-restricted-syntax
    get size() {
        return this.atoms.get().size;
    }
    forEach(callbackfn, thisArg) {
        for (const [key, value] of this.entries()){
            callbackfn.call(thisArg, value, key, this);
        }
    }
    [Symbol.iterator]() {
        return this.entries();
    }
    [Symbol.toStringTag] = "AtomMap";
}
;
 //# sourceMappingURL=AtomMap.mjs.map
}}),
"[project]/node_modules/@tldraw/store/dist-esm/lib/devFreeze.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "devFreeze": (()=>devFreeze)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/index.mjs [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$value$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/lib/value.mjs [app-ssr] (ecmascript)");
;
function devFreeze(object) {
    if ("TURBOPACK compile-time falsy", 0) {
        "TURBOPACK unreachable";
    }
    const proto = Object.getPrototypeOf(object);
    if (proto && !(Array.isArray(object) || proto === Object.prototype || proto === null || proto === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$value$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["STRUCTURED_CLONE_OBJECT_PROTOTYPE"])) {
        console.error("cannot include non-js data in a record", object);
        throw new Error("cannot include non-js data in a record");
    }
    const propNames = Object.getOwnPropertyNames(object);
    for (const name of propNames){
        const value = object[name];
        if (value && typeof value === "object") {
            devFreeze(value);
        }
    }
    return Object.freeze(object);
}
;
 //# sourceMappingURL=devFreeze.mjs.map
}}),
"[project]/node_modules/@tldraw/store/dist-esm/lib/IncrementalSetConstructor.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "IncrementalSetConstructor": (()=>IncrementalSetConstructor)
});
class IncrementalSetConstructor {
    constructor(previousValue){
        this.previousValue = previousValue;
    }
    /**
   * The next value of the set.
   *
   * @internal
   */ nextValue;
    /**
   * The diff of the set.
   *
   * @internal
   */ diff;
    /**
   * Get the next value of the set.
   *
   * @public
   */ get() {
        const numRemoved = this.diff?.removed?.size ?? 0;
        const numAdded = this.diff?.added?.size ?? 0;
        if (numRemoved === 0 && numAdded === 0) {
            return void 0;
        }
        return {
            value: this.nextValue,
            diff: this.diff
        };
    }
    /**
   * Add an item to the set.
   *
   * @param item - The item to add.
   * @param wasAlreadyPresent - Whether the item was already present in the set.
   * @internal
   */ _add(item, wasAlreadyPresent) {
        this.nextValue ??= new Set(this.previousValue);
        this.nextValue.add(item);
        this.diff ??= {};
        if (wasAlreadyPresent) {
            this.diff.removed?.delete(item);
        } else {
            this.diff.added ??= /* @__PURE__ */ new Set();
            this.diff.added.add(item);
        }
    }
    /**
   * Add an item to the set.
   *
   * @param item - The item to add.
   * @public
   */ add(item) {
        const wasAlreadyPresent = this.previousValue.has(item);
        if (wasAlreadyPresent) {
            const wasRemoved = this.diff?.removed?.has(item);
            if (!wasRemoved) return;
            return this._add(item, wasAlreadyPresent);
        }
        const isCurrentlyPresent = this.nextValue?.has(item);
        if (isCurrentlyPresent) return;
        this._add(item, wasAlreadyPresent);
    }
    /**
   * Remove an item from the set.
   *
   * @param item - The item to remove.
   * @param wasAlreadyPresent - Whether the item was already present in the set.
   * @internal
   */ _remove(item, wasAlreadyPresent) {
        this.nextValue ??= new Set(this.previousValue);
        this.nextValue.delete(item);
        this.diff ??= {};
        if (wasAlreadyPresent) {
            this.diff.removed ??= /* @__PURE__ */ new Set();
            this.diff.removed.add(item);
        } else {
            this.diff.added?.delete(item);
        }
    }
    /**
   * Remove an item from the set.
   *
   * @param item - The item to remove.
   * @public
   */ remove(item) {
        const wasAlreadyPresent = this.previousValue.has(item);
        if (!wasAlreadyPresent) {
            const wasAdded = this.diff?.added?.has(item);
            if (!wasAdded) return;
            return this._remove(item, wasAlreadyPresent);
        }
        const hasAlreadyBeenRemoved = this.diff?.removed?.has(item);
        if (hasAlreadyBeenRemoved) return;
        this._remove(item, wasAlreadyPresent);
    }
}
;
 //# sourceMappingURL=IncrementalSetConstructor.mjs.map
}}),
"[project]/node_modules/@tldraw/store/dist-esm/lib/migrate.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "MigrationFailureReason": (()=>MigrationFailureReason),
    "createMigrationIds": (()=>createMigrationIds),
    "createMigrationSequence": (()=>createMigrationSequence),
    "createRecordMigrationSequence": (()=>createRecordMigrationSequence),
    "defineMigrations": (()=>defineMigrations),
    "parseMigrationId": (()=>parseMigrationId),
    "sortMigrations": (()=>sortMigrations),
    "validateMigrations": (()=>validateMigrations)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/index.mjs [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/lib/control.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/lib/object.mjs [app-ssr] (ecmascript)");
;
let didWarn = false;
function defineMigrations(opts) {
    const { currentVersion, firstVersion, migrators = {}, subTypeKey, subTypeMigrations } = opts;
    if (!didWarn) {
        console.warn(`The 'defineMigrations' function is deprecated and will be removed in a future release. Use the new migrations API instead. See the migration guide for more info: https://tldraw.dev/docs/persistence#Updating-legacy-shape-migrations-defineMigrations`);
        didWarn = true;
    }
    if (typeof currentVersion === "number" && typeof firstVersion === "number") {
        if (currentVersion === firstVersion) {
            throw Error(`Current version is equal to initial version.`);
        } else if (currentVersion < firstVersion) {
            throw Error(`Current version is lower than initial version.`);
        }
    }
    return {
        firstVersion: firstVersion ?? 0,
        // defaults
        currentVersion: currentVersion ?? 0,
        // defaults
        migrators,
        subTypeKey,
        subTypeMigrations
    };
}
function squashDependsOn(sequence) {
    const result = [];
    for(let i = sequence.length - 1; i >= 0; i--){
        const elem = sequence[i];
        if (!("id" in elem)) {
            const dependsOn = elem.dependsOn;
            const prev = result[0];
            if (prev) {
                result[0] = {
                    ...prev,
                    dependsOn: dependsOn.concat(prev.dependsOn ?? [])
                };
            }
        } else {
            result.unshift(elem);
        }
    }
    return result;
}
function createMigrationSequence({ sequence, sequenceId, retroactive = true }) {
    const migrations = {
        sequenceId,
        retroactive,
        sequence: squashDependsOn(sequence)
    };
    validateMigrations(migrations);
    return migrations;
}
function createMigrationIds(sequenceId, versions) {
    return Object.fromEntries((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["objectMapEntries"])(versions).map(([key, version])=>[
            key,
            `${sequenceId}/${version}`
        ]));
}
function createRecordMigrationSequence(opts) {
    const sequenceId = opts.sequenceId;
    return createMigrationSequence({
        sequenceId,
        retroactive: opts.retroactive ?? true,
        sequence: opts.sequence.map((m)=>"id" in m ? {
                ...m,
                scope: "record",
                filter: (r)=>r.typeName === opts.recordType && (m.filter?.(r) ?? true) && (opts.filter?.(r) ?? true)
            } : m)
    });
}
function sortMigrations(migrations) {
    const byId = new Map(migrations.map((m)=>[
            m.id,
            m
        ]));
    const isProcessing = /* @__PURE__ */ new Set();
    const result = [];
    function process(m) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(!isProcessing.has(m.id), `Circular dependency in migrations: ${m.id}`);
        isProcessing.add(m.id);
        const { version, sequenceId } = parseMigrationId(m.id);
        const parent = byId.get(`${sequenceId}/${version - 1}`);
        if (parent) {
            process(parent);
        }
        if (m.dependsOn) {
            for (const dep of m.dependsOn){
                const depMigration = byId.get(dep);
                if (depMigration) {
                    process(depMigration);
                }
            }
        }
        byId.delete(m.id);
        result.push(m);
    }
    for (const m of byId.values()){
        process(m);
    }
    return result;
}
function parseMigrationId(id) {
    const [sequenceId, version] = id.split("/");
    return {
        sequenceId,
        version: parseInt(version)
    };
}
function validateMigrationId(id, expectedSequenceId) {
    if (expectedSequenceId) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(id.startsWith(expectedSequenceId + "/"), `Every migration in sequence '${expectedSequenceId}' must have an id starting with '${expectedSequenceId}/'. Got invalid id: '${id}'`);
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(id.match(/^(.*?)\/(0|[1-9]\d*)$/), `Invalid migration id: '${id}'`);
}
function validateMigrations(migrations) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(!migrations.sequenceId.includes("/"), `sequenceId cannot contain a '/', got ${migrations.sequenceId}`);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(migrations.sequenceId.length, "sequenceId must be a non-empty string");
    if (migrations.sequence.length === 0) {
        return;
    }
    validateMigrationId(migrations.sequence[0].id, migrations.sequenceId);
    let n = parseMigrationId(migrations.sequence[0].id).version;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(n === 1, `Expected the first migrationId to be '${migrations.sequenceId}/1' but got '${migrations.sequence[0].id}'`);
    for(let i = 1; i < migrations.sequence.length; i++){
        const id = migrations.sequence[i].id;
        validateMigrationId(id, migrations.sequenceId);
        const m = parseMigrationId(id).version;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(m === n + 1, `Migration id numbers must increase in increments of 1, expected ${migrations.sequenceId}/${n + 1} but got '${migrations.sequence[i].id}'`);
        n = m;
    }
}
var MigrationFailureReason = /* @__PURE__ */ ((MigrationFailureReason2)=>{
    MigrationFailureReason2["IncompatibleSubtype"] = "incompatible-subtype";
    MigrationFailureReason2["UnknownType"] = "unknown-type";
    MigrationFailureReason2["TargetVersionTooNew"] = "target-version-too-new";
    MigrationFailureReason2["TargetVersionTooOld"] = "target-version-too-old";
    MigrationFailureReason2["MigrationError"] = "migration-error";
    MigrationFailureReason2["UnrecognizedSubtype"] = "unrecognized-subtype";
    return MigrationFailureReason2;
})(MigrationFailureReason || {});
;
 //# sourceMappingURL=migrate.mjs.map
}}),
"[project]/node_modules/@tldraw/store/dist-esm/lib/RecordsDiff.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createEmptyRecordsDiff": (()=>createEmptyRecordsDiff),
    "isRecordsDiffEmpty": (()=>isRecordsDiffEmpty),
    "reverseRecordsDiff": (()=>reverseRecordsDiff),
    "squashRecordDiffs": (()=>squashRecordDiffs),
    "squashRecordDiffsMutable": (()=>squashRecordDiffsMutable)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/index.mjs [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/lib/object.mjs [app-ssr] (ecmascript)");
;
function createEmptyRecordsDiff() {
    return {
        added: {},
        updated: {},
        removed: {}
    };
}
function reverseRecordsDiff(diff) {
    const result = {
        added: diff.removed,
        removed: diff.added,
        updated: {}
    };
    for (const [from, to] of Object.values(diff.updated)){
        result.updated[from.id] = [
            to,
            from
        ];
    }
    return result;
}
function isRecordsDiffEmpty(diff) {
    return Object.keys(diff.added).length === 0 && Object.keys(diff.updated).length === 0 && Object.keys(diff.removed).length === 0;
}
function squashRecordDiffs(diffs) {
    const result = {
        added: {},
        removed: {},
        updated: {}
    };
    squashRecordDiffsMutable(result, diffs);
    return result;
}
function squashRecordDiffsMutable(target, diffs) {
    for (const diff of diffs){
        for (const [id, value] of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["objectMapEntries"])(diff.added)){
            if (target.removed[id]) {
                const original = target.removed[id];
                delete target.removed[id];
                if (original !== value) {
                    target.updated[id] = [
                        original,
                        value
                    ];
                }
            } else {
                target.added[id] = value;
            }
        }
        for (const [id, [_from, to]] of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["objectMapEntries"])(diff.updated)){
            if (target.added[id]) {
                target.added[id] = to;
                delete target.updated[id];
                delete target.removed[id];
                continue;
            }
            if (target.updated[id]) {
                target.updated[id] = [
                    target.updated[id][0],
                    to
                ];
                delete target.removed[id];
                continue;
            }
            target.updated[id] = diff.updated[id];
            delete target.removed[id];
        }
        for (const [id, value] of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["objectMapEntries"])(diff.removed)){
            if (target.added[id]) {
                delete target.added[id];
            } else if (target.updated[id]) {
                target.removed[id] = target.updated[id][0];
                delete target.updated[id];
            } else {
                target.removed[id] = value;
            }
        }
    }
}
;
 //# sourceMappingURL=RecordsDiff.mjs.map
}}),
"[project]/node_modules/@tldraw/store/dist-esm/lib/RecordType.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "RecordType": (()=>RecordType),
    "assertIdType": (()=>assertIdType),
    "createRecordType": (()=>createRecordType)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/index.mjs [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/lib/object.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$value$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/lib/value.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$id$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/lib/id.mjs [app-ssr] (ecmascript)");
;
class RecordType {
    constructor(typeName, config){
        this.typeName = typeName;
        this.createDefaultProperties = config.createDefaultProperties;
        this.validator = config.validator ?? {
            validate: (r)=>r
        };
        this.scope = config.scope ?? "document";
        this.ephemeralKeys = config.ephemeralKeys;
        const ephemeralKeySet = /* @__PURE__ */ new Set();
        if (config.ephemeralKeys) {
            for (const [key, isEphemeral] of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["objectMapEntries"])(config.ephemeralKeys)){
                if (isEphemeral) ephemeralKeySet.add(key);
            }
        }
        this.ephemeralKeySet = ephemeralKeySet;
    }
    createDefaultProperties;
    validator;
    ephemeralKeys;
    ephemeralKeySet;
    scope;
    /**
   * Create a new record of this type.
   *
   * @param properties - The properties of the record.
   * @returns The new record.
   */ create(properties) {
        const result = {
            ...this.createDefaultProperties(),
            id: "id" in properties ? properties.id : this.createId()
        };
        for (const [k, v] of Object.entries(properties)){
            if (v !== void 0) {
                result[k] = v;
            }
        }
        result.typeName = this.typeName;
        return result;
    }
    /**
   * Clone a record of this type.
   *
   * @param record - The record to clone.
   * @returns The cloned record.
   * @public
   */ clone(record) {
        return {
            ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$value$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["structuredClone"])(record),
            id: this.createId()
        };
    }
    /**
   * Create a new ID for this record type.
   *
   * @example
   *
   * ```ts
   * const id = recordType.createId()
   * ```
   *
   * @returns The new ID.
   * @public
   */ createId(customUniquePart) {
        return this.typeName + ":" + (customUniquePart ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$id$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["uniqueId"])());
    }
    /**
   * Create a new ID for this record type based on the given ID.
   *
   * @example
   *
   * ```ts
   * const id = recordType.createCustomId('myId')
   * ```
   *
   * @deprecated - Use `createId` instead.
   * @param id - The ID to base the new ID on.
   * @returns The new ID.
   */ createCustomId(id) {
        return this.typeName + ":" + id;
    }
    /**
   * Takes an id like `user:123` and returns the part after the colon `123`
   *
   * @param id - The id
   * @returns
   */ parseId(id) {
        if (!this.isId(id)) {
            throw new Error(`ID "${id}" is not a valid ID for type "${this.typeName}"`);
        }
        return id.slice(this.typeName.length + 1);
    }
    /**
   * Check whether a record is an instance of this record type.
   *
   * @example
   *
   * ```ts
   * const result = recordType.isInstance(someRecord)
   * ```
   *
   * @param record - The record to check.
   * @returns Whether the record is an instance of this record type.
   */ isInstance(record) {
        return record?.typeName === this.typeName;
    }
    /**
   * Check whether an id is an id of this type.
   *
   * @example
   *
   * ```ts
   * const result = recordType.isIn('someId')
   * ```
   *
   * @param id - The id to check.
   * @returns Whether the id is an id of this type.
   */ isId(id) {
        if (!id) return false;
        for(let i = 0; i < this.typeName.length; i++){
            if (id[i] !== this.typeName[i]) return false;
        }
        return id[this.typeName.length] === ":";
    }
    /**
   * Create a new RecordType that has the same type name as this RecordType and includes the given
   * default properties.
   *
   * @example
   *
   * ```ts
   * const authorType = createRecordType('author', () => ({ living: true }))
   * const deadAuthorType = authorType.withDefaultProperties({ living: false })
   * ```
   *
   * @param createDefaultProperties - A function that returns the default properties of the new RecordType.
   * @returns The new RecordType.
   */ withDefaultProperties(createDefaultProperties) {
        return new RecordType(this.typeName, {
            createDefaultProperties,
            validator: this.validator,
            scope: this.scope,
            ephemeralKeys: this.ephemeralKeys
        });
    }
    /**
   * Check that the passed in record passes the validations for this type. Returns its input
   * correctly typed if it does, but throws an error otherwise.
   */ validate(record, recordBefore) {
        if (recordBefore && this.validator.validateUsingKnownGoodVersion) {
            return this.validator.validateUsingKnownGoodVersion(recordBefore, record);
        }
        return this.validator.validate(record);
    }
}
function createRecordType(typeName, config) {
    return new RecordType(typeName, {
        createDefaultProperties: ()=>({}),
        validator: config.validator,
        scope: config.scope,
        ephemeralKeys: config.ephemeralKeys
    });
}
function assertIdType(id, type) {
    if (!id || !type.isId(id)) {
        throw new Error(`string ${JSON.stringify(id)} is not a valid ${type.typeName} id`);
    }
}
;
 //# sourceMappingURL=RecordType.mjs.map
}}),
"[project]/node_modules/@tldraw/store/dist-esm/lib/setUtils.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "diffSets": (()=>diffSets),
    "intersectSets": (()=>intersectSets)
});
function intersectSets(sets) {
    if (sets.length === 0) return /* @__PURE__ */ new Set();
    const first = sets[0];
    const rest = sets.slice(1);
    const result = /* @__PURE__ */ new Set();
    for (const val of first){
        if (rest.every((set)=>set.has(val))) {
            result.add(val);
        }
    }
    return result;
}
function diffSets(prev, next) {
    const result = {};
    for (const val of next){
        if (!prev.has(val)) {
            result.added ??= /* @__PURE__ */ new Set();
            result.added.add(val);
        }
    }
    for (const val of prev){
        if (!next.has(val)) {
            result.removed ??= /* @__PURE__ */ new Set();
            result.removed.add(val);
        }
    }
    return result.added || result.removed ? result : void 0;
}
;
 //# sourceMappingURL=setUtils.mjs.map
}}),
"[project]/node_modules/@tldraw/store/dist-esm/lib/executeQuery.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "executeQuery": (()=>executeQuery),
    "objectMatchesQuery": (()=>objectMatchesQuery)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$setUtils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/store/dist-esm/lib/setUtils.mjs [app-ssr] (ecmascript)");
;
function objectMatchesQuery(query, object) {
    for (const [key, _matcher] of Object.entries(query)){
        const matcher = _matcher;
        const value = object[key];
        if ("eq" in matcher && value !== matcher.eq) return false;
        if ("neq" in matcher && value === matcher.neq) return false;
        if ("gt" in matcher && (typeof value !== "number" || value <= matcher.gt)) return false;
    }
    return true;
}
function executeQuery(store, typeName, query) {
    const matchIds = Object.fromEntries(Object.keys(query).map((key)=>[
            key,
            /* @__PURE__ */ new Set()
        ]));
    for (const [k, matcher] of Object.entries(query)){
        if ("eq" in matcher) {
            const index = store.index(typeName, k);
            const ids = index.get().get(matcher.eq);
            if (ids) {
                for (const id of ids){
                    matchIds[k].add(id);
                }
            }
        } else if ("neq" in matcher) {
            const index = store.index(typeName, k);
            for (const [value, ids] of index.get()){
                if (value !== matcher.neq) {
                    for (const id of ids){
                        matchIds[k].add(id);
                    }
                }
            }
        } else if ("gt" in matcher) {
            const index = store.index(typeName, k);
            for (const [value, ids] of index.get()){
                if (value > matcher.gt) {
                    for (const id of ids){
                        matchIds[k].add(id);
                    }
                }
            }
        }
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$setUtils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["intersectSets"])(Object.values(matchIds));
}
;
 //# sourceMappingURL=executeQuery.mjs.map
}}),
"[project]/node_modules/@tldraw/store/dist-esm/lib/StoreQueries.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "StoreQueries": (()=>StoreQueries)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/state/dist-esm/index.mjs [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$Computed$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/state/dist-esm/lib/Computed.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$helpers$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/state/dist-esm/lib/helpers.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/state/dist-esm/lib/types.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/index.mjs [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$array$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/lib/array.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2e$isequal$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__isEqual$3e$__ = __turbopack_context__.i("[project]/node_modules/lodash.isequal/index.js [app-ssr] (ecmascript) <export default as isEqual>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/lib/object.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$executeQuery$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/store/dist-esm/lib/executeQuery.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$IncrementalSetConstructor$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/store/dist-esm/lib/IncrementalSetConstructor.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$setUtils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/store/dist-esm/lib/setUtils.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
class StoreQueries {
    constructor(recordMap, history){
        this.recordMap = recordMap;
        this.history = history;
    }
    /**
   * A cache of derivations (indexes).
   *
   * @internal
   */ indexCache = /* @__PURE__ */ new Map();
    /**
   * A cache of derivations (filtered histories).
   *
   * @internal
   */ historyCache = /* @__PURE__ */ new Map();
    /**
   * Create a derivation that contains the history for a given type
   *
   * @param typeName - The name of the type to filter by.
   * @returns A derivation that returns the ids of all records of the given type.
   * @public
   */ filterHistory(typeName) {
        if (this.historyCache.has(typeName)) {
            return this.historyCache.get(typeName);
        }
        const filtered = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$Computed$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["computed"])("filterHistory:" + typeName, (lastValue, lastComputedEpoch)=>{
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$Computed$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isUninitialized"])(lastValue)) {
                return this.history.get();
            }
            const diff = this.history.getDiffSince(lastComputedEpoch);
            if (diff === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RESET_VALUE"]) return this.history.get();
            const res = {
                added: {},
                removed: {},
                updated: {}
            };
            let numAdded = 0;
            let numRemoved = 0;
            let numUpdated = 0;
            for (const changes of diff){
                for (const added of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["objectMapValues"])(changes.added)){
                    if (added.typeName === typeName) {
                        if (res.removed[added.id]) {
                            const original = res.removed[added.id];
                            delete res.removed[added.id];
                            numRemoved--;
                            if (original !== added) {
                                res.updated[added.id] = [
                                    original,
                                    added
                                ];
                                numUpdated++;
                            }
                        } else {
                            res.added[added.id] = added;
                            numAdded++;
                        }
                    }
                }
                for (const [from, to] of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["objectMapValues"])(changes.updated)){
                    if (to.typeName === typeName) {
                        if (res.added[to.id]) {
                            res.added[to.id] = to;
                        } else if (res.updated[to.id]) {
                            res.updated[to.id] = [
                                res.updated[to.id][0],
                                to
                            ];
                        } else {
                            res.updated[to.id] = [
                                from,
                                to
                            ];
                            numUpdated++;
                        }
                    }
                }
                for (const removed of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["objectMapValues"])(changes.removed)){
                    if (removed.typeName === typeName) {
                        if (res.added[removed.id]) {
                            delete res.added[removed.id];
                            numAdded--;
                        } else if (res.updated[removed.id]) {
                            res.removed[removed.id] = res.updated[removed.id][0];
                            delete res.updated[removed.id];
                            numUpdated--;
                            numRemoved++;
                        } else {
                            res.removed[removed.id] = removed;
                            numRemoved++;
                        }
                    }
                }
            }
            if (numAdded || numRemoved || numUpdated) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$Computed$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["withDiff"])(this.history.get(), res);
            } else {
                return lastValue;
            }
        }, {
            historyLength: 100
        });
        this.historyCache.set(typeName, filtered);
        return filtered;
    }
    /**
   * Create a derivation that returns an index on a property for the given type.
   *
   * @param typeName - The name of the type.
   * @param property - The name of the property.
   * @public
   */ index(typeName, property) {
        const cacheKey = typeName + ":" + property;
        if (this.indexCache.has(cacheKey)) {
            return this.indexCache.get(cacheKey);
        }
        const index = this.__uncached_createIndex(typeName, property);
        this.indexCache.set(cacheKey, index);
        return index;
    }
    /**
   * Create a derivation that returns an index on a property for the given type.
   *
   * @param typeName - The name of the type?.
   * @param property - The name of the property?.
   * @internal
   */ __uncached_createIndex(typeName, property) {
        const typeHistory = this.filterHistory(typeName);
        const fromScratch = ()=>{
            typeHistory.get();
            const res = /* @__PURE__ */ new Map();
            for (const record of this.recordMap.values()){
                if (record.typeName === typeName) {
                    const value = record[property];
                    if (!res.has(value)) {
                        res.set(value, /* @__PURE__ */ new Set());
                    }
                    res.get(value).add(record.id);
                }
            }
            return res;
        };
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$Computed$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["computed"])("index:" + typeName + ":" + property, (prevValue, lastComputedEpoch)=>{
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$Computed$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isUninitialized"])(prevValue)) return fromScratch();
            const history = typeHistory.getDiffSince(lastComputedEpoch);
            if (history === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RESET_VALUE"]) {
                return fromScratch();
            }
            const setConstructors = /* @__PURE__ */ new Map();
            const add = (value, id)=>{
                let setConstructor = setConstructors.get(value);
                if (!setConstructor) setConstructor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$IncrementalSetConstructor$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["IncrementalSetConstructor"](prevValue.get(value) ?? /* @__PURE__ */ new Set());
                setConstructor.add(id);
                setConstructors.set(value, setConstructor);
            };
            const remove = (value, id)=>{
                let set = setConstructors.get(value);
                if (!set) set = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$IncrementalSetConstructor$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["IncrementalSetConstructor"](prevValue.get(value) ?? /* @__PURE__ */ new Set());
                set.remove(id);
                setConstructors.set(value, set);
            };
            for (const changes of history){
                for (const record of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["objectMapValues"])(changes.added)){
                    if (record.typeName === typeName) {
                        const value = record[property];
                        add(value, record.id);
                    }
                }
                for (const [from, to] of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["objectMapValues"])(changes.updated)){
                    if (to.typeName === typeName) {
                        const prev = from[property];
                        const next = to[property];
                        if (prev !== next) {
                            remove(prev, to.id);
                            add(next, to.id);
                        }
                    }
                }
                for (const record of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["objectMapValues"])(changes.removed)){
                    if (record.typeName === typeName) {
                        const value = record[property];
                        remove(value, record.id);
                    }
                }
            }
            let nextValue = void 0;
            let nextDiff = void 0;
            for (const [value, setConstructor] of setConstructors){
                const result = setConstructor.get();
                if (!result) continue;
                if (!nextValue) nextValue = new Map(prevValue);
                if (!nextDiff) nextDiff = /* @__PURE__ */ new Map();
                if (result.value.size === 0) {
                    nextValue.delete(value);
                } else {
                    nextValue.set(value, result.value);
                }
                nextDiff.set(value, result.diff);
            }
            if (nextValue && nextDiff) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$Computed$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["withDiff"])(nextValue, nextDiff);
            }
            return prevValue;
        }, {
            historyLength: 100
        });
    }
    /**
   * Create a derivation that will return a signle record matching the given query.
   *
   * It will return undefined if there is no matching record
   *
   * @param typeName - The name of the type?
   * @param queryCreator - A function that returns the query expression.
   * @param name - (optional) The name of the query.
   */ record(typeName, queryCreator = ()=>({}), name = "record:" + typeName + (queryCreator ? ":" + queryCreator.toString() : "")) {
        const ids = this.ids(typeName, queryCreator, name);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$Computed$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["computed"])(name, ()=>{
            for (const id of ids.get()){
                return this.recordMap.get(id);
            }
            return void 0;
        });
    }
    /**
   * Create a derivation that will return an array of records matching the given query
   *
   * @param typeName - The name of the type?
   * @param queryCreator - A function that returns the query expression.
   * @param name - (optinal) The name of the query.
   */ records(typeName, queryCreator = ()=>({}), name = "records:" + typeName + (queryCreator ? ":" + queryCreator.toString() : "")) {
        const ids = this.ids(typeName, queryCreator, "ids:" + name);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$Computed$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["computed"])(name, ()=>{
            return Array.from(ids.get(), (id)=>this.recordMap.get(id));
        }, {
            isEqual: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$array$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["areArraysShallowEqual"]
        });
    }
    /**
   * Create a derivation that will return the ids of all records of the given type.
   *
   * @param typeName - The name of the type.
   * @param queryCreator - A function that returns the query expression.
   * @param name - (optinal) The name of the query.
   */ ids(typeName, queryCreator = ()=>({}), name = "ids:" + typeName + (queryCreator ? ":" + queryCreator.toString() : "")) {
        const typeHistory = this.filterHistory(typeName);
        const fromScratch = ()=>{
            typeHistory.get();
            const query = queryCreator();
            if (Object.keys(query).length === 0) {
                const ids = /* @__PURE__ */ new Set();
                for (const record of this.recordMap.values()){
                    if (record.typeName === typeName) ids.add(record.id);
                }
                return ids;
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$executeQuery$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["executeQuery"])(this, typeName, query);
        };
        const fromScratchWithDiff = (prevValue)=>{
            const nextValue = fromScratch();
            const diff = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$setUtils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["diffSets"])(prevValue, nextValue);
            if (diff) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$Computed$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["withDiff"])(nextValue, diff);
            } else {
                return prevValue;
            }
        };
        const cachedQuery = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$Computed$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["computed"])("ids_query:" + name, queryCreator, {
            isEqual: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2e$isequal$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__isEqual$3e$__["isEqual"]
        });
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$Computed$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["computed"])("query:" + name, (prevValue, lastComputedEpoch)=>{
            const query = cachedQuery.get();
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$Computed$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isUninitialized"])(prevValue)) {
                return fromScratch();
            }
            if (lastComputedEpoch < cachedQuery.lastChangedEpoch) {
                return fromScratchWithDiff(prevValue);
            }
            const history = typeHistory.getDiffSince(lastComputedEpoch);
            if (history === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RESET_VALUE"]) {
                return fromScratchWithDiff(prevValue);
            }
            const setConstructor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$IncrementalSetConstructor$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["IncrementalSetConstructor"](prevValue);
            for (const changes of history){
                for (const added of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["objectMapValues"])(changes.added)){
                    if (added.typeName === typeName && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$executeQuery$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["objectMatchesQuery"])(query, added)) {
                        setConstructor.add(added.id);
                    }
                }
                for (const [_, updated] of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["objectMapValues"])(changes.updated)){
                    if (updated.typeName === typeName) {
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$executeQuery$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["objectMatchesQuery"])(query, updated)) {
                            setConstructor.add(updated.id);
                        } else {
                            setConstructor.remove(updated.id);
                        }
                    }
                }
                for (const removed of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["objectMapValues"])(changes.removed)){
                    if (removed.typeName === typeName) {
                        setConstructor.remove(removed.id);
                    }
                }
            }
            const result = setConstructor.get();
            if (!result) {
                return prevValue;
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$Computed$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["withDiff"])(result.value, result.diff);
        }, {
            historyLength: 50
        });
    }
    exec(typeName, query) {
        const ids = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$executeQuery$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["executeQuery"])(this, typeName, query);
        if (ids.size === 0) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$helpers$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EMPTY_ARRAY"];
        }
        return Array.from(ids, (id)=>this.recordMap.get(id));
    }
}
;
 //# sourceMappingURL=StoreQueries.mjs.map
}}),
"[project]/node_modules/@tldraw/store/dist-esm/lib/StoreSideEffects.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "StoreSideEffects": (()=>StoreSideEffects)
});
class StoreSideEffects {
    constructor(store){
        this.store = store;
    }
    _beforeCreateHandlers = {};
    _afterCreateHandlers = {};
    _beforeChangeHandlers = {};
    _afterChangeHandlers = {};
    _beforeDeleteHandlers = {};
    _afterDeleteHandlers = {};
    _operationCompleteHandlers = [];
    _isEnabled = true;
    /** @internal */ isEnabled() {
        return this._isEnabled;
    }
    /** @internal */ setIsEnabled(enabled) {
        this._isEnabled = enabled;
    }
    /** @internal */ handleBeforeCreate(record, source) {
        if (!this._isEnabled) return record;
        const handlers = this._beforeCreateHandlers[record.typeName];
        if (handlers) {
            let r = record;
            for (const handler of handlers){
                r = handler(r, source);
            }
            return r;
        }
        return record;
    }
    /** @internal */ handleAfterCreate(record, source) {
        if (!this._isEnabled) return;
        const handlers = this._afterCreateHandlers[record.typeName];
        if (handlers) {
            for (const handler of handlers){
                handler(record, source);
            }
        }
    }
    /** @internal */ handleBeforeChange(prev, next, source) {
        if (!this._isEnabled) return next;
        const handlers = this._beforeChangeHandlers[next.typeName];
        if (handlers) {
            let r = next;
            for (const handler of handlers){
                r = handler(prev, r, source);
            }
            return r;
        }
        return next;
    }
    /** @internal */ handleAfterChange(prev, next, source) {
        if (!this._isEnabled) return;
        const handlers = this._afterChangeHandlers[next.typeName];
        if (handlers) {
            for (const handler of handlers){
                handler(prev, next, source);
            }
        }
    }
    /** @internal */ handleBeforeDelete(record, source) {
        if (!this._isEnabled) return true;
        const handlers = this._beforeDeleteHandlers[record.typeName];
        if (handlers) {
            for (const handler of handlers){
                if (handler(record, source) === false) {
                    return false;
                }
            }
        }
        return true;
    }
    /** @internal */ handleAfterDelete(record, source) {
        if (!this._isEnabled) return;
        const handlers = this._afterDeleteHandlers[record.typeName];
        if (handlers) {
            for (const handler of handlers){
                handler(record, source);
            }
        }
    }
    /** @internal */ handleOperationComplete(source) {
        if (!this._isEnabled) return;
        for (const handler of this._operationCompleteHandlers){
            handler(source);
        }
    }
    /**
   * Internal helper for registering a bunch of side effects at once and keeping them organized.
   * @internal
   */ register(handlersByType) {
        const disposes = [];
        for (const [type, handlers] of Object.entries(handlersByType)){
            if (handlers?.beforeCreate) {
                disposes.push(this.registerBeforeCreateHandler(type, handlers.beforeCreate));
            }
            if (handlers?.afterCreate) {
                disposes.push(this.registerAfterCreateHandler(type, handlers.afterCreate));
            }
            if (handlers?.beforeChange) {
                disposes.push(this.registerBeforeChangeHandler(type, handlers.beforeChange));
            }
            if (handlers?.afterChange) {
                disposes.push(this.registerAfterChangeHandler(type, handlers.afterChange));
            }
            if (handlers?.beforeDelete) {
                disposes.push(this.registerBeforeDeleteHandler(type, handlers.beforeDelete));
            }
            if (handlers?.afterDelete) {
                disposes.push(this.registerAfterDeleteHandler(type, handlers.afterDelete));
            }
        }
        return ()=>{
            for (const dispose of disposes)dispose();
        };
    }
    /**
   * Register a handler to be called before a record of a certain type is created. Return a
   * modified record from the handler to change the record that will be created.
   *
   * Use this handle only to modify the creation of the record itself. If you want to trigger a
   * side-effect on a different record (for example, moving one shape when another is created),
   * use {@link StoreSideEffects.registerAfterCreateHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerBeforeCreateHandler('shape', (shape, source) => {
   *     // only modify shapes created by the user
   *     if (source !== 'user') return shape
   *
   *     //by default, arrow shapes have no label. Let's make sure they always have a label.
   *     if (shape.type === 'arrow') {
   *         return {...shape, props: {...shape.props, text: 'an arrow'}}
   *     }
   *
   *     // other shapes get returned unmodified
   *     return shape
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */ registerBeforeCreateHandler(typeName, handler) {
        const handlers = this._beforeCreateHandlers[typeName];
        if (!handlers) this._beforeCreateHandlers[typeName] = [];
        this._beforeCreateHandlers[typeName].push(handler);
        return ()=>remove(this._beforeCreateHandlers[typeName], handler);
    }
    /**
   * Register a handler to be called after a record is created. This is useful for side-effects
   * that would update _other_ records. If you want to modify the record being created use
   * {@link StoreSideEffects.registerBeforeCreateHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerAfterCreateHandler('page', (page, source) => {
   *     // Automatically create a shape when a page is created
   *     editor.createShape<TLTextShape>({
   *         id: createShapeId(),
   *         type: 'text',
   *         props: { richText: toRichText(page.name) },
   *     })
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */ registerAfterCreateHandler(typeName, handler) {
        const handlers = this._afterCreateHandlers[typeName];
        if (!handlers) this._afterCreateHandlers[typeName] = [];
        this._afterCreateHandlers[typeName].push(handler);
        return ()=>remove(this._afterCreateHandlers[typeName], handler);
    }
    /**
   * Register a handler to be called before a record is changed. The handler is given the old and
   * new record - you can return a modified record to apply a different update, or the old record
   * to block the update entirely.
   *
   * Use this handler only for intercepting updates to the record itself. If you want to update
   * other records in response to a change, use
   * {@link StoreSideEffects.registerAfterChangeHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerBeforeChangeHandler('shape', (prev, next, source) => {
   *     if (next.isLocked && !prev.isLocked) {
   *         // prevent shapes from ever being locked:
   *         return prev
   *     }
   *     // other types of change are allowed
   *     return next
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */ registerBeforeChangeHandler(typeName, handler) {
        const handlers = this._beforeChangeHandlers[typeName];
        if (!handlers) this._beforeChangeHandlers[typeName] = [];
        this._beforeChangeHandlers[typeName].push(handler);
        return ()=>remove(this._beforeChangeHandlers[typeName], handler);
    }
    /**
   * Register a handler to be called after a record is changed. This is useful for side-effects
   * that would update _other_ records - if you want to modify the record being changed, use
   * {@link StoreSideEffects.registerBeforeChangeHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerAfterChangeHandler('shape', (prev, next, source) => {
   *     if (next.props.color === 'red') {
   *         // there can only be one red shape at a time:
   *         const otherRedShapes = editor.getCurrentPageShapes().filter(s => s.props.color === 'red' && s.id !== next.id)
   *         editor.updateShapes(otherRedShapes.map(s => ({...s, props: {...s.props, color: 'blue'}})))
   *     }
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */ registerAfterChangeHandler(typeName, handler) {
        const handlers = this._afterChangeHandlers[typeName];
        if (!handlers) this._afterChangeHandlers[typeName] = [];
        this._afterChangeHandlers[typeName].push(handler);
        return ()=>remove(this._afterChangeHandlers[typeName], handler);
    }
    /**
   * Register a handler to be called before a record is deleted. The handler can return `false` to
   * prevent the deletion.
   *
   * Use this handler only for intercepting deletions of the record itself. If you want to do
   * something to other records in response to a deletion, use
   * {@link StoreSideEffects.registerAfterDeleteHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerBeforeDeleteHandler('shape', (shape, source) => {
   *     if (shape.props.color === 'red') {
   *         // prevent red shapes from being deleted
   * 	       return false
   *     }
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */ registerBeforeDeleteHandler(typeName, handler) {
        const handlers = this._beforeDeleteHandlers[typeName];
        if (!handlers) this._beforeDeleteHandlers[typeName] = [];
        this._beforeDeleteHandlers[typeName].push(handler);
        return ()=>remove(this._beforeDeleteHandlers[typeName], handler);
    }
    /**
   * Register a handler to be called after a record is deleted. This is useful for side-effects
   * that would update _other_ records - if you want to block the deletion of the record itself,
   * use {@link StoreSideEffects.registerBeforeDeleteHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerAfterDeleteHandler('shape', (shape, source) => {
   *     // if the last shape in a frame is deleted, delete the frame too:
   *     const parentFrame = editor.getShape(shape.parentId)
   *     if (!parentFrame || parentFrame.type !== 'frame') return
   *
   *     const siblings = editor.getSortedChildIdsForParent(parentFrame)
   *     if (siblings.length === 0) {
   *         editor.deleteShape(parentFrame.id)
   *     }
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */ registerAfterDeleteHandler(typeName, handler) {
        const handlers = this._afterDeleteHandlers[typeName];
        if (!handlers) this._afterDeleteHandlers[typeName] = [];
        this._afterDeleteHandlers[typeName].push(handler);
        return ()=>remove(this._afterDeleteHandlers[typeName], handler);
    }
    /**
   * Register a handler to be called when a store completes an atomic operation.
   *
   * @example
   * ```ts
   * let count = 0
   *
   * editor.sideEffects.registerOperationCompleteHandler(() => count++)
   *
   * editor.selectAll()
   * expect(count).toBe(1)
   *
   * editor.store.atomic(() => {
   *	editor.selectNone()
   * 	editor.selectAll()
   * })
   *
   * expect(count).toBe(2)
   * ```
   *
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   *
   * @public
   */ registerOperationCompleteHandler(handler) {
        this._operationCompleteHandlers.push(handler);
        return ()=>remove(this._operationCompleteHandlers, handler);
    }
}
function remove(array, item) {
    const index = array.indexOf(item);
    if (index >= 0) {
        array.splice(index, 1);
    }
}
;
 //# sourceMappingURL=StoreSideEffects.mjs.map
}}),
"[project]/node_modules/@tldraw/store/dist-esm/lib/Store.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "Store": (()=>Store),
    "createComputedCache": (()=>createComputedCache)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/state/dist-esm/index.mjs [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$Atom$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/state/dist-esm/lib/Atom.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$Computed$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/state/dist-esm/lib/Computed.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$EffectScheduler$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/state/dist-esm/lib/EffectScheduler.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$transactions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/state/dist-esm/lib/transactions.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/index.mjs [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$cache$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/lib/cache.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/lib/control.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/lib/object.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2e$isequal$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__isEqual$3e$__ = __turbopack_context__.i("[project]/node_modules/lodash.isequal/index.js [app-ssr] (ecmascript) <export default as isEqual>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$throttle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/lib/throttle.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$id$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/lib/id.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$AtomMap$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/store/dist-esm/lib/AtomMap.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$RecordsDiff$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/store/dist-esm/lib/RecordsDiff.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$StoreQueries$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/store/dist-esm/lib/StoreQueries.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$StoreSideEffects$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/store/dist-esm/lib/StoreSideEffects.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$devFreeze$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/store/dist-esm/lib/devFreeze.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
class Store {
    /**
   * The random id of the store.
   */ id;
    /**
   * An AtomMap containing the stores records.
   *
   * @internal
   * @readonly
   */ records;
    /**
   * An atom containing the store's history.
   *
   * @public
   * @readonly
   */ history = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$Atom$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["atom"])("history", 0, {
        historyLength: 1e3
    });
    /**
   * A StoreQueries instance for this store.
   *
   * @public
   * @readonly
   */ query;
    /**
   * A set containing listeners that have been added to this store.
   *
   * @internal
   */ listeners = /* @__PURE__ */ new Set();
    /**
   * An array of history entries that have not yet been flushed.
   *
   * @internal
   */ historyAccumulator = new HistoryAccumulator();
    /**
   * A reactor that responds to changes to the history by squashing the accumulated history and
   * notifying listeners of the changes.
   *
   * @internal
   */ historyReactor;
    /**
   * Function to dispose of any in-flight timeouts.
   *
   * @internal
   */ cancelHistoryReactor() {}
    schema;
    props;
    scopedTypes;
    sideEffects = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$StoreSideEffects$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["StoreSideEffects"](this);
    constructor(config){
        const { initialData, schema, id } = config;
        this.id = id ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$id$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["uniqueId"])();
        this.schema = schema;
        this.props = config.props;
        if (initialData) {
            this.records = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$AtomMap$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AtomMap"]("store", (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["objectMapEntries"])(initialData).map(([id2, record])=>[
                    id2,
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$devFreeze$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["devFreeze"])(this.schema.validateRecord(this, record, "initialize", null))
                ]));
        } else {
            this.records = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$AtomMap$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AtomMap"]("store");
        }
        this.query = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$StoreQueries$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["StoreQueries"](this.records, this.history);
        this.historyReactor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$EffectScheduler$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["reactor"])("Store.historyReactor", ()=>{
            this.history.get();
            this._flushHistory();
        }, {
            scheduleEffect: (cb)=>this.cancelHistoryReactor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$throttle$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["throttleToNextFrame"])(cb)
        });
        this.scopedTypes = {
            document: new Set((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["objectMapValues"])(this.schema.types).filter((t)=>t.scope === "document").map((t)=>t.typeName)),
            session: new Set((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["objectMapValues"])(this.schema.types).filter((t)=>t.scope === "session").map((t)=>t.typeName)),
            presence: new Set((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["objectMapValues"])(this.schema.types).filter((t)=>t.scope === "presence").map((t)=>t.typeName))
        };
    }
    _flushHistory() {
        if (this.historyAccumulator.hasChanges()) {
            const entries = this.historyAccumulator.flush();
            for (const { changes, source } of entries){
                let instanceChanges = null;
                let documentChanges = null;
                let presenceChanges = null;
                for (const { onHistory, filters } of this.listeners){
                    if (filters.source !== "all" && filters.source !== source) {
                        continue;
                    }
                    if (filters.scope !== "all") {
                        if (filters.scope === "document") {
                            documentChanges ??= this.filterChangesByScope(changes, "document");
                            if (!documentChanges) continue;
                            onHistory({
                                changes: documentChanges,
                                source
                            });
                        } else if (filters.scope === "session") {
                            instanceChanges ??= this.filterChangesByScope(changes, "session");
                            if (!instanceChanges) continue;
                            onHistory({
                                changes: instanceChanges,
                                source
                            });
                        } else {
                            presenceChanges ??= this.filterChangesByScope(changes, "presence");
                            if (!presenceChanges) continue;
                            onHistory({
                                changes: presenceChanges,
                                source
                            });
                        }
                    } else {
                        onHistory({
                            changes,
                            source
                        });
                    }
                }
            }
        }
    }
    dispose() {
        this.cancelHistoryReactor();
    }
    /**
   * Filters out non-document changes from a diff. Returns null if there are no changes left.
   * @param change - the records diff
   * @param scope - the records scope
   * @returns
   */ filterChangesByScope(change, scope) {
        const result = {
            added: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["filterEntries"])(change.added, (_, r)=>this.scopedTypes[scope].has(r.typeName)),
            updated: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["filterEntries"])(change.updated, (_, r)=>this.scopedTypes[scope].has(r[1].typeName)),
            removed: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["filterEntries"])(change.removed, (_, r)=>this.scopedTypes[scope].has(r.typeName))
        };
        if (Object.keys(result.added).length === 0 && Object.keys(result.updated).length === 0 && Object.keys(result.removed).length === 0) {
            return null;
        }
        return result;
    }
    /**
   * Update the history with a diff of changes.
   *
   * @param changes - The changes to add to the history.
   */ updateHistory(changes) {
        this.historyAccumulator.add({
            changes,
            source: this.isMergingRemoteChanges ? "remote" : "user"
        });
        if (this.listeners.size === 0) {
            this.historyAccumulator.clear();
        }
        this.history.set(this.history.get() + 1, changes);
    }
    validate(phase) {
        this.allRecords().forEach((record)=>this.schema.validateRecord(this, record, phase, null));
    }
    /**
   * Add some records to the store. It's an error if they already exist.
   *
   * @param records - The records to add.
   * @param phaseOverride - The phase override.
   * @public
   */ put(records, phaseOverride) {
        this.atomic(()=>{
            const updates = {};
            const additions = {};
            let record;
            let didChange = false;
            const source = this.isMergingRemoteChanges ? "remote" : "user";
            for(let i = 0, n = records.length; i < n; i++){
                record = records[i];
                const initialValue = this.records.__unsafe__getWithoutCapture(record.id);
                if (initialValue) {
                    record = this.sideEffects.handleBeforeChange(initialValue, record, source);
                    const validated = this.schema.validateRecord(this, record, phaseOverride ?? "updateRecord", initialValue);
                    if (validated === initialValue) continue;
                    record = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$devFreeze$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["devFreeze"])(record);
                    this.records.set(record.id, record);
                    didChange = true;
                    updates[record.id] = [
                        initialValue,
                        record
                    ];
                    this.addDiffForAfterEvent(initialValue, record);
                } else {
                    record = this.sideEffects.handleBeforeCreate(record, source);
                    didChange = true;
                    record = this.schema.validateRecord(this, record, phaseOverride ?? "createRecord", null);
                    record = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$devFreeze$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["devFreeze"])(record);
                    additions[record.id] = record;
                    this.addDiffForAfterEvent(null, record);
                    this.records.set(record.id, record);
                }
            }
            if (!didChange) return;
            this.updateHistory({
                added: additions,
                updated: updates,
                removed: {}
            });
        });
    }
    /**
   * Remove some records from the store via their ids.
   *
   * @param ids - The ids of the records to remove.
   * @public
   */ remove(ids) {
        this.atomic(()=>{
            const toDelete = new Set(ids);
            const source = this.isMergingRemoteChanges ? "remote" : "user";
            if (this.sideEffects.isEnabled()) {
                for (const id of ids){
                    const record = this.records.__unsafe__getWithoutCapture(id);
                    if (!record) continue;
                    if (this.sideEffects.handleBeforeDelete(record, source) === false) {
                        toDelete.delete(id);
                    }
                }
            }
            const actuallyDeleted = this.records.deleteMany(toDelete);
            if (actuallyDeleted.length === 0) return;
            const removed = {};
            for (const [id, record] of actuallyDeleted){
                removed[id] = record;
                this.addDiffForAfterEvent(record, null);
            }
            this.updateHistory({
                added: {},
                updated: {},
                removed
            });
        });
    }
    /**
   * Get the value of a store record by its id.
   *
   * @param id - The id of the record to get.
   * @public
   */ get(id) {
        return this.records.get(id);
    }
    /**
   * Get the value of a store record by its id without updating its epoch.
   *
   * @param id - The id of the record to get.
   * @public
   */ unsafeGetWithoutCapture(id) {
        return this.records.__unsafe__getWithoutCapture(id);
    }
    /**
   * Creates a JSON payload from the record store.
   *
   * @param scope - The scope of records to serialize. Defaults to 'document'.
   * @returns The record store snapshot as a JSON payload.
   */ serialize(scope = "document") {
        const result = {};
        for (const [id, record] of this.records){
            if (scope === "all" || this.scopedTypes[scope].has(record.typeName)) {
                result[id] = record;
            }
        }
        return result;
    }
    /**
   * Get a serialized snapshot of the store and its schema.
   *
   * ```ts
   * const snapshot = store.getStoreSnapshot()
   * store.loadStoreSnapshot(snapshot)
   * ```
   *
   * @param scope - The scope of records to serialize. Defaults to 'document'.
   *
   * @public
   */ getStoreSnapshot(scope = "document") {
        return {
            store: this.serialize(scope),
            schema: this.schema.serialize()
        };
    }
    /**
   * @deprecated use `getSnapshot` from the 'tldraw' package instead.
   */ getSnapshot(scope = "document") {
        console.warn("[tldraw] `Store.getSnapshot` is deprecated and will be removed in a future release. Use `getSnapshot` from the `tldraw` package instead.");
        return this.getStoreSnapshot(scope);
    }
    /**
   * Migrate a serialized snapshot of the store and its schema.
   *
   * ```ts
   * const snapshot = store.getSnapshot()
   * store.migrateSnapshot(snapshot)
   * ```
   *
   * @param snapshot - The snapshot to load.
   * @public
   */ migrateSnapshot(snapshot) {
        const migrationResult = this.schema.migrateStoreSnapshot(snapshot);
        if (migrationResult.type === "error") {
            throw new Error(`Failed to migrate snapshot: ${migrationResult.reason}`);
        }
        return {
            store: migrationResult.value,
            schema: this.schema.serialize()
        };
    }
    /**
   * Load a serialized snapshot.
   *
   * ```ts
   * const snapshot = store.getStoreSnapshot()
   * store.loadStoreSnapshot(snapshot)
   * ```
   *
   * @param snapshot - The snapshot to load.
   * @public
   */ loadStoreSnapshot(snapshot) {
        const migrationResult = this.schema.migrateStoreSnapshot(snapshot);
        if (migrationResult.type === "error") {
            throw new Error(`Failed to migrate snapshot: ${migrationResult.reason}`);
        }
        const prevSideEffectsEnabled = this.sideEffects.isEnabled();
        try {
            this.sideEffects.setIsEnabled(false);
            this.atomic(()=>{
                this.clear();
                this.put(Object.values(migrationResult.value));
                this.ensureStoreIsUsable();
            });
        } finally{
            this.sideEffects.setIsEnabled(prevSideEffectsEnabled);
        }
    }
    /**
   * @public
   * @deprecated use `loadSnapshot` from the 'tldraw' package instead.
   */ loadSnapshot(snapshot) {
        console.warn("[tldraw] `Store.loadSnapshot` is deprecated and will be removed in a future release. Use `loadSnapshot` from the 'tldraw' package instead.");
        this.loadStoreSnapshot(snapshot);
    }
    /**
   * Get an array of all values in the store.
   *
   * @returns An array of all values in the store.
   * @public
   */ allRecords() {
        return Array.from(this.records.values());
    }
    /**
   * Removes all records from the store.
   *
   * @public
   */ clear() {
        this.remove(Array.from(this.records.keys()));
    }
    /**
   * Update a record. To update multiple records at once, use the `update` method of the
   * `TypedStore` class.
   *
   * @param id - The id of the record to update.
   * @param updater - A function that updates the record.
   */ update(id, updater) {
        const existing = this.unsafeGetWithoutCapture(id);
        if (!existing) {
            console.error(`Record ${id} not found. This is probably an error`);
            return;
        }
        this.put([
            updater(existing)
        ]);
    }
    /**
   * Get whether the record store has a id.
   *
   * @param id - The id of the record to check.
   * @public
   */ has(id) {
        return this.records.has(id);
    }
    /**
   * Add a new listener to the store.
   *
   * @param onHistory - The listener to call when the store updates.
   * @param filters - Filters to apply to the listener.
   * @returns A function to remove the listener.
   */ listen(onHistory, filters) {
        this._flushHistory();
        const listener = {
            onHistory,
            filters: {
                source: filters?.source ?? "all",
                scope: filters?.scope ?? "all"
            }
        };
        if (!this.historyReactor.scheduler.isActivelyListening) {
            this.historyReactor.start();
            this.historyReactor.scheduler.execute();
        }
        this.listeners.add(listener);
        return ()=>{
            this.listeners.delete(listener);
            if (this.listeners.size === 0) {
                this.historyReactor.stop();
            }
        };
    }
    isMergingRemoteChanges = false;
    /**
   * Merge changes from a remote source
   *
   * @param fn - A function that merges the external changes.
   * @public
   */ mergeRemoteChanges(fn) {
        if (this.isMergingRemoteChanges) {
            return fn();
        }
        if (this._isInAtomicOp) {
            throw new Error("Cannot merge remote changes while in atomic operation");
        }
        try {
            this.atomic(fn, true, true);
        } finally{
            this.ensureStoreIsUsable();
        }
    }
    /**
   * Run `fn` and return a {@link RecordsDiff} of the changes that occurred as a result.
   */ extractingChanges(fn) {
        const changes = [];
        const dispose = this.historyAccumulator.addInterceptor((entry)=>changes.push(entry.changes));
        try {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$transactions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["transact"])(fn);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$RecordsDiff$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["squashRecordDiffs"])(changes);
        } finally{
            dispose();
        }
    }
    applyDiff(diff, { runCallbacks = true, ignoreEphemeralKeys = false } = {}) {
        this.atomic(()=>{
            const toPut = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["objectMapValues"])(diff.added);
            for (const [_from, to] of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["objectMapValues"])(diff.updated)){
                const type = this.schema.getType(to.typeName);
                if (ignoreEphemeralKeys && type.ephemeralKeySet.size) {
                    const existing = this.get(to.id);
                    if (!existing) {
                        toPut.push(to);
                        continue;
                    }
                    let changed = null;
                    for (const [key, value] of Object.entries(to)){
                        if (type.ephemeralKeySet.has(key) || Object.is(value, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getOwnProperty"])(existing, key))) {
                            continue;
                        }
                        if (!changed) changed = {
                            ...existing
                        };
                        changed[key] = value;
                    }
                    if (changed) toPut.push(changed);
                } else {
                    toPut.push(to);
                }
            }
            const toRemove = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["objectMapKeys"])(diff.removed);
            if (toPut.length) {
                this.put(toPut);
            }
            if (toRemove.length) {
                this.remove(toRemove);
            }
        }, runCallbacks);
    }
    /**
   * Create a cache based on values in the store. Pass in a function that takes and ID and a
   * signal for the underlying record. Return a signal (usually a computed) for the cached value.
   * For simple derivations, use {@link Store.createComputedCache}. This function is useful if you
   * need more precise control over intermediate values.
   */ createCache(create) {
        const cache = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$cache$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["WeakCache"]();
        return {
            get: (id)=>{
                const atom2 = this.records.getAtom(id);
                if (!atom2) return void 0;
                return cache.get(atom2, ()=>create(id, atom2)).get();
            }
        };
    }
    /**
   * Create a computed cache.
   *
   * @param name - The name of the derivation cache.
   * @param derive - A function used to derive the value of the cache.
   * @param opts - Options for the computed cache.
   * @public
   */ createComputedCache(name, derive, opts) {
        return this.createCache((id, record)=>{
            const recordSignal = opts?.areRecordsEqual ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$Computed$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["computed"])(`${name}:${id}:isEqual`, ()=>record.get(), {
                isEqual: opts.areRecordsEqual
            }) : record;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$Computed$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["computed"])(name + ":" + id, ()=>{
                return derive(recordSignal.get());
            }, {
                isEqual: opts?.areResultsEqual
            });
        });
    }
    _integrityChecker;
    /** @internal */ ensureStoreIsUsable() {
        this.atomic(()=>{
            this._integrityChecker ??= this.schema.createIntegrityChecker(this);
            this._integrityChecker?.();
        });
    }
    _isPossiblyCorrupted = false;
    /** @internal */ markAsPossiblyCorrupted() {
        this._isPossiblyCorrupted = true;
    }
    /** @internal */ isPossiblyCorrupted() {
        return this._isPossiblyCorrupted;
    }
    pendingAfterEvents = null;
    addDiffForAfterEvent(before, after) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(this.pendingAfterEvents, "must be in event operation");
        if (before === after) return;
        if (before && after) (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(before.id === after.id);
        if (!before && !after) return;
        const id = (before || after).id;
        const existing = this.pendingAfterEvents.get(id);
        if (existing) {
            existing.after = after;
        } else {
            this.pendingAfterEvents.set(id, {
                before,
                after
            });
        }
    }
    flushAtomicCallbacks(isMergingRemoteChanges) {
        let updateDepth = 0;
        let source = isMergingRemoteChanges ? "remote" : "user";
        while(this.pendingAfterEvents){
            const events = this.pendingAfterEvents;
            this.pendingAfterEvents = null;
            if (!this.sideEffects.isEnabled()) continue;
            updateDepth++;
            if (updateDepth > 100) {
                throw new Error("Maximum store update depth exceeded, bailing out");
            }
            for (const { before, after } of events.values()){
                if (before && after && before !== after && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2e$isequal$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__isEqual$3e$__["isEqual"])(before, after)) {
                    this.sideEffects.handleAfterChange(before, after, source);
                } else if (before && !after) {
                    this.sideEffects.handleAfterDelete(before, source);
                } else if (!before && after) {
                    this.sideEffects.handleAfterCreate(after, source);
                }
            }
            if (!this.pendingAfterEvents) {
                this.sideEffects.handleOperationComplete(source);
            } else {
                source = "user";
            }
        }
    }
    _isInAtomicOp = false;
    /** @internal */ atomic(fn, runCallbacks = true, isMergingRemoteChanges = false) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$state$2f$dist$2d$esm$2f$lib$2f$transactions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["transact"])(()=>{
            if (this._isInAtomicOp) {
                if (!this.pendingAfterEvents) this.pendingAfterEvents = /* @__PURE__ */ new Map();
                const prevSideEffectsEnabled2 = this.sideEffects.isEnabled();
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(!isMergingRemoteChanges, "cannot call mergeRemoteChanges while in atomic operation");
                try {
                    if (prevSideEffectsEnabled2 && !runCallbacks) {
                        this.sideEffects.setIsEnabled(false);
                    }
                    return fn();
                } finally{
                    this.sideEffects.setIsEnabled(prevSideEffectsEnabled2);
                }
            }
            this.pendingAfterEvents = /* @__PURE__ */ new Map();
            const prevSideEffectsEnabled = this.sideEffects.isEnabled();
            this.sideEffects.setIsEnabled(runCallbacks ?? prevSideEffectsEnabled);
            this._isInAtomicOp = true;
            if (isMergingRemoteChanges) {
                this.isMergingRemoteChanges = true;
            }
            try {
                const result = fn();
                this.isMergingRemoteChanges = false;
                this.flushAtomicCallbacks(isMergingRemoteChanges);
                return result;
            } finally{
                this.pendingAfterEvents = null;
                this.sideEffects.setIsEnabled(prevSideEffectsEnabled);
                this._isInAtomicOp = false;
                this.isMergingRemoteChanges = false;
            }
        });
    }
    /** @internal */ addHistoryInterceptor(fn) {
        return this.historyAccumulator.addInterceptor((entry)=>fn(entry, this.isMergingRemoteChanges ? "remote" : "user"));
    }
}
function squashHistoryEntries(entries) {
    if (entries.length === 0) return [];
    const chunked = [];
    let chunk = [
        entries[0]
    ];
    let entry;
    for(let i = 1, n = entries.length; i < n; i++){
        entry = entries[i];
        if (chunk[0].source !== entry.source) {
            chunked.push(chunk);
            chunk = [];
        }
        chunk.push(entry);
    }
    chunked.push(chunk);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$devFreeze$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["devFreeze"])(chunked.map((chunk2)=>({
            source: chunk2[0].source,
            changes: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$RecordsDiff$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["squashRecordDiffs"])(chunk2.map((e)=>e.changes))
        })));
}
class HistoryAccumulator {
    _history = [];
    _interceptors = /* @__PURE__ */ new Set();
    addInterceptor(fn) {
        this._interceptors.add(fn);
        return ()=>{
            this._interceptors.delete(fn);
        };
    }
    add(entry) {
        this._history.push(entry);
        for (const interceptor of this._interceptors){
            interceptor(entry);
        }
    }
    flush() {
        const history = squashHistoryEntries(this._history);
        this._history = [];
        return history;
    }
    clear() {
        this._history = [];
    }
    hasChanges() {
        return this._history.length > 0;
    }
}
function createComputedCache(name, derive, opts) {
    const cache = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$cache$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["WeakCache"]();
    return {
        get (context, id) {
            const computedCache = cache.get(context, ()=>{
                const store = context instanceof Store ? context : context.store;
                return store.createComputedCache(name, (record)=>derive(context, record), opts);
            });
            return computedCache.get(id);
        }
    };
}
;
 //# sourceMappingURL=Store.mjs.map
}}),
"[project]/node_modules/@tldraw/store/dist-esm/lib/StoreSchema.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "StoreSchema": (()=>StoreSchema),
    "upgradeSchema": (()=>upgradeSchema)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/index.mjs [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/lib/control.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/lib/object.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$value$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/lib/value.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$migrate$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/store/dist-esm/lib/migrate.mjs [app-ssr] (ecmascript)");
;
;
function upgradeSchema(schema) {
    if (schema.schemaVersion > 2 || schema.schemaVersion < 1) return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Result"].err("Bad schema version");
    if (schema.schemaVersion === 2) return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Result"].ok(schema);
    const result = {
        schemaVersion: 2,
        sequences: {
            "com.tldraw.store": schema.storeVersion
        }
    };
    for (const [typeName, recordVersion] of Object.entries(schema.recordVersions)){
        result.sequences[`com.tldraw.${typeName}`] = recordVersion.version;
        if ("subTypeKey" in recordVersion) {
            for (const [subType, version] of Object.entries(recordVersion.subTypeVersions)){
                result.sequences[`com.tldraw.${typeName}.${subType}`] = version;
            }
        }
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Result"].ok(result);
}
class StoreSchema {
    constructor(types, options){
        this.types = types;
        this.options = options;
        for (const m of options.migrations ?? []){
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(!this.migrations[m.sequenceId], `Duplicate migration sequenceId ${m.sequenceId}`);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$migrate$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["validateMigrations"])(m);
            this.migrations[m.sequenceId] = m;
        }
        const allMigrations = Object.values(this.migrations).flatMap((m)=>m.sequence);
        this.sortedMigrations = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$migrate$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sortMigrations"])(allMigrations);
        for (const migration of this.sortedMigrations){
            if (!migration.dependsOn?.length) continue;
            for (const dep of migration.dependsOn){
                const depMigration = allMigrations.find((m)=>m.id === dep);
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(depMigration, `Migration '${migration.id}' depends on missing migration '${dep}'`);
            }
        }
    }
    static create(types, options) {
        return new StoreSchema(types, options ?? {});
    }
    migrations = {};
    sortedMigrations;
    validateRecord(store, record, phase, recordBefore) {
        try {
            const recordType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getOwnProperty"])(this.types, record.typeName);
            if (!recordType) {
                throw new Error(`Missing definition for record type ${record.typeName}`);
            }
            return recordType.validate(record, recordBefore ?? void 0);
        } catch (error) {
            if (this.options.onValidationFailure) {
                return this.options.onValidationFailure({
                    store,
                    record,
                    phase,
                    recordBefore,
                    error
                });
            } else {
                throw error;
            }
        }
    }
    // TODO: use a weakmap to store the result of this function
    getMigrationsSince(persistedSchema) {
        const upgradeResult = upgradeSchema(persistedSchema);
        if (!upgradeResult.ok) {
            return upgradeResult;
        }
        const schema = upgradeResult.value;
        const sequenceIdsToInclude = new Set(// start with any shared sequences
        Object.keys(schema.sequences).filter((sequenceId)=>this.migrations[sequenceId]));
        for(const sequenceId in this.migrations){
            if (schema.sequences[sequenceId] === void 0 && this.migrations[sequenceId].retroactive) {
                sequenceIdsToInclude.add(sequenceId);
            }
        }
        if (sequenceIdsToInclude.size === 0) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Result"].ok([]);
        }
        const allMigrationsToInclude = /* @__PURE__ */ new Set();
        for (const sequenceId of sequenceIdsToInclude){
            const theirVersion = schema.sequences[sequenceId];
            if (typeof theirVersion !== "number" && this.migrations[sequenceId].retroactive || theirVersion === 0) {
                for (const migration of this.migrations[sequenceId].sequence){
                    allMigrationsToInclude.add(migration.id);
                }
                continue;
            }
            const theirVersionId = `${sequenceId}/${theirVersion}`;
            const idx = this.migrations[sequenceId].sequence.findIndex((m)=>m.id === theirVersionId);
            if (idx === -1) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Result"].err("Incompatible schema?");
            }
            for (const migration of this.migrations[sequenceId].sequence.slice(idx + 1)){
                allMigrationsToInclude.add(migration.id);
            }
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Result"].ok(this.sortedMigrations.filter(({ id })=>allMigrationsToInclude.has(id)));
    }
    migratePersistedRecord(record, persistedSchema, direction = "up") {
        const migrations = this.getMigrationsSince(persistedSchema);
        if (!migrations.ok) {
            console.error("Error migrating record", migrations.error);
            return {
                type: "error",
                reason: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$migrate$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MigrationFailureReason"].MigrationError
            };
        }
        let migrationsToApply = migrations.value;
        if (migrationsToApply.length === 0) {
            return {
                type: "success",
                value: record
            };
        }
        if (migrationsToApply.some((m)=>m.scope === "store")) {
            return {
                type: "error",
                reason: direction === "down" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$migrate$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MigrationFailureReason"].TargetVersionTooOld : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$migrate$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MigrationFailureReason"].TargetVersionTooNew
            };
        }
        if (direction === "down") {
            if (!migrationsToApply.every((m)=>m.down)) {
                return {
                    type: "error",
                    reason: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$migrate$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MigrationFailureReason"].TargetVersionTooOld
                };
            }
            migrationsToApply = migrationsToApply.slice().reverse();
        }
        record = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$value$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["structuredClone"])(record);
        try {
            for (const migration of migrationsToApply){
                if (migration.scope === "store") throw new Error();
                const shouldApply = migration.filter ? migration.filter(record) : true;
                if (!shouldApply) continue;
                const result = migration[direction](record);
                if (result) {
                    record = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$value$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["structuredClone"])(result);
                }
            }
        } catch (e) {
            console.error("Error migrating record", e);
            return {
                type: "error",
                reason: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$migrate$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MigrationFailureReason"].MigrationError
            };
        }
        return {
            type: "success",
            value: record
        };
    }
    migrateStoreSnapshot(snapshot) {
        let { store } = snapshot;
        const migrations = this.getMigrationsSince(snapshot.schema);
        if (!migrations.ok) {
            console.error("Error migrating store", migrations.error);
            return {
                type: "error",
                reason: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$migrate$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MigrationFailureReason"].MigrationError
            };
        }
        const migrationsToApply = migrations.value;
        if (migrationsToApply.length === 0) {
            return {
                type: "success",
                value: store
            };
        }
        store = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$value$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["structuredClone"])(store);
        try {
            for (const migration of migrationsToApply){
                if (migration.scope === "record") {
                    for (const [id, record] of Object.entries(store)){
                        const shouldApply = migration.filter ? migration.filter(record) : true;
                        if (!shouldApply) continue;
                        const result = migration.up(record);
                        if (result) {
                            store[id] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$value$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["structuredClone"])(result);
                        }
                    }
                } else if (migration.scope === "store") {
                    const result = migration.up(store);
                    if (result) {
                        store = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$value$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["structuredClone"])(result);
                    }
                } else {
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["exhaustiveSwitchError"])(migration);
                }
            }
        } catch (e) {
            console.error("Error migrating store", e);
            return {
                type: "error",
                reason: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$migrate$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MigrationFailureReason"].MigrationError
            };
        }
        return {
            type: "success",
            value: store
        };
    }
    /** @internal */ createIntegrityChecker(store) {
        return this.options.createIntegrityChecker?.(store) ?? void 0;
    }
    serialize() {
        return {
            schemaVersion: 2,
            sequences: Object.fromEntries(Object.values(this.migrations).map(({ sequenceId, sequence })=>[
                    sequenceId,
                    sequence.length ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$migrate$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseMigrationId"])(sequence.at(-1).id).version : 0
                ]))
        };
    }
    /**
   * @deprecated This is only here for legacy reasons, don't use it unless you have david's blessing!
   */ serializeEarliestVersion() {
        return {
            schemaVersion: 2,
            sequences: Object.fromEntries(Object.values(this.migrations).map(({ sequenceId })=>[
                    sequenceId,
                    0
                ]))
        };
    }
    /** @internal */ getType(typeName) {
        const type = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$object$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getOwnProperty"])(this.types, typeName);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$control$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(type, "record type does not exists");
        return type;
    }
}
;
 //# sourceMappingURL=StoreSchema.mjs.map
}}),
"[project]/node_modules/@tldraw/store/dist-esm/index.mjs [app-ssr] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/index.mjs [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$version$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/lib/version.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$AtomMap$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/store/dist-esm/lib/AtomMap.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$devFreeze$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/store/dist-esm/lib/devFreeze.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$IncrementalSetConstructor$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/store/dist-esm/lib/IncrementalSetConstructor.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$migrate$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/store/dist-esm/lib/migrate.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$RecordsDiff$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/store/dist-esm/lib/RecordsDiff.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$RecordType$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/store/dist-esm/lib/RecordType.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$Store$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/store/dist-esm/lib/Store.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$StoreQueries$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/store/dist-esm/lib/StoreQueries.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$StoreSchema$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/store/dist-esm/lib/StoreSchema.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$StoreSideEffects$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/store/dist-esm/lib/StoreSideEffects.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$lib$2f$version$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["registerTldrawLibraryVersion"])("@tldraw/store", "3.15.3", "esm");
;
 //# sourceMappingURL=index.mjs.map
}}),
"[project]/node_modules/@tldraw/store/dist-esm/index.mjs [app-ssr] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$utils$2f$dist$2d$esm$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/utils/dist-esm/index.mjs [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$AtomMap$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/store/dist-esm/lib/AtomMap.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$devFreeze$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/store/dist-esm/lib/devFreeze.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$IncrementalSetConstructor$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/store/dist-esm/lib/IncrementalSetConstructor.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$migrate$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/store/dist-esm/lib/migrate.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$RecordsDiff$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/store/dist-esm/lib/RecordsDiff.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$RecordType$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/store/dist-esm/lib/RecordType.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$Store$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/store/dist-esm/lib/Store.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$StoreQueries$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/store/dist-esm/lib/StoreQueries.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$StoreSchema$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/store/dist-esm/lib/StoreSchema.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$lib$2f$StoreSideEffects$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/store/dist-esm/lib/StoreSideEffects.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tldraw$2f$store$2f$dist$2d$esm$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@tldraw/store/dist-esm/index.mjs [app-ssr] (ecmascript) <locals>");
}}),

};

//# sourceMappingURL=node_modules_%40tldraw_store_dist-esm_ae67f0de._.js.map