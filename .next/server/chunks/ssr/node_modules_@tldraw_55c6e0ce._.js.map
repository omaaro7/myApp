{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/utils/src/lib/version.ts"],"sourcesContent":["interface TldrawLibraryVersion {\n\tname: string\n\tversion: string\n\tmodules: string\n}\n\ninterface TldrawLibraryVersionInfo {\n\tversions: TldrawLibraryVersion[]\n\tdidWarn: boolean\n\tscheduledNotice: number | NodeJS.Timeout | null\n}\n\nconst TLDRAW_LIBRARY_VERSION_KEY = '__TLDRAW_LIBRARY_VERSIONS__' as const\n\n// eslint-disable-next-line @typescript-eslint/prefer-namespace-keyword, @typescript-eslint/no-namespace\ndeclare module globalThis {\n\texport const __TLDRAW_LIBRARY_VERSIONS__: TldrawLibraryVersionInfo\n}\n\nfunction getLibraryVersions(): TldrawLibraryVersionInfo {\n\tif (globalThis[TLDRAW_LIBRARY_VERSION_KEY]) {\n\t\treturn globalThis[TLDRAW_LIBRARY_VERSION_KEY]\n\t}\n\n\tconst info: TldrawLibraryVersionInfo = {\n\t\tversions: [],\n\t\tdidWarn: false,\n\t\tscheduledNotice: null,\n\t}\n\n\tObject.defineProperty(globalThis, TLDRAW_LIBRARY_VERSION_KEY, {\n\t\tvalue: info,\n\t\twritable: false,\n\t\tconfigurable: false,\n\t\tenumerable: false,\n\t})\n\n\treturn info\n}\n\nexport function clearRegisteredVersionsForTests() {\n\tconst info = getLibraryVersions()\n\tinfo.versions = []\n\tinfo.didWarn = false\n\tif (info.scheduledNotice) {\n\t\tclearTimeout(info.scheduledNotice)\n\t\tinfo.scheduledNotice = null\n\t}\n}\n\n/** @internal */\nexport function registerTldrawLibraryVersion(name?: string, version?: string, modules?: string) {\n\tif (!name || !version || !modules) {\n\t\tif ((globalThis as any).TLDRAW_LIBRARY_IS_BUILD) {\n\t\t\tthrow new Error('Missing name/version/module system in built version of tldraw library')\n\t\t}\n\t\treturn\n\t}\n\n\tconst info = getLibraryVersions()\n\tinfo.versions.push({ name, version, modules })\n\n\tif (!info.scheduledNotice) {\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-restricted-globals\n\t\t\tinfo.scheduledNotice = setTimeout(() => {\n\t\t\t\tinfo.scheduledNotice = null\n\t\t\t\tcheckLibraryVersions(info)\n\t\t\t}, 100)\n\t\t} catch {\n\t\t\t// some environments (e.g. cloudflare workers) don't support setTimeout immediately, only in a handler.\n\t\t\t// in this case, we'll just check immediately.\n\t\t\tcheckLibraryVersions(info)\n\t\t}\n\t}\n}\n\nfunction checkLibraryVersions(info: TldrawLibraryVersionInfo) {\n\tif (!info.versions.length) return\n\tif (info.didWarn) return\n\n\tconst sorted = info.versions.sort((a, b) => compareVersions(a.version, b.version))\n\tconst latestVersion = sorted[sorted.length - 1].version\n\n\tconst matchingVersions = new Set<string>()\n\tconst nonMatchingVersions = new Map<string, Set<string>>()\n\tfor (const lib of sorted) {\n\t\tif (nonMatchingVersions.has(lib.name)) {\n\t\t\tmatchingVersions.delete(lib.name)\n\t\t\tentry(nonMatchingVersions, lib.name, new Set()).add(lib.version)\n\t\t\tcontinue\n\t\t}\n\n\t\tif (lib.version === latestVersion) {\n\t\t\tmatchingVersions.add(lib.name)\n\t\t} else {\n\t\t\tmatchingVersions.delete(lib.name)\n\t\t\tentry(nonMatchingVersions, lib.name, new Set()).add(lib.version)\n\t\t}\n\t}\n\n\tif (nonMatchingVersions.size > 0) {\n\t\tconst message = [\n\t\t\t`${format('[tldraw]', ['bold', 'bgRed', 'textWhite'])} ${format('You have multiple versions of tldraw libraries installed. This can lead to bugs and unexpected behavior.', ['textRed', 'bold'])}`,\n\t\t\t'',\n\t\t\t`The latest version you have installed is ${format(`v${latestVersion}`, ['bold', 'textBlue'])}. The following libraries are on the latest version:`,\n\t\t\t...Array.from(matchingVersions, (name) => `  • ✅ ${format(name, ['bold'])}`),\n\t\t\t'',\n\t\t\t`The following libraries are not on the latest version, or have multiple versions installed:`,\n\t\t\t...Array.from(nonMatchingVersions, ([name, versions]) => {\n\t\t\t\tconst sortedVersions = Array.from(versions)\n\t\t\t\t\t.sort(compareVersions)\n\t\t\t\t\t.map((v) => format(`v${v}`, v === latestVersion ? ['textGreen'] : ['textRed']))\n\t\t\t\treturn `  • ❌ ${format(name, ['bold'])} (${sortedVersions.join(', ')})`\n\t\t\t}),\n\t\t]\n\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.log(message.join('\\n'))\n\t\tinfo.didWarn = true\n\t\treturn\n\t}\n\n\t// at this point, we know that everything has the same version. there may still be duplicates though!\n\tconst potentialDuplicates = new Map<string, { version: string; modules: string[] }>()\n\tfor (const lib of sorted) {\n\t\tentry(potentialDuplicates, lib.name, { version: lib.version, modules: [] }).modules.push(\n\t\t\tlib.modules\n\t\t)\n\t}\n\n\tconst duplicates = new Map<string, { version: string; modules: string[] }>()\n\tfor (const [name, lib] of potentialDuplicates) {\n\t\tif (lib.modules.length > 1) duplicates.set(name, lib)\n\t}\n\n\tif (duplicates.size > 0) {\n\t\tconst message = [\n\t\t\t`${format('[tldraw]', ['bold', 'bgRed', 'textWhite'])} ${format('You have multiple instances of some tldraw libraries active. This can lead to bugs and unexpected behavior. ', ['textRed', 'bold'])}`,\n\t\t\t'',\n\t\t\t'This usually means that your bundler is misconfigured, and is importing the same library multiple times - usually once as an ES Module, and once as a CommonJS module.',\n\t\t\t'',\n\t\t\t'The following libraries have been imported multiple times:',\n\t\t\t...Array.from(duplicates, ([name, lib]) => {\n\t\t\t\tconst modules = lib.modules\n\t\t\t\t\t.map((m, i) => (m === 'esm' ? `      ${i + 1}. ES Modules` : `      ${i + 1}. CommonJS`))\n\t\t\t\t\t.join('\\n')\n\t\t\t\treturn `  • ❌ ${format(name, ['bold'])} v${lib.version}: \\n${modules}`\n\t\t\t}),\n\t\t\t'',\n\t\t\t'You should configure your bundler to only import one version of each library.',\n\t\t]\n\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.log(message.join('\\n'))\n\t\tinfo.didWarn = true\n\t\treturn\n\t}\n}\n\nfunction compareVersions(a: string, b: string) {\n\tconst aMatch = a.match(/^(\\d+)\\.(\\d+)\\.(\\d+)(?:-(\\w+))?$/)\n\tconst bMatch = b.match(/^(\\d+)\\.(\\d+)\\.(\\d+)(?:-(\\w+))?$/)\n\n\tif (!aMatch || !bMatch) return a.localeCompare(b)\n\tif (aMatch[1] !== bMatch[1]) return Number(aMatch[1]) - Number(bMatch[1])\n\tif (aMatch[2] !== bMatch[2]) return Number(aMatch[2]) - Number(bMatch[2])\n\tif (aMatch[3] !== bMatch[3]) return Number(aMatch[3]) - Number(bMatch[3])\n\tif (aMatch[4] && bMatch[4]) return aMatch[4].localeCompare(bMatch[4])\n\tif (aMatch[4]) return 1\n\tif (bMatch[4]) return -1\n\treturn 0\n}\n\nconst formats = {\n\tbold: '1',\n\ttextBlue: '94',\n\ttextRed: '31',\n\ttextGreen: '32',\n\tbgRed: '41',\n\ttextWhite: '97',\n} as const\nfunction format(value: string, formatters: (keyof typeof formats)[] = []) {\n\treturn `\\x1B[${formatters.map((f) => formats[f]).join(';')}m${value}\\x1B[m`\n}\n\nfunction entry<K, V>(map: Map<K, V>, key: K, defaultValue: V): V {\n\tif (map.has(key)) {\n\t\treturn map.get(key)!\n\t}\n\tmap.set(key, defaultValue)\n\treturn defaultValue\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 195, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/utils/src/lib/array.ts"],"sourcesContent":["/**\n * Rotate the contents of an array.\n *\n * @public\n */\nexport function rotateArray<T>(arr: T[], offset: number): T[] {\n\treturn arr.map((_, i) => arr[(i + offset) % arr.length])\n}\n\n/**\n * Deduplicate the items in an array\n *\n * @public\n */\nexport function dedupe<T>(input: T[], equals?: (a: any, b: any) => boolean): T[] {\n\tconst result: T[] = []\n\tmainLoop: for (const item of input) {\n\t\tfor (const existing of result) {\n\t\t\tif (equals ? equals(item, existing) : item === existing) {\n\t\t\t\tcontinue mainLoop\n\t\t\t}\n\t\t}\n\t\tresult.push(item)\n\t}\n\treturn result\n}\n\n/** @internal */\nexport function compact<T>(arr: T[]): NonNullable<T>[] {\n\treturn arr.filter((i) => i !== undefined && i !== null) as any\n}\n\n/** @internal */\nexport function last<T>(arr: readonly T[]): T | undefined {\n\treturn arr[arr.length - 1]\n}\n\n/** @internal */\nexport function minBy<T>(arr: readonly T[], fn: (item: T) => number): T | undefined {\n\tlet min: T | undefined\n\tlet minVal = Infinity\n\tfor (const item of arr) {\n\t\tconst val = fn(item)\n\t\tif (val < minVal) {\n\t\t\tmin = item\n\t\t\tminVal = val\n\t\t}\n\t}\n\treturn min\n}\n\n/** @internal */\nexport function maxBy<T>(arr: readonly T[], fn: (item: T) => number): T | undefined {\n\tlet max: T | undefined\n\tlet maxVal: number = -Infinity\n\tfor (const item of arr) {\n\t\tconst val = fn(item)\n\t\tif (val > maxVal) {\n\t\t\tmax = item\n\t\t\tmaxVal = val\n\t\t}\n\t}\n\treturn max\n}\n\n/**\n * Partitions an array into two arrays, one with items that satisfy the predicate, and one with\n * items that do not.\n *\n * @param arr - The array to partition\n * @param predicate - The predicate to use to partition the array\n * @returns A tuple of two arrays, the first one with items that satisfy the predicate and the\n *   second one with the ones that dont\n * @internal\n */\nexport function partition<T>(arr: T[], predicate: (item: T) => boolean): [T[], T[]] {\n\tconst satisfies: T[] = []\n\tconst doesNotSatisfy: T[] = []\n\tfor (const item of arr) {\n\t\tif (predicate(item)) {\n\t\t\tsatisfies.push(item)\n\t\t} else {\n\t\t\tdoesNotSatisfy.push(item)\n\t\t}\n\t}\n\treturn [satisfies, doesNotSatisfy]\n}\n\n/** @internal */\nexport function areArraysShallowEqual<T>(arr1: readonly T[], arr2: readonly T[]): boolean {\n\tif (arr1 === arr2) return true\n\tif (arr1.length !== arr2.length) return false\n\tfor (let i = 0; i < arr1.length; i++) {\n\t\tif (!Object.is(arr1[i], arr2[i])) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n/** @internal */\nexport function mergeArraysAndReplaceDefaults<\n\tconst Key extends string,\n\tT extends { [K in Key]: string },\n>(key: Key, customEntries: readonly T[], defaults: readonly T[]) {\n\tconst overrideTypes = new Set(customEntries.map((entry) => entry[key]))\n\n\tconst result = []\n\tfor (const defaultEntry of defaults) {\n\t\tif (overrideTypes.has(defaultEntry[key])) continue\n\t\tresult.push(defaultEntry)\n\t}\n\n\tfor (const customEntry of customEntries) {\n\t\tresult.push(customEntry)\n\t}\n\n\treturn result\n}\n"],"names":[],"mappings":";;;;;;;;;;;AAKO,SAAS,YAAe,GAAA,EAAU,MAAA,EAAqB;IAC7D,OAAO,IAAI,GAAA,CAAI,CAAC,GAAG,IAAM,GAAA,CAAA,CAAK,IAAI,MAAA,IAAU,IAAI,MAAM,CAAC;AACxD;AAOO,SAAS,OAAU,KAAA,EAAY,MAAA,EAA2C;IAChF,MAAM,SAAc,CAAC,CAAA;IACrB,SAAU,CAAA,KAAA,MAAW,QAAQ,MAAO;QACnC,KAAA,MAAW,YAAY,OAAQ;YAC9B,IAAI,SAAS,OAAO,MAAM,QAAQ,IAAI,SAAS,UAAU;gBACxD,SAAS;YACV;QACD;QACA,OAAO,IAAA,CAAK,IAAI;IACjB;IACA,OAAO;AACR;AAGO,SAAS,QAAW,GAAA,EAA4B;IACtD,OAAO,IAAI,MAAA,CAAO,CAAC,IAAM,MAAM,KAAA,KAAa,MAAM,IAAI;AACvD;AAGO,SAAS,KAAQ,GAAA,EAAkC;IACzD,OAAO,GAAA,CAAI,IAAI,MAAA,GAAS,CAAC,CAAA;AAC1B;AAGO,SAAS,MAAS,GAAA,EAAmB,EAAA,EAAwC;IACnF,IAAI;IACJ,IAAI,SAAS;IACb,KAAA,MAAW,QAAQ,IAAK;QACvB,MAAM,MAAM,GAAG,IAAI;QACnB,IAAI,MAAM,QAAQ;YACjB,MAAM;YACN,SAAS;QACV;IACD;IACA,OAAO;AACR;AAGO,SAAS,MAAS,GAAA,EAAmB,EAAA,EAAwC;IACnF,IAAI;IACJ,IAAI,SAAiB,CAAA;IACrB,KAAA,MAAW,QAAQ,IAAK;QACvB,MAAM,MAAM,GAAG,IAAI;QACnB,IAAI,MAAM,QAAQ;YACjB,MAAM;YACN,SAAS;QACV;IACD;IACA,OAAO;AACR;AAYO,SAAS,UAAa,GAAA,EAAU,SAAA,EAA6C;IACnF,MAAM,YAAiB,CAAC,CAAA;IACxB,MAAM,iBAAsB,CAAC,CAAA;IAC7B,KAAA,MAAW,QAAQ,IAAK;QACvB,IAAI,UAAU,IAAI,GAAG;YACpB,UAAU,IAAA,CAAK,IAAI;QACpB,OAAO;YACN,eAAe,IAAA,CAAK,IAAI;QACzB;IACD;IACA,OAAO;QAAC;QAAW,cAAc;KAAA;AAClC;AAGO,SAAS,sBAAyB,IAAA,EAAoB,IAAA,EAA6B;IACzF,IAAI,SAAS,KAAM,CAAA,OAAO;IAC1B,IAAI,KAAK,MAAA,KAAW,KAAK,MAAA,CAAQ,CAAA,OAAO;IACxC,IAAA,IAAS,IAAI,GAAG,IAAI,KAAK,MAAA,EAAQ,IAAK;QACrC,IAAI,CAAC,OAAO,EAAA,CAAG,IAAA,CAAK,CAAC,CAAA,EAAG,IAAA,CAAK,CAAC,CAAC,GAAG;YACjC,OAAO;QACR;IACD;IACA,OAAO;AACR;AAGO,SAAS,8BAGd,GAAA,EAAU,aAAA,EAA6B,QAAA,EAAwB;IAChE,MAAM,gBAAgB,IAAI,IAAI,cAAc,GAAA,CAAI,CAAC,QAAU,KAAA,CAAM,GAAG,CAAC,CAAC;IAEtE,MAAM,SAAS,CAAC,CAAA;IAChB,KAAA,MAAW,gBAAgB,SAAU;QACpC,IAAI,cAAc,GAAA,CAAI,YAAA,CAAa,GAAG,CAAC,EAAG,CAAA;QAC1C,OAAO,IAAA,CAAK,YAAY;IACzB;IAEA,KAAA,MAAW,eAAe,cAAe;QACxC,OAAO,IAAA,CAAK,WAAW;IACxB;IAEA,OAAO;AACR","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 296, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/utils/src/lib/function.ts"],"sourcesContent":["/**\n * When a function is wrapped in `omitFromStackTrace`, if it throws an error the stack trace won't\n * include the function itself or any stack frames above it. Useful for assertion-style function\n * where the error will ideally originate from the call-site rather than within the implementation\n * of the assert fn.\n *\n * Only works in platforms that support `Error.captureStackTrace` (ie v8).\n *\n * @internal\n */\nexport function omitFromStackTrace<Args extends Array<unknown>, Return>(\n\tfn: (...args: Args) => Return\n): (...args: Args) => Return {\n\tconst wrappedFn = (...args: Args) => {\n\t\ttry {\n\t\t\treturn fn(...args)\n\t\t} catch (error) {\n\t\t\tif (error instanceof Error && Error.captureStackTrace) {\n\t\t\t\tError.captureStackTrace(error, wrappedFn)\n\t\t\t}\n\t\t\tthrow error\n\t\t}\n\t}\n\n\treturn wrappedFn\n}\n\n/**\n * Does nothing, but it's really really good at it.\n * @internal\n */\nexport const noop: () => void = () => {}\n"],"names":[],"mappings":";;;;AAUO,SAAS,mBACf,EAAA,EAC4B;IAC5B,MAAM,YAAY,CAAA,GAAI,SAAe;QACpC,IAAI;YACH,OAAO,GAAG,GAAG,IAAI;QAClB,EAAA,OAAS,OAAO;YACf,IAAI,iBAAiB,SAAS,MAAM,iBAAA,EAAmB;gBACtD,MAAM,iBAAA,CAAkB,OAAO,SAAS;YACzC;YACA,MAAM;QACP;IACD;IAEA,OAAO;AACR;AAMO,MAAM,OAAmB,KAAO,CAAD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 322, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/utils/src/lib/control.ts"],"sourcesContent":["import { omitFromStackTrace } from './function'\n\n/** @public */\nexport interface OkResult<T> {\n\treadonly ok: true\n\treadonly value: T\n}\n/** @public */\nexport interface ErrorResult<E> {\n\treadonly ok: false\n\treadonly error: E\n}\n/** @public */\nexport type Result<T, E> = OkResult<T> | ErrorResult<E>\n\n/** @public */\nexport const Result = {\n\tok<T>(value: T): OkResult<T> {\n\t\treturn { ok: true, value }\n\t},\n\terr<E>(error: E): ErrorResult<E> {\n\t\treturn { ok: false, error }\n\t},\n}\n\n/** @internal */\nexport function exhaustiveSwitchError(value: never, property?: string): never {\n\tconst debugValue =\n\t\tproperty && value && typeof value === 'object' && property in value ? value[property] : value\n\tthrow new Error(`Unknown switch case ${debugValue}`)\n}\n\n/** @internal */\nexport const assert: (value: unknown, message?: string) => asserts value = omitFromStackTrace(\n\t(value, message) => {\n\t\tif (!value) {\n\t\t\tthrow new Error(message || 'Assertion Error')\n\t\t}\n\t}\n)\n\n/** @internal */\nexport const assertExists = omitFromStackTrace(<T>(value: T, message?: string): NonNullable<T> => {\n\t// note that value == null is equivalent to value === null || value === undefined\n\tif (value == null) {\n\t\tthrow new Error(message ?? 'value must be defined')\n\t}\n\treturn value as NonNullable<T>\n})\n\n/** @internal */\nexport function promiseWithResolve<T>(): Promise<T> & {\n\tresolve(value: T): void\n\treject(reason?: any): void\n} {\n\tlet resolve: (value: T) => void\n\tlet reject: (reason?: any) => void\n\tconst promise = new Promise<T>((res, rej) => {\n\t\tresolve = res\n\t\treject = rej\n\t})\n\treturn Object.assign(promise, {\n\t\tresolve: resolve!,\n\t\treject: reject!,\n\t})\n}\n\n/** @internal */\nexport function sleep(ms: number): Promise<void> {\n\t// eslint-disable-next-line no-restricted-globals\n\treturn new Promise((resolve) => setTimeout(resolve, ms))\n}\n"],"names":[],"mappings":";;;;;;;;AAAA,SAAS,0BAA0B;;AAgB5B,MAAM,SAAS;IACrB,IAAM,KAAA,EAAuB;QAC5B,OAAO;YAAE,IAAI;YAAM;QAAM;IAC1B;IACA,KAAO,KAAA,EAA0B;QAChC,OAAO;YAAE,IAAI;YAAO;QAAM;IAC3B;AACD;AAGO,SAAS,sBAAsB,KAAA,EAAc,QAAA,EAA0B;IAC7E,MAAM,aACL,YAAY,SAAS,OAAO,UAAU,YAAY,YAAY,QAAQ,KAAA,CAAM,QAAQ,CAAA,GAAI;IACzF,MAAM,IAAI,MAAM,CAAA,oBAAA,EAAuB,UAAU,EAAE;AACpD;AAGO,MAAM,UAA8D,6LAAA,EAC1E,CAAC,OAAO,YAAY;IACnB,IAAI,CAAC,OAAO;QACX,MAAM,IAAI,MAAM,WAAW,iBAAiB;IAC7C;AACD;AAIM,MAAM,eAAe,8LAAA,EAAmB,CAAI,OAAU,YAAqC;IAEjG,IAAI,SAAS,MAAM;QAClB,MAAM,IAAI,MAAM,WAAW,uBAAuB;IACnD;IACA,OAAO;AACR,CAAC;AAGM,SAAS,qBAGd;IACD,IAAI;IACJ,IAAI;IACJ,MAAM,UAAU,IAAI,QAAW,CAAC,KAAK,QAAQ;QAC5C,UAAU;QACV,SAAS;IACV,CAAC;IACD,OAAO,OAAO,MAAA,CAAO,SAAS;QAC7B;QACA;IACD,CAAC;AACF;AAGO,SAAS,MAAM,EAAA,EAA2B;IAEhD,OAAO,IAAI,QAAQ,CAAC,UAAY,WAAW,SAAS,EAAE,CAAC;AACxD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 384, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/utils/src/lib/bind.ts"],"sourcesContent":["/*!\n * MIT License: https://github.com/NoHomey/bind-decorator/blob/master/License\n * Copyright (c) 2016 Ivo Stratev\n */\n\nimport { assert } from './control'\n\n/**\n * `@bind` is a decorator that binds the method to the instance of the class (legacy stage-2\n * typescript decorators).\n *\n * @public\n */\nexport function bind<T extends (...args: any[]) => any>(\n\ttarget: object,\n\tpropertyKey: string,\n\tdescriptor: TypedPropertyDescriptor<T>\n): TypedPropertyDescriptor<T>\n\n/**\n * `@bind` is a decorator that binds the method to the instance of the class (TC39 decorators).\n *\n * @public\n */\nexport function bind<This extends object, T extends (...args: any[]) => any>(\n\toriginalMethod: T,\n\tcontext: ClassMethodDecoratorContext<This, T>\n): void\n\n/** @public */\nexport function bind(\n\t...args: // legacy stage-2 typescript decorators\n\t| [_target: object, propertyKey: string, descriptor: PropertyDescriptor]\n\t\t// TC39 decorators\n\t\t| [originalMethod: (...args: any[]) => any, context: ClassMemberDecoratorContext]\n): PropertyDescriptor | void {\n\tif (args.length === 2) {\n\t\tconst [originalMethod, context] = args\n\t\tcontext.addInitializer(function initializeMethod(this: any) {\n\t\t\tassert(Reflect.isExtensible(this), 'Cannot bind to a non-extensible class.')\n\t\t\tconst value = originalMethod.bind(this)\n\t\t\tconst ok = Reflect.defineProperty(this, context.name, {\n\t\t\t\tvalue,\n\t\t\t\twritable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t})\n\t\t\tassert(ok, 'Cannot bind a non-configurable class method.')\n\t\t})\n\t} else {\n\t\tconst [_target, propertyKey, descriptor] = args\n\t\tif (!descriptor || typeof descriptor.value !== 'function') {\n\t\t\tthrow new TypeError(\n\t\t\t\t`Only methods can be decorated with @bind. <${propertyKey}> is not a method!`\n\t\t\t)\n\t\t}\n\n\t\treturn {\n\t\t\tconfigurable: true,\n\t\t\tget(this: any): any {\n\t\t\t\tconst bound = descriptor.value!.bind(this)\n\t\t\t\t// Credits to https://github.com/andreypopp/autobind-decorator for memoizing the result of bind against a symbol on the instance.\n\t\t\t\tObject.defineProperty(this, propertyKey, {\n\t\t\t\t\tvalue: bound,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true,\n\t\t\t\t})\n\t\t\t\treturn bound\n\t\t\t},\n\t\t}\n\t}\n}\n"],"names":[],"mappings":"AAAA;;;CAAA;;;AAKA,SAAS,cAAc;;AAyBhB,SAAS,KAAA,GACZ,IAAA,EAIyB;IAC5B,IAAI,KAAK,MAAA,KAAW,GAAG;QACtB,MAAM,CAAC,gBAAgB,OAAO,CAAA,GAAI;QAClC,QAAQ,cAAA,CAAe,SAAS,mBAA4B;YAC3D,CAAA,GAAA,mKAAA,CAAA,SAAA,EAAO,QAAQ,YAAA,CAAa,IAAI,GAAG,wCAAwC;YAC3E,MAAM,QAAQ,eAAe,IAAA,CAAK,IAAI;YACtC,MAAM,KAAK,QAAQ,cAAA,CAAe,IAAA,EAAM,QAAQ,IAAA,EAAM;gBACrD;gBACA,UAAU;gBACV,cAAc;YACf,CAAC;YACD,CAAA,GAAA,mKAAA,CAAA,SAAA,EAAO,IAAI,8CAA8C;QAC1D,CAAC;IACF,OAAO;QACN,MAAM,CAAC,SAAS,aAAa,UAAU,CAAA,GAAI;QAC3C,IAAI,CAAC,cAAc,OAAO,WAAW,KAAA,KAAU,YAAY;YAC1D,MAAM,IAAI,UACT,CAAA,2CAAA,EAA8C,WAAW,CAAA,kBAAA,CAAA;QAE3D;QAEA,OAAO;YACN,cAAc;YACd,MAAoB;gBACnB,MAAM,QAAQ,WAAW,KAAA,CAAO,IAAA,CAAK,IAAI;gBAEzC,OAAO,cAAA,CAAe,IAAA,EAAM,aAAa;oBACxC,OAAO;oBACP,cAAc;oBACd,UAAU;gBACX,CAAC;gBACD,OAAO;YACR;QACD;IACD;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 432, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/utils/src/lib/cache.ts"],"sourcesContent":["/**\n * A micro cache used when storing records in memory (using a WeakMap).\n * @public\n */\nexport class WeakCache<K extends object, V> {\n\t/** The map of items to their cached values. */\n\titems = new WeakMap<K, V>()\n\n\t/**\n\t * Get the cached value for a given record. If the record is not present in the map, the callback\n\t * will be used to create the value (with the result being stored in the cache for next time).\n\t *\n\t * @param item - The item to get.\n\t * @param cb - The callback to use to create the value when a cached value is not found.\n\t */\n\tget<P extends K>(item: P, cb: (item: P) => V) {\n\t\tif (!this.items.has(item)) {\n\t\t\tthis.items.set(item, cb(item))\n\t\t}\n\n\t\treturn this.items.get(item)!\n\t}\n}\n"],"names":[],"mappings":";;;AAIO,MAAM,UAA+B;IAAA,6CAAA,GAE3C,QAAQ,aAAA,GAAA,IAAI,QAAc,EAAA;IAAA;;;;;;GAAA,GAS1B,IAAiB,IAAA,EAAS,EAAA,EAAoB;QAC7C,IAAI,CAAC,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,IAAI,GAAG;YAC1B,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,MAAM,GAAG,IAAI,CAAC;QAC9B;QAEA,OAAO,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI,IAAI;IAC3B;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 458, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/utils/src/lib/debounce.ts"],"sourcesContent":["/**\n * Debounce a function.\n *\n * @example\n *\n * ```ts\n * const A = debounce(myFunction, 1000)\n * ```\n *\n * @public\n * @see source - https://gist.github.com/ca0v/73a31f57b397606c9813472f7493a940\n */\nexport function debounce<T extends unknown[], U>(\n\tcallback: (...args: T) => PromiseLike<U> | U,\n\twait: number\n) {\n\tlet state:\n\t\t| undefined\n\t\t| {\n\t\t\t\ttimeout: ReturnType<typeof setTimeout>\n\t\t\t\tpromise: Promise<U>\n\t\t\t\tresolve(value: U | PromiseLike<U>): void\n\t\t\t\treject(value: any): void\n\t\t\t\tlatestArgs: T\n\t\t  } = undefined\n\n\tconst fn = (...args: T): Promise<U> => {\n\t\tif (!state) {\n\t\t\tstate = {} as any\n\t\t\tstate!.promise = new Promise((resolve, reject) => {\n\t\t\t\tstate!.resolve = resolve\n\t\t\t\tstate!.reject = reject\n\t\t\t})\n\t\t}\n\t\tclearTimeout(state!.timeout)\n\t\tstate!.latestArgs = args\n\t\t// It's up to the consumer of debounce to call `cancel`\n\t\t// eslint-disable-next-line no-restricted-globals\n\t\tstate!.timeout = setTimeout(() => {\n\t\t\tconst s = state!\n\t\t\tstate = undefined\n\t\t\ttry {\n\t\t\t\ts.resolve(callback(...s.latestArgs))\n\t\t\t} catch (e) {\n\t\t\t\ts.reject(e)\n\t\t\t}\n\t\t}, wait)\n\n\t\treturn state!.promise\n\t}\n\tfn.cancel = () => {\n\t\tif (!state) return\n\t\tclearTimeout(state.timeout)\n\t}\n\treturn fn\n}\n"],"names":[],"mappings":";;;AAYO,SAAS,SACf,QAAA,EACA,IAAA,EACC;IACD,IAAI,QAQG,KAAA;IAEP,MAAM,KAAK,CAAA,GAAI,SAAwB;QACtC,IAAI,CAAC,OAAO;YACX,QAAQ,CAAC;YACT,MAAO,OAAA,GAAU,IAAI,QAAQ,CAAC,SAAS,WAAW;gBACjD,MAAO,OAAA,GAAU;gBACjB,MAAO,MAAA,GAAS;YACjB,CAAC;QACF;QACA,aAAa,MAAO,OAAO;QAC3B,MAAO,UAAA,GAAa;QAGpB,MAAO,OAAA,GAAU,WAAW,MAAM;YACjC,MAAM,IAAI;YACV,QAAQ,KAAA;YACR,IAAI;gBACH,EAAE,OAAA,CAAQ,SAAS,GAAG,EAAE,UAAU,CAAC;YACpC,EAAA,OAAS,GAAG;gBACX,EAAE,MAAA,CAAO,CAAC;YACX;QACD,GAAG,IAAI;QAEP,OAAO,MAAO,OAAA;IACf;IACA,GAAG,MAAA,GAAS,MAAM;QACjB,IAAI,CAAC,MAAO,CAAA;QACZ,aAAa,MAAM,OAAO;IAC3B;IACA,OAAO;AACR","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 498, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/utils/src/lib/error.ts"],"sourcesContent":["/** @public */\nexport interface ErrorAnnotations {\n\ttags: Record<string, number | string | boolean | bigint | symbol | null | undefined>\n\textras: Record<string, unknown>\n}\n\nconst annotationsByError = new WeakMap<object, ErrorAnnotations>()\n\n/**\n * Annotate an error with tags and additional data. Annotations won't overwrite existing ones.\n * Retrieve them with `getErrorAnnotations`.\n *\n * @internal\n */\nexport function annotateError(error: unknown, annotations: Partial<ErrorAnnotations>) {\n\tif (typeof error !== 'object' || error === null) return\n\n\tlet currentAnnotations = annotationsByError.get(error)\n\tif (!currentAnnotations) {\n\t\tcurrentAnnotations = { tags: {}, extras: {} }\n\t\tannotationsByError.set(error, currentAnnotations)\n\t}\n\n\tif (annotations.tags) {\n\t\tcurrentAnnotations.tags = {\n\t\t\t...currentAnnotations.tags,\n\t\t\t...annotations.tags,\n\t\t}\n\t}\n\tif (annotations.extras) {\n\t\tcurrentAnnotations.extras = {\n\t\t\t...currentAnnotations.extras,\n\t\t\t...annotations.extras,\n\t\t}\n\t}\n}\n\n/** @internal */\nexport function getErrorAnnotations(error: Error): ErrorAnnotations {\n\treturn annotationsByError.get(error) ?? { tags: {}, extras: {} }\n}\n"],"names":[],"mappings":";;;;AAMA,MAAM,qBAAqB,aAAA,GAAA,IAAI,QAAkC;AAQ1D,SAAS,cAAc,KAAA,EAAgB,WAAA,EAAwC;IACrF,IAAI,OAAO,UAAU,YAAY,UAAU,KAAM,CAAA;IAEjD,IAAI,qBAAqB,mBAAmB,GAAA,CAAI,KAAK;IACrD,IAAI,CAAC,oBAAoB;QACxB,qBAAqB;YAAE,MAAM,CAAC;YAAG,QAAQ,CAAC;QAAE;QAC5C,mBAAmB,GAAA,CAAI,OAAO,kBAAkB;IACjD;IAEA,IAAI,YAAY,IAAA,EAAM;QACrB,mBAAmB,IAAA,GAAO;YACzB,GAAG,mBAAmB,IAAA;YACtB,GAAG,YAAY,IAAA;QAChB;IACD;IACA,IAAI,YAAY,MAAA,EAAQ;QACvB,mBAAmB,MAAA,GAAS;YAC3B,GAAG,mBAAmB,MAAA;YACtB,GAAG,YAAY,MAAA;QAChB;IACD;AACD;AAGO,SAAS,oBAAoB,KAAA,EAAgC;IACnE,OAAO,mBAAmB,GAAA,CAAI,KAAK,KAAK;QAAE,MAAM,CAAC;QAAG,QAAQ,CAAC;IAAE;AAChE","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 540, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/utils/src/lib/ExecutionQueue.ts"],"sourcesContent":["import { sleep } from './control'\n\n/** @internal */\nexport class ExecutionQueue {\n\tprivate queue: (() => Promise<any>)[] = []\n\tprivate running = false\n\n\tconstructor(private readonly timeout?: number) {}\n\n\tisEmpty() {\n\t\treturn this.queue.length === 0 && !this.running\n\t}\n\n\tprivate async run() {\n\t\tif (this.running) return\n\t\ttry {\n\t\t\tthis.running = true\n\t\t\twhile (this.queue.length) {\n\t\t\t\tconst task = this.queue.shift()!\n\t\t\t\tawait task()\n\t\t\t\tif (this.timeout) {\n\t\t\t\t\tawait sleep(this.timeout)\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\t// this try/finally should not be needed because the tasks don't throw\n\t\t\t// but better safe than sorry\n\t\t\tthis.running = false\n\t\t}\n\t}\n\n\tasync push<T>(task: () => T): Promise<Awaited<T>> {\n\t\treturn new Promise<Awaited<T>>((resolve, reject) => {\n\t\t\tthis.queue.push(() => Promise.resolve(task()).then(resolve).catch(reject))\n\t\t\tthis.run()\n\t\t})\n\t}\n\n\tclose() {\n\t\tthis.queue = []\n\t}\n}\n"],"names":[],"mappings":";;;AAAA,SAAS,aAAa;;AAGf,MAAM,eAAe;IAI3B,YAA6B,OAAA,CAAkB;QAAlB,IAAA,CAAA,OAAA,GAAA;IAAmB;IAHxC,QAAgC,CAAC,CAAA,CAAA;IACjC,UAAU,MAAA;IAIlB,UAAU;QACT,OAAO,IAAA,CAAK,KAAA,CAAM,MAAA,KAAW,KAAK,CAAC,IAAA,CAAK,OAAA;IACzC;IAEA,MAAc,MAAM;QACnB,IAAI,IAAA,CAAK,OAAA,CAAS,CAAA;QAClB,IAAI;YACH,IAAA,CAAK,OAAA,GAAU;YACf,MAAO,IAAA,CAAK,KAAA,CAAM,MAAA,CAAQ;gBACzB,MAAM,OAAO,IAAA,CAAK,KAAA,CAAM,KAAA,CAAM;gBAC9B,MAAM,KAAK;gBACX,IAAI,IAAA,CAAK,OAAA,EAAS;oBACjB,OAAM,+KAAA,EAAM,IAAA,CAAK,OAAO;gBACzB;YACD;QACD,SAAE;YAGD,IAAA,CAAK,OAAA,GAAU;QAChB;IACD;IAEA,MAAM,KAAQ,IAAA,EAAoC;QACjD,OAAO,IAAI,QAAoB,CAAC,SAAS,WAAW;YACnD,IAAA,CAAK,KAAA,CAAM,IAAA,CAAK,IAAM,QAAQ,OAAA,CAAQ,KAAK,CAAC,EAAE,IAAA,CAAK,OAAO,EAAE,KAAA,CAAM,MAAM,CAAC;YACzE,IAAA,CAAK,GAAA,CAAI;QACV,CAAC;IACF;IAEA,QAAQ;QACP,IAAA,CAAK,KAAA,GAAQ,CAAC,CAAA;IACf;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 587, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/utils/src/lib/network.ts"],"sourcesContent":["/**\n * Just a wrapper around `window.fetch` that sets the `referrerPolicy` to `strict-origin-when-cross-origin`.\n *\n * @internal\n */\nexport async function fetch(input: RequestInfo | URL, init?: RequestInit): Promise<Response> {\n\t// eslint-disable-next-line no-restricted-properties\n\treturn window.fetch(input, {\n\t\t// We want to make sure that the referrer is not sent to other domains.\n\t\treferrerPolicy: 'strict-origin-when-cross-origin',\n\t\t...init,\n\t})\n}\n\n/**\n * Just a wrapper around `new Image`, and yeah, it's a bit strange that it's in the network.ts file\n * but the main concern here is the referrerPolicy and setting it correctly.\n *\n * @internal\n */\nexport const Image = (width?: number, height?: number) => {\n\t// eslint-disable-next-line no-restricted-properties\n\tconst img = new window.Image(width, height)\n\timg.referrerPolicy = 'strict-origin-when-cross-origin'\n\treturn img\n}\n"],"names":[],"mappings":";;;;AAKA,eAAsB,MAAM,KAAA,EAA0B,IAAA,EAAuC;IAE5F,OAAO,OAAO,KAAA,CAAM,OAAO;QAAA,uEAAA;QAE1B,gBAAgB;QAChB,GAAG,IAAA;IACJ,CAAC;AACF;AAQO,MAAM,QAAQ,CAAC,OAAgB,WAAoB;IAEzD,MAAM,MAAM,IAAI,OAAO,KAAA,CAAM,OAAO,MAAM;IAC1C,IAAI,cAAA,GAAiB;IACrB,OAAO;AACR","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 611, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/utils/src/lib/file.ts"],"sourcesContent":["import { fetch } from './network'\n\n/**\n * Helpers for files\n *\n * @public\n */\nexport class FileHelpers {\n\t/**\n\t * @deprecated Use `urlToArrayBuffer` instead.\n\t */\n\tstatic async dataUrlToArrayBuffer(dataURL: string) {\n\t\treturn fetch(dataURL).then(function (result) {\n\t\t\treturn result.arrayBuffer()\n\t\t})\n\t}\n\n\t/**\n\t * @param url - The url of the file.\n\t */\n\tstatic async urlToArrayBuffer(url: string) {\n\t\tconst response = await fetch(url)\n\t\treturn await response.arrayBuffer()\n\t}\n\n\tstatic async urlToBlob(url: string) {\n\t\tconst response = await fetch(url)\n\t\treturn await response.blob()\n\t}\n\n\tstatic async urlToDataUrl(url: string) {\n\t\tif (url.startsWith('data:')) return url\n\t\tconst blob = await FileHelpers.urlToBlob(url)\n\t\treturn await FileHelpers.blobToDataUrl(blob)\n\t}\n\n\t/**\n\t * Convert a file to a base64 encoded data url.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const A = FileHelpers.toDataUrl(myImageFile)\n\t * ```\n\t *\n\t * @param file - The file as a blob.\n\t */\n\tstatic async blobToDataUrl(file: Blob): Promise<string> {\n\t\treturn await new Promise((resolve, reject) => {\n\t\t\tif (file) {\n\t\t\t\tconst reader = new FileReader()\n\t\t\t\treader.onload = () => resolve(reader.result as string)\n\t\t\t\treader.onerror = (error) => reject(error)\n\t\t\t\treader.onabort = (error) => reject(error)\n\t\t\t\treader.readAsDataURL(file)\n\t\t\t}\n\t\t})\n\t}\n\n\t/**\n\t * Convert a file to a unicode text string.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const A = FileHelpers.fileToDataUrl(myTextFile)\n\t * ```\n\t *\n\t * @param file - The file as a blob.\n\t */\n\tstatic async blobToText(file: Blob): Promise<string> {\n\t\treturn await new Promise((resolve, reject) => {\n\t\t\tif (file) {\n\t\t\t\tconst reader = new FileReader()\n\t\t\t\treader.onload = () => resolve(reader.result as string)\n\t\t\t\treader.onerror = (error) => reject(error)\n\t\t\t\treader.onabort = (error) => reject(error)\n\t\t\t\treader.readAsText(file)\n\t\t\t}\n\t\t})\n\t}\n\n\tstatic rewriteMimeType(blob: Blob, newMimeType: string): Blob\n\tstatic rewriteMimeType(blob: File, newMimeType: string): File\n\tstatic rewriteMimeType(blob: Blob | File, newMimeType: string): Blob | File {\n\t\tif (blob.type === newMimeType) return blob\n\t\tif (blob instanceof File) {\n\t\t\treturn new File([blob], blob.name, { type: newMimeType })\n\t\t}\n\t\treturn new Blob([blob], { type: newMimeType })\n\t}\n}\n"],"names":[],"mappings":";;;AAAA,SAAS,aAAa;;AAOf,MAAM,YAAY;IAAA;;GAAA,GAIxB,aAAa,qBAAqB,OAAA,EAAiB;QAClD,+KAAO,QAAA,EAAM,OAAO,EAAE,IAAA,CAAK,SAAU,MAAA,EAAQ;YAC5C,OAAO,OAAO,WAAA,CAAY;QAC3B,CAAC;IACF;IAAA;;GAAA,GAKA,aAAa,iBAAiB,GAAA,EAAa;QAC1C,MAAM,WAAW,MAAM,gLAAA,EAAM,GAAG;QAChC,OAAO,MAAM,SAAS,WAAA,CAAY;IACnC;IAEA,aAAa,UAAU,GAAA,EAAa;QACnC,MAAM,WAAW,8KAAM,QAAA,EAAM,GAAG;QAChC,OAAO,MAAM,SAAS,IAAA,CAAK;IAC5B;IAEA,aAAa,aAAa,GAAA,EAAa;QACtC,IAAI,IAAI,UAAA,CAAW,OAAO,EAAG,CAAA,OAAO;QACpC,MAAM,OAAO,MAAM,YAAY,SAAA,CAAU,GAAG;QAC5C,OAAO,MAAM,YAAY,aAAA,CAAc,IAAI;IAC5C;IAAA;;;;;;;;;;GAAA,GAaA,aAAa,cAAc,IAAA,EAA6B;QACvD,OAAO,MAAM,IAAI,QAAQ,CAAC,SAAS,WAAW;YAC7C,IAAI,MAAM;gBACT,MAAM,SAAS,IAAI,WAAW;gBAC9B,OAAO,MAAA,GAAS,IAAM,QAAQ,OAAO,MAAgB;gBACrD,OAAO,OAAA,GAAU,CAAC,QAAU,OAAO,KAAK;gBACxC,OAAO,OAAA,GAAU,CAAC,QAAU,OAAO,KAAK;gBACxC,OAAO,aAAA,CAAc,IAAI;YAC1B;QACD,CAAC;IACF;IAAA;;;;;;;;;;GAAA,GAaA,aAAa,WAAW,IAAA,EAA6B;QACpD,OAAO,MAAM,IAAI,QAAQ,CAAC,SAAS,WAAW;YAC7C,IAAI,MAAM;gBACT,MAAM,SAAS,IAAI,WAAW;gBAC9B,OAAO,MAAA,GAAS,IAAM,QAAQ,OAAO,MAAgB;gBACrD,OAAO,OAAA,GAAU,CAAC,QAAU,OAAO,KAAK;gBACxC,OAAO,OAAA,GAAU,CAAC,QAAU,OAAO,KAAK;gBACxC,OAAO,UAAA,CAAW,IAAI;YACvB;QACD,CAAC;IACF;IAIA,OAAO,gBAAgB,IAAA,EAAmB,WAAA,EAAkC;QAC3E,IAAI,KAAK,IAAA,KAAS,YAAa,CAAA,OAAO;QACtC,IAAI,gBAAgB,MAAM;YACzB,OAAO,IAAI,KAAK;gBAAC,IAAI;aAAA,EAAG,KAAK,IAAA,EAAM;gBAAE,MAAM;YAAY,CAAC;QACzD;QACA,OAAO,IAAI,KAAK;YAAC,IAAI;SAAA,EAAG;YAAE,MAAM;QAAY,CAAC;IAC9C;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 705, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/utils/src/lib/hash.ts"],"sourcesContent":["/**\n * Hash a string using the FNV-1a algorithm.\n *\n * @public\n */\nexport function getHashForString(string: string) {\n\tlet hash = 0\n\tfor (let i = 0; i < string.length; i++) {\n\t\thash = (hash << 5) - hash + string.charCodeAt(i)\n\t\thash |= 0 // Convert to 32bit integer\n\t}\n\treturn hash + ''\n}\n\n/**\n * Hash a string using the FNV-1a algorithm.\n *\n * @public\n */\nexport function getHashForObject(obj: any) {\n\treturn getHashForString(JSON.stringify(obj))\n}\n\n/**\n * Hash an ArrayBuffer using the FNV-1a algorithm.\n *\n * @public\n */\nexport function getHashForBuffer(buffer: ArrayBuffer) {\n\tconst view = new DataView(buffer)\n\tlet hash = 0\n\tfor (let i = 0; i < view.byteLength; i++) {\n\t\thash = (hash << 5) - hash + view.getUint8(i)\n\t\thash |= 0 // Convert to 32bit integer\n\t}\n\treturn hash + ''\n}\n\n/** @public */\nexport function lns(str: string) {\n\tconst result = str.split('')\n\tresult.push(...result.splice(0, Math.round(result.length / 5)))\n\tresult.push(...result.splice(0, Math.round(result.length / 4)))\n\tresult.push(...result.splice(0, Math.round(result.length / 3)))\n\tresult.push(...result.splice(0, Math.round(result.length / 2)))\n\treturn result\n\t\t.reverse()\n\t\t.map((n) => (+n ? (+n < 5 ? 5 + +n : +n > 5 ? +n - 5 : n) : n))\n\t\t.join('')\n}\n"],"names":[],"mappings":";;;;;;AAKO,SAAS,iBAAiB,MAAA,EAAgB;IAChD,IAAI,OAAO;IACX,IAAA,IAAS,IAAI,GAAG,IAAI,OAAO,MAAA,EAAQ,IAAK;QACvC,OAAA,CAAQ,QAAQ,CAAA,IAAK,OAAO,OAAO,UAAA,CAAW,CAAC;QAC/C,QAAQ;IACT;IACA,OAAO,OAAO;AACf;AAOO,SAAS,iBAAiB,GAAA,EAAU;IAC1C,OAAO,iBAAiB,KAAK,SAAA,CAAU,GAAG,CAAC;AAC5C;AAOO,SAAS,iBAAiB,MAAA,EAAqB;IACrD,MAAM,OAAO,IAAI,SAAS,MAAM;IAChC,IAAI,OAAO;IACX,IAAA,IAAS,IAAI,GAAG,IAAI,KAAK,UAAA,EAAY,IAAK;QACzC,OAAA,CAAQ,QAAQ,CAAA,IAAK,OAAO,KAAK,QAAA,CAAS,CAAC;QAC3C,QAAQ;IACT;IACA,OAAO,OAAO;AACf;AAGO,SAAS,IAAI,GAAA,EAAa;IAChC,MAAM,SAAS,IAAI,KAAA,CAAM,EAAE;IAC3B,OAAO,IAAA,CAAK,GAAG,OAAO,MAAA,CAAO,GAAG,KAAK,KAAA,CAAM,OAAO,MAAA,GAAS,CAAC,CAAC,CAAC;IAC9D,OAAO,IAAA,CAAK,GAAG,OAAO,MAAA,CAAO,GAAG,KAAK,KAAA,CAAM,OAAO,MAAA,GAAS,CAAC,CAAC,CAAC;IAC9D,OAAO,IAAA,CAAK,GAAG,OAAO,MAAA,CAAO,GAAG,KAAK,KAAA,CAAM,OAAO,MAAA,GAAS,CAAC,CAAC,CAAC;IAC9D,OAAO,IAAA,CAAK,GAAG,OAAO,MAAA,CAAO,GAAG,KAAK,KAAA,CAAM,OAAO,MAAA,GAAS,CAAC,CAAC,CAAC;IAC9D,OAAO,OACL,OAAA,CAAQ,EACR,GAAA,CAAI,CAAC,IAAO,CAAC,IAAK,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,IAAI,IAAK,CAAE,EAC7D,IAAA,CAAK,EAAE;AACV","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 747, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/utils/src/lib/id.ts"],"sourcesContent":["/*!\n * MIT License: https://github.com/ai/nanoid/blob/main/LICENSE\n * Modified code originally from <https://github.com/ai/nanoid>\n * Copyright 2017 Andrey Sitnik <andrey@sitnik.ru>\n *\n * `nanoid` is currently only distributed as an ES module. Some tools (jest, playwright) don't\n * properly support ESM-only code yet, and tldraw itself is distributed as both an ES module and a\n * CommonJS module. By including nanoid here, we can make sure it works well in every environment\n * where tldraw is used. We can also remove some unused features like custom alphabets.\n */\n\n// all environments that tldraw runs in (browser, workers, recent node versions) have global\n// `crypto`\nconst crypto = globalThis.crypto\n\n// This alphabet uses `A-Za-z0-9_-` symbols.\n// The order of characters is optimized for better gzip and brotli compression.\n// Same as in non-secure/index.js\nconst urlAlphabet = 'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\n\n// It is best to make fewer, larger requests to the crypto module to\n// avoid system call overhead. So, random numbers are generated in a\n// pool. The pool is a Buffer that is larger than the initial random\n// request size by this multiplier. The pool is enlarged if subsequent\n// requests exceed the maximum buffer size.\nconst POOL_SIZE_MULTIPLIER = 128\nlet pool: Uint8Array, poolOffset: number\n\nfunction fillPool(bytes: number) {\n\tif (!pool || pool.length < bytes) {\n\t\tpool = new Uint8Array(bytes * POOL_SIZE_MULTIPLIER)\n\t\tcrypto.getRandomValues(pool)\n\t\tpoolOffset = 0\n\t} else if (poolOffset + bytes > pool.length) {\n\t\tcrypto.getRandomValues(pool)\n\t\tpoolOffset = 0\n\t}\n\tpoolOffset += bytes\n}\n\nfunction nanoid(size = 21) {\n\t// `-=` convert `size` to number to prevent `valueOf` abusing\n\tfillPool((size -= 0))\n\tlet id = ''\n\t// We are reading directly from the random pool to avoid creating new array\n\tfor (let i = poolOffset - size; i < poolOffset; i++) {\n\t\t// It is incorrect to use bytes exceeding the alphabet size.\n\t\t// The following mask reduces the random byte in the 0-255 value\n\t\t// range to the 0-63 value range. Therefore, adding hacks, such\n\t\t// as empty string fallback or magic numbers, is unnecessary because\n\t\t// the bitmask trims bytes down to the alphabet size.\n\t\tid += urlAlphabet[pool[i] & 63]\n\t}\n\treturn id\n}\n\nlet impl = nanoid\n/** @internal */\nexport function mockUniqueId(fn: (size?: number) => string) {\n\timpl = fn\n}\n\n/** @internal */\nexport function restoreUniqueId() {\n\timpl = nanoid\n}\n\n/**\n * Generate a unique id.\n *\n * @example\n *\n * ```ts\n * const id = uniqueId()\n * ```\n *\n * @public\n */\nexport function uniqueId(size?: number): string {\n\treturn impl(size)\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;CAAA;;;;;AAaA,MAAM,SAAS,WAAW,MAAA;AAK1B,MAAM,cAAc;AAOpB,MAAM,uBAAuB;AAC7B,IAAI,MAAkB;AAEtB,SAAS,SAAS,KAAA,EAAe;IAChC,IAAI,CAAC,QAAQ,KAAK,MAAA,GAAS,OAAO;QACjC,OAAO,IAAI,WAAW,QAAQ,oBAAoB;QAClD,OAAO,eAAA,CAAgB,IAAI;QAC3B,aAAa;IACd,OAAA,IAAW,aAAa,QAAQ,KAAK,MAAA,EAAQ;QAC5C,OAAO,eAAA,CAAgB,IAAI;QAC3B,aAAa;IACd;IACA,cAAc;AACf;AAEA,SAAS,OAAO,OAAO,EAAA,EAAI;IAE1B,SAAU,QAAQ,CAAE;IACpB,IAAI,KAAK;IAET,IAAA,IAAS,IAAI,aAAa,MAAM,IAAI,YAAY,IAAK;QAMpD,MAAM,WAAA,CAAY,IAAA,CAAK,CAAC,CAAA,GAAI,EAAE,CAAA;IAC/B;IACA,OAAO;AACR;AAEA,IAAI,OAAO;AAEJ,SAAS,aAAa,EAAA,EAA+B;IAC3D,OAAO;AACR;AAGO,SAAS,kBAAkB;IACjC,OAAO;AACR;AAaO,SAAS,SAAS,IAAA,EAAuB;IAC/C,OAAO,KAAK,IAAI;AACjB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 802, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/utils/src/lib/iterable.ts"],"sourcesContent":["/**\n * Get the first item from an iterable Set or Map.\n *\n * @example\n *\n * ```ts\n * const A = getFirstItem(new Set([1, 2, 3])) // 1\n * const B = getFirstItem(\n * \tnew Map([\n * \t\t['a', 1],\n * \t\t['b', 2],\n * \t])\n * ) // 1\n * ```\n *\n * @param value - The iterable Set or Map.\n * @public\n */\nexport function getFirstFromIterable<T = unknown>(set: Set<T> | Map<any, T>): T {\n\treturn set.values().next().value!\n}\n"],"names":[],"mappings":";;;AAkBO,SAAS,qBAAkC,GAAA,EAA8B;IAC/E,OAAO,IAAI,MAAA,CAAO,EAAE,IAAA,CAAK,EAAE,KAAA;AAC5B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 816, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/utils/src/lib/media/apng.ts"],"sourcesContent":["/*!\n * MIT License: https://github.com/vHeemstra/is-apng/blob/main/license\n * Copyright (c) Philip van Heemstra\n */\n\nexport function isApngAnimated(buffer: ArrayBuffer): boolean {\n\tconst view = new Uint8Array(buffer)\n\n\tif (\n\t\t!view ||\n\t\t!((typeof Buffer !== 'undefined' && Buffer.isBuffer(view)) || view instanceof Uint8Array) ||\n\t\tview.length < 16\n\t) {\n\t\treturn false\n\t}\n\n\tconst isPNG =\n\t\tview[0] === 0x89 &&\n\t\tview[1] === 0x50 &&\n\t\tview[2] === 0x4e &&\n\t\tview[3] === 0x47 &&\n\t\tview[4] === 0x0d &&\n\t\tview[5] === 0x0a &&\n\t\tview[6] === 0x1a &&\n\t\tview[7] === 0x0a\n\n\tif (!isPNG) {\n\t\treturn false\n\t}\n\n\t/**\n\t * Returns the index of the first occurrence of a sequence in an typed array, or -1 if it is not present.\n\t *\n\t * Works similar to `Array.prototype.indexOf()`, but it searches for a sequence of array values (bytes).\n\t * The bytes in the `haystack` array are decoded (UTF-8) and then used to search for `needle`.\n\t *\n\t * @param haystack `Uint8Array`\n\t * Array to search in.\n\t *\n\t * @param needle `string | RegExp`\n\t * The value to locate in the array.\n\t *\n\t * @param fromIndex `number`\n\t * The array index at which to begin the search.\n\t *\n\t * @param upToIndex `number`\n\t * The array index up to which to search.\n\t * If omitted, search until the end.\n\t *\n\t * @param chunksize `number`\n\t * Size of the chunks used when searching (default 1024).\n\t *\n\t * @returns boolean\n\t * Whether the array holds Animated PNG data.\n\t */\n\tfunction indexOfSubstring(\n\t\thaystack: Uint8Array,\n\t\tneedle: string | RegExp,\n\t\tfromIndex: number,\n\t\tupToIndex?: number,\n\t\tchunksize = 1024 /* Bytes */\n\t) {\n\t\t/**\n\t\t * Adopted from: https://stackoverflow.com/a/67771214/2142071\n\t\t */\n\n\t\tif (!needle) {\n\t\t\treturn -1\n\t\t}\n\t\tneedle = new RegExp(needle, 'g')\n\n\t\t// The needle could get split over two chunks.\n\t\t// So, at every chunk we prepend the last few characters\n\t\t// of the last chunk.\n\t\tconst needle_length = needle.source.length\n\t\tconst decoder = new TextDecoder()\n\n\t\t// Handle search offset in line with\n\t\t// `Array.prototype.indexOf()` and `TypedArray.prototype.subarray()`.\n\t\tconst full_haystack_length = haystack.length\n\t\tif (typeof upToIndex === 'undefined') {\n\t\t\tupToIndex = full_haystack_length\n\t\t}\n\t\tif (fromIndex >= full_haystack_length || upToIndex <= 0 || fromIndex >= upToIndex) {\n\t\t\treturn -1\n\t\t}\n\t\thaystack = haystack.subarray(fromIndex, upToIndex)\n\n\t\tlet position = -1\n\t\tlet current_index = 0\n\t\tlet full_length = 0\n\t\tlet needle_buffer = ''\n\n\t\touter: while (current_index < haystack.length) {\n\t\t\tconst next_index = current_index + chunksize\n\t\t\t// subarray doesn't copy\n\t\t\tconst chunk = haystack.subarray(current_index, next_index)\n\t\t\tconst decoded = decoder.decode(chunk, { stream: true })\n\n\t\t\tconst text = needle_buffer + decoded\n\n\t\t\tlet match: RegExpExecArray | null\n\t\t\tlet last_index = -1\n\t\t\twhile ((match = needle.exec(text)) !== null) {\n\t\t\t\tlast_index = match.index - needle_buffer.length\n\t\t\t\tposition = full_length + last_index\n\t\t\t\tbreak outer\n\t\t\t}\n\n\t\t\tcurrent_index = next_index\n\t\t\tfull_length += decoded.length\n\n\t\t\t// Check that the buffer doesn't itself include the needle\n\t\t\t// this would cause duplicate finds (we could also use a Set to avoid that).\n\t\t\tconst needle_index =\n\t\t\t\tlast_index > -1 ? last_index + needle_length : decoded.length - needle_length\n\t\t\tneedle_buffer = decoded.slice(needle_index)\n\t\t}\n\n\t\t// Correct for search offset.\n\t\tif (position >= 0) {\n\t\t\tposition += fromIndex >= 0 ? fromIndex : full_haystack_length + fromIndex\n\t\t}\n\n\t\treturn position\n\t}\n\n\t// APNGs have an animation control chunk ('acTL') preceding the IDATs.\n\t// See: https://en.wikipedia.org/wiki/APNG#File_format\n\tconst idatIdx = indexOfSubstring(view, 'IDAT', 12)\n\tif (idatIdx >= 12) {\n\t\tconst actlIdx = indexOfSubstring(view, 'acTL', 8, idatIdx)\n\t\treturn actlIdx >= 8\n\t}\n\n\treturn false\n}\n\n// globalThis.isApng = isApng\n\n// (new TextEncoder()).encode('IDAT')\n// Decimal: [73, 68, 65, 84]\n// Hex: [0x49, 0x44, 0x41, 0x54]\n\n// (new TextEncoder()).encode('acTL')\n// Decimal: [97, 99, 84, 76]\n// Hex: [0x61, 0x63, 0x54, 0x4C]\n\n// const idatIdx = buffer.indexOf('IDAT')\n// const actlIdx = buffer.indexOf('acTL')\n"],"names":[],"mappings":"AAAA;;;CAAA;;;AAKO,SAAS,eAAe,MAAA,EAA8B;IAC5D,MAAM,OAAO,IAAI,WAAW,MAAM;IAElC,IACC,CAAC,QACD,CAAA,CAAG,OAAO,WAAW,eAAe,OAAO,QAAA,CAAS,IAAI,KAAM,gBAAgB,UAAA,KAC9E,KAAK,MAAA,GAAS,IACb;QACD,OAAO;IACR;IAEA,MAAM,QACL,IAAA,CAAK,CAAC,CAAA,KAAM,OACZ,IAAA,CAAK,CAAC,CAAA,KAAM,MACZ,IAAA,CAAK,CAAC,CAAA,KAAM,MACZ,IAAA,CAAK,CAAC,CAAA,KAAM,MACZ,IAAA,CAAK,CAAC,CAAA,KAAM,MACZ,IAAA,CAAK,CAAC,CAAA,KAAM,MACZ,IAAA,CAAK,CAAC,CAAA,KAAM,MACZ,IAAA,CAAK,CAAC,CAAA,KAAM;IAEb,IAAI,CAAC,OAAO;QACX,OAAO;IACR;IA2BA,SAAS,iBACR,QAAA,EACA,MAAA,EACA,SAAA,EACA,SAAA,EACA,YAAY,IAAA,EACX;QAKD,IAAI,CAAC,QAAQ;YACZ,OAAO,CAAA;QACR;QACA,SAAS,IAAI,OAAO,QAAQ,GAAG;QAK/B,MAAM,gBAAgB,OAAO,MAAA,CAAO,MAAA;QACpC,MAAM,UAAU,IAAI,YAAY;QAIhC,MAAM,uBAAuB,SAAS,MAAA;QACtC,IAAI,OAAO,cAAc,aAAa;YACrC,YAAY;QACb;QACA,IAAI,aAAa,wBAAwB,aAAa,KAAK,aAAa,WAAW;YAClF,OAAO,CAAA;QACR;QACA,WAAW,SAAS,QAAA,CAAS,WAAW,SAAS;QAEjD,IAAI,WAAW,CAAA;QACf,IAAI,gBAAgB;QACpB,IAAI,cAAc;QAClB,IAAI,gBAAgB;QAEpB,MAAO,CAAA,MAAO,gBAAgB,SAAS,MAAA,CAAQ;YAC9C,MAAM,aAAa,gBAAgB;YAEnC,MAAM,QAAQ,SAAS,QAAA,CAAS,eAAe,UAAU;YACzD,MAAM,UAAU,QAAQ,MAAA,CAAO,OAAO;gBAAE,QAAQ;YAAK,CAAC;YAEtD,MAAM,OAAO,gBAAgB;YAE7B,IAAI;YACJ,IAAI,aAAa,CAAA;YACjB,MAAA,CAAQ,QAAQ,OAAO,IAAA,CAAK,IAAI,CAAA,MAAO,KAAM;gBAC5C,aAAa,MAAM,KAAA,GAAQ,cAAc,MAAA;gBACzC,WAAW,cAAc;gBACzB,MAAM;YACP;YAEA,gBAAgB;YAChB,eAAe,QAAQ,MAAA;YAIvB,MAAM,eACL,aAAa,CAAA,IAAK,aAAa,gBAAgB,QAAQ,MAAA,GAAS;YACjE,gBAAgB,QAAQ,KAAA,CAAM,YAAY;QAC3C;QAGA,IAAI,YAAY,GAAG;YAClB,YAAY,aAAa,IAAI,YAAY,uBAAuB;QACjE;QAEA,OAAO;IACR;IAIA,MAAM,UAAU,iBAAiB,MAAM,QAAQ,EAAE;IACjD,IAAI,WAAW,IAAI;QAClB,MAAM,UAAU,iBAAiB,MAAM,QAAQ,GAAG,OAAO;QACzD,OAAO,WAAW;IACnB;IAEA,OAAO;AACR","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 889, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/utils/src/lib/media/avif.ts"],"sourcesContent":["export const isAvifAnimated = (buffer: ArrayBuffer) => {\n\tconst view = new Uint8Array(buffer)\n\treturn view[3] === 44\n}\n"],"names":[],"mappings":";;;AAAO,MAAM,iBAAiB,CAAC,WAAwB;IACtD,MAAM,OAAO,IAAI,WAAW,MAAM;IAClC,OAAO,IAAA,CAAK,CAAC,CAAA,KAAM;AACpB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 904, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/utils/src/lib/media/gif.ts"],"sourcesContent":["/*!\n * MIT License\n * Modified code originally from <https://github.com/qzb/is-animated>\n * Copyright (c) 2016 Józef Sokołowski <j.k.sokolowski@gmail.com>\n */\n\n/** Returns total length of data blocks sequence */\nfunction getDataBlocksLength(buffer: Uint8Array, offset: number): number {\n\tlet length = 0\n\n\twhile (buffer[offset + length]) {\n\t\tlength += buffer[offset + length] + 1\n\t}\n\n\treturn length + 1\n}\n\n/**\n * Checks if buffer contains GIF image\n *\n * @public\n */\nexport function isGIF(buffer: ArrayBuffer): boolean {\n\tconst enc = new TextDecoder('ascii')\n\tconst header = enc.decode(buffer.slice(0, 3))\n\treturn header === 'GIF'\n}\n\n/**\n * Checks if buffer contains animated GIF image\n *\n * @public\n */\nexport function isGifAnimated(buffer: ArrayBuffer): boolean {\n\tconst view = new Uint8Array(buffer)\n\tlet hasColorTable, colorTableSize\n\tlet offset = 0\n\tlet imagesCount = 0\n\n\t// Check if this is this image has valid GIF header.\n\t// If not return false. Chrome, FF and IE doesn't handle GIFs with invalid version.\n\tif (!isGIF(buffer)) {\n\t\treturn false\n\t}\n\n\t// Skip header, logical screen descriptor and global color table\n\n\thasColorTable = view[10] & 0x80 // 0b10000000\n\tcolorTableSize = view[10] & 0x07 // 0b00000111\n\n\toffset += 6 // skip header\n\toffset += 7 // skip logical screen descriptor\n\toffset += hasColorTable ? 3 * Math.pow(2, colorTableSize + 1) : 0 // skip global color table\n\n\t// Find if there is more than one image descriptor\n\n\twhile (imagesCount < 2 && offset < view.length) {\n\t\tswitch (view[offset]) {\n\t\t\t// Image descriptor block. According to specification there could be any\n\t\t\t// number of these blocks (even zero). When there is more than one image\n\t\t\t// descriptor browsers will display animation (they shouldn't when there\n\t\t\t// is no delays defined, but they do it anyway).\n\t\t\tcase 0x2c:\n\t\t\t\timagesCount += 1\n\n\t\t\t\thasColorTable = view[offset + 9] & 0x80 // 0b10000000\n\t\t\t\tcolorTableSize = view[offset + 9] & 0x07 // 0b00000111\n\n\t\t\t\toffset += 10 // skip image descriptor\n\t\t\t\toffset += hasColorTable ? 3 * Math.pow(2, colorTableSize + 1) : 0 // skip local color table\n\t\t\t\toffset += getDataBlocksLength(view, offset + 1) + 1 // skip image data\n\n\t\t\t\tbreak\n\n\t\t\t// Skip all extension blocks. In theory this \"plain text extension\" blocks\n\t\t\t// could be frames of animation, but no browser renders them.\n\t\t\tcase 0x21:\n\t\t\t\toffset += 2 // skip introducer and label\n\t\t\t\toffset += getDataBlocksLength(view, offset) // skip this block and following data blocks\n\n\t\t\t\tbreak\n\n\t\t\t// Stop processing on trailer block,\n\t\t\t// all data after this point will is ignored by decoders\n\t\t\tcase 0x3b:\n\t\t\t\toffset = view.length // fast forward to end of buffer\n\t\t\t\tbreak\n\n\t\t\t// Oops! This GIF seems to be invalid\n\t\t\tdefault:\n\t\t\t\t// fast forward to end of buffer\n\t\t\t\toffset = view.length\n\t\t\t\tbreak\n\t\t}\n\t}\n\n\treturn imagesCount > 1\n}\n"],"names":[],"mappings":"AAAA;;;;CAAA;;;;AAOA,SAAS,oBAAoB,MAAA,EAAoB,MAAA,EAAwB;IACxE,IAAI,SAAS;IAEb,MAAO,MAAA,CAAO,SAAS,MAAM,CAAA,CAAG;QAC/B,UAAU,MAAA,CAAO,SAAS,MAAM,CAAA,GAAI;IACrC;IAEA,OAAO,SAAS;AACjB;AAOO,SAAS,MAAM,MAAA,EAA8B;IACnD,MAAM,MAAM,IAAI,YAAY,OAAO;IACnC,MAAM,SAAS,IAAI,MAAA,CAAO,OAAO,KAAA,CAAM,GAAG,CAAC,CAAC;IAC5C,OAAO,WAAW;AACnB;AAOO,SAAS,cAAc,MAAA,EAA8B;IAC3D,MAAM,OAAO,IAAI,WAAW,MAAM;IAClC,IAAI,eAAe;IACnB,IAAI,SAAS;IACb,IAAI,cAAc;IAIlB,IAAI,CAAC,MAAM,MAAM,GAAG;QACnB,OAAO;IACR;IAIA,gBAAgB,IAAA,CAAK,EAAE,CAAA,GAAI;IAC3B,iBAAiB,IAAA,CAAK,EAAE,CAAA,GAAI;IAE5B,UAAU;IACV,UAAU;IACV,UAAU,gBAAgB,IAAI,KAAK,GAAA,CAAI,GAAG,iBAAiB,CAAC,IAAI;IAIhE,MAAO,cAAc,KAAK,SAAS,KAAK,MAAA,CAAQ;QAC/C,OAAQ,IAAA,CAAK,MAAM,CAAA,EAAG;YAAA,wEAAA;YAAA,wEAAA;YAAA,wEAAA;YAAA,gDAAA;YAKrB,KAAK;gBACJ,eAAe;gBAEf,gBAAgB,IAAA,CAAK,SAAS,CAAC,CAAA,GAAI;gBACnC,iBAAiB,IAAA,CAAK,SAAS,CAAC,CAAA,GAAI;gBAEpC,UAAU;gBACV,UAAU,gBAAgB,IAAI,KAAK,GAAA,CAAI,GAAG,iBAAiB,CAAC,IAAI;gBAChE,UAAU,oBAAoB,MAAM,SAAS,CAAC,IAAI;gBAElD;YAAA,0EAAA;YAAA,6DAAA;YAID,KAAK;gBACJ,UAAU;gBACV,UAAU,oBAAoB,MAAM,MAAM;gBAE1C;YAAA,oCAAA;YAAA,wDAAA;YAID,KAAK;gBACJ,SAAS,KAAK,MAAA;gBACd;YAAA,qCAAA;YAGD;gBAEC,SAAS,KAAK,MAAA;gBACd;QACF;IACD;IAEA,OAAO,cAAc;AACtB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 978, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/utils/src/lib/media/png.ts"],"sourcesContent":["/*!\n * MIT License: https://github.com/alexgorbatchev/crc/blob/master/LICENSE\n * Copyright: 2014 Alex Gorbatchev\n * Code: crc32, https://github.com/alexgorbatchev/crc/blob/master/src/calculators/crc32.ts\n */\n\ntype BufferInput = string | ArrayBuffer | Buffer\n\ninterface CRCCalculator<T = BufferInput | Uint8Array> {\n\t(value: T, previous?: number): number\n}\n\nlet TABLE: Array<number> | Int32Array = [\n\t0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,\n\t0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,\n\t0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,\n\t0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,\n\t0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,\n\t0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,\n\t0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,\n\t0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,\n\t0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,\n\t0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,\n\t0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,\n\t0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,\n\t0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,\n\t0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,\n\t0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n\t0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,\n\t0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,\n\t0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,\n\t0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,\n\t0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,\n\t0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,\n\t0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,\n\t0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,\n\t0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,\n\t0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,\n\t0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,\n\t0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,\n\t0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,\n\t0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,\n\t0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n\t0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,\n\t0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d,\n]\n\nif (typeof Int32Array !== 'undefined') {\n\tTABLE = new Int32Array(TABLE)\n}\n\nconst crc: CRCCalculator<Uint8Array> = (current, previous) => {\n\tlet crc = previous === 0 ? 0 : ~~previous! ^ -1\n\n\tfor (let index = 0; index < current.length; index++) {\n\t\tcrc = TABLE[(crc ^ current[index]) & 0xff] ^ (crc >>> 8)\n\t}\n\n\treturn crc ^ -1\n}\n\nconst LEN_SIZE = 4\nconst CRC_SIZE = 4\n\n/** @public */\nexport class PngHelpers {\n\tstatic isPng(view: DataView, offset: number) {\n\t\tif (\n\t\t\tview.getUint8(offset + 0) === 0x89 &&\n\t\t\tview.getUint8(offset + 1) === 0x50 &&\n\t\t\tview.getUint8(offset + 2) === 0x4e &&\n\t\t\tview.getUint8(offset + 3) === 0x47 &&\n\t\t\tview.getUint8(offset + 4) === 0x0d &&\n\t\t\tview.getUint8(offset + 5) === 0x0a &&\n\t\t\tview.getUint8(offset + 6) === 0x1a &&\n\t\t\tview.getUint8(offset + 7) === 0x0a\n\t\t) {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\n\tstatic getChunkType(view: DataView, offset: number) {\n\t\treturn [\n\t\t\tString.fromCharCode(view.getUint8(offset)),\n\t\t\tString.fromCharCode(view.getUint8(offset + 1)),\n\t\t\tString.fromCharCode(view.getUint8(offset + 2)),\n\t\t\tString.fromCharCode(view.getUint8(offset + 3)),\n\t\t].join('')\n\t}\n\n\tstatic readChunks(view: DataView, offset = 0) {\n\t\tconst chunks: Record<string, { dataOffset: number; size: number; start: number }> = {}\n\t\tif (!PngHelpers.isPng(view, offset)) {\n\t\t\tthrow new Error('Not a PNG')\n\t\t}\n\t\toffset += 8\n\n\t\twhile (offset <= view.buffer.byteLength) {\n\t\t\tconst start = offset\n\t\t\tconst len = view.getInt32(offset)\n\t\t\toffset += 4\n\t\t\tconst chunkType = PngHelpers.getChunkType(view, offset)\n\n\t\t\tif (chunkType === 'IDAT' && chunks[chunkType]) {\n\t\t\t\toffset += len + LEN_SIZE + CRC_SIZE\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif (chunkType === 'IEND') {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tchunks[chunkType] = {\n\t\t\t\tstart,\n\t\t\t\tdataOffset: offset + 4,\n\t\t\t\tsize: len,\n\t\t\t}\n\t\t\toffset += len + LEN_SIZE + CRC_SIZE\n\t\t}\n\n\t\treturn chunks\n\t}\n\n\tstatic parsePhys(view: DataView, offset: number) {\n\t\treturn {\n\t\t\tppux: view.getUint32(offset),\n\t\t\tppuy: view.getUint32(offset + 4),\n\t\t\tunit: view.getUint8(offset + 4),\n\t\t}\n\t}\n\n\tstatic findChunk(view: DataView, type: string) {\n\t\tconst chunks = PngHelpers.readChunks(view)\n\t\treturn chunks[type]\n\t}\n\n\tstatic setPhysChunk(view: DataView, dpr = 1, options?: BlobPropertyBag) {\n\t\tlet offset = 46\n\t\tlet size = 0\n\t\tconst res1 = PngHelpers.findChunk(view, 'pHYs')\n\t\tif (res1) {\n\t\t\toffset = res1.start\n\t\t\tsize = res1.size\n\t\t}\n\n\t\tconst res2 = PngHelpers.findChunk(view, 'IDAT')\n\t\tif (res2) {\n\t\t\toffset = res2.start\n\t\t\tsize = 0\n\t\t}\n\n\t\tconst pHYsData = new ArrayBuffer(21)\n\t\tconst pHYsDataView = new DataView(pHYsData)\n\n\t\tpHYsDataView.setUint32(0, 9)\n\n\t\tpHYsDataView.setUint8(4, 'p'.charCodeAt(0))\n\t\tpHYsDataView.setUint8(5, 'H'.charCodeAt(0))\n\t\tpHYsDataView.setUint8(6, 'Y'.charCodeAt(0))\n\t\tpHYsDataView.setUint8(7, 's'.charCodeAt(0))\n\n\t\tconst DPI_96 = 2835.5\n\n\t\tpHYsDataView.setInt32(8, DPI_96 * dpr)\n\t\tpHYsDataView.setInt32(12, DPI_96 * dpr)\n\t\tpHYsDataView.setInt8(16, 1)\n\n\t\tconst crcBit = new Uint8Array(pHYsData.slice(4, 17))\n\t\tpHYsDataView.setInt32(17, crc(crcBit))\n\n\t\tconst startBuf = view.buffer.slice(0, offset)\n\t\tconst endBuf = view.buffer.slice(offset + size)\n\n\t\treturn new Blob([startBuf as ArrayBuffer, pHYsData, endBuf as ArrayBuffer], options)\n\t}\n}\n"],"names":["crc"],"mappings":"AAAA;;;;CAAA;;;AAYA,IAAI,QAAoC;IACvC;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IACpF;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IACpF;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IACpF;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IACpF;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IACpF;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IACpF;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IACpF;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IACpF;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IACpF;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IACpF;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IACpF;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IACpF;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IACpF;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IACpF;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IACpF;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IACpF;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IACpF;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IACpF;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IACpF;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IACpF;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IACpF;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IACpF;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IACpF;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IACpF;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IACpF;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IACpF;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IACpF;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IAAY;IACpF;IAAY;IAAY;IAAY;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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1351, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/utils/src/lib/media/webp.ts"],"sourcesContent":["/*!\n * MIT License: https://github.com/sindresorhus/is-webp/blob/main/license\n * Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)\n */\nfunction isWebp(view: Uint8Array) {\n\tif (!view || view.length < 12) {\n\t\treturn false\n\t}\n\n\treturn view[8] === 87 && view[9] === 69 && view[10] === 66 && view[11] === 80\n}\n\nexport function isWebpAnimated(buffer: ArrayBuffer) {\n\tconst view = new Uint8Array(buffer)\n\n\tif (!isWebp(view)) {\n\t\treturn false\n\t}\n\n\tif (!view || view.length < 21) {\n\t\treturn false\n\t}\n\n\treturn ((view[20] >> 1) & 1) === 1\n}\n"],"names":[],"mappings":"AAAA;;;CAAA;;;AAIA,SAAS,OAAO,IAAA,EAAkB;IACjC,IAAI,CAAC,QAAQ,KAAK,MAAA,GAAS,IAAI;QAC9B,OAAO;IACR;IAEA,OAAO,IAAA,CAAK,CAAC,CAAA,KAAM,MAAM,IAAA,CAAK,CAAC,CAAA,KAAM,MAAM,IAAA,CAAK,EAAE,CAAA,KAAM,MAAM,IAAA,CAAK,EAAE,CAAA,KAAM;AAC5E;AAEO,SAAS,eAAe,MAAA,EAAqB;IACnD,MAAM,OAAO,IAAI,WAAW,MAAM;IAElC,IAAI,CAAC,OAAO,IAAI,GAAG;QAClB,OAAO;IACR;IAEA,IAAI,CAAC,QAAQ,KAAK,MAAA,GAAS,IAAI;QAC9B,OAAO;IACR;IAEA,OAAA,CAAS,IAAA,CAAK,EAAE,CAAA,IAAK,IAAK,CAAA,MAAO;AAClC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1381, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/utils/src/lib/media/media.ts"],"sourcesContent":["import { promiseWithResolve } from '../control'\nimport { Image } from '../network'\nimport { isApngAnimated } from './apng'\nimport { isAvifAnimated } from './avif'\nimport { isGifAnimated } from './gif'\nimport { PngHelpers } from './png'\nimport { isWebpAnimated } from './webp'\n\n/** @public */\nexport const DEFAULT_SUPPORTED_VECTOR_IMAGE_TYPES = Object.freeze(['image/svg+xml' as const])\n/** @public */\nexport const DEFAULT_SUPPORTED_STATIC_IMAGE_TYPES = Object.freeze([\n\t'image/jpeg' as const,\n\t'image/png' as const,\n\t'image/webp' as const,\n])\n/** @public */\nexport const DEFAULT_SUPPORTED_ANIMATED_IMAGE_TYPES = Object.freeze([\n\t'image/gif' as const,\n\t'image/apng' as const,\n\t'image/avif' as const,\n])\n/** @public */\nexport const DEFAULT_SUPPORTED_IMAGE_TYPES = Object.freeze([\n\t...DEFAULT_SUPPORTED_STATIC_IMAGE_TYPES,\n\t...DEFAULT_SUPPORTED_VECTOR_IMAGE_TYPES,\n\t...DEFAULT_SUPPORTED_ANIMATED_IMAGE_TYPES,\n])\n/** @public */\nexport const DEFAULT_SUPPORT_VIDEO_TYPES = Object.freeze([\n\t'video/mp4' as const,\n\t'video/webm' as const,\n\t'video/quicktime' as const,\n])\n/** @public */\nexport const DEFAULT_SUPPORTED_MEDIA_TYPES = Object.freeze([\n\t...DEFAULT_SUPPORTED_IMAGE_TYPES,\n\t...DEFAULT_SUPPORT_VIDEO_TYPES,\n])\n/** @public */\nexport const DEFAULT_SUPPORTED_MEDIA_TYPE_LIST = DEFAULT_SUPPORTED_MEDIA_TYPES.join(',')\n\n/**\n * Helpers for media\n *\n * @public\n */\nexport class MediaHelpers {\n\t/**\n\t * Load a video from a url.\n\t * @public\n\t */\n\tstatic loadVideo(src: string): Promise<HTMLVideoElement> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst video = document.createElement('video')\n\t\t\tvideo.onloadeddata = () => resolve(video)\n\t\t\tvideo.onerror = (e) => {\n\t\t\t\tconsole.error(e)\n\t\t\t\treject(new Error('Could not load video'))\n\t\t\t}\n\t\t\tvideo.crossOrigin = 'anonymous'\n\t\t\tvideo.src = src\n\t\t})\n\t}\n\n\tstatic async getVideoFrameAsDataUrl(video: HTMLVideoElement, time = 0): Promise<string> {\n\t\tconst promise = promiseWithResolve<string>()\n\t\tlet didSetTime = false\n\n\t\tconst onReadyStateChanged = () => {\n\t\t\tif (!didSetTime) {\n\t\t\t\tif (video.readyState >= video.HAVE_METADATA) {\n\t\t\t\t\tdidSetTime = true\n\t\t\t\t\tvideo.currentTime = time\n\t\t\t\t} else {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (video.readyState >= video.HAVE_CURRENT_DATA) {\n\t\t\t\tconst canvas = document.createElement('canvas')\n\t\t\t\tcanvas.width = video.videoWidth\n\t\t\t\tcanvas.height = video.videoHeight\n\t\t\t\tconst ctx = canvas.getContext('2d')\n\t\t\t\tif (!ctx) {\n\t\t\t\t\tthrow new Error('Could not get 2d context')\n\t\t\t\t}\n\t\t\t\tctx.drawImage(video, 0, 0)\n\t\t\t\tpromise.resolve(canvas.toDataURL())\n\t\t\t}\n\t\t}\n\t\tconst onError = (e: Event) => {\n\t\t\tconsole.error(e)\n\t\t\tpromise.reject(new Error('Could not get video frame'))\n\t\t}\n\n\t\tvideo.addEventListener('loadedmetadata', onReadyStateChanged)\n\t\tvideo.addEventListener('loadeddata', onReadyStateChanged)\n\t\tvideo.addEventListener('canplay', onReadyStateChanged)\n\t\tvideo.addEventListener('seeked', onReadyStateChanged)\n\n\t\tvideo.addEventListener('error', onError)\n\t\tvideo.addEventListener('stalled', onError)\n\n\t\tonReadyStateChanged()\n\n\t\ttry {\n\t\t\treturn await promise\n\t\t} finally {\n\t\t\tvideo.removeEventListener('loadedmetadata', onReadyStateChanged)\n\t\t\tvideo.removeEventListener('loadeddata', onReadyStateChanged)\n\t\t\tvideo.removeEventListener('canplay', onReadyStateChanged)\n\t\t\tvideo.removeEventListener('seeked', onReadyStateChanged)\n\n\t\t\tvideo.removeEventListener('error', onError)\n\t\t\tvideo.removeEventListener('stalled', onError)\n\t\t}\n\t}\n\n\t/**\n\t * Load an image from a url.\n\t * @public\n\t */\n\tstatic getImageAndDimensions(\n\t\tsrc: string\n\t): Promise<{ w: number; h: number; image: HTMLImageElement }> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst img = Image()\n\t\t\timg.onload = () => {\n\t\t\t\tlet dimensions\n\t\t\t\tif (img.naturalWidth) {\n\t\t\t\t\tdimensions = {\n\t\t\t\t\t\tw: img.naturalWidth,\n\t\t\t\t\t\th: img.naturalHeight,\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Sigh, Firefox doesn't have naturalWidth or naturalHeight for SVGs. :-/\n\t\t\t\t\t// We have to attach to dom and use clientWidth/clientHeight.\n\t\t\t\t\tdocument.body.appendChild(img)\n\t\t\t\t\tdimensions = {\n\t\t\t\t\t\tw: img.clientWidth,\n\t\t\t\t\t\th: img.clientHeight,\n\t\t\t\t\t}\n\t\t\t\t\tdocument.body.removeChild(img)\n\t\t\t\t}\n\t\t\t\tresolve({ ...dimensions, image: img })\n\t\t\t}\n\t\t\timg.onerror = (e) => {\n\t\t\t\tconsole.error(e)\n\t\t\t\treject(new Error('Could not load image'))\n\t\t\t}\n\t\t\timg.crossOrigin = 'anonymous'\n\t\t\timg.referrerPolicy = 'strict-origin-when-cross-origin'\n\t\t\timg.style.visibility = 'hidden'\n\t\t\timg.style.position = 'absolute'\n\t\t\timg.style.opacity = '0'\n\t\t\timg.style.zIndex = '-9999'\n\t\t\timg.src = src\n\t\t})\n\t}\n\n\t/**\n\t * Get the size of a video blob\n\t *\n\t * @param blob - A SharedBlob containing the video\n\t * @public\n\t */\n\tstatic async getVideoSize(blob: Blob): Promise<{ w: number; h: number }> {\n\t\treturn MediaHelpers.usingObjectURL(blob, async (url) => {\n\t\t\tconst video = await MediaHelpers.loadVideo(url)\n\t\t\treturn { w: video.videoWidth, h: video.videoHeight }\n\t\t})\n\t}\n\n\t/**\n\t * Get the size of an image blob\n\t *\n\t * @param blob - A Blob containing the image.\n\t * @public\n\t */\n\tstatic async getImageSize(blob: Blob): Promise<{ w: number; h: number }> {\n\t\tconst { w, h } = await MediaHelpers.usingObjectURL(blob, MediaHelpers.getImageAndDimensions)\n\n\t\ttry {\n\t\t\tif (blob.type === 'image/png') {\n\t\t\t\tconst view = new DataView(await blob.arrayBuffer())\n\t\t\t\tif (PngHelpers.isPng(view, 0)) {\n\t\t\t\t\tconst physChunk = PngHelpers.findChunk(view, 'pHYs')\n\t\t\t\t\tif (physChunk) {\n\t\t\t\t\t\tconst physData = PngHelpers.parsePhys(view, physChunk.dataOffset)\n\t\t\t\t\t\tif (physData.unit === 0 && physData.ppux === physData.ppuy) {\n\t\t\t\t\t\t\t// Calculate pixels per meter:\n\t\t\t\t\t\t\t// - 1 inch = 0.0254 meters\n\t\t\t\t\t\t\t// - 72 DPI is 72 dots per inch\n\t\t\t\t\t\t\t// - pixels per meter = 72 / 0.0254\n\t\t\t\t\t\t\tconst pixelsPerMeter = 72 / 0.0254\n\t\t\t\t\t\t\tconst pixelRatio = Math.max(physData.ppux / pixelsPerMeter, 1)\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tw: Math.round(w / pixelRatio),\n\t\t\t\t\t\t\t\th: Math.round(h / pixelRatio),\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tconsole.error(err)\n\t\t\treturn { w, h }\n\t\t}\n\t\treturn { w, h }\n\t}\n\n\tstatic async isAnimated(file: Blob): Promise<boolean> {\n\t\tif (file.type === 'image/gif') {\n\t\t\treturn isGifAnimated(await file.arrayBuffer())\n\t\t}\n\n\t\tif (file.type === 'image/avif') {\n\t\t\treturn isAvifAnimated(await file.arrayBuffer())\n\t\t}\n\n\t\tif (file.type === 'image/webp') {\n\t\t\treturn isWebpAnimated(await file.arrayBuffer())\n\t\t}\n\n\t\tif (file.type === 'image/apng') {\n\t\t\treturn isApngAnimated(await file.arrayBuffer())\n\t\t}\n\n\t\treturn false\n\t}\n\n\tstatic isAnimatedImageType(mimeType: string | null): boolean {\n\t\treturn DEFAULT_SUPPORTED_ANIMATED_IMAGE_TYPES.includes((mimeType as any) || '')\n\t}\n\n\tstatic isStaticImageType(mimeType: string | null): boolean {\n\t\treturn DEFAULT_SUPPORTED_STATIC_IMAGE_TYPES.includes((mimeType as any) || '')\n\t}\n\n\tstatic isVectorImageType(mimeType: string | null): boolean {\n\t\treturn DEFAULT_SUPPORTED_VECTOR_IMAGE_TYPES.includes((mimeType as any) || '')\n\t}\n\n\tstatic isImageType(mimeType: string): boolean {\n\t\treturn DEFAULT_SUPPORTED_IMAGE_TYPES.includes((mimeType as any) || '')\n\t}\n\n\tstatic async usingObjectURL<T>(blob: Blob, fn: (url: string) => Promise<T>): Promise<T> {\n\t\tconst url = URL.createObjectURL(blob)\n\t\ttry {\n\t\t\treturn await fn(url)\n\t\t} finally {\n\t\t\tURL.revokeObjectURL(url)\n\t\t}\n\t}\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1629, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/utils/src/lib/number.ts"],"sourcesContent":["/**\n * Linear interpolate between two values.\n *\n * @example\n *\n * ```ts\n * const A = lerp(0, 1, 0.5)\n * ```\n *\n * @public\n */\nexport function lerp(a: number, b: number, t: number) {\n\treturn a + (b - a) * t\n}\n\n/**\n * Inverse lerp between two values. Given a value `n` in the range [a, b], returns a number between\n * 0 and 1.\n *\n * @public\n */\nexport function invLerp(a: number, b: number, t: number) {\n\treturn (t - a) / (b - a)\n}\n\n/**\n * Seeded random number generator, using [xorshift](https://en.wikipedia.org/wiki/Xorshift). The\n * result will always be betweeen -1 and 1.\n *\n * Adapted from [seedrandom](https://github.com/davidbau/seedrandom).\n *\n * @public\n */\nexport function rng(seed = '') {\n\tlet x = 0\n\tlet y = 0\n\tlet z = 0\n\tlet w = 0\n\n\tfunction next() {\n\t\tconst t = x ^ (x << 11)\n\t\tx = y\n\t\ty = z\n\t\tz = w\n\t\tw ^= ((w >>> 19) ^ t ^ (t >>> 8)) >>> 0\n\t\treturn (w / 0x100000000) * 2\n\t}\n\n\tfor (let k = 0; k < seed.length + 64; k++) {\n\t\tx ^= seed.charCodeAt(k) | 0\n\t\tnext()\n\t}\n\n\treturn next\n}\n\n/**\n * Modulate a value between two ranges.\n *\n * @example\n *\n * ```ts\n * const A = modulate(0, [0, 1], [0, 100])\n * ```\n *\n * @param value - The interpolation value.\n * @param rangeA - From [low, high]\n * @param rangeB - To [low, high]\n * @param clamp - Whether to clamp the the result to [low, high]\n * @public\n */\nexport function modulate(value: number, rangeA: number[], rangeB: number[], clamp = false): number {\n\tconst [fromLow, fromHigh] = rangeA\n\tconst [v0, v1] = rangeB\n\tconst result = v0 + ((value - fromLow) / (fromHigh - fromLow)) * (v1 - v0)\n\n\treturn clamp\n\t\t? v0 < v1\n\t\t\t? Math.max(Math.min(result, v1), v0)\n\t\t\t: Math.max(Math.min(result, v0), v1)\n\t\t: result\n}\n"],"names":[],"mappings":";;;;;;AAWO,SAAS,KAAK,CAAA,EAAW,CAAA,EAAW,CAAA,EAAW;IACrD,OAAO,IAAA,CAAK,IAAI,CAAA,IAAK;AACtB;AAQO,SAAS,QAAQ,CAAA,EAAW,CAAA,EAAW,CAAA,EAAW;IACxD,OAAA,CAAQ,IAAI,CAAA,IAAA,CAAM,IAAI,CAAA;AACvB;AAUO,SAAS,IAAI,OAAO,EAAA,EAAI;IAC9B,IAAI,IAAI;IACR,IAAI,IAAI;IACR,IAAI,IAAI;IACR,IAAI,IAAI;IAER,SAAS,OAAO;QACf,MAAM,IAAI,IAAK,KAAK;QACpB,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,KAAA,CAAO,MAAM,KAAM,IAAK,MAAM,CAAA,MAAQ;QACtC,OAAQ,IAAI,aAAe;IAC5B;IAEA,IAAA,IAAS,IAAI,GAAG,IAAI,KAAK,MAAA,GAAS,IAAI,IAAK;QAC1C,KAAK,KAAK,UAAA,CAAW,CAAC,IAAI;QAC1B,KAAK;IACN;IAEA,OAAO;AACR;AAiBO,SAAS,SAAS,KAAA,EAAe,MAAA,EAAkB,MAAA,EAAkB,QAAQ,KAAA,EAAe;IAClG,MAAM,CAAC,SAAS,QAAQ,CAAA,GAAI;IAC5B,MAAM,CAAC,IAAI,EAAE,CAAA,GAAI;IACjB,MAAM,SAAS,KAAA,CAAO,QAAQ,OAAA,IAAA,CAAY,WAAW,OAAA,IAAA,CAAa,KAAK,EAAA;IAEvE,OAAO,QACJ,KAAK,KACJ,KAAK,GAAA,CAAI,KAAK,GAAA,CAAI,QAAQ,EAAE,GAAG,EAAE,IACjC,KAAK,GAAA,CAAI,KAAK,GAAA,CAAI,QAAQ,EAAE,GAAG,EAAE,IAClC;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1674, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/utils/src/lib/object.ts"],"sourcesContent":["import isEqualWith from 'lodash.isequalwith'\n\n/** @internal */\nexport function hasOwnProperty(obj: object, key: string): boolean {\n\treturn Object.prototype.hasOwnProperty.call(obj, key)\n}\n\n/** @internal */\nexport function getOwnProperty<K extends string, V>(\n\tobj: Partial<Record<K, V>>,\n\tkey: K\n): V | undefined\n/** @internal */\nexport function getOwnProperty<O extends object>(obj: O, key: string): O[keyof O] | undefined\n/** @internal */\nexport function getOwnProperty(obj: object, key: string): unknown\n/** @internal */\nexport function getOwnProperty(obj: object, key: string): unknown {\n\tif (!hasOwnProperty(obj, key)) {\n\t\treturn undefined\n\t}\n\t// @ts-expect-error we know the property exists\n\treturn obj[key]\n}\n\n/**\n * An alias for `Object.keys` that treats the object as a map and so preserves the type of the keys.\n *\n * @internal\n */\nexport function objectMapKeys<Key extends string>(object: {\n\treadonly [K in Key]: unknown\n}): Array<Key> {\n\treturn Object.keys(object) as Key[]\n}\n\n/**\n * An alias for `Object.values` that treats the object as a map and so preserves the type of the\n * keys.\n *\n * @internal\n */\nexport function objectMapValues<Key extends string, Value>(object: {\n\t[K in Key]: Value\n}): Array<Value> {\n\treturn Object.values(object) as Value[]\n}\n\n/**\n * An alias for `Object.entries` that treats the object as a map and so preserves the type of the\n * keys.\n *\n * @internal\n */\nexport function objectMapEntries<Key extends string, Value>(object: {\n\t[K in Key]: Value\n}): Array<[Key, Value]> {\n\treturn Object.entries(object) as [Key, Value][]\n}\n\n/**\n * An alias for `Object.fromEntries` that treats the object as a map and so preserves the type of the\n * keys.\n *\n * @internal\n */\nexport function objectMapFromEntries<Key extends string, Value>(\n\tentries: ReadonlyArray<readonly [Key, Value]>\n): { [K in Key]: Value } {\n\treturn Object.fromEntries(entries) as { [K in Key]: Value }\n}\n\n/**\n * Filters an object using a predicate function.\n * @returns a new object with only the entries that pass the predicate\n * @internal\n */\nexport function filterEntries<Key extends string, Value>(\n\tobject: { [K in Key]: Value },\n\tpredicate: (key: Key, value: Value) => boolean\n): { [K in Key]: Value } {\n\tconst result: { [K in Key]?: Value } = {}\n\tlet didChange = false\n\tfor (const [key, value] of objectMapEntries(object)) {\n\t\tif (predicate(key, value)) {\n\t\t\tresult[key] = value\n\t\t} else {\n\t\t\tdidChange = true\n\t\t}\n\t}\n\treturn didChange ? (result as { [K in Key]: Value }) : object\n}\n\n/**\n * Maps the values of one object map to another.\n * @returns a new object with the entries mapped\n * @internal\n */\nexport function mapObjectMapValues<Key extends string, ValueBefore, ValueAfter>(\n\tobject: { readonly [K in Key]: ValueBefore },\n\tmapper: (key: Key, value: ValueBefore) => ValueAfter\n): { [K in Key]: ValueAfter } {\n\tconst result = {} as { [K in Key]: ValueAfter }\n\tfor (const [key, value] of objectMapEntries(object)) {\n\t\tconst newValue = mapper(key, value)\n\t\tresult[key] = newValue\n\t}\n\treturn result\n}\n\n/** @internal */\nexport function areObjectsShallowEqual<T extends object>(obj1: T, obj2: T): boolean {\n\tif (obj1 === obj2) return true\n\tconst keys1 = new Set(Object.keys(obj1))\n\tconst keys2 = new Set(Object.keys(obj2))\n\tif (keys1.size !== keys2.size) return false\n\tfor (const key of keys1) {\n\t\tif (!keys2.has(key)) return false\n\t\tif (!Object.is((obj1 as any)[key], (obj2 as any)[key])) return false\n\t}\n\treturn true\n}\n\n/** @internal */\nexport function groupBy<K extends string, V>(\n\tarray: ReadonlyArray<V>,\n\tkeySelector: (value: V) => K\n): Record<K, V[]> {\n\tconst result: Record<K, V[]> = {} as any\n\tfor (const value of array) {\n\t\tconst key = keySelector(value)\n\t\tif (!result[key]) result[key] = []\n\t\tresult[key].push(value)\n\t}\n\treturn result\n}\n\n/** @internal */\nexport function omit(\n\tobj: Record<string, unknown>,\n\tkeys: ReadonlyArray<string>\n): Record<string, unknown> {\n\tconst result = { ...obj }\n\tfor (const key of keys) {\n\t\tdelete result[key]\n\t}\n\treturn result\n}\n\n/** @internal */\nexport function getChangedKeys<T extends object>(obj1: T, obj2: T): (keyof T)[] {\n\tconst result: (keyof T)[] = []\n\tfor (const key in obj1) {\n\t\tif (!Object.is(obj1[key], obj2[key])) {\n\t\t\tresult.push(key)\n\t\t}\n\t}\n\treturn result\n}\n\n/** @internal */\nexport function isEqualAllowingForFloatingPointErrors(\n\tobj1: object,\n\tobj2: object,\n\tthreshold = 0.000001\n): boolean {\n\treturn isEqualWith(obj1, obj2, (value1, value2) => {\n\t\tif (typeof value1 === 'number' && typeof value2 === 'number') {\n\t\t\treturn Math.abs(value1 - value2) < threshold\n\t\t}\n\t\treturn undefined\n\t})\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1786, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/utils/src/lib/perf.ts"],"sourcesContent":["export const PERFORMANCE_COLORS = {\n\tGood: '#40C057',\n\tMid: '#FFC078',\n\tPoor: '#E03131',\n}\n\nexport const PERFORMANCE_PREFIX_COLOR = PERFORMANCE_COLORS.Good\n\n/** @internal */\nexport function measureCbDuration(name: string, cb: () => any) {\n\tconst start = performance.now()\n\tconst result = cb()\n\t// eslint-disable-next-line no-console\n\tconsole.debug(\n\t\t`%cPerf%c ${name} took ${performance.now() - start}ms`,\n\t\t`color: white; background: ${PERFORMANCE_PREFIX_COLOR};padding: 2px;border-radius: 3px;`,\n\t\t'font-weight: normal'\n\t)\n\treturn result\n}\n\n/** @internal */\nexport function measureDuration(_target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n\tconst originalMethod = descriptor.value\n\tdescriptor.value = function (...args: any[]) {\n\t\tconst start = performance.now()\n\t\tconst result = originalMethod.apply(this, args)\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.debug(\n\t\t\t`%cPerf%c ${propertyKey} took: ${performance.now() - start}ms`,\n\t\t\t`color: white; background: ${PERFORMANCE_PREFIX_COLOR};padding: 2px;border-radius: 3px;`,\n\t\t\t'font-weight: normal'\n\t\t)\n\t\treturn result\n\t}\n\treturn descriptor\n}\n\nconst averages = new Map<any, { total: number; count: number }>()\n\n/** @internal */\nexport function measureAverageDuration(\n\t_target: any,\n\tpropertyKey: string,\n\tdescriptor: PropertyDescriptor\n) {\n\tconst originalMethod = descriptor.value\n\tdescriptor.value = function (...args: any[]) {\n\t\tconst start = performance.now()\n\t\tconst result = originalMethod.apply(this, args)\n\t\tconst end = performance.now()\n\t\tconst length = end - start\n\t\tif (length !== 0) {\n\t\t\tconst value = averages.get(descriptor.value)!\n\t\t\tconst total = value.total + length\n\t\t\tconst count = value.count + 1\n\t\t\taverages.set(descriptor.value, { total, count })\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.debug(\n\t\t\t\t`%cPerf%c ${propertyKey} took ${(end - start).toFixed(2)}ms | average ${(total / count).toFixed(2)}ms`,\n\t\t\t\t`color: white; background: ${PERFORMANCE_PREFIX_COLOR};padding: 2px;border-radius: 3px;`,\n\t\t\t\t'font-weight: normal'\n\t\t\t)\n\t\t}\n\t\treturn result\n\t}\n\taverages.set(descriptor.value, { total: 0, count: 0 })\n\treturn descriptor\n}\n"],"names":[],"mappings":";;;;;;;AAAO,MAAM,qBAAqB;IACjC,MAAM;IACN,KAAK;IACL,MAAM;AACP;AAEO,MAAM,2BAA2B,mBAAmB,IAAA;AAGpD,SAAS,kBAAkB,IAAA,EAAc,EAAA,EAAe;IAC9D,MAAM,QAAQ,YAAY,GAAA,CAAI;IAC9B,MAAM,SAAS,GAAG;IAElB,QAAQ,KAAA,CACP,CAAA,SAAA,EAAY,IAAI,CAAA,MAAA,EAAS,YAAY,GAAA,CAAI,IAAI,KAAK,CAAA,EAAA,CAAA,EAClD,CAAA,0BAAA,EAA6B,wBAAwB,CAAA,iCAAA,CAAA,EACrD;IAED,OAAO;AACR;AAGO,SAAS,gBAAgB,OAAA,EAAc,WAAA,EAAqB,UAAA,EAAgC;IAClG,MAAM,iBAAiB,WAAW,KAAA;IAClC,WAAW,KAAA,GAAQ,SAAA,GAAa,IAAA,EAAa;QAC5C,MAAM,QAAQ,YAAY,GAAA,CAAI;QAC9B,MAAM,SAAS,eAAe,KAAA,CAAM,IAAA,EAAM,IAAI;QAE9C,QAAQ,KAAA,CACP,CAAA,SAAA,EAAY,WAAW,CAAA,OAAA,EAAU,YAAY,GAAA,CAAI,IAAI,KAAK,CAAA,EAAA,CAAA,EAC1D,CAAA,0BAAA,EAA6B,wBAAwB,CAAA,iCAAA,CAAA,EACrD;QAED,OAAO;IACR;IACA,OAAO;AACR;AAEA,MAAM,WAAW,aAAA,GAAA,IAAI,IAA2C;AAGzD,SAAS,uBACf,OAAA,EACA,WAAA,EACA,UAAA,EACC;IACD,MAAM,iBAAiB,WAAW,KAAA;IAClC,WAAW,KAAA,GAAQ,SAAA,GAAa,IAAA,EAAa;QAC5C,MAAM,QAAQ,YAAY,GAAA,CAAI;QAC9B,MAAM,SAAS,eAAe,KAAA,CAAM,IAAA,EAAM,IAAI;QAC9C,MAAM,MAAM,YAAY,GAAA,CAAI;QAC5B,MAAM,SAAS,MAAM;QACrB,IAAI,WAAW,GAAG;YACjB,MAAM,QAAQ,SAAS,GAAA,CAAI,WAAW,KAAK;YAC3C,MAAM,QAAQ,MAAM,KAAA,GAAQ;YAC5B,MAAM,QAAQ,MAAM,KAAA,GAAQ;YAC5B,SAAS,GAAA,CAAI,WAAW,KAAA,EAAO;gBAAE;gBAAO;YAAM,CAAC;YAE/C,QAAQ,KAAA,CACP,CAAA,SAAA,EAAY,WAAW,CAAA,MAAA,EAAA,CAAU,MAAM,KAAA,EAAO,OAAA,CAAQ,CAAC,CAAC,CAAA,aAAA,EAAA,CAAiB,QAAQ,KAAA,EAAO,OAAA,CAAQ,CAAC,CAAC,CAAA,EAAA,CAAA,EAClG,CAAA,0BAAA,EAA6B,wBAAwB,CAAA,iCAAA,CAAA,EACrD;QAEF;QACA,OAAO;IACR;IACA,SAAS,GAAA,CAAI,WAAW,KAAA,EAAO;QAAE,OAAO;QAAG,OAAO;IAAE,CAAC;IACrD,OAAO;AACR","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1849, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/utils/src/lib/PerformanceTracker.ts"],"sourcesContent":["import { PERFORMANCE_COLORS, PERFORMANCE_PREFIX_COLOR } from './perf'\n\n/** @public */\nexport class PerformanceTracker {\n\tprivate startTime = 0\n\tprivate name = ''\n\tprivate frames = 0\n\tprivate started = false\n\tprivate frame: number | null = null\n\n\t// eslint-disable-next-line local/prefer-class-methods\n\trecordFrame = () => {\n\t\tthis.frames++\n\t\tif (!this.started) return\n\t\t// eslint-disable-next-line no-restricted-globals\n\t\tthis.frame = requestAnimationFrame(this.recordFrame)\n\t}\n\n\tstart(name: string) {\n\t\tthis.name = name\n\t\tthis.frames = 0\n\t\tthis.started = true\n\t\tif (this.frame !== null) cancelAnimationFrame(this.frame)\n\t\t// eslint-disable-next-line no-restricted-globals\n\t\tthis.frame = requestAnimationFrame(this.recordFrame)\n\t\tthis.startTime = performance.now()\n\t}\n\n\tstop() {\n\t\tthis.started = false\n\t\tif (this.frame !== null) cancelAnimationFrame(this.frame)\n\t\tconst duration = (performance.now() - this.startTime) / 1000\n\t\tconst fps = duration === 0 ? 0 : Math.floor(this.frames / duration)\n\t\tconst background =\n\t\t\tfps > 55\n\t\t\t\t? PERFORMANCE_COLORS.Good\n\t\t\t\t: fps > 30\n\t\t\t\t\t? PERFORMANCE_COLORS.Mid\n\t\t\t\t\t: PERFORMANCE_COLORS.Poor\n\t\tconst color = background === PERFORMANCE_COLORS.Mid ? 'black' : 'white'\n\t\tconst capitalized = this.name[0].toUpperCase() + this.name.slice(1)\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.debug(\n\t\t\t`%cPerf%c ${capitalized} %c${fps}%c fps`,\n\t\t\t`color: white; background: ${PERFORMANCE_PREFIX_COLOR};padding: 2px;border-radius: 3px;`,\n\t\t\t'font-weight: normal',\n\t\t\t`font-weight: bold; padding: 2px; background: ${background};color: ${color};`,\n\t\t\t'font-weight: normal'\n\t\t)\n\t}\n\n\tisStarted() {\n\t\treturn this.started\n\t}\n}\n"],"names":[],"mappings":";;;AAAA,SAAS,oBAAoB,gCAAgC;;AAGtD,MAAM,mBAAmB;IACvB,YAAY,EAAA;IACZ,OAAO,GAAA;IACP,SAAS,EAAA;IACT,UAAU,MAAA;IACV,QAAuB,KAAA;IAAA,sDAAA;IAG/B,cAAc,MAAM;QACnB,IAAA,CAAK,MAAA;QACL,IAAI,CAAC,IAAA,CAAK,OAAA,CAAS,CAAA;QAEnB,IAAA,CAAK,KAAA,GAAQ,sBAAsB,IAAA,CAAK,WAAW;IACpD,EAAA;IAEA,MAAM,IAAA,EAAc;QACnB,IAAA,CAAK,IAAA,GAAO;QACZ,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,OAAA,GAAU;QACf,IAAI,IAAA,CAAK,KAAA,KAAU,KAAM,CAAA,qBAAqB,IAAA,CAAK,KAAK;QAExD,IAAA,CAAK,KAAA,GAAQ,sBAAsB,IAAA,CAAK,WAAW;QACnD,IAAA,CAAK,SAAA,GAAY,YAAY,GAAA,CAAI;IAClC;IAEA,OAAO;QACN,IAAA,CAAK,OAAA,GAAU;QACf,IAAI,IAAA,CAAK,KAAA,KAAU,KAAM,CAAA,qBAAqB,IAAA,CAAK,KAAK;QACxD,MAAM,WAAA,CAAY,YAAY,GAAA,CAAI,IAAI,IAAA,CAAK,SAAA,IAAa;QACxD,MAAM,MAAM,aAAa,IAAI,IAAI,KAAK,KAAA,CAAM,IAAA,CAAK,MAAA,GAAS,QAAQ;QAClE,MAAM,aACL,MAAM,sKACH,qBAAA,CAAmB,IAAA,GACnB,MAAM,sKACL,qBAAA,CAAmB,GAAA,oKACnB,qBAAA,CAAmB,IAAA;QACxB,MAAM,QAAQ,gLAAe,qBAAA,CAAmB,GAAA,GAAM,UAAU;QAChE,MAAM,cAAc,IAAA,CAAK,IAAA,CAAK,CAAC,CAAA,CAAE,WAAA,CAAY,IAAI,IAAA,CAAK,IAAA,CAAK,KAAA,CAAM,CAAC;QAElE,QAAQ,KAAA,CACP,CAAA,SAAA,EAAY,WAAW,CAAA,GAAA,EAAM,GAAG,CAAA,MAAA,CAAA,EAChC,CAAA,0BAAA,mKAA6B,2BAAwB,CAAA,iCAAA,CAAA,EACrD,uBACA,CAAA,6CAAA,EAAgD,UAAU,CAAA,QAAA,EAAW,KAAK,CAAA,CAAA,CAAA,EAC1E;IAEF;IAEA,YAAY;QACX,OAAO,IAAA,CAAK,OAAA;IACb;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1896, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/utils/src/lib/reordering.ts"],"sourcesContent":["import {\n\tgenerateJitteredKeyBetween,\n\tgenerateNJitteredKeysBetween,\n\tgenerateNKeysBetween,\n} from 'fractional-indexing-jittered'\n\nconst generateKeysFn =\n\tprocess.env.NODE_ENV === 'test' ? generateNKeysBetween : generateNJitteredKeysBetween\n\n/**\n * A string made up of an integer part followed by a fraction part. The fraction point consists of\n * zero or more digits with no trailing zeros. Based on\n * {@link https://observablehq.com/@dgreensp/implementing-fractional-indexing}.\n *\n * @public\n */\nexport type IndexKey = string & { __brand: 'indexKey' }\n\n/**\n * The index key for the first index - 'a0'.\n * @public\n */\nexport const ZERO_INDEX_KEY = 'a0' as IndexKey\n\n/** @internal */\nexport function validateIndexKey(index: string): asserts index is IndexKey {\n\ttry {\n\t\tgenerateJitteredKeyBetween(index, null)\n\t} catch {\n\t\tthrow new Error('invalid index: ' + index)\n\t}\n}\n\n/**\n * Get a number of indices between two indices.\n * @param below - The index below.\n * @param above - The index above.\n * @param n - The number of indices to get.\n * @public\n */\nexport function getIndicesBetween(\n\tbelow: IndexKey | null | undefined,\n\tabove: IndexKey | null | undefined,\n\tn: number\n) {\n\treturn generateKeysFn(below ?? null, above ?? null, n) as IndexKey[]\n}\n\n/**\n * Get a number of indices above an index.\n * @param below - The index below.\n * @param n - The number of indices to get.\n * @public\n */\nexport function getIndicesAbove(below: IndexKey | null | undefined, n: number) {\n\treturn generateKeysFn(below ?? null, null, n) as IndexKey[]\n}\n\n/**\n * Get a number of indices below an index.\n * @param above - The index above.\n * @param n - The number of indices to get.\n * @public\n */\nexport function getIndicesBelow(above: IndexKey | null | undefined, n: number) {\n\treturn generateKeysFn(null, above ?? null, n) as IndexKey[]\n}\n\n/**\n * Get the index between two indices.\n * @param below - The index below.\n * @param above - The index above.\n * @public\n */\nexport function getIndexBetween(\n\tbelow: IndexKey | null | undefined,\n\tabove: IndexKey | null | undefined\n) {\n\treturn generateKeysFn(below ?? null, above ?? null, 1)[0] as IndexKey\n}\n\n/**\n * Get the index above a given index.\n * @param below - The index below.\n * @public\n */\nexport function getIndexAbove(below: IndexKey | null | undefined = null) {\n\treturn generateKeysFn(below, null, 1)[0] as IndexKey\n}\n\n/**\n * Get the index below a given index.\n * @param above - The index above.\n *  @public\n */\nexport function getIndexBelow(above: IndexKey | null | undefined = null) {\n\treturn generateKeysFn(null, above, 1)[0] as IndexKey\n}\n\n/**\n * Get n number of indices, starting at an index.\n * @param n - The number of indices to get.\n * @param start -  The index to start at.\n * @public\n */\nexport function getIndices(n: number, start = 'a1' as IndexKey) {\n\treturn [start, ...generateKeysFn(start, null, n)] as IndexKey[]\n}\n\n/**\n * Sort by index.\n * @param a - An object with an index property.\n * @param b - An object with an index property.\n * @public */\nexport function sortByIndex<T extends { index: IndexKey }>(a: T, b: T) {\n\tif (a.index < b.index) {\n\t\treturn -1\n\t} else if (a.index > b.index) {\n\t\treturn 1\n\t}\n\treturn 0\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;;AAMA,MAAM,iBACL,QAAQ,IAAI,aAAa,SAAS,8MAAuB,+BAAA;AAenD,MAAM,iBAAiB;AAGvB,SAAS,iBAAiB,KAAA,EAA0C;IAC1E,IAAI;QACH,CAAA,GAAA,kKAAA,CAAA,6BAAA,EAA2B,OAAO,IAAI;IACvC,EAAA,OAAQ;QACP,MAAM,IAAI,MAAM,oBAAoB,KAAK;IAC1C;AACD;AASO,SAAS,kBACf,KAAA,EACA,KAAA,EACA,CAAA,EACC;IACD,OAAO,eAAe,SAAS,MAAM,SAAS,MAAM,CAAC;AACtD;AAQO,SAAS,gBAAgB,KAAA,EAAoC,CAAA,EAAW;IAC9E,OAAO,eAAe,SAAS,MAAM,MAAM,CAAC;AAC7C;AAQO,SAAS,gBAAgB,KAAA,EAAoC,CAAA,EAAW;IAC9E,OAAO,eAAe,MAAM,SAAS,MAAM,CAAC;AAC7C;AAQO,SAAS,gBACf,KAAA,EACA,KAAA,EACC;IACD,OAAO,eAAe,SAAS,MAAM,SAAS,MAAM,CAAC,CAAA,CAAE,CAAC,CAAA;AACzD;AAOO,SAAS,cAAc,QAAqC,IAAA,EAAM;IACxE,OAAO,eAAe,OAAO,MAAM,CAAC,CAAA,CAAE,CAAC,CAAA;AACxC;AAOO,SAAS,cAAc,QAAqC,IAAA,EAAM;IACxE,OAAO,eAAe,MAAM,OAAO,CAAC,CAAA,CAAE,CAAC,CAAA;AACxC;AAQO,SAAS,WAAW,CAAA,EAAW,QAAQ,IAAA,EAAkB;IAC/D,OAAO;QAAC,OAAO;WAAG,eAAe,OAAO,MAAM,CAAC,CAAC;KAAA;AACjD;AAOO,SAAS,YAA2C,CAAA,EAAM,CAAA,EAAM;IACtE,IAAI,EAAE,KAAA,GAAQ,EAAE,KAAA,EAAO;QACtB,OAAO,CAAA;IACR,OAAA,IAAW,EAAE,KAAA,GAAQ,EAAE,KAAA,EAAO;QAC7B,OAAO;IACR;IACA,OAAO;AACR","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1959, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/utils/src/lib/retry.ts"],"sourcesContent":["import { sleep } from './control'\n\n/** @internal */\nexport async function retry<T>(\n\tfn: () => Promise<T>,\n\t{\n\t\tattempts = 3,\n\t\twaitDuration = 1000,\n\t\tabortSignal,\n\t\tmatchError,\n\t}: {\n\t\tattempts?: number\n\t\twaitDuration?: number\n\t\tabortSignal?: AbortSignal\n\t\tmatchError?(error: unknown): boolean\n\t} = {}\n): Promise<T> {\n\tlet error: unknown = null\n\tfor (let i = 0; i < attempts; i++) {\n\t\tif (abortSignal?.aborted) throw new Error('aborted')\n\t\ttry {\n\t\t\treturn await fn()\n\t\t} catch (e) {\n\t\t\tif (matchError && !matchError(e)) throw e\n\t\t\terror = e\n\t\t\tawait sleep(waitDuration)\n\t\t}\n\t}\n\tthrow error\n}\n"],"names":[],"mappings":";;;AAAA,SAAS,aAAa;;AAGtB,eAAsB,MACrB,EAAA,EACA,EACC,WAAW,CAAA,EACX,eAAe,GAAA,EACf,WAAA,EACA,UAAA,EACD,GAKI,CAAC,CAAA,EACQ;IACb,IAAI,QAAiB;IACrB,IAAA,IAAS,IAAI,GAAG,IAAI,UAAU,IAAK;QAClC,IAAI,aAAa,QAAS,CAAA,MAAM,IAAI,MAAM,SAAS;QACnD,IAAI;YACH,OAAO,MAAM,GAAG;QACjB,EAAA,OAAS,GAAG;YACX,IAAI,cAAc,CAAC,WAAW,CAAC,EAAG,CAAA,MAAM;YACxC,QAAQ;YACR,8KAAM,QAAA,EAAM,YAAY;QACzB;IACD;IACA,MAAM;AACP","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1986, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/utils/src/lib/sort.ts"],"sourcesContent":["/** @public */\nexport function sortById<T extends { id: any }>(a: T, b: T) {\n\treturn a.id > b.id ? 1 : -1\n}\n"],"names":[],"mappings":";;;AACO,SAAS,SAAgC,CAAA,EAAM,CAAA,EAAM;IAC3D,OAAO,EAAE,EAAA,GAAK,EAAE,EAAA,GAAK,IAAI,CAAA;AAC1B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2000, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/utils/src/lib/storage.tsx"],"sourcesContent":["/* eslint-disable no-restricted-syntax */\n\n/**\n * Get a value from local storage.\n *\n * @param key - The key to get.\n *\n * @internal\n */\nexport function getFromLocalStorage(key: string) {\n\ttry {\n\t\treturn localStorage.getItem(key)\n\t} catch {\n\t\treturn null\n\t}\n}\n\n/**\n * Set a value in local storage. Will not throw an error if localStorage is not available.\n *\n * @param key - The key to set.\n * @param value - The value to set.\n *\n * @internal\n */\nexport function setInLocalStorage(key: string, value: string) {\n\ttry {\n\t\tlocalStorage.setItem(key, value)\n\t} catch {\n\t\t// noop\n\t}\n}\n\n/**\n * Remove a value from local storage. Will not throw an error if localStorage is not available.\n *\n * @param key - The key to set.\n *\n * @internal\n */\nexport function deleteFromLocalStorage(key: string) {\n\ttry {\n\t\tlocalStorage.removeItem(key)\n\t} catch {\n\t\t// noop\n\t}\n}\n\n/**\n * Clear all values from local storage. Will not throw an error if localStorage is not available.\n *\n * @internal\n */\nexport function clearLocalStorage() {\n\ttry {\n\t\tlocalStorage.clear()\n\t} catch {\n\t\t// noop\n\t}\n}\n\n/**\n * Get a value from session storage.\n *\n * @param key - The key to get.\n *\n * @internal\n */\nexport function getFromSessionStorage(key: string) {\n\ttry {\n\t\treturn sessionStorage.getItem(key)\n\t} catch {\n\t\treturn null\n\t}\n}\n\n/**\n * Set a value in session storage. Will not throw an error if sessionStorage is not available.\n *\n * @param key - The key to set.\n * @param value - The value to set.\n *\n * @internal\n */\nexport function setInSessionStorage(key: string, value: string) {\n\ttry {\n\t\tsessionStorage.setItem(key, value)\n\t} catch {\n\t\t// noop\n\t}\n}\n\n/**\n * Remove a value from session storage. Will not throw an error if sessionStorage is not available.\n *\n * @param key - The key to set.\n *\n * @internal\n */\nexport function deleteFromSessionStorage(key: string) {\n\ttry {\n\t\tsessionStorage.removeItem(key)\n\t} catch {\n\t\t// noop\n\t}\n}\n\n/**\n * Clear all values from session storage. Will not throw an error if sessionStorage is not available.\n *\n * @internal\n */\nexport function clearSessionStorage() {\n\ttry {\n\t\tsessionStorage.clear()\n\t} catch {\n\t\t// noop\n\t}\n}\n"],"names":[],"mappings":";;;;;;;;;;AASO,SAAS,oBAAoB,GAAA,EAAa;IAChD,IAAI;QACH,OAAO,aAAa,OAAA,CAAQ,GAAG;IAChC,EAAA,OAAQ;QACP,OAAO;IACR;AACD;AAUO,SAAS,kBAAkB,GAAA,EAAa,KAAA,EAAe;IAC7D,IAAI;QACH,aAAa,OAAA,CAAQ,KAAK,KAAK;IAChC,EAAA,OAAQ,CAER;AACD;AASO,SAAS,uBAAuB,GAAA,EAAa;IACnD,IAAI;QACH,aAAa,UAAA,CAAW,GAAG;IAC5B,EAAA,OAAQ,CAER;AACD;AAOO,SAAS,oBAAoB;IACnC,IAAI;QACH,aAAa,KAAA,CAAM;IACpB,EAAA,OAAQ,CAER;AACD;AASO,SAAS,sBAAsB,GAAA,EAAa;IAClD,IAAI;QACH,OAAO,eAAe,OAAA,CAAQ,GAAG;IAClC,EAAA,OAAQ;QACP,OAAO;IACR;AACD;AAUO,SAAS,oBAAoB,GAAA,EAAa,KAAA,EAAe;IAC/D,IAAI;QACH,eAAe,OAAA,CAAQ,KAAK,KAAK;IAClC,EAAA,OAAQ,CAER;AACD;AASO,SAAS,yBAAyB,GAAA,EAAa;IACrD,IAAI;QACH,eAAe,UAAA,CAAW,GAAG;IAC9B,EAAA,OAAQ,CAER;AACD;AAOO,SAAS,sBAAsB;IACrC,IAAI;QACH,eAAe,KAAA,CAAM;IACtB,EAAA,OAAQ,CAER;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2062, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/utils/src/lib/stringEnum.ts"],"sourcesContent":["/** @internal */\nexport function stringEnum<T extends string>(...values: T[]): { [K in T]: K } {\n\tconst obj = {} as { [K in T]: K }\n\tfor (const value of values) {\n\t\tobj[value] = value\n\t}\n\treturn obj\n}\n"],"names":[],"mappings":";;;AACO,SAAS,WAAA,GAAgC,MAAA,EAA8B;IAC7E,MAAM,MAAM,CAAC;IACb,KAAA,MAAW,SAAS,OAAQ;QAC3B,GAAA,CAAI,KAAK,CAAA,GAAI;IACd;IACA,OAAO;AACR","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2080, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/utils/src/lib/throttle.ts"],"sourcesContent":["const isTest = () =>\n\ttypeof process !== 'undefined' &&\n\tprocess.env.NODE_ENV === 'test' &&\n\t// @ts-expect-error\n\t!globalThis.__FORCE_RAF_IN_TESTS__\n\nconst fpsQueue: Array<() => void> = []\nconst targetFps = 60\nconst targetTimePerFrame = Math.floor(1000 / targetFps) * 0.9 // ~15ms - we allow for some variance as browsers aren't that precise.\nlet frameRaf: undefined | number\nlet flushRaf: undefined | number\nlet lastFlushTime = -targetTimePerFrame\n\nconst flush = () => {\n\tconst queue = fpsQueue.splice(0, fpsQueue.length)\n\tfor (const fn of queue) {\n\t\tfn()\n\t}\n}\n\nfunction tick(isOnNextFrame = false) {\n\tif (frameRaf) return\n\n\tconst now = Date.now()\n\tconst elapsed = now - lastFlushTime\n\n\tif (elapsed < targetTimePerFrame) {\n\t\t// If we're too early to flush, we need to wait until the next frame to try and flush again.\n\t\t// eslint-disable-next-line no-restricted-globals\n\t\tframeRaf = requestAnimationFrame(() => {\n\t\t\tframeRaf = undefined\n\t\t\ttick(true)\n\t\t})\n\t\treturn\n\t}\n\n\tif (isOnNextFrame) {\n\t\t// If we've already waited for the next frame to run the tick, then we can flush immediately\n\t\tif (flushRaf) return // ...though if there's a flush raf, that means we'll be flushing on this frame already, so we can do nothing here.\n\t\tlastFlushTime = now\n\t\tflush()\n\t} else {\n\t\t// If we haven't already waited for the next frame to run the tick, we need to wait until the next frame to flush.\n\t\tif (flushRaf) return // ...though if there's a flush raf, that means we'll be flushing on the next frame already, so we can do nothing here.\n\t\t// eslint-disable-next-line no-restricted-globals\n\t\tflushRaf = requestAnimationFrame(() => {\n\t\t\tflushRaf = undefined\n\t\t\tlastFlushTime = now\n\t\t\tflush()\n\t\t})\n\t}\n}\n\n/**\n * Returns a throttled version of the function that will only be called max once per frame.\n * The target frame rate is 60fps.\n * @param fn - the fun to return a throttled version of\n * @returns\n * @internal\n */\nexport function fpsThrottle(fn: { (): void; cancel?(): void }): {\n\t(): void\n\tcancel?(): void\n} {\n\tif (isTest()) {\n\t\tfn.cancel = () => {\n\t\t\tif (frameRaf) {\n\t\t\t\tcancelAnimationFrame(frameRaf)\n\t\t\t\tframeRaf = undefined\n\t\t\t}\n\t\t\tif (flushRaf) {\n\t\t\t\tcancelAnimationFrame(flushRaf)\n\t\t\t\tflushRaf = undefined\n\t\t\t}\n\t\t}\n\t\treturn fn\n\t}\n\n\tconst throttledFn = () => {\n\t\tif (fpsQueue.includes(fn)) {\n\t\t\treturn\n\t\t}\n\t\tfpsQueue.push(fn)\n\t\ttick()\n\t}\n\tthrottledFn.cancel = () => {\n\t\tconst index = fpsQueue.indexOf(fn)\n\t\tif (index > -1) {\n\t\t\tfpsQueue.splice(index, 1)\n\t\t}\n\t}\n\treturn throttledFn\n}\n\n/**\n * Calls the function on the next frame. The target frame rate is 60fps.\n * If the same fn is passed again before the next frame, it will still be called only once.\n * @param fn - the fun to call on the next frame\n * @returns a function that will cancel the call if called before the next frame\n * @internal\n */\nexport function throttleToNextFrame(fn: () => void): () => void {\n\tif (isTest()) {\n\t\tfn()\n\t\treturn () => void null // noop\n\t}\n\n\tif (!fpsQueue.includes(fn)) {\n\t\tfpsQueue.push(fn)\n\t\ttick()\n\t}\n\n\treturn () => {\n\t\tconst index = fpsQueue.indexOf(fn)\n\t\tif (index > -1) {\n\t\t\tfpsQueue.splice(index, 1)\n\t\t}\n\t}\n}\n"],"names":[],"mappings":";;;;AAAA,MAAM,SAAS,IACd,OAAO,YAAY,eACnB,QAAQ,IAAI,wCAAa,UAAA,mBAAA;IAEzB,CAAC,WAAW,sBAAA;AAEb,MAAM,WAA8B,CAAC,CAAA;AACrC,MAAM,YAAY;AAClB,MAAM,qBAAqB,KAAK,KAAA,CAAM,MAAO,SAAS,IAAI;AAC1D,IAAI;AACJ,IAAI;AACJ,IAAI,gBAAgB,CAAC;AAErB,MAAM,QAAQ,MAAM;IACnB,MAAM,QAAQ,SAAS,MAAA,CAAO,GAAG,SAAS,MAAM;IAChD,KAAA,MAAW,MAAM,MAAO;QACvB,GAAG;IACJ;AACD;AAEA,SAAS,KAAK,gBAAgB,KAAA,EAAO;IACpC,IAAI,SAAU,CAAA;IAEd,MAAM,MAAM,KAAK,GAAA,CAAI;IACrB,MAAM,UAAU,MAAM;IAEtB,IAAI,UAAU,oBAAoB;QAGjC,WAAW,sBAAsB,MAAM;YACtC,WAAW,KAAA;YACX,KAAK,IAAI;QACV,CAAC;QACD;IACD;IAEA,IAAI,eAAe;QAElB,IAAI,SAAU,CAAA;QACd,gBAAgB;QAChB,MAAM;IACP,OAAO;QAEN,IAAI,SAAU,CAAA;QAEd,WAAW,sBAAsB,MAAM;YACtC,WAAW,KAAA;YACX,gBAAgB;YAChB,MAAM;QACP,CAAC;IACF;AACD;AASO,SAAS,YAAY,EAAA,EAG1B;IACD,IAAI,OAAO,GAAG;;IAYd;IAEA,MAAM,cAAc,MAAM;QACzB,IAAI,SAAS,QAAA,CAAS,EAAE,GAAG;YAC1B;QACD;QACA,SAAS,IAAA,CAAK,EAAE;QAChB,KAAK;IACN;IACA,YAAY,MAAA,GAAS,MAAM;QAC1B,MAAM,QAAQ,SAAS,OAAA,CAAQ,EAAE;QACjC,IAAI,QAAQ,CAAA,GAAI;YACf,SAAS,MAAA,CAAO,OAAO,CAAC;QACzB;IACD;IACA,OAAO;AACR;AASO,SAAS,oBAAoB,EAAA,EAA4B;IAC/D,IAAI,OAAO,GAAG;;IAGd;IAEA,IAAI,CAAC,SAAS,QAAA,CAAS,EAAE,GAAG;QAC3B,SAAS,IAAA,CAAK,EAAE;QAChB,KAAK;IACN;IAEA,OAAO,MAAM;QACZ,MAAM,QAAQ,SAAS,OAAA,CAAQ,EAAE;QACjC,IAAI,QAAQ,CAAA,GAAI;YACf,SAAS,MAAA,CAAO,OAAO,CAAC;QACzB;IACD;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2164, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/utils/src/lib/timers.ts"],"sourcesContent":["/* eslint-disable no-restricted-properties */\n\n/** @public */\nexport class Timers {\n\tprivate timeouts = new Map<string, number[]>()\n\tprivate intervals = new Map<string, number[]>()\n\tprivate rafs = new Map<string, number[]>()\n\n\tconstructor() {\n\t\tthis.setTimeout = this.setTimeout.bind(this)\n\t\tthis.setInterval = this.setInterval.bind(this)\n\t\tthis.requestAnimationFrame = this.requestAnimationFrame.bind(this)\n\t\tthis.dispose = this.dispose.bind(this)\n\t}\n\n\t/** @public */\n\tsetTimeout(contextId: string, handler: TimerHandler, timeout?: number, ...args: any[]): number {\n\t\tconst id = window.setTimeout(handler, timeout, args)\n\t\tconst current = this.timeouts.get(contextId) ?? []\n\t\tthis.timeouts.set(contextId, [...current, id])\n\t\treturn id\n\t}\n\n\t/** @public */\n\tsetInterval(contextId: string, handler: TimerHandler, timeout?: number, ...args: any[]): number {\n\t\tconst id = window.setInterval(handler, timeout, args)\n\t\tconst current = this.intervals.get(contextId) ?? []\n\t\tthis.intervals.set(contextId, [...current, id])\n\t\treturn id\n\t}\n\n\t/** @public */\n\trequestAnimationFrame(contextId: string, callback: FrameRequestCallback): number {\n\t\tconst id = window.requestAnimationFrame(callback)\n\t\tconst current = this.rafs.get(contextId) ?? []\n\t\tthis.rafs.set(contextId, [...current, id])\n\t\treturn id\n\t}\n\n\t/** @public */\n\tdispose(contextId: string) {\n\t\tthis.timeouts.get(contextId)?.forEach((id) => clearTimeout(id))\n\t\tthis.intervals.get(contextId)?.forEach((id) => clearInterval(id))\n\t\tthis.rafs.get(contextId)?.forEach((id) => cancelAnimationFrame(id))\n\n\t\tthis.timeouts.delete(contextId)\n\t\tthis.intervals.delete(contextId)\n\t\tthis.rafs.delete(contextId)\n\t}\n\n\tdisposeAll() {\n\t\tfor (const contextId of this.timeouts.keys()) {\n\t\t\tthis.dispose(contextId)\n\t\t}\n\t}\n\n\tforContext(contextId: string) {\n\t\treturn {\n\t\t\tsetTimeout: (handler: TimerHandler, timeout?: number, ...args: any[]) =>\n\t\t\t\tthis.setTimeout(contextId, handler, timeout, args),\n\t\t\tsetInterval: (handler: TimerHandler, timeout?: number, ...args: any[]) =>\n\t\t\t\tthis.setInterval(contextId, handler, timeout, args),\n\t\t\trequestAnimationFrame: (callback: FrameRequestCallback) =>\n\t\t\t\tthis.requestAnimationFrame(contextId, callback),\n\t\t\tdispose: () => this.dispose(contextId),\n\t\t}\n\t}\n}\n"],"names":[],"mappings":";;;AAGO,MAAM,OAAO;IACX,WAAW,aAAA,GAAA,IAAI,IAAsB,EAAA;IACrC,YAAY,aAAA,GAAA,IAAI,IAAsB,EAAA;IACtC,OAAO,aAAA,GAAA,IAAI,IAAsB,EAAA;IAEzC,aAAc;QACb,IAAA,CAAK,UAAA,GAAa,IAAA,CAAK,UAAA,CAAW,IAAA,CAAK,IAAI;QAC3C,IAAA,CAAK,WAAA,GAAc,IAAA,CAAK,WAAA,CAAY,IAAA,CAAK,IAAI;QAC7C,IAAA,CAAK,qBAAA,GAAwB,IAAA,CAAK,qBAAA,CAAsB,IAAA,CAAK,IAAI;QACjE,IAAA,CAAK,OAAA,GAAU,IAAA,CAAK,OAAA,CAAQ,IAAA,CAAK,IAAI;IACtC;IAAA,YAAA,GAGA,WAAW,SAAA,EAAmB,OAAA,EAAuB,OAAA,EAAA,GAAqB,IAAA,EAAqB;QAC9F,MAAM,KAAK,OAAO,UAAA,CAAW,SAAS,SAAS,IAAI;QACnD,MAAM,UAAU,IAAA,CAAK,QAAA,CAAS,GAAA,CAAI,SAAS,KAAK,CAAC,CAAA;QACjD,IAAA,CAAK,QAAA,CAAS,GAAA,CAAI,WAAW,CAAC;eAAG;YAAS,EAAE;SAAC;QAC7C,OAAO;IACR;IAAA,YAAA,GAGA,YAAY,SAAA,EAAmB,OAAA,EAAuB,OAAA,EAAA,GAAqB,IAAA,EAAqB;QAC/F,MAAM,KAAK,OAAO,WAAA,CAAY,SAAS,SAAS,IAAI;QACpD,MAAM,UAAU,IAAA,CAAK,SAAA,CAAU,GAAA,CAAI,SAAS,KAAK,CAAC,CAAA;QAClD,IAAA,CAAK,SAAA,CAAU,GAAA,CAAI,WAAW,CAAC;eAAG;YAAS,EAAE;SAAC;QAC9C,OAAO;IACR;IAAA,YAAA,GAGA,sBAAsB,SAAA,EAAmB,QAAA,EAAwC;QAChF,MAAM,KAAK,OAAO,qBAAA,CAAsB,QAAQ;QAChD,MAAM,UAAU,IAAA,CAAK,IAAA,CAAK,GAAA,CAAI,SAAS,KAAK,CAAC,CAAA;QAC7C,IAAA,CAAK,IAAA,CAAK,GAAA,CAAI,WAAW,CAAC;eAAG;YAAS,EAAE;SAAC;QACzC,OAAO;IACR;IAAA,YAAA,GAGA,QAAQ,SAAA,EAAmB;QAC1B,IAAA,CAAK,QAAA,CAAS,GAAA,CAAI,SAAS,GAAG,QAAQ,CAAC,KAAO,aAAa,EAAE,CAAC;QAC9D,IAAA,CAAK,SAAA,CAAU,GAAA,CAAI,SAAS,GAAG,QAAQ,CAAC,KAAO,cAAc,EAAE,CAAC;QAChE,IAAA,CAAK,IAAA,CAAK,GAAA,CAAI,SAAS,GAAG,QAAQ,CAAC,KAAO,qBAAqB,EAAE,CAAC;QAElE,IAAA,CAAK,QAAA,CAAS,MAAA,CAAO,SAAS;QAC9B,IAAA,CAAK,SAAA,CAAU,MAAA,CAAO,SAAS;QAC/B,IAAA,CAAK,IAAA,CAAK,MAAA,CAAO,SAAS;IAC3B;IAEA,aAAa;QACZ,KAAA,MAAW,aAAa,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,EAAG;YAC7C,IAAA,CAAK,OAAA,CAAQ,SAAS;QACvB;IACD;IAEA,WAAW,SAAA,EAAmB;QAC7B,OAAO;YACN,YAAY,CAAC,SAAuB,SAAA,GAAqB,OACxD,IAAA,CAAK,UAAA,CAAW,WAAW,SAAS,SAAS,IAAI;YAClD,aAAa,CAAC,SAAuB,SAAA,GAAqB,OACzD,IAAA,CAAK,WAAA,CAAY,WAAW,SAAS,SAAS,IAAI;YACnD,uBAAuB,CAAC,WACvB,IAAA,CAAK,qBAAA,CAAsB,WAAW,QAAQ;YAC/C,SAAS,IAAM,IAAA,CAAK,OAAA,CAAQ,SAAS;QACtC;IACD;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2234, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/utils/src/lib/url.ts"],"sourcesContent":["/** @public */\nexport const safeParseUrl = (url: string, baseUrl?: string | URL) => {\n\ttry {\n\t\treturn new URL(url, baseUrl)\n\t} catch {\n\t\treturn\n\t}\n}\n"],"names":[],"mappings":";;;AACO,MAAM,eAAe,CAAC,KAAa,YAA2B;IACpE,IAAI;QACH,OAAO,IAAI,IAAI,KAAK,OAAO;IAC5B,EAAA,OAAQ;QACP;IACD;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2252, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/utils/src/lib/value.ts"],"sourcesContent":["/**\n * Get whether a value is not undefined.\n *\n * @param value - The value to check.\n * @public\n */\nexport function isDefined<T>(value: T): value is typeof value extends undefined ? never : T {\n\treturn value !== undefined\n}\n\n/**\n * Get whether a value is null\n *\n * @param value - The value to check.\n * @public\n */\nexport function isNonNull<T>(value: T): value is typeof value extends null ? never : T {\n\treturn value !== null\n}\n\n/**\n * Get whether a value is nullish (null, undefined).\n *\n * @param value - The value to check.\n * @public\n */\nexport function isNonNullish<T>(\n\tvalue: T\n): value is typeof value extends undefined ? never : typeof value extends null ? never : T {\n\treturn value !== null && value !== undefined\n}\n\nfunction getStructuredClone(): [<T>(i: T) => T, boolean] {\n\tif (typeof globalThis !== 'undefined' && (globalThis as any).structuredClone) {\n\t\treturn [globalThis.structuredClone as <T>(i: T) => T, true]\n\t}\n\n\tif (typeof global !== 'undefined' && (global as any).structuredClone) {\n\t\treturn [global.structuredClone as <T>(i: T) => T, true]\n\t}\n\n\tif (typeof window !== 'undefined' && (window as any).structuredClone) {\n\t\treturn [window.structuredClone as <T>(i: T) => T, true]\n\t}\n\n\treturn [<T>(i: T): T => (i ? JSON.parse(JSON.stringify(i)) : i), false]\n}\n\nconst _structuredClone = getStructuredClone()\n\n/**\n * Create a deep copy of a value. Uses the structuredClone API if available, otherwise uses JSON.parse(JSON.stringify()).\n *\n * @param i - The value to clone.\n * @public */\nexport const structuredClone = _structuredClone[0]\n\n/**\n * @internal\n */\nexport const isNativeStructuredClone = _structuredClone[1]\n\n/**\n * When we patch structuredClone in jsdom for testing (see https://github.com/jsdom/jsdom/issues/3363),\n * the Object that is used as a prototype for the cloned object is not the same as the Object in\n * the code under test (that comes from jsdom's fake global context). This constant is used in\n * our code to work around this case.\n *\n * This is also the case for Array prototype, but that problem can be worked around with an\n * Array.isArray() check.\n * @internal\n */\nexport const STRUCTURED_CLONE_OBJECT_PROTOTYPE = Object.getPrototypeOf(structuredClone({}))\n"],"names":[],"mappings":";;;;;;;;AAMO,SAAS,UAAa,KAAA,EAA+D;IAC3F,OAAO,UAAU,KAAA;AAClB;AAQO,SAAS,UAAa,KAAA,EAA0D;IACtF,OAAO,UAAU;AAClB;AAQO,SAAS,aACf,KAAA,EAC0F;IAC1F,OAAO,UAAU,QAAQ,UAAU,KAAA;AACpC;AAEA,SAAS,qBAAgD;IACxD,IAAI,OAAO,eAAe,eAAgB,WAAmB,eAAA,EAAiB;QAC7E,OAAO;YAAC,WAAW,eAAA;YAAmC,IAAI;SAAA;IAC3D;IAEA,IAAI,OAAO,WAAW,eAAgB,OAAe,eAAA,EAAiB;QACrE,OAAO;YAAC,OAAO,eAAA;YAAmC,IAAI;SAAA;IACvD;IAEA,IAAI,OAAO,WAAW,eAAgB,OAAe,eAAA,EAAiB;QACrE,OAAO;YAAC,OAAO,eAAA;YAAmC,IAAI;SAAA;IACvD;IAEA,OAAO;QAAC,CAAI,IAAa,IAAI,KAAK,KAAA,CAAM,KAAK,SAAA,CAAU,CAAC,CAAC,IAAI;QAAI,KAAK;KAAA;AACvE;AAEA,MAAM,mBAAmB,mBAAmB;AAOrC,MAAM,kBAAkB,gBAAA,CAAiB,CAAC,CAAA;AAK1C,MAAM,0BAA0B,gBAAA,CAAiB,CAAC,CAAA;AAYlD,MAAM,oCAAoC,OAAO,cAAA,CAAe,gBAAgB,CAAC,CAAC,CAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2305, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/utils/src/lib/warn.ts"],"sourcesContent":["const usedWarnings = new Set<string>()\n\n/** @internal */\nexport function warnDeprecatedGetter(name: string) {\n\twarnOnce(\n\t\t`Using '${name}' is deprecated and will be removed in the near future. Please refactor to use 'get${name[0].toLocaleUpperCase()}${name.slice(\n\t\t\t1\n\t\t)}' instead.`\n\t)\n}\n\n/** @internal */\nexport function warnOnce(message: string) {\n\tif (usedWarnings.has(message)) return\n\n\tusedWarnings.add(message)\n\tconsole.warn(`[tldraw] ${message}`)\n}\n"],"names":[],"mappings":";;;;AAAA,MAAM,eAAe,aAAA,GAAA,IAAI,IAAY;AAG9B,SAAS,qBAAqB,IAAA,EAAc;IAClD,SACC,CAAA,OAAA,EAAU,IAAI,CAAA,mFAAA,EAAsF,IAAA,CAAK,CAAC,CAAA,CAAE,iBAAA,CAAkB,CAAC,GAAG,KAAK,KAAA,CACtI,GACA,UAAA,CAAA;AAEH;AAGO,SAAS,SAAS,OAAA,EAAiB;IACzC,IAAI,aAAa,GAAA,CAAI,OAAO,EAAG,CAAA;IAE/B,aAAa,GAAA,CAAI,OAAO;IACxB,QAAQ,IAAA,CAAK,CAAA,SAAA,EAAY,OAAO,EAAE;AACnC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2326, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/utils/src/index.ts"],"sourcesContent":["import { registerTldrawLibraryVersion } from './lib/version'\n\nexport { default as isEqual } from 'lodash.isequal'\nexport { default as isEqualWith } from 'lodash.isequalwith'\nexport { default as throttle } from 'lodash.throttle'\nexport { default as uniq } from 'lodash.uniq'\nexport {\n\tareArraysShallowEqual,\n\tcompact,\n\tdedupe,\n\tlast,\n\tmaxBy,\n\tmergeArraysAndReplaceDefaults,\n\tminBy,\n\tpartition,\n\trotateArray,\n} from './lib/array'\nexport { bind } from './lib/bind'\nexport { WeakCache } from './lib/cache'\nexport {\n\tassert,\n\tassertExists,\n\texhaustiveSwitchError,\n\tpromiseWithResolve,\n\tResult,\n\tsleep,\n\ttype ErrorResult,\n\ttype OkResult,\n} from './lib/control'\nexport { debounce } from './lib/debounce'\nexport { annotateError, getErrorAnnotations, type ErrorAnnotations } from './lib/error'\nexport { ExecutionQueue } from './lib/ExecutionQueue'\nexport { FileHelpers } from './lib/file'\nexport { noop, omitFromStackTrace } from './lib/function'\nexport { getHashForBuffer, getHashForObject, getHashForString, lns } from './lib/hash'\nexport { mockUniqueId, restoreUniqueId, uniqueId } from './lib/id'\nexport { getFirstFromIterable } from './lib/iterable'\nexport type { JsonArray, JsonObject, JsonPrimitive, JsonValue } from './lib/json-value'\nexport {\n\tDEFAULT_SUPPORT_VIDEO_TYPES,\n\tDEFAULT_SUPPORTED_IMAGE_TYPES,\n\tDEFAULT_SUPPORTED_MEDIA_TYPE_LIST,\n\tDEFAULT_SUPPORTED_MEDIA_TYPES,\n\tMediaHelpers,\n} from './lib/media/media'\nexport { PngHelpers } from './lib/media/png'\nexport { fetch, Image } from './lib/network'\nexport { invLerp, lerp, modulate, rng } from './lib/number'\nexport {\n\tareObjectsShallowEqual,\n\tfilterEntries,\n\tgetChangedKeys,\n\tgetOwnProperty,\n\tgroupBy,\n\thasOwnProperty,\n\tisEqualAllowingForFloatingPointErrors,\n\tmapObjectMapValues,\n\tobjectMapEntries,\n\tobjectMapFromEntries,\n\tobjectMapKeys,\n\tobjectMapValues,\n\tomit,\n} from './lib/object'\nexport { measureAverageDuration, measureCbDuration, measureDuration } from './lib/perf'\nexport { PerformanceTracker } from './lib/PerformanceTracker'\nexport {\n\tgetIndexAbove,\n\tgetIndexBelow,\n\tgetIndexBetween,\n\tgetIndices,\n\tgetIndicesAbove,\n\tgetIndicesBelow,\n\tgetIndicesBetween,\n\tsortByIndex,\n\tvalidateIndexKey,\n\tZERO_INDEX_KEY,\n\ttype IndexKey,\n} from './lib/reordering'\nexport { retry } from './lib/retry'\nexport { sortById } from './lib/sort'\nexport {\n\tclearLocalStorage,\n\tclearSessionStorage,\n\tdeleteFromLocalStorage,\n\tdeleteFromSessionStorage,\n\tgetFromLocalStorage,\n\tgetFromSessionStorage,\n\tsetInLocalStorage,\n\tsetInSessionStorage,\n} from './lib/storage'\nexport { stringEnum } from './lib/stringEnum'\nexport { fpsThrottle, throttleToNextFrame } from './lib/throttle'\nexport { Timers } from './lib/timers'\nexport {\n\ttype Expand,\n\ttype MakeUndefinedOptional,\n\ttype RecursivePartial,\n\ttype Required,\n} from './lib/types'\nexport { safeParseUrl } from './lib/url'\nexport {\n\tisDefined,\n\tisNativeStructuredClone,\n\tisNonNull,\n\tisNonNullish,\n\tSTRUCTURED_CLONE_OBJECT_PROTOTYPE,\n\tstructuredClone,\n} from './lib/value'\nexport { registerTldrawLibraryVersion } from './lib/version'\nexport { warnDeprecatedGetter, warnOnce } from './lib/warn'\n\nregisterTldrawLibraryVersion(\n\t(globalThis as any).TLDRAW_LIBRARY_NAME,\n\t(globalThis as any).TLDRAW_LIBRARY_VERSION,\n\t(globalThis as any).TLDRAW_LIBRARY_MODULES\n)\n"],"names":["default","registerTldrawLibraryVersion"],"mappings":";AAAA,SAAS,oCAAoC;AAE7C,SAAoB,WAAXA,gBAA0B;AACnC,SAAoB,WAAXA,gBAA8B;AACvC,SAAoB,WAAXA,gBAA2B;AACpC,SAAoB,WAAXA,gBAAuB;AAChC;AAWA,SAAS,YAAY;AACrB,SAAS,iBAAiB;AAC1B;AAUA,SAAS,gBAAgB;AACzB,SAAS,eAAe,2BAAkD;AAC1E,SAAS,sBAAsB;AAC/B,SAAS,mBAAmB;AAC5B,SAAS,MAAM,0BAA0B;AACzC,SAAS,kBAAkB,kBAAkB,kBAAkB,WAAW;AAC1E,SAAS,cAAc,iBAAiB,gBAAgB;AACxD,SAAS,4BAA4B;AAErC;AAOA,SAAS,kBAAkB;AAC3B,SAAS,OAAO,aAAa;AAC7B,SAAS,SAAS,MAAM,UAAU,WAAW;AAC7C;AAeA,SAAS,wBAAwB,mBAAmB,uBAAuB;AAC3E,SAAS,0BAA0B;AACnC;AAaA,SAAS,aAAa;AACtB,SAAS,gBAAgB;AACzB;AAUA,SAAS,kBAAkB;AAC3B,SAAS,aAAa,2BAA2B;AACjD,SAAS,cAAc;AAOvB,SAAS,oBAAoB;AAC7B;AASA,SAAS,sBAAsB,gBAAgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wKAE/C,+BAAA,EACE,iBACA,UACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2447, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/state/src/lib/helpers.ts"],"sourcesContent":["import { Child, Signal } from './types'\n\n/**\n * Get whether the given value is a child.\n *\n * @param x The value to check.\n * @returns True if the value is a child, false otherwise.\n */\nfunction isChild(x: any): x is Child {\n\treturn x && typeof x === 'object' && 'parents' in x\n}\n\n/**\n * Get whether a child's parents have changed.\n *\n * @param child The child to check.\n * @returns True if the child's parents have changed, false otherwise.\n */\nexport function haveParentsChanged(child: Child): boolean {\n\tfor (let i = 0, n = child.parents.length; i < n; i++) {\n\t\t// Get the parent's value without capturing it.\n\t\tchild.parents[i].__unsafe__getWithoutCapture(true)\n\n\t\t// If the parent's epoch does not match the child's view of the parent's epoch, then the parent has changed.\n\t\tif (child.parents[i].lastChangedEpoch !== child.parentEpochs[i]) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n/**\n * Detach a child from a parent.\n *\n * @param parent The parent to detach from.\n * @param child The child to detach.\n */\nexport function detach(parent: Signal<any>, child: Child) {\n\t// If the child is not attached to the parent, do nothing.\n\tif (!parent.children.remove(child)) {\n\t\treturn\n\t}\n\n\t// If the parent has no more children, then detach the parent from its parents.\n\tif (parent.children.isEmpty && isChild(parent)) {\n\t\tfor (let i = 0, n = parent.parents.length; i < n; i++) {\n\t\t\tdetach(parent.parents[i], parent)\n\t\t}\n\t}\n}\n\n/**\n * Attach a child to a parent.\n *\n * @param parent The parent to attach to.\n * @param child The child to attach.\n */\nexport function attach(parent: Signal<any>, child: Child) {\n\t// If the child is already attached to the parent, do nothing.\n\tif (!parent.children.add(child)) {\n\t\treturn\n\t}\n\n\t// If the parent itself is a child, add the parent to the parent's parents.\n\tif (isChild(parent)) {\n\t\tfor (let i = 0, n = parent.parents.length; i < n; i++) {\n\t\t\tattach(parent.parents[i], parent)\n\t\t}\n\t}\n}\n\n/**\n * Get whether two values are equal (insofar as @tldraw/state is concerned).\n *\n * @param a The first value.\n * @param b The second value.\n */\nexport function equals(a: any, b: any): boolean {\n\tconst shallowEquals =\n\t\ta === b || Object.is(a, b) || Boolean(a && b && typeof a.equals === 'function' && a.equals(b))\n\treturn shallowEquals\n}\n\nexport declare function assertNever(x: never): never\n\nexport function singleton<T>(key: string, init: () => T): T {\n\tconst symbol = Symbol.for(`com.tldraw.state/${key}`)\n\tconst global = globalThis as any\n\tglobal[symbol] ??= init()\n\treturn global[symbol]\n}\n\n/**\n * @public\n */\nexport const EMPTY_ARRAY: [] = singleton('empty_array', () => Object.freeze([]) as any)\n\n/**\n * Does this signal have any active reactors attached to it? When it changes, will it cause anything to run?\n * @public\n */\nexport function hasReactors(signal: Signal<any>) {\n\tfor (const child of signal.children) {\n\t\tif (child.isActivelyListening) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n"],"names":[],"mappings":";;;;;;;;;AAQA,SAAS,QAAQ,CAAA,EAAoB;IACpC,OAAO,KAAK,OAAO,MAAM,YAAY,aAAa;AACnD;AAQO,SAAS,mBAAmB,KAAA,EAAuB;IACzD,IAAA,IAAS,IAAI,GAAG,IAAI,MAAM,OAAA,CAAQ,MAAA,EAAQ,IAAI,GAAG,IAAK;QAErD,MAAM,OAAA,CAAQ,CAAC,CAAA,CAAE,2BAAA,CAA4B,IAAI;QAGjD,IAAI,MAAM,OAAA,CAAQ,CAAC,CAAA,CAAE,gBAAA,KAAqB,MAAM,YAAA,CAAa,CAAC,CAAA,EAAG;YAChE,OAAO;QACR;IACD;IAEA,OAAO;AACR;AAQO,SAAS,OAAO,MAAA,EAAqB,KAAA,EAAc;IAEzD,IAAI,CAAC,OAAO,QAAA,CAAS,MAAA,CAAO,KAAK,GAAG;QACnC;IACD;IAGA,IAAI,OAAO,QAAA,CAAS,OAAA,IAAW,QAAQ,MAAM,GAAG;QAC/C,IAAA,IAAS,IAAI,GAAG,IAAI,OAAO,OAAA,CAAQ,MAAA,EAAQ,IAAI,GAAG,IAAK;YACtD,OAAO,OAAO,OAAA,CAAQ,CAAC,CAAA,EAAG,MAAM;QACjC;IACD;AACD;AAQO,SAAS,OAAO,MAAA,EAAqB,KAAA,EAAc;IAEzD,IAAI,CAAC,OAAO,QAAA,CAAS,GAAA,CAAI,KAAK,GAAG;QAChC;IACD;IAGA,IAAI,QAAQ,MAAM,GAAG;QACpB,IAAA,IAAS,IAAI,GAAG,IAAI,OAAO,OAAA,CAAQ,MAAA,EAAQ,IAAI,GAAG,IAAK;YACtD,OAAO,OAAO,OAAA,CAAQ,CAAC,CAAA,EAAG,MAAM;QACjC;IACD;AACD;AAQO,SAAS,OAAO,CAAA,EAAQ,CAAA,EAAiB;IAC/C,MAAM,gBACL,MAAM,KAAK,OAAO,EAAA,CAAG,GAAG,CAAC,KAAK,QAAQ,KAAK,KAAK,OAAO,EAAE,MAAA,KAAW,cAAc,EAAE,MAAA,CAAO,CAAC,CAAC;IAC9F,OAAO;AACR;AAIO,SAAS,UAAa,GAAA,EAAa,IAAA,EAAkB;IAC3D,MAAM,SAAS,OAAO,GAAA,CAAI,CAAA,iBAAA,EAAoB,GAAG,EAAE;IACnD,MAAM,SAAS;IACf,MAAA,CAAO,MAAM,CAAA,KAAM,KAAK;IACxB,OAAO,MAAA,CAAO,MAAM,CAAA;AACrB;AAKO,MAAM,cAAkB,UAAU,eAAe,IAAM,OAAO,MAAA,CAAO,CAAC,CAAC,CAAQ;AAM/E,SAAS,YAAY,MAAA,EAAqB;IAChD,KAAA,MAAW,SAAS,OAAO,QAAA,CAAU;QACpC,IAAI,MAAM,mBAAA,EAAqB;YAC9B,OAAO;QACR;IACD;IAEA,OAAO;AACR","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2515, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/state/src/lib/ArraySet.ts"],"sourcesContent":["// The maximum size for an array in an ArraySet\nexport const ARRAY_SIZE_THRESHOLD = 8\n\n/**\n * An ArraySet operates as an array until it reaches a certain size, after which a Set is used\n * instead. In either case, the same methods are used to get, set, remove, and visit the items.\n * @internal\n */\nexport class ArraySet<T> {\n\tprivate arraySize = 0\n\n\tprivate array: (T | undefined)[] | null = Array(ARRAY_SIZE_THRESHOLD)\n\n\tprivate set: Set<T> | null = null\n\n\t/**\n\t * Get whether this ArraySet has any elements.\n\t *\n\t * @returns True if this ArraySet has any elements, false otherwise.\n\t */\n\t// eslint-disable-next-line no-restricted-syntax\n\tget isEmpty() {\n\t\tif (this.array) {\n\t\t\treturn this.arraySize === 0\n\t\t}\n\n\t\tif (this.set) {\n\t\t\treturn this.set.size === 0\n\t\t}\n\n\t\tthrow new Error('no set or array')\n\t}\n\n\t/**\n\t * Add an item to the ArraySet if it is not already present.\n\t *\n\t * @param elem - The element to add.\n\t */\n\n\tadd(elem: T) {\n\t\tif (this.array) {\n\t\t\tconst idx = this.array.indexOf(elem)\n\n\t\t\t// Return false if the element is already in the array.\n\t\t\tif (idx !== -1) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tif (this.arraySize < ARRAY_SIZE_THRESHOLD) {\n\t\t\t\t// If the array is below the size threshold, push items into the array.\n\n\t\t\t\t// Insert the element into the array's next available slot.\n\t\t\t\tthis.array[this.arraySize] = elem\n\t\t\t\tthis.arraySize++\n\n\t\t\t\treturn true\n\t\t\t} else {\n\t\t\t\t// If the array is full, convert it to a set and remove the array.\n\t\t\t\tthis.set = new Set(this.array as any)\n\t\t\t\tthis.array = null\n\t\t\t\tthis.set.add(elem)\n\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\n\t\tif (this.set) {\n\t\t\t// Return false if the element is already in the set.\n\t\t\tif (this.set.has(elem)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tthis.set.add(elem)\n\t\t\treturn true\n\t\t}\n\n\t\tthrow new Error('no set or array')\n\t}\n\n\t/**\n\t * Remove an item from the ArraySet if it is present.\n\t *\n\t * @param elem - The element to remove\n\t */\n\tremove(elem: T) {\n\t\tif (this.array) {\n\t\t\tconst idx = this.array.indexOf(elem)\n\n\t\t\t// If the item is not in the array, return false.\n\t\t\tif (idx === -1) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tthis.array[idx] = undefined\n\t\t\tthis.arraySize--\n\n\t\t\tif (idx !== this.arraySize) {\n\t\t\t\t// If the item is not the last item in the array, move the last item into the\n\t\t\t\t// removed item's slot.\n\t\t\t\tthis.array[idx] = this.array[this.arraySize]\n\t\t\t\tthis.array[this.arraySize] = undefined\n\t\t\t}\n\n\t\t\treturn true\n\t\t}\n\n\t\tif (this.set) {\n\t\t\t// If the item is not in the set, return false.\n\t\t\tif (!this.set.has(elem)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tthis.set.delete(elem)\n\n\t\t\treturn true\n\t\t}\n\n\t\tthrow new Error('no set or array')\n\t}\n\n\t/**\n\t * Run a callback for each element in the ArraySet.\n\t *\n\t * @param visitor - The callback to run for each element.\n\t */\n\tvisit(visitor: (item: T) => void) {\n\t\tif (this.array) {\n\t\t\tfor (let i = 0; i < this.arraySize; i++) {\n\t\t\t\tconst elem = this.array[i]\n\n\t\t\t\tif (typeof elem !== 'undefined') {\n\t\t\t\t\tvisitor(elem)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn\n\t\t}\n\n\t\tif (this.set) {\n\t\t\tthis.set.forEach(visitor)\n\n\t\t\treturn\n\t\t}\n\n\t\tthrow new Error('no set or array')\n\t}\n\n\t*[Symbol.iterator]() {\n\t\tif (this.array) {\n\t\t\tfor (let i = 0; i < this.arraySize; i++) {\n\t\t\t\tconst elem = this.array[i]\n\n\t\t\t\tif (typeof elem !== 'undefined') {\n\t\t\t\t\tyield elem\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.set) {\n\t\t\tyield* this.set\n\t\t} else {\n\t\t\tthrow new Error('no set or array')\n\t\t}\n\t}\n\n\thas(elem: T) {\n\t\tif (this.array) {\n\t\t\treturn this.array.indexOf(elem) !== -1\n\t\t} else {\n\t\t\treturn this.set!.has(elem)\n\t\t}\n\t}\n\n\tclear() {\n\t\tif (this.set) {\n\t\t\tthis.set.clear()\n\t\t} else {\n\t\t\tthis.arraySize = 0\n\t\t\tthis.array = []\n\t\t}\n\t}\n\n\tsize() {\n\t\tif (this.set) {\n\t\t\treturn this.set.size\n\t\t} else {\n\t\t\treturn this.arraySize\n\t\t}\n\t}\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2660, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/state/src/lib/types.ts"],"sourcesContent":["import { ArraySet } from './ArraySet'\n\n/** @public */\nexport const RESET_VALUE: unique symbol = Symbol.for('com.tldraw.state/RESET_VALUE')\n\n/** @public */\nexport type RESET_VALUE = typeof RESET_VALUE\n\n/**\n * A Signal is a reactive value container. The value may change over time, and it may keep track of the diffs between sequential values.\n *\n * There are two types of signal:\n *\n * - Atomic signals, created using {@link atom}. These are mutable references to values that can be changed using {@link Atom.set}.\n * - Computed signals, created using `computed`. These are values that are computed from other signals. They are recomputed lazily if their dependencies change.\n *\n * @public\n */\nexport interface Signal<Value, Diff = unknown> {\n\t/**\n\t * The name of the signal. This is used at runtime for debugging and perf profiling only. It does not need to be globally unique.\n\t */\n\tname: string\n\t/**\n\t * The current value of the signal. This is a reactive value, and will update when the signal changes.\n\t * Any computed signal that depends on this signal will be lazily recomputed if this signal changes.\n\t * Any effect that depends on this signal will be rescheduled if this signal changes.\n\t */\n\tget(): Value\n\n\t/**\n\t * The epoch when this signal's value last changed. Note that this is not the same as when the value was last computed.\n\t * A signal may recompute it's value without changing it.\n\t */\n\tlastChangedEpoch: number\n\t/**\n\t * Returns the sequence of diffs between the the value at the given epoch and the current value.\n\t * Returns the `RESET_VALUE` constant if there is not enough information to compute the diff sequence.\n\t * @param epoch - The epoch to get diffs since.\n\t */\n\tgetDiffSince(epoch: number): RESET_VALUE | Diff[]\n\t/**\n\t * Returns the current value of the signal without capturing it as a dependency.\n\t * Use this if you need to retrieve the signal's value in a hot loop where the performance overhead of dependency tracking is too high.\n\t */\n\t__unsafe__getWithoutCapture(ignoreErrors?: boolean): Value\n\t/** @internal */\n\tchildren: ArraySet<Child>\n}\n\n/** @internal */\nexport interface Child {\n\tlastTraversedEpoch: number\n\treadonly parentSet: ArraySet<Signal<any, any>>\n\treadonly parents: Signal<any, any>[]\n\treadonly parentEpochs: number[]\n\treadonly name: string\n\tisActivelyListening: boolean\n\t__debug_ancestor_epochs__: Map<Signal<any, any>, number> | null\n}\n\n/**\n * Computes the diff between the previous and current value.\n *\n * If the diff cannot be computed for whatever reason, it should return {@link state#RESET_VALUE}.\n *\n * @public\n */\nexport type ComputeDiff<Value, Diff> = (\n\tpreviousValue: Value,\n\tcurrentValue: Value,\n\tlastComputedEpoch: number,\n\tcurrentEpoch: number\n) => Diff | RESET_VALUE\n"],"names":[],"mappings":";;;AAGO,MAAM,cAA6B,OAAO,GAAA,CAAI,8BAA8B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2672, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/state/src/lib/HistoryBuffer.ts"],"sourcesContent":["import { RESET_VALUE } from './types'\n\ntype RangeTuple<Diff> = [fromEpoch: number, toEpoch: number, diff: Diff]\n\n/**\n * A structure that stores diffs between values of an atom.\n *\n * @internal\n */\nexport class HistoryBuffer<Diff> {\n\tprivate index = 0\n\n\t// use a wrap around buffer to store the last N values\n\tbuffer: Array<RangeTuple<Diff> | undefined>\n\n\tconstructor(private readonly capacity: number) {\n\t\tthis.buffer = new Array(capacity)\n\t}\n\n\t/**\n\t * Add a diff to the history buffer.\n\t *\n\t * @param lastComputedEpoch - The epoch when the diff was computed.\n\t * @param currentEpoch - The current epoch.\n\t * @param diff - The diff to add, or else a reset value.\n\t */\n\tpushEntry(lastComputedEpoch: number, currentEpoch: number, diff: Diff | RESET_VALUE) {\n\t\tif (diff === undefined) {\n\t\t\treturn\n\t\t}\n\n\t\tif (diff === RESET_VALUE) {\n\t\t\tthis.clear()\n\t\t\treturn\n\t\t}\n\n\t\t// Add the diff to the buffer as a range tuple.\n\t\tthis.buffer[this.index] = [lastComputedEpoch, currentEpoch, diff]\n\n\t\t// Bump the index, wrapping around if necessary.\n\t\tthis.index = (this.index + 1) % this.capacity\n\t}\n\n\t/**\n\t * Clear the history buffer.\n\t */\n\tclear() {\n\t\tthis.index = 0\n\t\tthis.buffer.fill(undefined)\n\t}\n\n\t/**\n\t * Get the diffs since the given epoch.\n\t *\n\t * @param sinceEpoch - The epoch to get diffs since.\n\t * @returns An array of diffs or a flag to reset the history buffer.\n\t */\n\tgetChangesSince(sinceEpoch: number): RESET_VALUE | Diff[] {\n\t\tconst { index, capacity, buffer } = this\n\n\t\t// For each item in the buffer...\n\t\tfor (let i = 0; i < capacity; i++) {\n\t\t\tconst offset = (index - 1 + capacity - i) % capacity\n\n\t\t\tconst elem = buffer[offset]\n\n\t\t\t// If there's no element in the offset position, return the reset value\n\t\t\tif (!elem) {\n\t\t\t\treturn RESET_VALUE\n\t\t\t}\n\n\t\t\tconst [fromEpoch, toEpoch] = elem\n\n\t\t\t// If the first element is already too early, bail\n\t\t\tif (i === 0 && sinceEpoch >= toEpoch) {\n\t\t\t\treturn []\n\t\t\t}\n\n\t\t\t// If the element is since the given epoch, return an array with all diffs from this element and all following elements\n\t\t\tif (fromEpoch <= sinceEpoch && sinceEpoch < toEpoch) {\n\t\t\t\tconst len = i + 1\n\t\t\t\tconst result = new Array(len)\n\n\t\t\t\tfor (let j = 0; j < len; j++) {\n\t\t\t\t\tresult[j] = buffer[(offset + j) % capacity]![2]\n\t\t\t\t}\n\n\t\t\t\treturn result\n\t\t\t}\n\t\t}\n\n\t\t// If we haven't returned yet, return the reset value\n\t\treturn RESET_VALUE\n\t}\n}\n"],"names":[],"mappings":";;;AAAA,SAAS,mBAAmB;;AASrB,MAAM,cAAoB;IAMhC,YAA6B,QAAA,CAAkB;QAAlB,IAAA,CAAA,QAAA,GAAA;QAC5B,IAAA,CAAK,MAAA,GAAS,IAAI,MAAM,QAAQ;IACjC;IAPQ,QAAQ,EAAA;IAAA,sDAAA;IAGhB,OAAA;IAAA;;;;;;GAAA,GAaA,UAAU,iBAAA,EAA2B,YAAA,EAAsB,IAAA,EAA0B;QACpF,IAAI,SAAS,KAAA,GAAW;YACvB;QACD;QAEA,IAAI,2KAAS,cAAA,EAAa;YACzB,IAAA,CAAK,KAAA,CAAM;YACX;QACD;QAGA,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,KAAK,CAAA,GAAI;YAAC;YAAmB;YAAc,IAAI;SAAA;QAGhE,IAAA,CAAK,KAAA,GAAA,CAAS,IAAA,CAAK,KAAA,GAAQ,CAAA,IAAK,IAAA,CAAK,QAAA;IACtC;IAAA;;GAAA,GAKA,QAAQ;QACP,IAAA,CAAK,KAAA,GAAQ;QACb,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,KAAA,CAAS;IAC3B;IAAA;;;;;GAAA,GAQA,gBAAgB,UAAA,EAA0C;QACzD,MAAM,EAAE,KAAA,EAAO,QAAA,EAAU,MAAA,CAAO,CAAA,GAAI,IAAA;QAGpC,IAAA,IAAS,IAAI,GAAG,IAAI,UAAU,IAAK;YAClC,MAAM,SAAA,CAAU,QAAQ,IAAI,WAAW,CAAA,IAAK;YAE5C,MAAM,OAAO,MAAA,CAAO,MAAM,CAAA;YAG1B,IAAI,CAAC,MAAM;gBACV,yKAAO,cAAA;YACR;YAEA,MAAM,CAAC,WAAW,OAAO,CAAA,GAAI;YAG7B,IAAI,MAAM,KAAK,cAAc,SAAS;gBACrC,OAAO,CAAC,CAAA;YACT;YAGA,IAAI,aAAa,cAAc,aAAa,SAAS;gBACpD,MAAM,MAAM,IAAI;gBAChB,MAAM,SAAS,IAAI,MAAM,GAAG;gBAE5B,IAAA,IAAS,IAAI,GAAG,IAAI,KAAK,IAAK;oBAC7B,MAAA,CAAO,CAAC,CAAA,GAAI,MAAA,CAAA,CAAQ,SAAS,CAAA,IAAK,QAAQ,CAAA,CAAG,CAAC,CAAA;gBAC/C;gBAEA,OAAO;YACR;QACD;QAGA,yKAAO,cAAA;IACR;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2749, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/state/src/lib/constants.ts"],"sourcesContent":["// Derivations start on GLOBAL_START_EPOCH so they are dirty before having been computed\nexport const GLOBAL_START_EPOCH = -1\n"],"names":[],"mappings":";;;AACO,MAAM,qBAAqB,CAAA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2761, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/state/src/lib/EffectScheduler.ts"],"sourcesContent":["import { ArraySet } from './ArraySet'\nimport { startCapturingParents, stopCapturingParents } from './capture'\nimport { GLOBAL_START_EPOCH } from './constants'\nimport { attach, detach, haveParentsChanged, singleton } from './helpers'\nimport { getGlobalEpoch } from './transactions'\nimport { Signal } from './types'\n\n/** @public */\nexport interface EffectSchedulerOptions {\n\t/**\n\t * scheduleEffect is a function that will be called when the effect is scheduled.\n\t *\n\t * It can be used to defer running effects until a later time, for example to batch them together with requestAnimationFrame.\n\t *\n\t *\n\t * @example\n\t * ```ts\n\t * let isRafScheduled = false\n\t * const scheduledEffects: Array<() => void> = []\n\t * const scheduleEffect = (runEffect: () => void) => {\n\t * \tscheduledEffects.push(runEffect)\n\t * \tif (!isRafScheduled) {\n\t * \t\tisRafScheduled = true\n\t * \t\trequestAnimationFrame(() => {\n\t * \t\t\tisRafScheduled = false\n\t * \t\t\tscheduledEffects.forEach((runEffect) => runEffect())\n\t * \t\t\tscheduledEffects.length = 0\n\t * \t\t})\n\t * \t}\n\t * }\n\t * const stop = react('set page title', () => {\n\t * \tdocument.title = doc.title,\n\t * }, scheduleEffect)\n\t * ```\n\t *\n\t * @param execute - A function that will execute the effect.\n\t * @returns\n\t */\n\t// eslint-disable-next-line @typescript-eslint/method-signature-style\n\tscheduleEffect?: (execute: () => void) => void\n}\n\nclass __EffectScheduler__<Result> implements EffectScheduler<Result> {\n\tprivate _isActivelyListening = false\n\t/**\n\t * Whether this scheduler is attached and actively listening to its parents.\n\t * @public\n\t */\n\t// eslint-disable-next-line no-restricted-syntax\n\tget isActivelyListening() {\n\t\treturn this._isActivelyListening\n\t}\n\t/** @internal */\n\tlastTraversedEpoch = GLOBAL_START_EPOCH\n\n\tprivate lastReactedEpoch = GLOBAL_START_EPOCH\n\tprivate _scheduleCount = 0\n\t__debug_ancestor_epochs__: Map<Signal<any, any>, number> | null = null\n\n\t/**\n\t * The number of times this effect has been scheduled.\n\t * @public\n\t */\n\t// eslint-disable-next-line no-restricted-syntax\n\tget scheduleCount() {\n\t\treturn this._scheduleCount\n\t}\n\n\t/** @internal */\n\treadonly parentSet = new ArraySet<Signal<any, any>>()\n\t/** @internal */\n\treadonly parentEpochs: number[] = []\n\t/** @internal */\n\treadonly parents: Signal<any, any>[] = []\n\tprivate readonly _scheduleEffect?: (execute: () => void) => void\n\tconstructor(\n\t\tpublic readonly name: string,\n\t\tprivate readonly runEffect: (lastReactedEpoch: number) => Result,\n\t\toptions?: EffectSchedulerOptions\n\t) {\n\t\tthis._scheduleEffect = options?.scheduleEffect\n\t}\n\n\t/** @internal */\n\tmaybeScheduleEffect() {\n\t\t// bail out if we have been cancelled by another effect\n\t\tif (!this._isActivelyListening) return\n\t\t// bail out if no atoms have changed since the last time we ran this effect\n\t\tif (this.lastReactedEpoch === getGlobalEpoch()) return\n\n\t\t// bail out if we have parents and they have not changed since last time\n\t\tif (this.parents.length && !haveParentsChanged(this)) {\n\t\t\tthis.lastReactedEpoch = getGlobalEpoch()\n\t\t\treturn\n\t\t}\n\t\t// if we don't have parents it's probably the first time this is running.\n\t\tthis.scheduleEffect()\n\t}\n\n\t/** @internal */\n\tscheduleEffect() {\n\t\tthis._scheduleCount++\n\t\tif (this._scheduleEffect) {\n\t\t\t// if the effect should be deferred (e.g. until a react render), do so\n\t\t\tthis._scheduleEffect(this.maybeExecute)\n\t\t} else {\n\t\t\t// otherwise execute right now!\n\t\t\tthis.execute()\n\t\t}\n\t}\n\n\t/** @internal */\n\t// eslint-disable-next-line local/prefer-class-methods\n\treadonly maybeExecute = () => {\n\t\t// bail out if we have been detached before this runs\n\t\tif (!this._isActivelyListening) return\n\t\tthis.execute()\n\t}\n\n\t/**\n\t * Makes this scheduler become 'actively listening' to its parents.\n\t * If it has been executed before it will immediately become eligible to receive 'maybeScheduleEffect' calls.\n\t * If it has not executed before it will need to be manually executed once to become eligible for scheduling, i.e. by calling `EffectScheduler.execute`.\n\t * @public\n\t */\n\tattach() {\n\t\tthis._isActivelyListening = true\n\t\tfor (let i = 0, n = this.parents.length; i < n; i++) {\n\t\t\tattach(this.parents[i], this)\n\t\t}\n\t}\n\n\t/**\n\t * Makes this scheduler stop 'actively listening' to its parents.\n\t * It will no longer be eligible to receive 'maybeScheduleEffect' calls until `EffectScheduler.attach` is called again.\n\t */\n\tdetach() {\n\t\tthis._isActivelyListening = false\n\t\tfor (let i = 0, n = this.parents.length; i < n; i++) {\n\t\t\tdetach(this.parents[i], this)\n\t\t}\n\t}\n\n\t/**\n\t * Executes the effect immediately and returns the result.\n\t * @returns The result of the effect.\n\t */\n\texecute(): Result {\n\t\ttry {\n\t\t\tstartCapturingParents(this)\n\t\t\t// Important! We have to make a note of the current epoch before running the effect.\n\t\t\t// We allow atoms to be updated during effects, which increments the global epoch,\n\t\t\t// so if we were to wait until after the effect runs, the this.lastReactedEpoch value might get ahead of itself.\n\t\t\tconst currentEpoch = getGlobalEpoch()\n\t\t\tconst result = this.runEffect(this.lastReactedEpoch)\n\t\t\tthis.lastReactedEpoch = currentEpoch\n\t\t\treturn result\n\t\t} finally {\n\t\t\tstopCapturingParents()\n\t\t}\n\t}\n}\n\n/**\n * An EffectScheduler is responsible for executing side effects in response to changes in state.\n *\n * You probably don't need to use this directly unless you're integrating this library with a framework of some kind.\n *\n * Instead, use the {@link react} and {@link reactor} functions.\n *\n * @example\n * ```ts\n * const render = new EffectScheduler('render', drawToCanvas)\n *\n * render.attach()\n * render.execute()\n * ```\n *\n * @public\n */\nexport const EffectScheduler = singleton(\n\t'EffectScheduler',\n\t(): {\n\t\tnew <Result>(\n\t\t\tname: string,\n\t\t\trunEffect: (lastReactedEpoch: number) => Result,\n\t\t\toptions?: EffectSchedulerOptions\n\t\t): EffectScheduler<Result>\n\t} => __EffectScheduler__\n)\n/** @public */\nexport interface EffectScheduler<Result> {\n\t/** @internal */\n\t/**\n\t * Whether this scheduler is attached and actively listening to its parents.\n\t * @public\n\t */\n\treadonly isActivelyListening: boolean\n\n\t/** @internal */\n\treadonly lastTraversedEpoch: number\n\n\t/** @public */\n\treadonly name: string\n\n\t/** @internal */\n\t__debug_ancestor_epochs__: Map<Signal<any, any>, number> | null\n\n\t/**\n\t * The number of times this effect has been scheduled.\n\t * @public\n\t */\n\treadonly scheduleCount: number\n\n\t/** @internal */\n\treadonly parentSet: ArraySet<Signal<any, any>>\n\n\t/** @internal */\n\treadonly parentEpochs: number[]\n\n\t/** @internal */\n\treadonly parents: Signal<any, any>[]\n\n\t/** @internal */\n\tmaybeScheduleEffect(): void\n\n\t/** @internal */\n\tscheduleEffect(): void\n\n\t/** @internal */\n\tmaybeExecute(): void\n\n\t/**\n\t * Makes this scheduler become 'actively listening' to its parents.\n\t * If it has been executed before it will immediately become eligible to receive 'maybeScheduleEffect' calls.\n\t * If it has not executed before it will need to be manually executed once to become eligible for scheduling, i.e. by calling `EffectScheduler.execute`.\n\t * @public\n\t */\n\tattach(): void\n\n\t/**\n\t * Makes this scheduler stop 'actively listening' to its parents.\n\t * It will no longer be eligible to receive 'maybeScheduleEffect' calls until `EffectScheduler.attach` is called again.\n\t */\n\tdetach(): void\n\n\t/**\n\t * Executes the effect immediately and returns the result.\n\t * @returns The result of the effect.\n\t */\n\texecute(): Result\n}\n\n/**\n * Starts a new effect scheduler, scheduling the effect immediately.\n *\n * Returns a function that can be called to stop the scheduler.\n *\n * @example\n * ```ts\n * const color = atom('color', 'red')\n * const stop = react('set style', () => {\n *   divElem.style.color = color.get()\n * })\n * color.set('blue')\n * // divElem.style.color === 'blue'\n * stop()\n * color.set('green')\n * // divElem.style.color === 'blue'\n * ```\n *\n *\n * Also useful in React applications for running effects outside of the render cycle.\n *\n * @example\n * ```ts\n * useEffect(() => react('set style', () => {\n *   divRef.current.style.color = color.get()\n * }), [])\n * ```\n *\n * @public\n */\nexport function react(\n\tname: string,\n\tfn: (lastReactedEpoch: number) => any,\n\toptions?: EffectSchedulerOptions\n) {\n\tconst scheduler = new EffectScheduler(name, fn, options)\n\tscheduler.attach()\n\tscheduler.scheduleEffect()\n\treturn () => {\n\t\tscheduler.detach()\n\t}\n}\n\n/**\n * The reactor is a user-friendly interface for starting and stopping an `EffectScheduler`.\n *\n * Calling `.start()` will attach the scheduler and execute the effect immediately the first time it is called.\n *\n * If the reactor is stopped, calling `.start()` will re-attach the scheduler but will only execute the effect if any of its parents have changed since it was stopped.\n *\n * You can create a reactor with {@link reactor}.\n * @public\n */\nexport interface Reactor<T = unknown> {\n\t/**\n\t * The underlying effect scheduler.\n\t * @public\n\t */\n\tscheduler: EffectScheduler<T>\n\t/**\n\t * Start the scheduler. The first time this is called the effect will be scheduled immediately.\n\t *\n\t * If the reactor is stopped, calling this will start the scheduler again but will only execute the effect if any of its parents have changed since it was stopped.\n\t *\n\t * If you need to force re-execution of the effect, pass `{ force: true }`.\n\t * @public\n\t */\n\tstart(options?: { force?: boolean }): void\n\t/**\n\t * Stop the scheduler.\n\t * @public\n\t */\n\tstop(): void\n}\n\n/**\n * Creates a {@link Reactor}, which is a thin wrapper around an `EffectScheduler`.\n *\n * @public\n */\nexport function reactor<Result>(\n\tname: string,\n\tfn: (lastReactedEpoch: number) => Result,\n\toptions?: EffectSchedulerOptions\n): Reactor<Result> {\n\tconst scheduler = new EffectScheduler<Result>(name, fn, options)\n\treturn {\n\t\tscheduler,\n\t\tstart: (options?: { force?: boolean }) => {\n\t\t\tconst force = options?.force ?? false\n\t\t\tscheduler.attach()\n\t\t\tif (force) {\n\t\t\t\tscheduler.scheduleEffect()\n\t\t\t} else {\n\t\t\t\tscheduler.maybeScheduleEffect()\n\t\t\t}\n\t\t},\n\t\tstop: () => {\n\t\t\tscheduler.detach()\n\t\t},\n\t}\n}\n"],"names":["options"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2897, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/state/src/lib/transactions.ts"],"sourcesContent":["import { _Atom } from './Atom'\nimport { EffectScheduler } from './EffectScheduler'\nimport { GLOBAL_START_EPOCH } from './constants'\nimport { singleton } from './helpers'\nimport { Child, Signal } from './types'\n\nclass Transaction {\n\tasyncProcessCount = 0\n\tconstructor(\n\t\tpublic readonly parent: Transaction | null,\n\t\tpublic readonly isSync: boolean\n\t) {}\n\n\tinitialAtomValues = new Map<_Atom, any>()\n\n\t/**\n\t * Get whether this transaction is a root (no parents).\n\t *\n\t * @public\n\t */\n\t// eslint-disable-next-line no-restricted-syntax\n\tget isRoot() {\n\t\treturn this.parent === null\n\t}\n\n\t/**\n\t * Commit the transaction's changes.\n\t *\n\t * @public\n\t */\n\tcommit() {\n\t\tif (inst.globalIsReacting) {\n\t\t\t// if we're committing during a reaction we actually need to\n\t\t\t// use the 'cleanup' reactors set to ensure we re-run effects if necessary\n\t\t\tfor (const atom of this.initialAtomValues.keys()) {\n\t\t\t\ttraverseAtomForCleanup(atom)\n\t\t\t}\n\t\t} else if (this.isRoot) {\n\t\t\t// For root transactions, flush changed atoms\n\t\t\tflushChanges(this.initialAtomValues.keys())\n\t\t} else {\n\t\t\t// For transactions with parents, add the transaction's initial values to the parent's.\n\t\t\tthis.initialAtomValues.forEach((value, atom) => {\n\t\t\t\tif (!this.parent!.initialAtomValues.has(atom)) {\n\t\t\t\t\tthis.parent!.initialAtomValues.set(atom, value)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\t/**\n\t * Abort the transaction.\n\t *\n\t * @public\n\t */\n\tabort() {\n\t\tinst.globalEpoch++\n\n\t\t// Reset each of the transaction's atoms to its initial value.\n\t\tthis.initialAtomValues.forEach((value, atom) => {\n\t\t\tatom.set(value)\n\t\t\tatom.historyBuffer?.clear()\n\t\t})\n\n\t\t// Commit the changes.\n\t\tthis.commit()\n\t}\n}\n\nconst inst = singleton('transactions', () => ({\n\t// The current epoch (global to all atoms).\n\tglobalEpoch: GLOBAL_START_EPOCH + 1,\n\t// Whether any transaction is reacting.\n\tglobalIsReacting: false,\n\tcurrentTransaction: null as Transaction | null,\n\n\tcleanupReactors: null as null | Set<EffectScheduler<unknown>>,\n\treactionEpoch: GLOBAL_START_EPOCH + 1,\n}))\n\nexport function getReactionEpoch() {\n\treturn inst.reactionEpoch\n}\n\nexport function getGlobalEpoch() {\n\treturn inst.globalEpoch\n}\n\nexport function getIsReacting() {\n\treturn inst.globalIsReacting\n}\n\nfunction traverse(reactors: Set<EffectScheduler<unknown>>, child: Child) {\n\tif (child.lastTraversedEpoch === inst.globalEpoch) {\n\t\treturn\n\t}\n\n\tchild.lastTraversedEpoch = inst.globalEpoch\n\n\tif (child instanceof EffectScheduler) {\n\t\treactors.add(child)\n\t} else {\n\t\t;(child as any as Signal<any>).children.visit((c) => traverse(reactors, c))\n\t}\n}\n\n/**\n * Collect all of the reactors that need to run for an atom and run them.\n *\n * @param atoms - The atoms to flush changes for.\n */\nfunction flushChanges(atoms: Iterable<_Atom>) {\n\tif (inst.globalIsReacting) {\n\t\tthrow new Error('flushChanges cannot be called during a reaction')\n\t}\n\n\tconst outerTxn = inst.currentTransaction\n\ttry {\n\t\t// clear the transaction stack\n\t\tinst.currentTransaction = null\n\t\tinst.globalIsReacting = true\n\t\tinst.reactionEpoch = inst.globalEpoch\n\n\t\t// Collect all of the visited reactors.\n\t\tconst reactors = new Set<EffectScheduler<unknown>>()\n\n\t\tfor (const atom of atoms) {\n\t\t\tatom.children.visit((child) => traverse(reactors, child))\n\t\t}\n\n\t\t// Run each reactor.\n\t\tfor (const r of reactors) {\n\t\t\tr.maybeScheduleEffect()\n\t\t}\n\n\t\tlet updateDepth = 0\n\t\twhile (inst.cleanupReactors?.size) {\n\t\t\tif (updateDepth++ > 1000) {\n\t\t\t\tthrow new Error('Reaction update depth limit exceeded')\n\t\t\t}\n\t\t\tconst reactors = inst.cleanupReactors\n\t\t\tinst.cleanupReactors = null\n\t\t\tfor (const r of reactors) {\n\t\t\t\tr.maybeScheduleEffect()\n\t\t\t}\n\t\t}\n\t} finally {\n\t\tinst.cleanupReactors = null\n\t\tinst.globalIsReacting = false\n\t\tinst.currentTransaction = outerTxn\n\t}\n}\n\n/**\n * Handle a change to an atom.\n *\n * @param atom The atom that changed.\n * @param previousValue The atom's previous value.\n *\n * @internal\n */\nexport function atomDidChange(atom: _Atom, previousValue: any) {\n\tif (inst.currentTransaction) {\n\t\t// If we are in a transaction, then all we have to do is preserve\n\t\t// the value of the atom at the start of the transaction in case\n\t\t// we need to roll back.\n\t\tif (!inst.currentTransaction.initialAtomValues.has(atom)) {\n\t\t\tinst.currentTransaction.initialAtomValues.set(atom, previousValue)\n\t\t}\n\t} else if (inst.globalIsReacting) {\n\t\t// If the atom changed during the reaction phase of flushChanges\n\t\t// (and there are no transactions started inside the reaction phase)\n\t\t// then we are past the point where a transaction can be aborted\n\t\t// so we don't need to note down the previousValue.\n\t\ttraverseAtomForCleanup(atom)\n\t} else {\n\t\t// If there is no transaction, flush the changes immediately.\n\t\tflushChanges([atom])\n\t}\n}\n\nfunction traverseAtomForCleanup(atom: _Atom) {\n\tconst rs = (inst.cleanupReactors ??= new Set())\n\tatom.children.visit((child) => traverse(rs, child))\n}\n\nexport function advanceGlobalEpoch() {\n\tinst.globalEpoch++\n}\n\n/**\n * Batches state updates, deferring side effects until after the transaction completes.\n *\n * @example\n * ```ts\n * const firstName = atom('John')\n * const lastName = atom('Doe')\n *\n * react('greet', () => {\n *   print(`Hello, ${firstName.get()} ${lastName.get()}!`)\n * })\n *\n * // Logs \"Hello, John Doe!\"\n *\n * transaction(() => {\n *  firstName.set('Jane')\n *  lastName.set('Smith')\n * })\n *\n * // Logs \"Hello, Jane Smith!\"\n * ```\n *\n * If the function throws, the transaction is aborted and any signals that were updated during the transaction revert to their state before the transaction began.\n *\n * @example\n * ```ts\n * const firstName = atom('John')\n * const lastName = atom('Doe')\n *\n * react('greet', () => {\n *   print(`Hello, ${firstName.get()} ${lastName.get()}!`)\n * })\n *\n * // Logs \"Hello, John Doe!\"\n *\n * transaction(() => {\n *  firstName.set('Jane')\n *  throw new Error('oops')\n * })\n *\n * // Does not log\n * // firstName.get() === 'John'\n * ```\n *\n * A `rollback` callback is passed into the function.\n * Calling this will prevent the transaction from committing and will revert any signals that were updated during the transaction to their state before the transaction began.\n *\n * @example\n * ```ts\n * const firstName = atom('John')\n * const lastName = atom('Doe')\n *\n * react('greet', () => {\n *   print(`Hello, ${firstName.get()} ${lastName.get()}!`)\n * })\n *\n * // Logs \"Hello, John Doe!\"\n *\n * transaction((rollback) => {\n *  firstName.set('Jane')\n *  lastName.set('Smith')\n *  rollback()\n * })\n *\n * // Does not log\n * // firstName.get() === 'John'\n * // lastName.get() === 'Doe'\n * ```\n *\n * @param fn - The function to run in a transaction, called with a function to roll back the change.\n * @public\n */\nexport function transaction<T>(fn: (rollback: () => void) => T) {\n\tconst txn = new Transaction(inst.currentTransaction, true)\n\n\t// Set the current transaction to the transaction\n\tinst.currentTransaction = txn\n\n\ttry {\n\t\tlet result = undefined as T | undefined\n\t\tlet rollback = false\n\n\t\ttry {\n\t\t\t// Run the function.\n\t\t\tresult = fn(() => (rollback = true))\n\t\t} catch (e) {\n\t\t\t// Abort the transaction if the function throws.\n\t\t\ttxn.abort()\n\t\t\tthrow e\n\t\t}\n\n\t\tif (inst.currentTransaction !== txn) {\n\t\t\tthrow new Error('Transaction boundaries overlap')\n\t\t}\n\n\t\tif (rollback) {\n\t\t\t// If the rollback was triggered, abort the transaction.\n\t\t\ttxn.abort()\n\t\t} else {\n\t\t\ttxn.commit()\n\t\t}\n\n\t\treturn result\n\t} finally {\n\t\t// Set the current transaction to the transaction's parent.\n\t\tinst.currentTransaction = txn.parent\n\t}\n}\n\n/**\n * Like {@link transaction}, but does not create a new transaction if there is already one in progress.\n *\n * @param fn - The function to run in a transaction.\n * @public\n */\nexport function transact<T>(fn: () => T): T {\n\tif (inst.currentTransaction) {\n\t\treturn fn()\n\t}\n\treturn transaction(fn)\n}\n\n/**\n * @internal\n */\nexport async function deferAsyncEffects<T>(fn: () => Promise<T>) {\n\t// Can't kick off async transactions during a sync transaction because\n\t// the async transaction won't finish until after the sync transaction\n\t// is done.\n\tif (inst.currentTransaction?.isSync) {\n\t\tthrow new Error('deferAsyncEffects cannot be called during a sync transaction')\n\t}\n\n\t// Can't kick off async transactions during a reaction phase at the moment,\n\t// because the transaction stack is cleared after the reaction phase.\n\t// So wait until the path ahead is clear\n\twhile (inst.globalIsReacting) {\n\t\tawait new Promise((r) => queueMicrotask(() => r(null)))\n\t}\n\n\tconst txn = inst.currentTransaction ?? new Transaction(null, false)\n\n\t// don't think this can happen, but just in case\n\tif (txn.isSync) throw new Error('deferAsyncEffects cannot be called during a sync transaction')\n\n\tinst.currentTransaction = txn\n\ttxn.asyncProcessCount++\n\n\tlet result = undefined as T | undefined\n\n\tlet error = undefined as any\n\ttry {\n\t\t// Run the function.\n\t\tresult = await fn()\n\t} catch (e) {\n\t\t// Abort the transaction if the function throws.\n\t\terror = e ?? null\n\t}\n\n\tif (--txn.asyncProcessCount > 0) {\n\t\tif (typeof error !== 'undefined') {\n\t\t\t// If the rollback was triggered, abort the transaction.\n\t\t\tthrow error\n\t\t} else {\n\t\t\treturn result\n\t\t}\n\t}\n\n\tinst.currentTransaction = null\n\n\tif (typeof error !== 'undefined') {\n\t\t// If the rollback was triggered, abort the transaction.\n\t\ttxn.abort()\n\t\tthrow error\n\t} else {\n\t\ttxn.commit()\n\t\treturn result\n\t}\n}\n"],"names":["reactors"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3116, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/state/src/lib/warnings.ts"],"sourcesContent":["let didWarnComputedGetter = false\n\nexport function logComputedGetterWarning() {\n\tif (didWarnComputedGetter) return\n\tdidWarnComputedGetter = true\n\tconsole.warn(\n\t\t`Using \\`@computed\\` as a decorator for getters is deprecated and will be removed in the near future. Please refactor to use \\`@computed\\` as a decorator for methods.\n\n// Before\n@computed\nget foo() {\n\treturn 'foo'\n}\n\n// After\n@computed\ngetFoo() {\n\treturn 'foo'\n}\n`\n\t)\n}\n"],"names":[],"mappings":";;;AAAA,IAAI,wBAAwB;AAErB,SAAS,2BAA2B;IAC1C,IAAI,sBAAuB,CAAA;IAC3B,wBAAwB;IACxB,QAAQ,IAAA,CACP,CAAA;;;;;;;;;;;;;AAAA,CAAA;AAeF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3146, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/state/src/lib/Computed.ts"],"sourcesContent":["/* eslint-disable prefer-rest-params */\nimport { assert } from '@tldraw/utils'\nimport { ArraySet } from './ArraySet'\nimport { HistoryBuffer } from './HistoryBuffer'\nimport { maybeCaptureParent, startCapturingParents, stopCapturingParents } from './capture'\nimport { GLOBAL_START_EPOCH } from './constants'\nimport { EMPTY_ARRAY, equals, haveParentsChanged, singleton } from './helpers'\nimport { getGlobalEpoch, getIsReacting, getReactionEpoch } from './transactions'\nimport { Child, ComputeDiff, RESET_VALUE, Signal } from './types'\nimport { logComputedGetterWarning } from './warnings'\n\n/**\n * @public\n */\nexport const UNINITIALIZED = Symbol.for('com.tldraw.state/UNINITIALIZED')\n/**\n * The type of the first value passed to a computed signal function as the 'prevValue' parameter.\n *\n * @see {@link isUninitialized}.\n * @public\n */\nexport type UNINITIALIZED = typeof UNINITIALIZED\n\n/**\n * Call this inside a computed signal function to determine whether it is the first time the function is being called.\n *\n * Mainly useful for incremental signal computation.\n *\n * @example\n * ```ts\n * const count = atom('count', 0)\n * const double = computed('double', (prevValue) => {\n *   if (isUninitialized(prevValue)) {\n *     print('First time!')\n *   }\n *   return count.get() * 2\n * })\n * ```\n *\n * @param value - The value to check.\n * @public\n */\nexport function isUninitialized(value: any): value is UNINITIALIZED {\n\treturn value === UNINITIALIZED\n}\n\n/** @public */\nexport const WithDiff = singleton(\n\t'WithDiff',\n\t() =>\n\t\tclass WithDiff<Value, Diff> {\n\t\t\tconstructor(\n\t\t\t\tpublic value: Value,\n\t\t\t\tpublic diff: Diff\n\t\t\t) {}\n\t\t}\n)\n\n/** @public */\nexport interface WithDiff<Value, Diff> {\n\tvalue: Value\n\tdiff: Diff\n}\n\n/**\n * When writing incrementally-computed signals it is convenient (and usually more performant) to incrementally compute the diff too.\n *\n * You can use this function to wrap the return value of a computed signal function to indicate that the diff should be used instead of calculating a new one with {@link AtomOptions.computeDiff}.\n *\n * @example\n * ```ts\n * const count = atom('count', 0)\n * const double = computed('double', (prevValue) => {\n *   const nextValue = count.get() * 2\n *   if (isUninitialized(prevValue)) {\n *     return nextValue\n *   }\n *   return withDiff(nextValue, nextValue - prevValue)\n * }, { historyLength: 10 })\n * ```\n *\n *\n * @param value - The value.\n * @param diff - The diff.\n * @public\n */\nexport function withDiff<Value, Diff>(value: Value, diff: Diff): WithDiff<Value, Diff> {\n\treturn new WithDiff(value, diff)\n}\n\n/**\n * Options for creating computed signals. Used when calling `computed`.\n * @public\n */\nexport interface ComputedOptions<Value, Diff> {\n\t/**\n\t * The maximum number of diffs to keep in the history buffer.\n\t *\n\t * If you don't need to compute diffs, or if you will supply diffs manually via {@link Atom.set}, you can leave this as `undefined` and no history buffer will be created.\n\t *\n\t * If you expect the value to be part of an active effect subscription all the time, and to not change multiple times inside of a single transaction, you can set this to a relatively low number (e.g. 10).\n\t *\n\t * Otherwise, set this to a higher number based on your usage pattern and memory constraints.\n\t *\n\t */\n\thistoryLength?: number\n\t/**\n\t * A method used to compute a diff between the atom's old and new values. If provided, it will not be used unless you also specify {@link AtomOptions.historyLength}.\n\t */\n\tcomputeDiff?: ComputeDiff<Value, Diff>\n\t/**\n\t * If provided, this will be used to compare the old and new values of the atom to determine if the value has changed.\n\t * By default, values are compared using first using strict equality (`===`), then `Object.is`, and finally any `.equals` method present in the object's prototype chain.\n\t * @param a - The old value\n\t * @param b - The new value\n\t * @returns\n\t */\n\tisEqual?(a: any, b: any): boolean\n}\n\n/**\n * A computed signal created via `computed`.\n *\n * @public\n */\nexport interface Computed<Value, Diff = unknown> extends Signal<Value, Diff> {\n\t/**\n\t * Whether this computed child is involved in an actively-running effect graph.\n\t * @public\n\t */\n\treadonly isActivelyListening: boolean\n\n\t/** @internal */\n\treadonly parentSet: ArraySet<Signal<any, any>>\n\t/** @internal */\n\treadonly parents: Signal<any, any>[]\n\t/** @internal */\n\treadonly parentEpochs: number[]\n}\n\n/**\n * @internal\n */\nclass __UNSAFE__Computed<Value, Diff = unknown> implements Computed<Value, Diff> {\n\tlastChangedEpoch = GLOBAL_START_EPOCH\n\tlastTraversedEpoch = GLOBAL_START_EPOCH\n\n\t__debug_ancestor_epochs__: Map<Signal<any, any>, number> | null = null\n\n\t/**\n\t * The epoch when the reactor was last checked.\n\t */\n\tprivate lastCheckedEpoch = GLOBAL_START_EPOCH\n\n\tparentSet = new ArraySet<Signal<any, any>>()\n\tparents: Signal<any, any>[] = []\n\tparentEpochs: number[] = []\n\n\tchildren = new ArraySet<Child>()\n\n\t// eslint-disable-next-line no-restricted-syntax\n\tget isActivelyListening(): boolean {\n\t\treturn !this.children.isEmpty\n\t}\n\n\thistoryBuffer?: HistoryBuffer<Diff>\n\n\t// The last-computed value of this signal.\n\tprivate state: Value = UNINITIALIZED as unknown as Value\n\t// If the signal throws an error we stash it so we can rethrow it on the next get()\n\tprivate error: null | { thrownValue: any } = null\n\n\tprivate computeDiff?: ComputeDiff<Value, Diff>\n\n\tprivate readonly isEqual: (a: any, b: any) => boolean\n\n\tconstructor(\n\t\t/**\n\t\t * The name of the signal. This is used for debugging and performance profiling purposes. It does not need to be globally unique.\n\t\t */\n\t\tpublic readonly name: string,\n\t\t/**\n\t\t * The function that computes the value of the signal.\n\t\t */\n\t\tprivate readonly derive: (\n\t\t\tpreviousValue: Value | UNINITIALIZED,\n\t\t\tlastComputedEpoch: number\n\t\t) => Value | WithDiff<Value, Diff>,\n\t\toptions?: ComputedOptions<Value, Diff>\n\t) {\n\t\tif (options?.historyLength) {\n\t\t\tthis.historyBuffer = new HistoryBuffer(options.historyLength)\n\t\t}\n\t\tthis.computeDiff = options?.computeDiff\n\t\tthis.isEqual = options?.isEqual ?? equals\n\t}\n\n\t__unsafe__getWithoutCapture(ignoreErrors?: boolean): Value {\n\t\tconst isNew = this.lastChangedEpoch === GLOBAL_START_EPOCH\n\n\t\tconst globalEpoch = getGlobalEpoch()\n\n\t\tif (\n\t\t\t!isNew &&\n\t\t\t(this.lastCheckedEpoch === globalEpoch ||\n\t\t\t\t(this.isActivelyListening &&\n\t\t\t\t\tgetIsReacting() &&\n\t\t\t\t\tthis.lastTraversedEpoch < getReactionEpoch()) ||\n\t\t\t\t!haveParentsChanged(this))\n\t\t) {\n\t\t\tthis.lastCheckedEpoch = globalEpoch\n\t\t\tif (this.error) {\n\t\t\t\tif (!ignoreErrors) {\n\t\t\t\t\tthrow this.error.thrownValue\n\t\t\t\t} else {\n\t\t\t\t\treturn this.state // will be UNINITIALIZED\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn this.state\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tstartCapturingParents(this)\n\t\t\tconst result = this.derive(this.state, this.lastCheckedEpoch)\n\t\t\tconst newState = result instanceof WithDiff ? result.value : result\n\t\t\tconst isUninitialized = this.state === UNINITIALIZED\n\t\t\tif (isUninitialized || !this.isEqual(newState, this.state)) {\n\t\t\t\tif (this.historyBuffer && !isUninitialized) {\n\t\t\t\t\tconst diff = result instanceof WithDiff ? result.diff : undefined\n\t\t\t\t\tthis.historyBuffer.pushEntry(\n\t\t\t\t\t\tthis.lastChangedEpoch,\n\t\t\t\t\t\tgetGlobalEpoch(),\n\t\t\t\t\t\tdiff ??\n\t\t\t\t\t\t\tthis.computeDiff?.(this.state, newState, this.lastCheckedEpoch, getGlobalEpoch()) ??\n\t\t\t\t\t\t\tRESET_VALUE\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\tthis.lastChangedEpoch = getGlobalEpoch()\n\t\t\t\tthis.state = newState\n\t\t\t}\n\t\t\tthis.error = null\n\t\t\tthis.lastCheckedEpoch = getGlobalEpoch()\n\n\t\t\treturn this.state\n\t\t} catch (e) {\n\t\t\t// if a derived value throws an error, we reset the state to UNINITIALIZED\n\t\t\tif (this.state !== UNINITIALIZED) {\n\t\t\t\tthis.state = UNINITIALIZED as unknown as Value\n\t\t\t\tthis.lastChangedEpoch = getGlobalEpoch()\n\t\t\t}\n\t\t\tthis.lastCheckedEpoch = getGlobalEpoch()\n\t\t\t// we also clear the history buffer if an error was thrown\n\t\t\tif (this.historyBuffer) {\n\t\t\t\tthis.historyBuffer.clear()\n\t\t\t}\n\t\t\tthis.error = { thrownValue: e }\n\t\t\t// we don't wish to propagate errors when derefed via haveParentsChanged()\n\t\t\tif (!ignoreErrors) throw e\n\t\t\treturn this.state\n\t\t} finally {\n\t\t\tstopCapturingParents()\n\t\t}\n\t}\n\n\tget(): Value {\n\t\ttry {\n\t\t\treturn this.__unsafe__getWithoutCapture()\n\t\t} finally {\n\t\t\t// if the deriver throws an error we still need to capture\n\t\t\tmaybeCaptureParent(this)\n\t\t}\n\t}\n\n\tgetDiffSince(epoch: number): RESET_VALUE | Diff[] {\n\t\t// we can ignore any errors thrown during derive\n\t\tthis.__unsafe__getWithoutCapture(true)\n\t\t// and we still need to capture this signal as a parent\n\t\tmaybeCaptureParent(this)\n\n\t\tif (epoch >= this.lastChangedEpoch) {\n\t\t\treturn EMPTY_ARRAY\n\t\t}\n\n\t\treturn this.historyBuffer?.getChangesSince(epoch) ?? RESET_VALUE\n\t}\n}\n\nexport const _Computed = singleton('Computed', () => __UNSAFE__Computed)\nexport type _Computed = InstanceType<typeof __UNSAFE__Computed>\n\nfunction computedMethodLegacyDecorator(\n\toptions: ComputedOptions<any, any> = {},\n\t_target: any,\n\tkey: string,\n\tdescriptor: PropertyDescriptor\n) {\n\tconst originalMethod = descriptor.value\n\tconst derivationKey = Symbol.for('__@tldraw/state__computed__' + key)\n\n\tdescriptor.value = function (this: any) {\n\t\tlet d = this[derivationKey] as Computed<any> | undefined\n\n\t\tif (!d) {\n\t\t\td = new _Computed(key, originalMethod!.bind(this) as any, options)\n\t\t\tObject.defineProperty(this, derivationKey, {\n\t\t\t\tenumerable: false,\n\t\t\t\tconfigurable: false,\n\t\t\t\twritable: false,\n\t\t\t\tvalue: d,\n\t\t\t})\n\t\t}\n\t\treturn d.get()\n\t}\n\tdescriptor.value[isComputedMethodKey] = true\n\n\treturn descriptor\n}\n\nfunction computedGetterLegacyDecorator(\n\toptions: ComputedOptions<any, any> = {},\n\t_target: any,\n\tkey: string,\n\tdescriptor: PropertyDescriptor\n) {\n\tconst originalMethod = descriptor.get\n\tconst derivationKey = Symbol.for('__@tldraw/state__computed__' + key)\n\n\tdescriptor.get = function (this: any) {\n\t\tlet d = this[derivationKey] as Computed<any> | undefined\n\n\t\tif (!d) {\n\t\t\td = new _Computed(key, originalMethod!.bind(this) as any, options)\n\t\t\tObject.defineProperty(this, derivationKey, {\n\t\t\t\tenumerable: false,\n\t\t\t\tconfigurable: false,\n\t\t\t\twritable: false,\n\t\t\t\tvalue: d,\n\t\t\t})\n\t\t}\n\t\treturn d.get()\n\t}\n\n\treturn descriptor\n}\n\nfunction computedMethodTc39Decorator<This extends object, Value>(\n\toptions: ComputedOptions<Value, any>,\n\tcompute: () => Value,\n\tcontext: ClassMethodDecoratorContext<This, () => Value>\n) {\n\tassert(context.kind === 'method', '@computed can only be used on methods')\n\tconst derivationKey = Symbol.for('__@tldraw/state__computed__' + String(context.name))\n\n\tconst fn = function (this: any) {\n\t\tlet d = this[derivationKey] as Computed<any> | undefined\n\n\t\tif (!d) {\n\t\t\td = new _Computed(String(context.name), compute.bind(this) as any, options)\n\t\t\tObject.defineProperty(this, derivationKey, {\n\t\t\t\tenumerable: false,\n\t\t\t\tconfigurable: false,\n\t\t\t\twritable: false,\n\t\t\t\tvalue: d,\n\t\t\t})\n\t\t}\n\t\treturn d.get()\n\t}\n\tfn[isComputedMethodKey] = true\n\treturn fn\n}\n\nfunction computedDecorator(\n\toptions: ComputedOptions<any, any> = {},\n\targs:\n\t\t| [target: any, key: string, descriptor: PropertyDescriptor]\n\t\t| [originalMethod: () => any, context: ClassMethodDecoratorContext]\n) {\n\tif (args.length === 2) {\n\t\tconst [originalMethod, context] = args\n\t\treturn computedMethodTc39Decorator(options, originalMethod, context)\n\t} else {\n\t\tconst [_target, key, descriptor] = args\n\t\tif (descriptor.get) {\n\t\t\tlogComputedGetterWarning()\n\t\t\treturn computedGetterLegacyDecorator(options, _target, key, descriptor)\n\t\t} else {\n\t\t\treturn computedMethodLegacyDecorator(options, _target, key, descriptor)\n\t\t}\n\t}\n}\n\nconst isComputedMethodKey = '@@__isComputedMethod__@@'\n\n/**\n * Retrieves the underlying computed instance for a given property created with the `computed`\n * decorator.\n *\n * @example\n * ```ts\n * class Counter {\n *   max = 100\n *   count = atom(0)\n *\n *   @computed getRemaining() {\n *     return this.max - this.count.get()\n *   }\n * }\n *\n * const c = new Counter()\n * const remaining = getComputedInstance(c, 'getRemaining')\n * remaining.get() === 100 // true\n * c.count.set(13)\n * remaining.get() === 87 // true\n * ```\n *\n * @param obj - The object\n * @param propertyName - The property name\n * @public\n */\nexport function getComputedInstance<Obj extends object, Prop extends keyof Obj>(\n\tobj: Obj,\n\tpropertyName: Prop\n): Computed<Obj[Prop]> {\n\tconst key = Symbol.for('__@tldraw/state__computed__' + propertyName.toString())\n\tlet inst = obj[key as keyof typeof obj] as Computed<Obj[Prop]> | undefined\n\tif (!inst) {\n\t\t// deref to make sure it exists first\n\t\tconst val = obj[propertyName]\n\t\tif (typeof val === 'function' && (val as any)[isComputedMethodKey]) {\n\t\t\tval.call(obj)\n\t\t}\n\n\t\tinst = obj[key as keyof typeof obj] as Computed<Obj[Prop]> | undefined\n\t}\n\treturn inst as any\n}\n\n/**\n * Creates a computed signal.\n *\n * @example\n * ```ts\n * const name = atom('name', 'John')\n * const greeting = computed('greeting', () => `Hello ${name.get()}!`)\n * console.log(greeting.get()) // 'Hello John!'\n * ```\n *\n * `computed` may also be used as a decorator for creating computed getter methods.\n *\n * @example\n * ```ts\n * class Counter {\n *   max = 100\n *   count = atom<number>(0)\n *\n *   @computed getRemaining() {\n *     return this.max - this.count.get()\n *   }\n * }\n * ```\n *\n * You may optionally pass in a {@link ComputedOptions} when used as a decorator:\n *\n * @example\n * ```ts\n * class Counter {\n *   max = 100\n *   count = atom<number>(0)\n *\n *   @computed({isEqual: (a, b) => a === b})\n *   getRemaining() {\n *     return this.max - this.count.get()\n *   }\n * }\n * ```\n *\n * @param name - The name of the signal.\n * @param compute - The function that computes the value of the signal.\n * @param options - Options for the signal.\n *\n * @public\n */\nexport function computed<Value, Diff = unknown>(\n\tname: string,\n\tcompute: (\n\t\tpreviousValue: Value | typeof UNINITIALIZED,\n\t\tlastComputedEpoch: number\n\t) => Value | WithDiff<Value, Diff>,\n\toptions?: ComputedOptions<Value, Diff>\n): Computed<Value, Diff>\n/**\n * `@computed` decorator (TC39 decorators).\n * @public\n */\nexport function computed<This extends object, Value>(\n\tcompute: () => Value,\n\tcontext: ClassMethodDecoratorContext<This, () => Value>\n): () => Value\n/**\n * `@computed` decorator (legacy typescript decorator syntax).\n *\n * @public */\nexport function computed(\n\ttarget: any,\n\tkey: string,\n\tdescriptor: PropertyDescriptor\n): PropertyDescriptor\n/**\n * `@computed` decorator with options.\n * @public\n */\nexport function computed<Value, Diff = unknown>(\n\toptions?: ComputedOptions<Value, Diff>\n): ((target: any, key: string, descriptor: PropertyDescriptor) => PropertyDescriptor) &\n\t(<This>(\n\t\tcompute: () => Value,\n\t\tcontext: ClassMethodDecoratorContext<This, () => Value>\n\t) => () => Value)\n\n/** @public */\nexport function computed() {\n\tif (arguments.length === 1) {\n\t\tconst options = arguments[0]\n\t\treturn (...args: any) => computedDecorator(options, args)\n\t} else if (typeof arguments[0] === 'string') {\n\t\treturn new _Computed(arguments[0], arguments[1], arguments[2])\n\t} else {\n\t\treturn computedDecorator(undefined, arguments as any)\n\t}\n}\n\n/**\n * Returns true if the given value is a computed signal.\n *\n * @param value\n * @returns {value is Computed<any>}\n * @public\n */\nexport function isComputed(value: any): value is Computed<any> {\n\treturn value && value instanceof _Computed\n}\n"],"names":["isUninitialized"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3389, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/state/src/lib/capture.ts"],"sourcesContent":["import { isComputed } from './Computed'\nimport { attach, detach, singleton } from './helpers'\nimport type { Child, Signal } from './types'\n\nclass CaptureStackFrame {\n\toffset = 0\n\n\tmaybeRemoved?: Signal<any>[]\n\n\tconstructor(\n\t\tpublic readonly below: CaptureStackFrame | null,\n\t\tpublic readonly child: Child\n\t) {}\n}\n\nconst inst = singleton('capture', () => ({ stack: null as null | CaptureStackFrame }))\n\n/**\n * Executes the given function without capturing any parents in the current capture context.\n *\n * This is mainly useful if you want to run an effect only when certain signals change while also\n * dereferencing other signals which should not cause the effect to rerun on their own.\n *\n * @example\n * ```ts\n * const name = atom('name', 'Sam')\n * const time = atom('time', () => new Date().getTime())\n *\n * setInterval(() => {\n *   time.set(new Date().getTime())\n * })\n *\n * react('log name changes', () => {\n * \t print(name.get(), 'was changed at', unsafe__withoutCapture(() => time.get()))\n * })\n *\n * ```\n *\n * @public\n */\nexport function unsafe__withoutCapture<T>(fn: () => T): T {\n\tconst oldStack = inst.stack\n\tinst.stack = null\n\ttry {\n\t\treturn fn()\n\t} finally {\n\t\tinst.stack = oldStack\n\t}\n}\n\nexport function startCapturingParents(child: Child) {\n\tinst.stack = new CaptureStackFrame(inst.stack, child)\n\tif (child.__debug_ancestor_epochs__) {\n\t\tconst previousAncestorEpochs = child.__debug_ancestor_epochs__\n\t\tchild.__debug_ancestor_epochs__ = null\n\t\tfor (const p of child.parents) {\n\t\t\tp.__unsafe__getWithoutCapture(true)\n\t\t}\n\t\tlogChangedAncestors(child, previousAncestorEpochs)\n\t}\n\tchild.parentSet.clear()\n}\n\nexport function stopCapturingParents() {\n\tconst frame = inst.stack!\n\tinst.stack = frame.below\n\n\tif (frame.offset < frame.child.parents.length) {\n\t\tfor (let i = frame.offset; i < frame.child.parents.length; i++) {\n\t\t\tconst maybeRemovedParent = frame.child.parents[i]\n\t\t\tif (!frame.child.parentSet.has(maybeRemovedParent)) {\n\t\t\t\tdetach(maybeRemovedParent, frame.child)\n\t\t\t}\n\t\t}\n\n\t\tframe.child.parents.length = frame.offset\n\t\tframe.child.parentEpochs.length = frame.offset\n\t}\n\n\tif (frame.maybeRemoved) {\n\t\tfor (let i = 0; i < frame.maybeRemoved.length; i++) {\n\t\t\tconst maybeRemovedParent = frame.maybeRemoved[i]\n\t\t\tif (!frame.child.parentSet.has(maybeRemovedParent)) {\n\t\t\t\tdetach(maybeRemovedParent, frame.child)\n\t\t\t}\n\t\t}\n\t}\n\n\tif (frame.child.__debug_ancestor_epochs__) {\n\t\tcaptureAncestorEpochs(frame.child, frame.child.__debug_ancestor_epochs__)\n\t}\n}\n\n// this must be called after the parent is up to date\nexport function maybeCaptureParent(p: Signal<any, any>) {\n\tif (inst.stack) {\n\t\tconst wasCapturedAlready = inst.stack.child.parentSet.has(p)\n\t\t// if the child didn't deref this parent last time it executed, then idx will be -1\n\t\t// if the child did deref this parent last time but in a different order relative to other parents, then idx will be greater than stack.offset\n\t\t// if the child did deref this parent last time in the same order, then idx will be the same as stack.offset\n\t\t// if the child did deref this parent already during this capture session then 0 <= idx < stack.offset\n\n\t\tif (wasCapturedAlready) {\n\t\t\treturn\n\t\t}\n\n\t\tinst.stack.child.parentSet.add(p)\n\t\tif (inst.stack.child.isActivelyListening) {\n\t\t\tattach(p, inst.stack.child)\n\t\t}\n\n\t\tif (inst.stack.offset < inst.stack.child.parents.length) {\n\t\t\tconst maybeRemovedParent = inst.stack.child.parents[inst.stack.offset]\n\t\t\tif (maybeRemovedParent !== p) {\n\t\t\t\tif (!inst.stack.maybeRemoved) {\n\t\t\t\t\tinst.stack.maybeRemoved = [maybeRemovedParent]\n\t\t\t\t} else {\n\t\t\t\t\tinst.stack.maybeRemoved.push(maybeRemovedParent)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tinst.stack.child.parents[inst.stack.offset] = p\n\t\tinst.stack.child.parentEpochs[inst.stack.offset] = p.lastChangedEpoch\n\t\tinst.stack.offset++\n\t}\n}\n\n/**\n * A debugging tool that tells you why a computed signal or effect is running.\n * Call in the body of a computed signal or effect function.\n *\n * @example\n * ```ts\n * const name = atom('name', 'Bob')\n * react('greeting', () => {\n * \twhyAmIRunning()\n *\tprint('Hello', name.get())\n * })\n *\n * name.set('Alice')\n *\n * // 'greeting' is running because:\n * //     'name' changed => 'Alice'\n * ```\n *\n * @public\n */\nexport function whyAmIRunning() {\n\tconst child = inst.stack?.child\n\tif (!child) {\n\t\tthrow new Error('whyAmIRunning() called outside of a reactive context')\n\t}\n\tchild.__debug_ancestor_epochs__ = new Map()\n}\n\nfunction captureAncestorEpochs(child: Child, ancestorEpochs: Map<Signal<any>, number>) {\n\tfor (let i = 0; i < child.parents.length; i++) {\n\t\tconst parent = child.parents[i]\n\t\tconst epoch = child.parentEpochs[i]\n\t\tancestorEpochs.set(parent, epoch)\n\t\tif (isComputed(parent)) {\n\t\t\tcaptureAncestorEpochs(parent as any, ancestorEpochs)\n\t\t}\n\t}\n\treturn ancestorEpochs\n}\n\ntype ChangeTree = { [signalName: string]: ChangeTree } | null\nfunction collectChangedAncestors(\n\tchild: Child,\n\tancestorEpochs: Map<Signal<any>, number>\n): NonNullable<ChangeTree> {\n\tconst changeTree: ChangeTree = {}\n\tfor (let i = 0; i < child.parents.length; i++) {\n\t\tconst parent = child.parents[i]\n\t\tif (!ancestorEpochs.has(parent)) {\n\t\t\tcontinue\n\t\t}\n\t\tconst prevEpoch = ancestorEpochs.get(parent)\n\t\tconst currentEpoch = parent.lastChangedEpoch\n\t\tif (currentEpoch !== prevEpoch) {\n\t\t\tif (isComputed(parent)) {\n\t\t\t\tchangeTree[parent.name] = collectChangedAncestors(parent as any, ancestorEpochs)\n\t\t\t} else {\n\t\t\t\tchangeTree[parent.name] = null\n\t\t\t}\n\t\t}\n\t}\n\treturn changeTree\n}\n\nfunction logChangedAncestors(child: Child, ancestorEpochs: Map<Signal<any>, number>) {\n\tconst changeTree = collectChangedAncestors(child, ancestorEpochs)\n\tif (Object.keys(changeTree).length === 0) {\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.log(`Effect(${child.name}) was executed manually.`)\n\t\treturn\n\t}\n\n\tlet str = isComputed(child)\n\t\t? `Computed(${child.name}) is recomputing because:`\n\t\t: `Effect(${child.name}) is executing because:`\n\n\tfunction logParent(tree: NonNullable<ChangeTree>, indent: number) {\n\t\tconst indentStr = '\\n' + ' '.repeat(indent) + '↳ '\n\t\tfor (const [name, val] of Object.entries(tree)) {\n\t\t\tif (val) {\n\t\t\t\tstr += `${indentStr}Computed(${name}) changed`\n\t\t\t\tlogParent(val, indent + 2)\n\t\t\t} else {\n\t\t\t\tstr += `${indentStr}Atom(${name}) changed`\n\t\t\t}\n\t\t}\n\t}\n\n\tlogParent(changeTree, 1)\n\n\t// eslint-disable-next-line no-console\n\tconsole.log(str)\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3550, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/state/src/lib/Atom.ts"],"sourcesContent":["import { ArraySet } from './ArraySet'\nimport { HistoryBuffer } from './HistoryBuffer'\nimport { maybeCaptureParent } from './capture'\nimport { EMPTY_ARRAY, equals, singleton } from './helpers'\nimport { advanceGlobalEpoch, atomDidChange, getGlobalEpoch } from './transactions'\nimport { Child, ComputeDiff, RESET_VALUE, Signal } from './types'\n\n/**\n * The options to configure an atom, passed into the {@link atom} function.\n * @public\n */\nexport interface AtomOptions<Value, Diff> {\n\t/**\n\t * The maximum number of diffs to keep in the history buffer.\n\t *\n\t * If you don't need to compute diffs, or if you will supply diffs manually via {@link Atom.set}, you can leave this as `undefined` and no history buffer will be created.\n\t *\n\t * If you expect the value to be part of an active effect subscription all the time, and to not change multiple times inside of a single transaction, you can set this to a relatively low number (e.g. 10).\n\t *\n\t * Otherwise, set this to a higher number based on your usage pattern and memory constraints.\n\t *\n\t */\n\thistoryLength?: number\n\t/**\n\t * A method used to compute a diff between the atom's old and new values. If provided, it will not be used unless you also specify {@link AtomOptions.historyLength}.\n\t */\n\tcomputeDiff?: ComputeDiff<Value, Diff>\n\t/**\n\t * If provided, this will be used to compare the old and new values of the atom to determine if the value has changed.\n\t * By default, values are compared using first using strict equality (`===`), then `Object.is`, and finally any `.equals` method present in the object's prototype chain.\n\t * @param a - The old value\n\t * @param b - The new value\n\t * @returns\n\t */\n\tisEqual?(a: any, b: any): boolean\n}\n\n/**\n * An Atom is a signal that can be updated directly by calling {@link Atom.set} or {@link Atom.update}.\n *\n * Atoms are created using the {@link atom} function.\n *\n * @example\n * ```ts\n * const name = atom('name', 'John')\n *\n * print(name.get()) // 'John'\n * ```\n *\n * @public\n */\nexport interface Atom<Value, Diff = unknown> extends Signal<Value, Diff> {\n\t/**\n\t * Sets the value of this atom to the given value. If the value is the same as the current value, this is a no-op.\n\t *\n\t * @param value - The new value to set.\n\t * @param diff - The diff to use for the update. If not provided, the diff will be computed using {@link AtomOptions.computeDiff}.\n\t */\n\tset(value: Value, diff?: Diff): Value\n\t/**\n\t * Updates the value of this atom using the given updater function. If the returned value is the same as the current value, this is a no-op.\n\t *\n\t * @param updater - A function that takes the current value and returns the new value.\n\t */\n\tupdate(updater: (value: Value) => Value): Value\n}\n\n/**\n * @internal\n */\nclass __Atom__<Value, Diff = unknown> implements Atom<Value, Diff> {\n\tconstructor(\n\t\tpublic readonly name: string,\n\t\tprivate current: Value,\n\t\toptions?: AtomOptions<Value, Diff>\n\t) {\n\t\tthis.isEqual = options?.isEqual ?? null\n\n\t\tif (!options) return\n\n\t\tif (options.historyLength) {\n\t\t\tthis.historyBuffer = new HistoryBuffer(options.historyLength)\n\t\t}\n\n\t\tthis.computeDiff = options.computeDiff\n\t}\n\n\treadonly isEqual: null | ((a: any, b: any) => boolean)\n\n\tcomputeDiff?: ComputeDiff<Value, Diff>\n\n\tlastChangedEpoch = getGlobalEpoch()\n\n\tchildren = new ArraySet<Child>()\n\n\thistoryBuffer?: HistoryBuffer<Diff>\n\n\t__unsafe__getWithoutCapture(_ignoreErrors?: boolean): Value {\n\t\treturn this.current\n\t}\n\n\tget() {\n\t\tmaybeCaptureParent(this)\n\t\treturn this.current\n\t}\n\n\tset(value: Value, diff?: Diff): Value {\n\t\t// If the value has not changed, do nothing.\n\t\tif (this.isEqual?.(this.current, value) ?? equals(this.current, value)) {\n\t\t\treturn this.current\n\t\t}\n\n\t\t// Tick forward the global epoch\n\t\tadvanceGlobalEpoch()\n\n\t\t// Add the diff to the history buffer.\n\t\tif (this.historyBuffer) {\n\t\t\tthis.historyBuffer.pushEntry(\n\t\t\t\tthis.lastChangedEpoch,\n\t\t\t\tgetGlobalEpoch(),\n\t\t\t\tdiff ??\n\t\t\t\t\tthis.computeDiff?.(this.current, value, this.lastChangedEpoch, getGlobalEpoch()) ??\n\t\t\t\t\tRESET_VALUE\n\t\t\t)\n\t\t}\n\n\t\t// Update the atom's record of the epoch when last changed.\n\t\tthis.lastChangedEpoch = getGlobalEpoch()\n\n\t\tconst oldValue = this.current\n\t\tthis.current = value\n\n\t\t// Notify all children that this atom has changed.\n\t\tatomDidChange(this as any, oldValue)\n\n\t\treturn value\n\t}\n\n\tupdate(updater: (value: Value) => Value): Value {\n\t\treturn this.set(updater(this.current))\n\t}\n\n\tgetDiffSince(epoch: number): RESET_VALUE | Diff[] {\n\t\tmaybeCaptureParent(this)\n\n\t\t// If no changes have occurred since the given epoch, return an empty array.\n\t\tif (epoch >= this.lastChangedEpoch) {\n\t\t\treturn EMPTY_ARRAY\n\t\t}\n\n\t\treturn this.historyBuffer?.getChangesSince(epoch) ?? RESET_VALUE\n\t}\n}\n\nexport const _Atom = singleton('Atom', () => __Atom__)\nexport type _Atom = InstanceType<typeof _Atom>\n\n/**\n * Creates a new {@link Atom}.\n *\n * An Atom is a signal that can be updated directly by calling {@link Atom.set} or {@link Atom.update}.\n *\n * @example\n * ```ts\n * const name = atom('name', 'John')\n *\n * name.get() // 'John'\n *\n * name.set('Jane')\n *\n * name.get() // 'Jane'\n * ```\n *\n * @public\n */\nexport function atom<Value, Diff = unknown>(\n\t/**\n\t * A name for the signal. This is used for debugging and profiling purposes, it does not need to be unique.\n\t */\n\tname: string,\n\t/**\n\t * The initial value of the signal.\n\t */\n\tinitialValue: Value,\n\t/**\n\t * The options to configure the atom. See {@link AtomOptions}.\n\t */\n\toptions?: AtomOptions<Value, Diff>\n): Atom<Value, Diff> {\n\treturn new _Atom(name, initialValue, options)\n}\n\n/**\n * Returns true if the given value is an {@link Atom}.\n * @public\n */\nexport function isAtom(value: unknown): value is Atom<unknown> {\n\treturn value instanceof _Atom\n}\n"],"names":[],"mappings":";;;;;AAAA,SAAS,gBAAgB;AACzB,SAAS,qBAAqB;AAC9B,SAAS,0BAA0B;AACnC,SAAS,aAAa,QAAQ,iBAAiB;AAC/C,SAAS,oBAAoB,eAAe,sBAAsB;AAClE,SAA6B,mBAA2B;;;;;;;AAiExD,MAAM,SAA6D;IAClE,YACiB,IAAA,EACR,OAAA,EACR,OAAA,CACC;QAHe,IAAA,CAAA,IAAA,GAAA;QACR,IAAA,CAAA,OAAA,GAAA;QAGR,IAAA,CAAK,OAAA,GAAU,SAAS,WAAW;QAEnC,IAAI,CAAC,QAAS,CAAA;QAEd,IAAI,QAAQ,aAAA,EAAe;YAC1B,IAAA,CAAK,aAAA,GAAgB,8KAAI,gBAAA,CAAc,QAAQ,aAAa;QAC7D;QAEA,IAAA,CAAK,WAAA,GAAc,QAAQ,WAAA;IAC5B;IAES,QAAA;IAET,YAAA;IAEA,gMAAmB,iBAAA,CAAe,GAAA;IAElC,WAAW,wKAAI,YAAA,CAAgB,EAAA;IAE/B,cAAA;IAEA,4BAA4B,aAAA,EAAgC;QAC3D,OAAO,IAAA,CAAK,OAAA;IACb;IAEA,MAAM;QACL,CAAA,GAAA,mKAAA,CAAA,qBAAA,EAAmB,IAAI;QACvB,OAAO,IAAA,CAAK,OAAA;IACb;IAEA,IAAI,KAAA,EAAc,IAAA,EAAoB;QAErC,IAAI,IAAA,CAAK,OAAA,GAAU,IAAA,CAAK,OAAA,EAAS,KAAK,6KAAK,SAAA,EAAO,IAAA,CAAK,OAAA,EAAS,KAAK,GAAG;YACvE,OAAO,IAAA,CAAK,OAAA;QACb;QAGA,CAAA,GAAA,wKAAA,CAAA,qBAAA,CAAmB;QAGnB,IAAI,IAAA,CAAK,aAAA,EAAe;YACvB,IAAA,CAAK,aAAA,CAAc,SAAA,CAClB,IAAA,CAAK,gBAAA,+KACL,iBAAA,CAAe,IACf,QACC,IAAA,CAAK,WAAA,GAAc,IAAA,CAAK,OAAA,EAAS,OAAO,IAAA,CAAK,gBAAA,+KAAkB,iBAAA,CAAe,CAAC,wKAC/E,cAAA;QAEH;QAGA,IAAA,CAAK,gBAAA,OAAmB,0LAAA,CAAe;QAEvC,MAAM,WAAW,IAAA,CAAK,OAAA;QACtB,IAAA,CAAK,OAAA,GAAU;QAGf,CAAA,GAAA,wKAAA,CAAA,gBAAA,EAAc,IAAA,EAAa,QAAQ;QAEnC,OAAO;IACR;IAEA,OAAO,OAAA,EAAyC;QAC/C,OAAO,IAAA,CAAK,GAAA,CAAI,QAAQ,IAAA,CAAK,OAAO,CAAC;IACtC;IAEA,aAAa,KAAA,EAAqC;QACjD,CAAA,GAAA,mKAAA,CAAA,qBAAA,EAAmB,IAAI;QAGvB,IAAI,SAAS,IAAA,CAAK,gBAAA,EAAkB;YACnC,2KAAO,cAAA;QACR;QAEA,OAAO,IAAA,CAAK,aAAA,EAAe,gBAAgB,KAAK,uKAAK,cAAA;IACtD;AACD;AAEO,MAAM,SAAQ,mLAAA,EAAU,QAAQ,IAAM,QAAQ;AAqB9C,SAAS,KAIf,IAAA,EAIA,YAAA,EAIA,OAAA,EACoB;IACpB,OAAO,IAAI,MAAM,MAAM,cAAc,OAAO;AAC7C;AAMO,SAAS,OAAO,KAAA,EAAwC;IAC9D,OAAO,iBAAiB;AACzB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3630, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/state/src/lib/isSignal.ts"],"sourcesContent":["import { _Atom } from './Atom'\nimport { _Computed } from './Computed'\nimport { Signal } from './types'\n\n/**\n * @public\n */\nexport function isSignal(value: any): value is Signal<any> {\n\treturn value instanceof _Atom || value instanceof _Computed\n}\n"],"names":[],"mappings":";;;AAAA,SAAS,aAAa;AACtB,SAAS,iBAAiB;;;AAMnB,SAAS,SAAS,KAAA,EAAkC;IAC1D,OAAO,kLAAiB,QAAA,IAAS,sLAAiB,YAAA;AACnD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3648, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/state/src/index.ts"],"sourcesContent":["import { registerTldrawLibraryVersion } from '@tldraw/utils'\nimport { singleton } from './lib/helpers'\n\nexport { ArraySet } from './lib/ArraySet'\nexport { atom, isAtom } from './lib/Atom'\nexport type { Atom, AtomOptions } from './lib/Atom'\nexport { unsafe__withoutCapture, whyAmIRunning } from './lib/capture'\nexport {\n\tcomputed,\n\tgetComputedInstance,\n\tisUninitialized,\n\tUNINITIALIZED,\n\twithDiff,\n} from './lib/Computed'\nexport type { Computed, ComputedOptions, WithDiff } from './lib/Computed'\nexport { EffectScheduler, react, reactor } from './lib/EffectScheduler'\nexport type { EffectSchedulerOptions, Reactor } from './lib/EffectScheduler'\nexport { EMPTY_ARRAY } from './lib/helpers'\nexport { isSignal } from './lib/isSignal'\nexport { deferAsyncEffects, transact, transaction } from './lib/transactions'\nexport { RESET_VALUE } from './lib/types'\nexport type { Child, ComputeDiff, Signal } from './lib/types'\n\n// This should be incremented any time an API change is made. i.e. for additions or removals.\n// Bugfixes need not increment this.\nconst currentApiVersion = 1\n\nconst actualApiVersion = singleton('apiVersion', () => currentApiVersion)\n\nif (actualApiVersion !== currentApiVersion) {\n\tthrow new Error(\n\t\t`You have multiple incompatible versions of @tldraw/state in your app. Please deduplicate the package.`\n\t)\n}\n\nregisterTldrawLibraryVersion(\n\t(globalThis as any).TLDRAW_LIBRARY_NAME,\n\t(globalThis as any).TLDRAW_LIBRARY_VERSION,\n\t(globalThis as any).TLDRAW_LIBRARY_MODULES\n)\n"],"names":[],"mappings":";AAAA,SAAS,oCAAoC;;AAC7C,SAAS,iBAAiB;AAE1B,SAAS,gBAAgB;AACzB,SAAS,MAAM,cAAc;AAE7B,SAAS,wBAAwB,qBAAqB;AACtD;AAQA,SAAS,iBAAiB,OAAO,eAAe;AAGhD,SAAS,gBAAgB;AACzB,SAAS,mBAAmB,UAAU,mBAAmB;AACzD,SAAS,mBAAmB;;;;;;;;;;;;AAK5B,MAAM,oBAAoB;AAE1B,MAAM,2LAAmB,YAAA,EAAU,cAAc,IAAM,iBAAiB;AAExE,IAAI,qBAAqB,mBAAmB;IAC3C,MAAM,IAAI,MACT,CAAA,qGAAA,CAAA;AAEF;wKAEA,+BAAA,EACE,iBACA,UACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3703, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/state-react/src/lib/useStateTracking.ts"],"sourcesContent":["import { EffectScheduler } from '@tldraw/state'\nimport React from 'react'\n\n/**\n * Wraps some synchronous react render logic in a reactive tracking context.\n *\n * This allows you to use reactive values transparently.\n *\n * See the `track` component wrapper, which uses this under the hood.\n *\n * @example\n * ```ts\n * function MyComponent() {\n *   return useStateTracking('MyComponent', () => {\n *     const editor = useEditor()\n *     return <div>Num shapes: {editor.getCurrentPageShapes().length}</div>\n *   })\n * }\n * ```\n *\n *\n * @public\n */\nexport function useStateTracking<T>(name: string, render: () => T, deps: unknown[] = []): T {\n\t// This hook creates an effect scheduler that will trigger re-renders when its reactive dependencies change, but it\n\t// defers the actual execution of the effect to the consumer of this hook.\n\n\t// We need the exec fn to always be up-to-date when calling scheduler.execute() but it'd be wasteful to\n\t// instantiate a new EffectScheduler on every render, so we use an immediately-updated ref\n\t// to wrap it\n\tconst renderRef = React.useRef(render)\n\trenderRef.current = render\n\n\tconst [scheduler, subscribe, getSnapshot] = React.useMemo(() => {\n\t\tlet scheduleUpdate = null as null | (() => void)\n\t\t// useSyncExternalStore requires a subscribe function that returns an unsubscribe function\n\t\tconst subscribe = (cb: () => void) => {\n\t\t\tscheduleUpdate = cb\n\t\t\treturn () => {\n\t\t\t\tscheduleUpdate = null\n\t\t\t}\n\t\t}\n\n\t\tconst scheduler = new EffectScheduler(\n\t\t\t`useStateTracking(${name})`,\n\t\t\t// this is what `scheduler.execute()` will call\n\t\t\t() => renderRef.current?.(),\n\t\t\t// this is what will be invoked when @tldraw/state detects a change in an upstream reactive value\n\t\t\t{\n\t\t\t\tscheduleEffect() {\n\t\t\t\t\tscheduleUpdate?.()\n\t\t\t\t},\n\t\t\t}\n\t\t)\n\n\t\t// we use an incrementing number based on when this\n\t\tconst getSnapshot = () => scheduler.scheduleCount\n\n\t\treturn [scheduler, subscribe, getSnapshot]\n\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t}, [name, ...deps])\n\n\tReact.useSyncExternalStore(subscribe, getSnapshot, getSnapshot)\n\n\t// reactive dependencies are captured when `scheduler.execute()` is called\n\t// and then to make it reactive we wait for a `useEffect` to 'attach'\n\t// this allows us to avoid rendering outside of React's render phase\n\t// and avoid 'zombie' components that try to render with bad/deleted data before\n\t// react has a chance to umount them.\n\tReact.useEffect(() => {\n\t\tscheduler.attach()\n\t\t// do not execute, we only do that in render\n\t\tscheduler.maybeScheduleEffect()\n\t\treturn () => {\n\t\t\tscheduler.detach()\n\t\t}\n\t}, [scheduler])\n\n\treturn scheduler.execute()\n}\n"],"names":["subscribe","scheduler","getSnapshot"],"mappings":";;;;AAAA,SAAS,uBAAuB;AAChC,OAAO,WAAW;;;AAsBX,SAAS,iBAAoB,IAAA,EAAc,MAAA,EAAiB,OAAkB,CAAC,CAAA,EAAM;IAO3F,MAAM,kNAAY,UAAA,CAAM,MAAA,CAAO,MAAM;IACrC,UAAU,OAAA,GAAU;IAEpB,MAAM,CAAC,WAAW,WAAW,WAAW,CAAA,yMAAI,UAAA,CAAM,OAAA,CAAQ,MAAM;QAC/D,IAAI,iBAAiB;QAErB,MAAMA,aAAY,CAAC,OAAmB;YACrC,iBAAiB;YACjB,OAAO,MAAM;gBACZ,iBAAiB;YAClB;QACD;QAEA,MAAMC,aAAY,gLAAI,kBAAA,CACrB,CAAA,iBAAA,EAAoB,IAAI,CAAA,CAAA,CAAA,EAAA,+CAAA;QAExB,IAAM,UAAU,OAAA,GAAU,GAAA,iGAAA;QAE1B;YACC,iBAAiB;gBAChB,iBAAiB;YAClB;QACD;QAID,MAAMC,eAAc,IAAMD,WAAU,aAAA;QAEpC,OAAO;YAACA;YAAWD;YAAWE,YAAW;SAAA;IAE1C,GAAG;QAAC,MAAM;WAAG,IAAI;KAAC;IAElB,qMAAA,CAAA,UAAA,CAAM,oBAAA,CAAqB,WAAW,aAAa,WAAW;IAO9D,qMAAA,CAAA,UAAA,CAAM,SAAA,CAAU,MAAM;QACrB,UAAU,MAAA,CAAO;QAEjB,UAAU,mBAAA,CAAoB;QAC9B,OAAO,MAAM;YACZ,UAAU,MAAA,CAAO;QAClB;IACD,GAAG;QAAC,SAAS;KAAC;IAEd,OAAO,UAAU,OAAA,CAAQ;AAC1B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3759, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/state-react/src/lib/track.ts"],"sourcesContent":["import React, { forwardRef, FunctionComponent, memo } from 'react'\nimport { useStateTracking } from './useStateTracking'\n\nexport const ProxyHandlers = {\n\t/**\n\t * This is a function call trap for functional components. When this is called, we know it means\n\t * React did run 'Component()', that means we can use any hooks here to setup our effect and\n\t * store.\n\t *\n\t * With the native Proxy, all other calls such as access/setting to/of properties will be\n\t * forwarded to the target Component, so we don't need to copy the Component's own or inherited\n\t * properties.\n\t *\n\t * @see https://github.com/facebook/react/blob/2d80a0cd690bb5650b6c8a6c079a87b5dc42bd15/packages/react-reconciler/src/ReactFiberHooks.old.js#L460\n\t */\n\tapply(Component: FunctionComponent, thisArg: any, argumentsList: any) {\n\t\t// eslint-disable-next-line react-hooks/rules-of-hooks\n\t\treturn useStateTracking(Component.displayName ?? Component.name ?? 'tracked(???)', () =>\n\t\t\tComponent.apply(thisArg, argumentsList)\n\t\t)\n\t},\n}\n\nexport const ReactMemoSymbol = Symbol.for('react.memo')\nexport const ReactForwardRefSymbol = Symbol.for('react.forward_ref')\n\n/**\n * Returns a tracked version of the given component.\n * Any signals whose values are read while the component renders will be tracked.\n * If any of the tracked signals change later it will cause the component to re-render.\n *\n * This also wraps the component in a React.memo() call, so it will only re-render if the props change.\n *\n * @example\n * ```ts\n * const Counter = track(function Counter(props: CounterProps) {\n *   const count = useAtom('count', 0)\n *   const increment = useCallback(() => count.set(count.get() + 1), [count])\n *   return <button onClick={increment}>{count.get()}</button>\n * })\n * ```\n *\n * @param baseComponent - The base component to track.\n * @public\n */\nexport function track<T extends FunctionComponent<any>>(\n\tbaseComponent: T\n): React.NamedExoticComponent<React.ComponentProps<T>> {\n\tlet compare = null\n\tconst $$typeof = baseComponent['$$typeof' as keyof typeof baseComponent]\n\tif ($$typeof === ReactMemoSymbol) {\n\t\tbaseComponent = (baseComponent as any).type\n\t\tcompare = (baseComponent as any).compare\n\t}\n\tif ($$typeof === ReactForwardRefSymbol) {\n\t\treturn memo(forwardRef(new Proxy((baseComponent as any).render, ProxyHandlers) as any)) as any\n\t}\n\n\treturn memo(new Proxy(baseComponent, ProxyHandlers) as any, compare) as any\n}\n"],"names":[],"mappings":";;;;;;AAAA,SAAgB,YAA+B,YAAY;AAC3D,SAAS,wBAAwB;;;AAE1B,MAAM,gBAAgB;IAAA;;;;;;;;;;GAAA,GAY5B,OAAM,SAAA,EAA8B,OAAA,EAAc,aAAA,EAAoB;QAErE,iMAAO,mBAAA,EAAiB,UAAU,WAAA,IAAe,UAAU,IAAA,IAAQ,gBAAgB,IAClF,UAAU,KAAA,CAAM,SAAS,aAAa;IAExC;AACD;AAEO,MAAM,kBAAkB,OAAO,GAAA,CAAI,YAAY;AAC/C,MAAM,wBAAwB,OAAO,GAAA,CAAI,mBAAmB;AAqB5D,SAAS,MACf,aAAA,EACsD;IACtD,IAAI,UAAU;IACd,MAAM,WAAW,aAAA,CAAc,UAAwC,CAAA;IACvE,IAAI,aAAa,iBAAiB;QACjC,gBAAiB,cAAsB,IAAA;QACvC,UAAW,cAAsB,OAAA;IAClC;IACA,IAAI,aAAa,uBAAuB;QACvC,iNAAO,OAAA,4MAAK,aAAA,EAAW,IAAI,MAAO,cAAsB,MAAA,EAAQ,aAAa,CAAQ,CAAC;IACvF;IAEA,iNAAO,OAAA,EAAK,IAAI,MAAM,eAAe,aAAa,GAAU,OAAO;AACpE","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3806, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/state-react/src/lib/useAtom.ts"],"sourcesContent":["import { Atom, AtomOptions, atom } from '@tldraw/state'\nimport { useState } from 'react'\n\n/**\n * Creates a new atom and returns it. The atom will be created only once.\n *\n * See `atom`.\n *\n * @example\n * ```ts\n * const Counter = track(function Counter () {\n *   const count = useAtom('count', 0)\n *   const increment = useCallback(() => count.set(count.get() + 1), [count])\n *   return <button onClick={increment}>{count.get()}</button>\n * })\n * ```\n *\n * @param name - The name of the atom. This does not need to be globally unique. It is used for debugging and performance profiling.\n * @param valueOrInitialiser - The initial value of the atom. If this is a function, it will be called to get the initial value.\n * @param options - Options for the atom.\n *\n * @public\n */\nexport function useAtom<Value, Diff = unknown>(\n\tname: string,\n\tvalueOrInitialiser: Value | (() => Value),\n\toptions?: AtomOptions<Value, Diff>\n): Atom<Value, Diff> {\n\treturn useState(() => {\n\t\tconst initialValue =\n\t\t\ttypeof valueOrInitialiser === 'function' ? (valueOrInitialiser as any)() : valueOrInitialiser\n\n\t\treturn atom(`useAtom(${name})`, initialValue, options)\n\t})[0]\n}\n"],"names":[],"mappings":";;;AAAA,SAA4B,YAAY;;AACxC,SAAS,gBAAgB;;;AAsBlB,SAAS,QACf,IAAA,EACA,kBAAA,EACA,OAAA,EACoB;IACpB,iNAAO,WAAA,EAAS,MAAM;QACrB,MAAM,eACL,OAAO,uBAAuB,aAAc,mBAA2B,IAAI;QAE5E,4KAAO,OAAA,EAAK,CAAA,QAAA,EAAW,IAAI,CAAA,CAAA,CAAA,EAAK,cAAc,OAAO;IACtD,CAAC,CAAA,CAAE,CAAC,CAAA;AACL","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3828, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/state-react/src/lib/useComputed.ts"],"sourcesContent":["/* eslint-disable prefer-rest-params */\nimport { Computed, ComputedOptions, computed } from '@tldraw/state'\nimport { useMemo } from 'react'\n\n/** @public */\nexport function useComputed<Value>(name: string, compute: () => Value, deps: any[]): Computed<Value>\n\n/**\n * Creates a new computed signal and returns it. The computed signal will be created only once.\n *\n * @example\n * ```ts\n * type GreeterProps = {\n *   firstName: Signal<string>\n *   lastName: Signal<string>\n * }\n *\n * const Greeter = track(function Greeter ({firstName, lastName}: GreeterProps) {\n *   const fullName = useComputed('fullName', () => `${firstName.get()} ${lastName.get()}`)\n *   return <div>Hello {fullName.get()}!</div>\n * })\n * ```\n *\n * @public\n */\nexport function useComputed<Value, Diff = unknown>(\n\tname: string,\n\tcompute: () => Value,\n\topts: ComputedOptions<Value, Diff>,\n\tdeps: any[]\n): Computed<Value>\n/** @public */\nexport function useComputed() {\n\tconst name = arguments[0]\n\tconst compute = arguments[1]\n\tconst opts = arguments.length === 3 ? undefined : arguments[2]\n\tconst deps = arguments.length === 3 ? arguments[2] : arguments[3]\n\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\treturn useMemo(() => computed(`useComputed(${name})`, compute, opts), deps)\n}\n"],"names":[],"mappings":";;;AACA,SAAoC,gBAAgB;;AACpD,SAAS,eAAe;;;AA8BjB,SAAS,cAAc;IAC7B,MAAM,OAAO,SAAA,CAAU,CAAC,CAAA;IACxB,MAAM,UAAU,SAAA,CAAU,CAAC,CAAA;IAC3B,MAAM,OAAO,UAAU,MAAA,KAAW,IAAI,KAAA,IAAY,SAAA,CAAU,CAAC,CAAA;IAC7D,MAAM,OAAO,UAAU,MAAA,KAAW,IAAI,SAAA,CAAU,CAAC,CAAA,GAAI,SAAA,CAAU,CAAC,CAAA;IAEhE,iNAAO,UAAA,EAAQ,6KAAM,WAAA,EAAS,CAAA,YAAA,EAAe,IAAI,CAAA,CAAA,CAAA,EAAK,SAAS,IAAI,GAAG,IAAI;AAC3E","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3851, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/state-react/src/lib/useQuickReactor.ts"],"sourcesContent":["import { EMPTY_ARRAY, EffectScheduler } from '@tldraw/state'\nimport { useEffect } from 'react'\n\n/** @public */\nexport function useQuickReactor(name: string, reactFn: () => void, deps: any[] = EMPTY_ARRAY) {\n\tuseEffect(() => {\n\t\tconst scheduler = new EffectScheduler(name, reactFn)\n\t\tscheduler.attach()\n\t\tscheduler.execute()\n\t\treturn () => {\n\t\t\tscheduler.detach()\n\t\t}\n\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t}, deps)\n}\n"],"names":[],"mappings":";;;AAAA,SAAS,aAAa,uBAAuB;;;AAC7C,SAAS,iBAAiB;;;AAGnB,SAAS,gBAAgB,IAAA,EAAc,OAAA,EAAqB,2KAAc,cAAA,EAAa;IAC7F,CAAA,GAAA,qMAAA,CAAA,YAAA,EAAU,MAAM;QACf,MAAM,YAAY,gLAAI,kBAAA,CAAgB,MAAM,OAAO;QACnD,UAAU,MAAA,CAAO;QACjB,UAAU,OAAA,CAAQ;QAClB,OAAO,MAAM;YACZ,UAAU,MAAA,CAAO;QAClB;IAED,GAAG,IAAI;AACR","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3878, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/state-react/src/lib/useReactor.ts"],"sourcesContent":["import { EffectScheduler } from '@tldraw/state'\nimport { throttleToNextFrame } from '@tldraw/utils'\nimport { useEffect } from 'react'\n\n/** @public */\nexport function useReactor(name: string, reactFn: () => void, deps: undefined | any[] = []) {\n\tuseEffect(() => {\n\t\tlet cancelFn: () => void | undefined\n\t\tconst scheduler = new EffectScheduler(name, reactFn, {\n\t\t\tscheduleEffect: (cb) => {\n\t\t\t\tcancelFn = throttleToNextFrame(cb)\n\t\t\t},\n\t\t})\n\t\tscheduler.attach()\n\t\tscheduler.execute()\n\t\treturn () => {\n\t\t\tscheduler.detach()\n\t\t\tcancelFn?.()\n\t\t}\n\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t}, deps)\n}\n"],"names":[],"mappings":";;;AAAA,SAAS,uBAAuB;;;AAChC,SAAS,2BAA2B;AACpC,SAAS,iBAAiB;;;;AAGnB,SAAS,WAAW,IAAA,EAAc,OAAA,EAAqB,OAA0B,CAAC,CAAA,EAAG;IAC3F,CAAA,GAAA,qMAAA,CAAA,YAAA,EAAU,MAAM;QACf,IAAI;QACJ,MAAM,YAAY,gLAAI,kBAAA,CAAgB,MAAM,SAAS;YACpD,gBAAgB,CAAC,OAAO;gBACvB,oLAAW,sBAAA,EAAoB,EAAE;YAClC;QACD,CAAC;QACD,UAAU,MAAA,CAAO;QACjB,UAAU,OAAA,CAAQ;QAClB,OAAO,MAAM;YACZ,UAAU,MAAA,CAAO;YACjB,WAAW;QACZ;IAED,GAAG,IAAI;AACR","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3913, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/state-react/src/lib/useValue.ts"],"sourcesContent":["/* eslint-disable prefer-rest-params */\nimport { Signal, computed, react } from '@tldraw/state'\nimport { useMemo, useSyncExternalStore } from 'react'\n\n/** @public */\nexport function useValue<Value>(value: Signal<Value>): Value\n\n/**\n * Extracts the value from a signal and subscribes to it.\n *\n * Note that you do not need to use this hook if you are wrapping the component with {@link track}\n *\n * @example\n * ```ts\n * const Counter: React.FC = () => {\n *   const $count = useAtom('count', 0)\n *   const increment = useCallback(() => $count.set($count.get() + 1), [count])\n *   const currentCount = useValue($count)\n *   return <button onClick={increment}>{currentCount}</button>\n * }\n * ```\n *\n * You can also pass a function to compute the value and it will be memoized as in `useComputed`:\n *\n * @example\n * ```ts\n * type GreeterProps = {\n *   firstName: Signal<string>\n *   lastName: Signal<string>\n * }\n *\n * const Greeter = track(function Greeter({ firstName, lastName }: GreeterProps) {\n *   const fullName = useValue('fullName', () => `${firstName.get()} ${lastName.get()}`, [\n *     firstName,\n *     lastName,\n *   ])\n *   return <div>Hello {fullName}!</div>\n * })\n * ```\n *\n * @public\n */\nexport function useValue<Value>(name: string, fn: () => Value, deps: unknown[]): Value\n\n/** @public */\nexport function useValue() {\n\tconst args = arguments\n\t// deps will be either the computed or the deps array\n\tconst deps = args.length === 3 ? args[2] : [args[0]]\n\tconst name = args.length === 3 ? args[0] : `useValue(${args[0].name})`\n\n\tconst { $val, subscribe, getSnapshot } = useMemo(() => {\n\t\tconst $val =\n\t\t\targs.length === 1 ? (args[0] as Signal<any>) : (computed(name, args[1]) as Signal<any>)\n\n\t\treturn {\n\t\t\t$val,\n\t\t\tsubscribe: (notify: () => void) => {\n\t\t\t\treturn react(`useValue(${name})`, () => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t$val.get()\n\t\t\t\t\t} catch {\n\t\t\t\t\t\t// Will be rethrown during render if the component doesn't unmount first.\n\t\t\t\t\t}\n\t\t\t\t\tnotify()\n\t\t\t\t})\n\t\t\t},\n\t\t\tgetSnapshot: () => $val.lastChangedEpoch,\n\t\t}\n\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t}, deps)\n\n\tuseSyncExternalStore(subscribe, getSnapshot, getSnapshot)\n\treturn $val.__unsafe__getWithoutCapture()\n}\n"],"names":["$val"],"mappings":";;;AACA,SAAiB,UAAU,aAAa;;;AACxC,SAAS,SAAS,4BAA4B;;;AA2CvC,SAAS,WAAW;IAC1B,MAAM,OAAO;IAEb,MAAM,OAAO,KAAK,MAAA,KAAW,IAAI,IAAA,CAAK,CAAC,CAAA,GAAI;QAAC,IAAA,CAAK,CAAC,CAAC;KAAA;IACnD,MAAM,OAAO,KAAK,MAAA,KAAW,IAAI,IAAA,CAAK,CAAC,CAAA,GAAI,CAAA,SAAA,EAAY,IAAA,CAAK,CAAC,CAAA,CAAE,IAAI,CAAA,CAAA,CAAA;IAEnE,MAAM,EAAE,IAAA,EAAM,SAAA,EAAW,WAAA,CAAY,CAAA,IAAI,mNAAA,EAAQ,MAAM;QACtD,MAAMA,QACL,KAAK,MAAA,KAAW,IAAK,IAAA,CAAK,CAAC,CAAA,4KAAqB,WAAA,EAAS,MAAM,IAAA,CAAK,CAAC,CAAC;QAEvE,OAAO;YACN,MAAAA;YACA,WAAW,CAAC,WAAuB;gBAClC,QAAO,uLAAA,EAAM,CAAA,SAAA,EAAY,IAAI,CAAA,CAAA,CAAA,EAAK,MAAM;oBACvC,IAAI;wBACHA,MAAK,GAAA,CAAI;oBACV,EAAA,OAAQ,CAER;oBACA,OAAO;gBACR,CAAC;YACF;YACA,aAAa,IAAMA,MAAK,gBAAA;QACzB;IAED,GAAG,IAAI;IAEP,CAAA,GAAA,qMAAA,CAAA,uBAAA,EAAqB,WAAW,aAAa,WAAW;IACxD,OAAO,KAAK,2BAAA,CAA4B;AACzC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3954, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/state-react/src/index.ts"],"sourcesContent":["import { registerTldrawLibraryVersion } from '@tldraw/utils'\nexport { track } from './lib/track'\nexport { useAtom } from './lib/useAtom'\nexport { useComputed } from './lib/useComputed'\nexport { useQuickReactor } from './lib/useQuickReactor'\nexport { useReactor } from './lib/useReactor'\nexport { useStateTracking } from './lib/useStateTracking'\nexport { useValue } from './lib/useValue'\n\nregisterTldrawLibraryVersion(\n\t(globalThis as any).TLDRAW_LIBRARY_NAME,\n\t(globalThis as any).TLDRAW_LIBRARY_VERSION,\n\t(globalThis as any).TLDRAW_LIBRARY_MODULES\n)\n"],"names":[],"mappings":";;AAAA,SAAS,oCAAoC;AAC7C,SAAS,aAAa;AACtB,SAAS,eAAe;AACxB,SAAS,mBAAmB;AAC5B,SAAS,uBAAuB;AAChC,SAAS,kBAAkB;AAC3B,SAAS,wBAAwB;AACjC,SAAS,gBAAgB;;;;;;;;;wKAEzB,+BAAA,EACE,uBACA,UACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3997, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/validate/src/lib/validation.ts"],"sourcesContent":["import {\n\tIndexKey,\n\tJsonValue,\n\tMakeUndefinedOptional,\n\tSTRUCTURED_CLONE_OBJECT_PROTOTYPE,\n\texhaustiveSwitchError,\n\tgetOwnProperty,\n\thasOwnProperty,\n\tvalidateIndexKey,\n} from '@tldraw/utils'\n\n/** @public */\nexport type ValidatorFn<T> = (value: unknown) => T\n/** @public */\nexport type ValidatorUsingKnownGoodVersionFn<In, Out = In> = (\n\tknownGoodValue: In,\n\tvalue: unknown\n) => Out\n\n/** @public */\nexport interface Validatable<T> {\n\tvalidate(value: unknown): T\n\t/**\n\t * This is a performance optimizing version of validate that can use a previous\n\t * version of the value to avoid revalidating every part of the new value if\n\t * any part of it has not changed since the last validation.\n\t *\n\t * If the value has not changed but is not referentially equal, the function\n\t * should return the previous value.\n\t * @returns\n\t */\n\tvalidateUsingKnownGoodVersion?(knownGoodValue: T, newValue: unknown): T\n}\n\nfunction formatPath(path: ReadonlyArray<number | string>): string | null {\n\tif (!path.length) {\n\t\treturn null\n\t}\n\n\tlet formattedPath = ''\n\tfor (const item of path) {\n\t\tif (typeof item === 'number') {\n\t\t\tformattedPath += `.${item}`\n\t\t} else if (item.startsWith('(')) {\n\t\t\tif (formattedPath.endsWith(')')) {\n\t\t\t\tformattedPath = `${formattedPath.slice(0, -1)}, ${item.slice(1)}`\n\t\t\t} else {\n\t\t\t\tformattedPath += item\n\t\t\t}\n\t\t} else {\n\t\t\tformattedPath += `.${item}`\n\t\t}\n\t}\n\n\t// N.B. We don't want id's in the path because they make grouping in Sentry tough.\n\tformattedPath = formattedPath.replace(/id = [^,]+, /, '').replace(/id = [^)]+/, '')\n\n\tif (formattedPath.startsWith('.')) {\n\t\treturn formattedPath.slice(1)\n\t}\n\treturn formattedPath\n}\n\n/** @public */\nexport class ValidationError extends Error {\n\toverride name = 'ValidationError'\n\n\tconstructor(\n\t\tpublic readonly rawMessage: string,\n\t\tpublic readonly path: ReadonlyArray<number | string> = []\n\t) {\n\t\tconst formattedPath = formatPath(path)\n\t\tconst indentedMessage = rawMessage\n\t\t\t.split('\\n')\n\t\t\t.map((line, i) => (i === 0 ? line : `  ${line}`))\n\t\t\t.join('\\n')\n\t\tsuper(path ? `At ${formattedPath}: ${indentedMessage}` : indentedMessage)\n\t}\n}\n\nfunction prefixError<T>(path: string | number, fn: () => T): T {\n\ttry {\n\t\treturn fn()\n\t} catch (err) {\n\t\tif (err instanceof ValidationError) {\n\t\t\tthrow new ValidationError(err.rawMessage, [path, ...err.path])\n\t\t}\n\t\tthrow new ValidationError((err as Error).toString(), [path])\n\t}\n}\n\nfunction typeToString(value: unknown): string {\n\tif (value === null) return 'null'\n\tif (Array.isArray(value)) return 'an array'\n\tconst type = typeof value\n\tswitch (type) {\n\t\tcase 'bigint':\n\t\tcase 'boolean':\n\t\tcase 'function':\n\t\tcase 'number':\n\t\tcase 'string':\n\t\tcase 'symbol':\n\t\t\treturn `a ${type}`\n\t\tcase 'object':\n\t\t\treturn `an ${type}`\n\t\tcase 'undefined':\n\t\t\treturn 'undefined'\n\t\tdefault:\n\t\t\texhaustiveSwitchError(type)\n\t}\n}\n\n/** @public */\nexport type TypeOf<V extends Validatable<any>> = V extends Validatable<infer T> ? T : never\n\n/** @public */\nexport class Validator<T> implements Validatable<T> {\n\tconstructor(\n\t\treadonly validationFn: ValidatorFn<T>,\n\t\treadonly validateUsingKnownGoodVersionFn?: ValidatorUsingKnownGoodVersionFn<T>\n\t) {}\n\n\t/**\n\t * Asserts that the passed value is of the correct type and returns it. The returned value is\n\t * guaranteed to be referentially equal to the passed value.\n\t */\n\tvalidate(value: unknown): T {\n\t\tconst validated = this.validationFn(value)\n\t\tif (process.env.NODE_ENV !== 'production' && !Object.is(value, validated)) {\n\t\t\tthrow new ValidationError('Validator functions must return the same value they were passed')\n\t\t}\n\t\treturn validated\n\t}\n\n\tvalidateUsingKnownGoodVersion(knownGoodValue: T, newValue: unknown): T {\n\t\tif (Object.is(knownGoodValue, newValue)) {\n\t\t\treturn knownGoodValue as T\n\t\t}\n\n\t\tif (this.validateUsingKnownGoodVersionFn) {\n\t\t\treturn this.validateUsingKnownGoodVersionFn(knownGoodValue, newValue)\n\t\t}\n\n\t\treturn this.validate(newValue)\n\t}\n\n\t/** Checks that the passed value is of the correct type. */\n\tisValid(value: unknown): value is T {\n\t\ttry {\n\t\t\tthis.validate(value)\n\t\t\treturn true\n\t\t} catch {\n\t\t\treturn false\n\t\t}\n\t}\n\n\t/**\n\t * Returns a new validator that also accepts null or undefined. The resulting value will always be\n\t * null.\n\t */\n\tnullable(): Validator<T | null> {\n\t\treturn nullable(this)\n\t}\n\n\t/**\n\t * Returns a new validator that also accepts null or undefined. The resulting value will always be\n\t * null.\n\t */\n\toptional(): Validator<T | undefined> {\n\t\treturn optional(this)\n\t}\n\n\t/**\n\t * Refine this validation to a new type. The passed-in validation function should throw an error\n\t * if the value can't be converted to the new type, or return the new type otherwise.\n\t */\n\trefine<U>(otherValidationFn: (value: T) => U): Validator<U> {\n\t\treturn new Validator(\n\t\t\t(value) => {\n\t\t\t\treturn otherValidationFn(this.validate(value))\n\t\t\t},\n\n\t\t\t(knownGoodValue, newValue) => {\n\t\t\t\tconst validated = this.validateUsingKnownGoodVersion(knownGoodValue as any, newValue)\n\t\t\t\tif (Object.is(knownGoodValue, validated)) {\n\t\t\t\t\treturn knownGoodValue\n\t\t\t\t}\n\t\t\t\treturn otherValidationFn(validated)\n\t\t\t}\n\t\t)\n\t}\n\n\t/**\n\t * Refine this validation with an additional check that doesn't change the resulting value.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const numberLessThan10Validator = T.number.check((value) => {\n\t * \tif (value >= 10) {\n\t * \t\tthrow new ValidationError(`Expected number less than 10, got ${value}`)\n\t * \t}\n\t * })\n\t * ```\n\t */\n\tcheck(name: string, checkFn: (value: T) => void): Validator<T>\n\tcheck(checkFn: (value: T) => void): Validator<T>\n\tcheck(nameOrCheckFn: string | ((value: T) => void), checkFn?: (value: T) => void): Validator<T> {\n\t\tif (typeof nameOrCheckFn === 'string') {\n\t\t\treturn this.refine((value) => {\n\t\t\t\tprefixError(`(check ${nameOrCheckFn})`, () => checkFn!(value))\n\t\t\t\treturn value\n\t\t\t})\n\t\t} else {\n\t\t\treturn this.refine((value) => {\n\t\t\t\tnameOrCheckFn(value)\n\t\t\t\treturn value\n\t\t\t})\n\t\t}\n\t}\n}\n\n/** @public */\nexport class ArrayOfValidator<T> extends Validator<T[]> {\n\tconstructor(readonly itemValidator: Validatable<T>) {\n\t\tsuper(\n\t\t\t(value) => {\n\t\t\t\tconst arr = array.validate(value)\n\t\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\t\tprefixError(i, () => itemValidator.validate(arr[i]))\n\t\t\t\t}\n\t\t\t\treturn arr as T[]\n\t\t\t},\n\t\t\t(knownGoodValue, newValue) => {\n\t\t\t\tif (!itemValidator.validateUsingKnownGoodVersion) return this.validate(newValue)\n\t\t\t\tconst arr = array.validate(newValue)\n\t\t\t\tlet isDifferent = knownGoodValue.length !== arr.length\n\t\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\t\tconst item = arr[i]\n\t\t\t\t\tif (i >= knownGoodValue.length) {\n\t\t\t\t\t\tisDifferent = true\n\t\t\t\t\t\tprefixError(i, () => itemValidator.validate(item))\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\t// sneaky quick check here to avoid the prefix + validator overhead\n\t\t\t\t\tif (Object.is(knownGoodValue[i], item)) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tconst checkedItem = prefixError(i, () =>\n\t\t\t\t\t\titemValidator.validateUsingKnownGoodVersion!(knownGoodValue[i], item)\n\t\t\t\t\t)\n\t\t\t\t\tif (!Object.is(checkedItem, knownGoodValue[i])) {\n\t\t\t\t\t\tisDifferent = true\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn isDifferent ? (newValue as T[]) : knownGoodValue\n\t\t\t}\n\t\t)\n\t}\n\n\tnonEmpty() {\n\t\treturn this.check((value) => {\n\t\t\tif (value.length === 0) {\n\t\t\t\tthrow new ValidationError('Expected a non-empty array')\n\t\t\t}\n\t\t})\n\t}\n\n\tlengthGreaterThan1() {\n\t\treturn this.check((value) => {\n\t\t\tif (value.length <= 1) {\n\t\t\t\tthrow new ValidationError('Expected an array with length greater than 1')\n\t\t\t}\n\t\t})\n\t}\n}\n\n/** @public */\nexport class ObjectValidator<Shape extends object> extends Validator<Shape> {\n\tconstructor(\n\t\tpublic readonly config: {\n\t\t\treadonly [K in keyof Shape]: Validatable<Shape[K]>\n\t\t},\n\t\tprivate readonly shouldAllowUnknownProperties = false\n\t) {\n\t\tsuper(\n\t\t\t(object) => {\n\t\t\t\tif (typeof object !== 'object' || object === null) {\n\t\t\t\t\tthrow new ValidationError(`Expected object, got ${typeToString(object)}`)\n\t\t\t\t}\n\n\t\t\t\tfor (const [key, validator] of Object.entries(config)) {\n\t\t\t\t\tprefixError(key, () => {\n\t\t\t\t\t\t;(validator as Validatable<unknown>).validate(getOwnProperty(object, key))\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\tif (!shouldAllowUnknownProperties) {\n\t\t\t\t\tfor (const key of Object.keys(object)) {\n\t\t\t\t\t\tif (!hasOwnProperty(config, key)) {\n\t\t\t\t\t\t\tthrow new ValidationError(`Unexpected property`, [key])\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn object as Shape\n\t\t\t},\n\t\t\t(knownGoodValue, newValue) => {\n\t\t\t\tif (typeof newValue !== 'object' || newValue === null) {\n\t\t\t\t\tthrow new ValidationError(`Expected object, got ${typeToString(newValue)}`)\n\t\t\t\t}\n\n\t\t\t\tlet isDifferent = false\n\n\t\t\t\tfor (const [key, validator] of Object.entries(config)) {\n\t\t\t\t\tconst prev = getOwnProperty(knownGoodValue, key)\n\t\t\t\t\tconst next = getOwnProperty(newValue, key)\n\t\t\t\t\t// sneaky quick check here to avoid the prefix + validator overhead\n\t\t\t\t\tif (Object.is(prev, next)) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tconst checked = prefixError(key, () => {\n\t\t\t\t\t\tconst validatable = validator as Validatable<unknown>\n\t\t\t\t\t\tif (validatable.validateUsingKnownGoodVersion) {\n\t\t\t\t\t\t\treturn validatable.validateUsingKnownGoodVersion(prev, next)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn validatable.validate(next)\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\tif (!Object.is(checked, prev)) {\n\t\t\t\t\t\tisDifferent = true\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!shouldAllowUnknownProperties) {\n\t\t\t\t\tfor (const key of Object.keys(newValue)) {\n\t\t\t\t\t\tif (!hasOwnProperty(config, key)) {\n\t\t\t\t\t\t\tthrow new ValidationError(`Unexpected property`, [key])\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (const key of Object.keys(knownGoodValue)) {\n\t\t\t\t\tif (!hasOwnProperty(newValue, key)) {\n\t\t\t\t\t\tisDifferent = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn isDifferent ? (newValue as Shape) : knownGoodValue\n\t\t\t}\n\t\t)\n\t}\n\n\tallowUnknownProperties() {\n\t\treturn new ObjectValidator(this.config, true)\n\t}\n\n\t/**\n\t * Extend an object validator by adding additional properties.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const animalValidator = T.object({\n\t * \tname: T.string,\n\t * })\n\t * const catValidator = animalValidator.extend({\n\t * \tmeowVolume: T.number,\n\t * })\n\t * ```\n\t */\n\textend<Extension extends Record<string, unknown>>(extension: {\n\t\treadonly [K in keyof Extension]: Validatable<Extension[K]>\n\t}): ObjectValidator<Shape & Extension> {\n\t\treturn new ObjectValidator({ ...this.config, ...extension }) as any as ObjectValidator<\n\t\t\tShape & Extension\n\t\t>\n\t}\n}\n\n// pass this into itself e.g. Config extends UnionObjectSchemaConfig<Key, Config>\n/** @public */\nexport type UnionValidatorConfig<Key extends string, Config> = {\n\treadonly [Variant in keyof Config]: Validatable<any> & {\n\t\tvalidate(input: any): { readonly [K in Key]: Variant }\n\t}\n}\n/** @public */\nexport class UnionValidator<\n\tKey extends string,\n\tConfig extends UnionValidatorConfig<Key, Config>,\n\tUnknownValue = never,\n> extends Validator<TypeOf<Config[keyof Config]> | UnknownValue> {\n\tconstructor(\n\t\tprivate readonly key: Key,\n\t\tprivate readonly config: Config,\n\t\tprivate readonly unknownValueValidation: (value: object, variant: string) => UnknownValue,\n\t\tprivate readonly useNumberKeys: boolean\n\t) {\n\t\tsuper(\n\t\t\t(input) => {\n\t\t\t\tthis.expectObject(input)\n\n\t\t\t\tconst { matchingSchema, variant } = this.getMatchingSchemaAndVariant(input)\n\t\t\t\tif (matchingSchema === undefined) {\n\t\t\t\t\treturn this.unknownValueValidation(input, variant)\n\t\t\t\t}\n\n\t\t\t\treturn prefixError(`(${key} = ${variant})`, () => matchingSchema.validate(input))\n\t\t\t},\n\t\t\t(prevValue, newValue) => {\n\t\t\t\tthis.expectObject(newValue)\n\t\t\t\tthis.expectObject(prevValue)\n\n\t\t\t\tconst { matchingSchema, variant } = this.getMatchingSchemaAndVariant(newValue)\n\t\t\t\tif (matchingSchema === undefined) {\n\t\t\t\t\treturn this.unknownValueValidation(newValue, variant)\n\t\t\t\t}\n\n\t\t\t\tif (getOwnProperty(prevValue, key) !== getOwnProperty(newValue, key)) {\n\t\t\t\t\t// the type has changed so bail out and do a regular validation\n\t\t\t\t\treturn prefixError(`(${key} = ${variant})`, () => matchingSchema.validate(newValue))\n\t\t\t\t}\n\n\t\t\t\treturn prefixError(`(${key} = ${variant})`, () => {\n\t\t\t\t\tif (matchingSchema.validateUsingKnownGoodVersion) {\n\t\t\t\t\t\treturn matchingSchema.validateUsingKnownGoodVersion(prevValue, newValue)\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn matchingSchema.validate(newValue)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t)\n\t}\n\n\tprivate expectObject(value: unknown): asserts value is object {\n\t\tif (typeof value !== 'object' || value === null) {\n\t\t\tthrow new ValidationError(`Expected an object, got ${typeToString(value)}`, [])\n\t\t}\n\t}\n\n\tprivate getMatchingSchemaAndVariant(object: object): {\n\t\tmatchingSchema: Validatable<any> | undefined\n\t\tvariant: string\n\t} {\n\t\tconst variant = getOwnProperty(object, this.key)! as string & keyof Config\n\t\tif (!this.useNumberKeys && typeof variant !== 'string') {\n\t\t\tthrow new ValidationError(\n\t\t\t\t`Expected a string for key \"${this.key}\", got ${typeToString(variant)}`\n\t\t\t)\n\t\t} else if (this.useNumberKeys && !Number.isFinite(Number(variant))) {\n\t\t\tthrow new ValidationError(`Expected a number for key \"${this.key}\", got \"${variant as any}\"`)\n\t\t}\n\n\t\tconst matchingSchema = hasOwnProperty(this.config, variant) ? this.config[variant] : undefined\n\t\treturn { matchingSchema, variant }\n\t}\n\n\tvalidateUnknownVariants<Unknown>(\n\t\tunknownValueValidation: (value: object, variant: string) => Unknown\n\t): UnionValidator<Key, Config, Unknown> {\n\t\treturn new UnionValidator(this.key, this.config, unknownValueValidation, this.useNumberKeys)\n\t}\n}\n\n/** @public */\nexport class DictValidator<Key extends string, Value> extends Validator<Record<Key, Value>> {\n\tconstructor(\n\t\tpublic readonly keyValidator: Validatable<Key>,\n\t\tpublic readonly valueValidator: Validatable<Value>\n\t) {\n\t\tsuper(\n\t\t\t(object) => {\n\t\t\t\tif (typeof object !== 'object' || object === null) {\n\t\t\t\t\tthrow new ValidationError(`Expected object, got ${typeToString(object)}`)\n\t\t\t\t}\n\n\t\t\t\tfor (const [key, value] of Object.entries(object)) {\n\t\t\t\t\tprefixError(key, () => {\n\t\t\t\t\t\tkeyValidator.validate(key)\n\t\t\t\t\t\tvalueValidator.validate(value)\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\treturn object as Record<Key, Value>\n\t\t\t},\n\t\t\t(knownGoodValue, newValue) => {\n\t\t\t\tif (typeof newValue !== 'object' || newValue === null) {\n\t\t\t\t\tthrow new ValidationError(`Expected object, got ${typeToString(newValue)}`)\n\t\t\t\t}\n\n\t\t\t\tlet isDifferent = false\n\n\t\t\t\tfor (const [key, value] of Object.entries(newValue)) {\n\t\t\t\t\tif (!hasOwnProperty(knownGoodValue, key)) {\n\t\t\t\t\t\tisDifferent = true\n\t\t\t\t\t\tprefixError(key, () => {\n\t\t\t\t\t\t\tkeyValidator.validate(key)\n\t\t\t\t\t\t\tvalueValidator.validate(value)\n\t\t\t\t\t\t})\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tconst prev = getOwnProperty(knownGoodValue, key)\n\t\t\t\t\tconst next = value\n\t\t\t\t\t// sneaky quick check here to avoid the prefix + validator overhead\n\t\t\t\t\tif (Object.is(prev, next)) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tconst checked = prefixError(key, () => {\n\t\t\t\t\t\tif (valueValidator.validateUsingKnownGoodVersion) {\n\t\t\t\t\t\t\treturn valueValidator.validateUsingKnownGoodVersion(prev as any, next)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn valueValidator.validate(next)\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\tif (!Object.is(checked, prev)) {\n\t\t\t\t\t\tisDifferent = true\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (const key of Object.keys(knownGoodValue)) {\n\t\t\t\t\tif (!hasOwnProperty(newValue, key)) {\n\t\t\t\t\t\tisDifferent = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn isDifferent ? (newValue as Record<Key, Value>) : knownGoodValue\n\t\t\t}\n\t\t)\n\t}\n}\n\nfunction typeofValidator<T>(type: string): Validator<T> {\n\treturn new Validator((value) => {\n\t\tif (typeof value !== type) {\n\t\t\tthrow new ValidationError(`Expected ${type}, got ${typeToString(value)}`)\n\t\t}\n\t\treturn value as T\n\t})\n}\n\n/**\n * Validation that accepts any value. Useful as a starting point for building your own custom\n * validations.\n *\n * @public\n */\nexport const unknown = new Validator((value) => value)\n/**\n * Validation that accepts any value. Generally this should be avoided, but you can use it as an\n * escape hatch if you want to work without validations for e.g. a prototype.\n *\n * @public\n */\nexport const any = new Validator((value): any => value)\n\n/**\n * Validates that a value is a string.\n *\n * @public\n */\nexport const string = typeofValidator<string>('string')\n\n/**\n * Validates that a value is a finite non-NaN number.\n *\n * @public\n */\nexport const number = typeofValidator<number>('number').check((number) => {\n\tif (Number.isNaN(number)) {\n\t\tthrow new ValidationError('Expected a number, got NaN')\n\t}\n\tif (!Number.isFinite(number)) {\n\t\tthrow new ValidationError(`Expected a finite number, got ${number}`)\n\t}\n})\n/**\n * Fails if value \\< 0\n *\n * @public\n */\nexport const positiveNumber = number.check((value) => {\n\tif (value < 0) throw new ValidationError(`Expected a positive number, got ${value}`)\n})\n/**\n * Fails if value \\<= 0\n *\n * @public\n */\nexport const nonZeroNumber = number.check((value) => {\n\tif (value <= 0) throw new ValidationError(`Expected a non-zero positive number, got ${value}`)\n})\n/**\n * Fails if number is not an integer\n *\n * @public\n */\nexport const integer = number.check((value) => {\n\tif (!Number.isInteger(value)) throw new ValidationError(`Expected an integer, got ${value}`)\n})\n/**\n * Fails if value \\< 0 and is not an integer\n *\n * @public\n */\nexport const positiveInteger = integer.check((value) => {\n\tif (value < 0) throw new ValidationError(`Expected a positive integer, got ${value}`)\n})\n/**\n * Fails if value \\<= 0 and is not an integer\n *\n * @public\n */\nexport const nonZeroInteger = integer.check((value) => {\n\tif (value <= 0) throw new ValidationError(`Expected a non-zero positive integer, got ${value}`)\n})\n\n/**\n * Validates that a value is boolean.\n *\n * @public\n */\nexport const boolean = typeofValidator<boolean>('boolean')\n/**\n * Validates that a value is a bigint.\n *\n * @public\n */\nexport const bigint = typeofValidator<bigint>('bigint')\n/**\n * Validates that a value matches another that was passed in.\n *\n * @example\n *\n * ```ts\n * const trueValidator = T.literal(true)\n * ```\n *\n * @public\n */\nexport function literal<T extends string | number | boolean>(expectedValue: T): Validator<T> {\n\treturn new Validator((actualValue) => {\n\t\tif (actualValue !== expectedValue) {\n\t\t\tthrow new ValidationError(`Expected ${expectedValue}, got ${JSON.stringify(actualValue)}`)\n\t\t}\n\t\treturn expectedValue\n\t})\n}\n\n/**\n * Validates that a value is an array. To check the contents of the array, use T.arrayOf.\n *\n * @public\n */\nexport const array = new Validator<unknown[]>((value) => {\n\tif (!Array.isArray(value)) {\n\t\tthrow new ValidationError(`Expected an array, got ${typeToString(value)}`)\n\t}\n\treturn value\n})\n\n/**\n * Validates that a value is an array whose contents matches the passed-in validator.\n *\n * @public\n */\nexport function arrayOf<T>(itemValidator: Validatable<T>): ArrayOfValidator<T> {\n\treturn new ArrayOfValidator(itemValidator)\n}\n\n/** @public */\nexport const unknownObject = new Validator<Record<string, unknown>>((value) => {\n\tif (typeof value !== 'object' || value === null) {\n\t\tthrow new ValidationError(`Expected object, got ${typeToString(value)}`)\n\t}\n\treturn value as Record<string, unknown>\n})\n\n/**\n * Validate an object has a particular shape.\n *\n * @public\n */\nexport function object<Shape extends object>(config: {\n\treadonly [K in keyof Shape]: Validatable<Shape[K]>\n}): ObjectValidator<MakeUndefinedOptional<Shape>> {\n\treturn new ObjectValidator(config) as any\n}\n\nfunction isPlainObject(value: unknown): value is Record<string, unknown> {\n\treturn (\n\t\ttypeof value === 'object' &&\n\t\tvalue !== null &&\n\t\t(Object.getPrototypeOf(value) === Object.prototype ||\n\t\t\tObject.getPrototypeOf(value) === null ||\n\t\t\tObject.getPrototypeOf(value) === STRUCTURED_CLONE_OBJECT_PROTOTYPE)\n\t)\n}\n\nfunction isValidJson(value: any): value is JsonValue {\n\tif (\n\t\tvalue === null ||\n\t\ttypeof value === 'number' ||\n\t\ttypeof value === 'string' ||\n\t\ttypeof value === 'boolean'\n\t) {\n\t\treturn true\n\t}\n\n\tif (Array.isArray(value)) {\n\t\treturn value.every(isValidJson)\n\t}\n\n\tif (isPlainObject(value)) {\n\t\treturn Object.values(value).every(isValidJson)\n\t}\n\n\treturn false\n}\n\n/**\n * Validate that a value is valid JSON.\n *\n * @public\n */\nexport const jsonValue: Validator<JsonValue> = new Validator<JsonValue>(\n\t(value): JsonValue => {\n\t\tif (isValidJson(value)) {\n\t\t\treturn value as JsonValue\n\t\t}\n\n\t\tthrow new ValidationError(`Expected json serializable value, got ${typeof value}`)\n\t},\n\t(knownGoodValue, newValue) => {\n\t\tif (Array.isArray(knownGoodValue) && Array.isArray(newValue)) {\n\t\t\tlet isDifferent = knownGoodValue.length !== newValue.length\n\t\t\tfor (let i = 0; i < newValue.length; i++) {\n\t\t\t\tif (i >= knownGoodValue.length) {\n\t\t\t\t\tisDifferent = true\n\t\t\t\t\tjsonValue.validate(newValue[i])\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tconst prev = knownGoodValue[i]\n\t\t\t\tconst next = newValue[i]\n\t\t\t\tif (Object.is(prev, next)) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tconst checked = jsonValue.validateUsingKnownGoodVersion!(prev, next)\n\t\t\t\tif (!Object.is(checked, prev)) {\n\t\t\t\t\tisDifferent = true\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn isDifferent ? (newValue as JsonValue) : knownGoodValue\n\t\t} else if (isPlainObject(knownGoodValue) && isPlainObject(newValue)) {\n\t\t\tlet isDifferent = false\n\t\t\tfor (const key of Object.keys(newValue)) {\n\t\t\t\tif (!hasOwnProperty(knownGoodValue, key)) {\n\t\t\t\t\tisDifferent = true\n\t\t\t\t\tjsonValue.validate(newValue[key])\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tconst prev = knownGoodValue[key]\n\t\t\t\tconst next = newValue[key]\n\t\t\t\tif (Object.is(prev, next)) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tconst checked = jsonValue.validateUsingKnownGoodVersion!(prev!, next)\n\t\t\t\tif (!Object.is(checked, prev)) {\n\t\t\t\t\tisDifferent = true\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const key of Object.keys(knownGoodValue)) {\n\t\t\t\tif (!hasOwnProperty(newValue, key)) {\n\t\t\t\t\tisDifferent = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn isDifferent ? (newValue as JsonValue) : knownGoodValue\n\t\t} else {\n\t\t\treturn jsonValue.validate(newValue)\n\t\t}\n\t}\n)\n\n/**\n * Validate an object has a particular shape.\n *\n * @public\n */\nexport function jsonDict(): DictValidator<string, JsonValue> {\n\treturn dict(string, jsonValue)\n}\n\n/**\n * Validation that an option is a dict with particular keys and values.\n *\n * @public\n */\nexport function dict<Key extends string, Value>(\n\tkeyValidator: Validatable<Key>,\n\tvalueValidator: Validatable<Value>\n): DictValidator<Key, Value> {\n\treturn new DictValidator(keyValidator, valueValidator)\n}\n\n/**\n * Validate a union of several object types. Each object must have a property matching `key` which\n * should be a unique string.\n *\n * @example\n *\n * ```ts\n * const catValidator = T.object({ kind: T.literal('cat'), meow: T.boolean })\n * const dogValidator = T.object({ kind: T.literal('dog'), bark: T.boolean })\n * const animalValidator = T.union('kind', { cat: catValidator, dog: dogValidator })\n * ```\n *\n * @public\n */\nexport function union<Key extends string, Config extends UnionValidatorConfig<Key, Config>>(\n\tkey: Key,\n\tconfig: Config\n): UnionValidator<Key, Config> {\n\treturn new UnionValidator(\n\t\tkey,\n\t\tconfig,\n\t\t(_unknownValue, unknownVariant) => {\n\t\t\tthrow new ValidationError(\n\t\t\t\t`Expected one of ${Object.keys(config)\n\t\t\t\t\t.map((key) => JSON.stringify(key))\n\t\t\t\t\t.join(' or ')}, got ${JSON.stringify(unknownVariant)}`,\n\t\t\t\t[key]\n\t\t\t)\n\t\t},\n\t\tfalse\n\t)\n}\n\n/**\n * @internal\n */\nexport function numberUnion<Key extends string, Config extends UnionValidatorConfig<Key, Config>>(\n\tkey: Key,\n\tconfig: Config\n): UnionValidator<Key, Config> {\n\treturn new UnionValidator(\n\t\tkey,\n\t\tconfig,\n\t\t(unknownValue, unknownVariant) => {\n\t\t\tthrow new ValidationError(\n\t\t\t\t`Expected one of ${Object.keys(config)\n\t\t\t\t\t.map((key) => JSON.stringify(key))\n\t\t\t\t\t.join(' or ')}, got ${JSON.stringify(unknownVariant)}`,\n\t\t\t\t[key]\n\t\t\t)\n\t\t},\n\t\ttrue\n\t)\n}\n\n/**\n * A named object with an ID. Errors will be reported as being part of the object with the given\n * name.\n *\n * @public\n */\nexport function model<T extends { readonly id: string }>(\n\tname: string,\n\tvalidator: Validatable<T>\n): Validator<T> {\n\treturn new Validator(\n\t\t(value) => {\n\t\t\treturn prefixError(name, () => validator.validate(value))\n\t\t},\n\t\t(prevValue, newValue) => {\n\t\t\treturn prefixError(name, () => {\n\t\t\t\tif (validator.validateUsingKnownGoodVersion) {\n\t\t\t\t\treturn validator.validateUsingKnownGoodVersion(prevValue, newValue)\n\t\t\t\t} else {\n\t\t\t\t\treturn validator.validate(newValue)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t)\n}\n\n/** @public */\nexport function setEnum<T>(values: ReadonlySet<T>): Validator<T> {\n\treturn new Validator((value) => {\n\t\tif (!values.has(value as T)) {\n\t\t\tconst valuesString = Array.from(values, (value) => JSON.stringify(value)).join(' or ')\n\t\t\tthrow new ValidationError(`Expected ${valuesString}, got ${value}`)\n\t\t}\n\t\treturn value as T\n\t})\n}\n\n/** @public */\nexport function optional<T>(validator: Validatable<T>): Validator<T | undefined> {\n\treturn new Validator(\n\t\t(value) => {\n\t\t\tif (value === undefined) return undefined\n\t\t\treturn validator.validate(value)\n\t\t},\n\t\t(knownGoodValue, newValue) => {\n\t\t\tif (knownGoodValue === undefined && newValue === undefined) return undefined\n\t\t\tif (newValue === undefined) return undefined\n\t\t\tif (validator.validateUsingKnownGoodVersion && knownGoodValue !== undefined) {\n\t\t\t\treturn validator.validateUsingKnownGoodVersion(knownGoodValue as T, newValue)\n\t\t\t}\n\t\t\treturn validator.validate(newValue)\n\t\t}\n\t)\n}\n\n/** @public */\nexport function nullable<T>(validator: Validatable<T>): Validator<T | null> {\n\treturn new Validator(\n\t\t(value) => {\n\t\t\tif (value === null) return null\n\t\t\treturn validator.validate(value)\n\t\t},\n\t\t(knownGoodValue, newValue) => {\n\t\t\tif (newValue === null) return null\n\t\t\tif (validator.validateUsingKnownGoodVersion && knownGoodValue !== null) {\n\t\t\t\treturn validator.validateUsingKnownGoodVersion(knownGoodValue as T, newValue)\n\t\t\t}\n\t\t\treturn validator.validate(newValue)\n\t\t}\n\t)\n}\n\n/** @public */\nexport function literalEnum<const Values extends readonly unknown[]>(\n\t...values: Values\n): Validator<Values[number]> {\n\treturn setEnum(new Set(values))\n}\n\nfunction parseUrl(str: string) {\n\ttry {\n\t\treturn new URL(str)\n\t} catch {\n\t\tif (str.startsWith('/') || str.startsWith('./')) {\n\t\t\ttry {\n\t\t\t\treturn new URL(str, 'http://example.com')\n\t\t\t} catch {\n\t\t\t\tthrow new ValidationError(`Expected a valid url, got ${JSON.stringify(str)}`)\n\t\t\t}\n\t\t}\n\t\tthrow new ValidationError(`Expected a valid url, got ${JSON.stringify(str)}`)\n\t}\n}\n\nconst validLinkProtocols = new Set(['http:', 'https:', 'mailto:'])\n\n/**\n * Validates that a value is a url safe to use as a link.\n *\n * @public\n */\nexport const linkUrl = string.check((value) => {\n\tif (value === '') return\n\tconst url = parseUrl(value)\n\n\tif (!validLinkProtocols.has(url.protocol.toLowerCase())) {\n\t\tthrow new ValidationError(\n\t\t\t`Expected a valid url, got ${JSON.stringify(value)} (invalid protocol)`\n\t\t)\n\t}\n})\n\n// N.B. asset: is a reference to the local indexedDB object store.\nconst validSrcProtocols = new Set(['http:', 'https:', 'data:', 'asset:'])\n\n/**\n * Validates that a valid is a url safe to load as an asset.\n *\n * @public\n */\nexport const srcUrl = string.check((value) => {\n\tif (value === '') return\n\tconst url = parseUrl(value)\n\n\tif (!validSrcProtocols.has(url.protocol.toLowerCase())) {\n\t\tthrow new ValidationError(\n\t\t\t`Expected a valid url, got ${JSON.stringify(value)} (invalid protocol)`\n\t\t)\n\t}\n})\n\n/**\n * Validates an http(s) url\n *\n * @public\n */\nexport const httpUrl = string.check((value) => {\n\tif (value === '') return\n\tconst url = parseUrl(value)\n\n\tif (!url.protocol.toLowerCase().match(/^https?:$/)) {\n\t\tthrow new ValidationError(\n\t\t\t`Expected a valid url, got ${JSON.stringify(value)} (invalid protocol)`\n\t\t)\n\t}\n})\n\n/**\n * Validates that a value is an IndexKey.\n * @public\n */\nexport const indexKey = string.refine<IndexKey>((key) => {\n\ttry {\n\t\tvalidateIndexKey(key)\n\t\treturn key\n\t} catch {\n\t\tthrow new ValidationError(`Expected an index key, got ${JSON.stringify(key)}`)\n\t}\n})\n\n/**\n * Validate a value against one of two types.\n *\n * @public\n */\nexport function or<T1, T2>(v1: Validatable<T1>, v2: Validatable<T2>): Validator<T1 | T2> {\n\treturn new Validator((value) => {\n\t\ttry {\n\t\t\treturn v1.validate(value)\n\t\t} catch {\n\t\t\treturn v2.validate(value)\n\t\t}\n\t})\n}\n"],"names":["object","number","key","value"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4698, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/validate/src/index.ts"],"sourcesContent":["import { registerTldrawLibraryVersion } from '@tldraw/utils'\nimport * as T from './lib/validation'\n\nexport {\n\tArrayOfValidator,\n\tDictValidator,\n\tObjectValidator,\n\tUnionValidator,\n\tValidator,\n\ttype UnionValidatorConfig,\n} from './lib/validation'\nexport { T }\n\nregisterTldrawLibraryVersion(\n\t(globalThis as any).TLDRAW_LIBRARY_NAME,\n\t(globalThis as any).TLDRAW_LIBRARY_VERSION,\n\t(globalThis as any).TLDRAW_LIBRARY_MODULES\n)\n"],"names":[],"mappings":";;AAAA,SAAS,oCAAoC;AAC7C,YAAY,OAAO;;;;wKAYnB,+BAAA,EACE,oBACA,UACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4744, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/%40tldraw/tldraw/src/index.ts"],"sourcesContent":["import { registerTldrawLibraryVersion } from 'tldraw'\n// eslint-disable-next-line local/no-export-star\nexport * from 'tldraw'\n\nregisterTldrawLibraryVersion(\n\t(globalThis as any).TLDRAW_LIBRARY_NAME,\n\t(globalThis as any).TLDRAW_LIBRARY_VERSION,\n\t(globalThis as any).TLDRAW_LIBRARY_MODULES\n)\n"],"names":[],"mappings":";;AAAA,SAAS,oCAAoC;;;wKAI7C,+BAAA,EACE,kBACA,UACA","ignoreList":[0],"debugId":null}}]
}