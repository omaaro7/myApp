{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/%40tldraw/editor/src/lib/editor/shapes/ShapeUtil.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { EMPTY_ARRAY } from '@tldraw/state'\nimport { LegacyMigrations, MigrationSequence } from '@tldraw/store'\nimport {\n\tRecordProps,\n\tTLHandle,\n\tTLParentId,\n\tTLPropsMigrations,\n\tTLShape,\n\tTLShapeCrop,\n\tTLShapeId,\n\tTLShapePartial,\n\tTLUnknownShape,\n} from '@tldraw/tlschema'\nimport { IndexKey } from '@tldraw/utils'\nimport { ReactElement } from 'react'\nimport { Box, SelectionHandle } from '../../primitives/Box'\nimport { Vec } from '../../primitives/Vec'\nimport { Geometry2d } from '../../primitives/geometry/Geometry2d'\nimport type { Editor } from '../Editor'\nimport { TLFontFace } from '../managers/FontManager/FontManager'\nimport { BoundsSnapGeometry } from '../managers/SnapManager/BoundsSnaps'\nimport { HandleSnapGeometry } from '../managers/SnapManager/HandleSnaps'\nimport { SvgExportContext } from '../types/SvgExportContext'\nimport { TLClickEventInfo } from '../types/event-types'\nimport { TLResizeHandle } from '../types/selection-types'\n\n/** @public */\nexport interface TLShapeUtilConstructor<\n\tT extends TLUnknownShape,\n\tU extends ShapeUtil<T> = ShapeUtil<T>,\n> {\n\tnew (editor: Editor): U\n\ttype: T['type']\n\tprops?: RecordProps<T>\n\tmigrations?: LegacyMigrations | TLPropsMigrations | MigrationSequence\n}\n\n/**\n * Options passed to {@link ShapeUtil.canBind}. A binding that could be made. At least one of\n * `fromShapeType` or `toShapeType` will belong to this shape util.\n *\n * @public\n */\nexport interface TLShapeUtilCanBindOpts<Shape extends TLUnknownShape = TLUnknownShape> {\n\t/** The type of shape referenced by the `fromId` of the binding. */\n\tfromShapeType: string\n\t/** The type of shape referenced by the `toId` of the binding. */\n\ttoShapeType: string\n\t/** The type of binding. */\n\tbindingType: string\n}\n\n/**\n * Options passed to {@link ShapeUtil.canBeLaidOut}.\n *\n * @public\n */\nexport interface TLShapeUtilCanBeLaidOutOpts {\n\t/** The type of action causing the layout. */\n\ttype?: 'align' | 'distribute' | 'pack' | 'stack' | 'flip' | 'stretch'\n\t/** The other shapes being laid out */\n\tshapes?: TLShape[]\n}\n\n/** Additional options for the {@link ShapeUtil.getGeometry} method.\n *\n * @public\n */\nexport interface TLGeometryOpts {\n\t/** The context in which the geometry is being requested. */\n\tcontext?: string\n}\n\n/** @public */\nexport interface TLShapeUtilCanvasSvgDef {\n\tkey: string\n\tcomponent: React.ComponentType\n}\n\n/** @public */\nexport abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {\n\t/** Configure this shape utils {@link ShapeUtil.options | `options`}. */\n\tstatic configure<T extends TLShapeUtilConstructor<any, any>>(\n\t\tthis: T,\n\t\toptions: T extends new (...args: any[]) => { options: infer Options } ? Partial<Options> : never\n\t): T {\n\t\t// @ts-expect-error -- typescript has no idea what's going on here but it's fine\n\t\treturn class extends this {\n\t\t\t// @ts-expect-error\n\t\t\toptions = { ...this.options, ...options }\n\t\t}\n\t}\n\n\tconstructor(public editor: Editor) {}\n\n\t/**\n\t * Options for this shape util. If you're implementing a custom shape util, you can override\n\t * this to provide customization options for your shape. If using an existing shape util, you\n\t * can customizing this by calling {@link ShapeUtil.configure}.\n\t */\n\toptions = {}\n\n\t/**\n\t * Props allow you to define the shape's properties in a way that the editor can understand.\n\t * This has two main uses:\n\t *\n\t * 1. Validation. Shapes will be validated using these props to stop bad data from being saved.\n\t * 2. Styles. Each {@link @tldraw/tlschema#StyleProp} in the props can be set on many shapes at\n\t *    once, and will be remembered from one shape to the next.\n\t *\n\t * @example\n\t * ```tsx\n\t * import {T, TLBaseShape, TLDefaultColorStyle, DefaultColorStyle, ShapeUtil} from 'tldraw'\n\t *\n\t * type MyShape = TLBaseShape<'mine', {\n\t *      color: TLDefaultColorStyle,\n\t *      text: string,\n\t * }>\n\t *\n\t * class MyShapeUtil extends ShapeUtil<MyShape> {\n\t *     static props = {\n\t *         // we use tldraw's built-in color style:\n\t *         color: DefaultColorStyle,\n\t *         // validate that the text prop is a string:\n\t *         text: T.string,\n\t *     }\n\t * }\n\t * ```\n\t */\n\tstatic props?: RecordProps<TLUnknownShape>\n\n\t/**\n\t * Migrations allow you to make changes to a shape's props over time. Read the\n\t * {@link https://www.tldraw.dev/docs/persistence#Shape-props-migrations | shape prop migrations}\n\t * guide for more information.\n\t */\n\tstatic migrations?: LegacyMigrations | TLPropsMigrations | MigrationSequence\n\n\t/**\n\t * The type of the shape util, which should match the shape's type.\n\t *\n\t * @public\n\t */\n\tstatic type: string\n\n\t/**\n\t * Get the default props for a shape.\n\t *\n\t * @public\n\t */\n\tabstract getDefaultProps(): Shape['props']\n\n\t/**\n\t * Get the shape's geometry.\n\t *\n\t * @param shape - The shape.\n\t * @param opts - Additional options for the request.\n\t * @public\n\t */\n\tabstract getGeometry(shape: Shape, opts?: TLGeometryOpts): Geometry2d\n\n\t/**\n\t * Get a JSX element for the shape (as an HTML element).\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\tabstract component(shape: Shape): any\n\n\t/**\n\t * Get JSX describing the shape's indicator (as an SVG element).\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\tabstract indicator(shape: Shape): any\n\n\t/**\n\t * Get the font faces that should be rendered in the document in order for this shape to render\n\t * correctly.\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\tgetFontFaces(shape: Shape): TLFontFace[] {\n\t\treturn EMPTY_ARRAY\n\t}\n\n\t/**\n\t * Whether the shape can be snapped to by another shape.\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\tcanSnap(_shape: Shape): boolean {\n\t\treturn true\n\t}\n\n\t/**\n\t * Whether the shape can be tabbed to.\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\tcanTabTo(_shape: Shape): boolean {\n\t\treturn true\n\t}\n\n\t/**\n\t * Whether the shape can be scrolled while editing.\n\t *\n\t * @public\n\t */\n\tcanScroll(_shape: Shape): boolean {\n\t\treturn false\n\t}\n\n\t/**\n\t * Whether the shape can be bound to. See {@link TLShapeUtilCanBindOpts} for details.\n\t *\n\t * @public\n\t */\n\tcanBind(_opts: TLShapeUtilCanBindOpts): boolean {\n\t\treturn true\n\t}\n\n\t/**\n\t * Whether the shape can be double clicked to edit.\n\t *\n\t * @public\n\t */\n\tcanEdit(_shape: Shape): boolean {\n\t\treturn false\n\t}\n\n\t/**\n\t * Whether the shape can be resized.\n\t *\n\t * @public\n\t */\n\tcanResize(_shape: Shape): boolean {\n\t\treturn true\n\t}\n\n\t/**\n\t * When the shape is resized, whether the shape's children should also be resized.\n\t *\n\t * @public\n\t */\n\tcanResizeChildren(_shape: Shape): boolean {\n\t\treturn true\n\t}\n\n\t/**\n\t * Whether the shape can be edited in read-only mode.\n\t *\n\t * @public\n\t */\n\tcanEditInReadonly(_shape: Shape): boolean {\n\t\treturn false\n\t}\n\n\t/**\n\t * Whether the shape can be cropped.\n\t *\n\t * @public\n\t */\n\tcanCrop(_shape: Shape): boolean {\n\t\treturn false\n\t}\n\n\t/**\n\t * Whether the shape can participate in layout functions such as alignment or distribution.\n\t *\n\t * @param shape - The shape.\n\t * @param info - Additional context information: the type of action causing the layout and the\n\t * @public\n\t *\n\t * @public\n\t */\n\tcanBeLaidOut(_shape: Shape, _info: TLShapeUtilCanBeLaidOutOpts): boolean {\n\t\treturn true\n\t}\n\n\t/**\n\t * Does this shape provide a background for its children? If this is true,\n\t * then any children with a `renderBackground` method will have their\n\t * backgrounds rendered _above_ this shape. Otherwise, the children's\n\t * backgrounds will be rendered above either the next ancestor that provides\n\t * a background, or the canvas background.\n\t *\n\t * @internal\n\t */\n\tprovidesBackgroundForChildren(_shape: Shape): boolean {\n\t\treturn false\n\t}\n\n\t/**\n\t * Whether the shape should hide its resize handles when selected.\n\t *\n\t * @public\n\t */\n\thideResizeHandles(_shape: Shape): boolean {\n\t\treturn false\n\t}\n\n\t/**\n\t * Whether the shape should hide its rotation handles when selected.\n\t *\n\t * @public\n\t */\n\thideRotateHandle(_shape: Shape): boolean {\n\t\treturn false\n\t}\n\n\t/**\n\t * Whether the shape should hide its selection bounds background when selected.\n\t *\n\t * @public\n\t */\n\thideSelectionBoundsBg(_shape: Shape): boolean {\n\t\treturn false\n\t}\n\n\t/**\n\t * Whether the shape should hide its selection bounds foreground when selected.\n\t *\n\t * @public\n\t */\n\thideSelectionBoundsFg(_shape: Shape): boolean {\n\t\treturn false\n\t}\n\n\t/**\n\t * Whether the shape's aspect ratio is locked.\n\t *\n\t * @public\n\t */\n\tisAspectRatioLocked(_shape: Shape): boolean {\n\t\treturn false\n\t}\n\n\t/**\n\t * Get a JSX element for the shape (as an HTML element) to be rendered as part of the canvas background - behind any other shape content.\n\t *\n\t * @param shape - The shape.\n\t * @internal\n\t */\n\tbackgroundComponent?(shape: Shape): any\n\n\t/**\n\t * Get the interpolated props for an animating shape. This is an optional method.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * util.getInterpolatedProps?.(startShape, endShape, t)\n\t * ```\n\t *\n\t * @param startShape - The initial shape.\n\t * @param endShape - The initial shape.\n\t * @param progress - The normalized progress between zero (start) and 1 (end).\n\t * @public\n\t */\n\tgetInterpolatedProps?(startShape: Shape, endShape: Shape, progress: number): Shape['props']\n\n\t/**\n\t * Get an array of handle models for the shape. This is an optional method.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * util.getHandles?.(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\tgetHandles?(shape: Shape): TLHandle[]\n\n\t/**\n\t * Get whether the shape can receive children of a given type.\n\t *\n\t * @param shape - The shape.\n\t * @param type - The shape type.\n\t * @public\n\t */\n\tcanReceiveNewChildrenOfType(_shape: Shape, _type: TLShape['type']) {\n\t\treturn false\n\t}\n\n\t/**\n\t * Get the shape as an SVG object.\n\t *\n\t * @param shape - The shape.\n\t * @param ctx - The export context for the SVG - used for adding e.g. \\<def\\>s\n\t * @returns An SVG element.\n\t * @public\n\t */\n\ttoSvg?(shape: Shape, ctx: SvgExportContext): ReactElement | null | Promise<ReactElement | null>\n\n\t/**\n\t * Get the shape's background layer as an SVG object.\n\t *\n\t * @param shape - The shape.\n\t * @param ctx - ctx - The export context for the SVG - used for adding e.g. \\<def\\>s\n\t * @returns An SVG element.\n\t * @public\n\t */\n\ttoBackgroundSvg?(\n\t\tshape: Shape,\n\t\tctx: SvgExportContext\n\t): ReactElement | null | Promise<ReactElement | null>\n\n\t/** @internal */\n\texpandSelectionOutlinePx(shape: Shape): number | Box {\n\t\treturn 0\n\t}\n\n\t/**\n\t * Return elements to be added to the \\<defs\\> section of the canvases SVG context. This can be\n\t * used to define SVG content (e.g. patterns & masks) that can be referred to by ID from svg\n\t * elements returned by `component`.\n\t *\n\t * Each def should have a unique `key`. If multiple defs from different shapes all have the same\n\t * key, only one will be used.\n\t */\n\tgetCanvasSvgDefs(): TLShapeUtilCanvasSvgDef[] {\n\t\treturn []\n\t}\n\n\t/**\n\t * Get the geometry to use when snapping to this this shape in translate/resize operations. See\n\t * {@link BoundsSnapGeometry} for details.\n\t */\n\tgetBoundsSnapGeometry(_shape: Shape): BoundsSnapGeometry {\n\t\treturn {}\n\t}\n\n\t/**\n\t * Get the geometry to use when snapping handles to this shape. See {@link HandleSnapGeometry}\n\t * for details.\n\t */\n\tgetHandleSnapGeometry(_shape: Shape): HandleSnapGeometry {\n\t\treturn {}\n\t}\n\n\tgetText(_shape: Shape): string | undefined {\n\t\treturn undefined\n\t}\n\n\tgetAriaDescriptor(_shape: Shape): string | undefined {\n\t\treturn undefined\n\t}\n\n\t//  Events\n\n\t/**\n\t * A callback called just before a shape is created. This method provides a last chance to modify\n\t * the created shape.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * onBeforeCreate = (next) => {\n\t * \treturn { ...next, x: next.x + 1 }\n\t * }\n\t * ```\n\t *\n\t * @param next - The next shape.\n\t * @returns The next shape or void.\n\t * @public\n\t */\n\tonBeforeCreate?(next: Shape): Shape | void\n\n\t/**\n\t * A callback called just before a shape is updated. This method provides a last chance to modify\n\t * the updated shape.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * onBeforeUpdate = (prev, next) => {\n\t * \tif (prev.x === next.x) {\n\t * \t\treturn { ...next, x: next.x + 1 }\n\t * \t}\n\t * }\n\t * ```\n\t *\n\t * @param prev - The previous shape.\n\t * @param next - The next shape.\n\t * @returns The next shape or void.\n\t * @public\n\t */\n\tonBeforeUpdate?(prev: Shape, next: Shape): Shape | void\n\n\t/**\n\t * A callback called when a shape changes from a crop.\n\t *\n\t * @param shape - The shape at the start of the crop.\n\t * @param info - Info about the crop.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonCrop?(\n\t\tshape: Shape,\n\t\tinfo: TLCropInfo<Shape>\n\t): Omit<TLShapePartial<Shape>, 'id' | 'type'> | undefined | void\n\n\t/**\n\t * A callback called when some other shapes are dragged into this one. This fires when the shapes are dragged over the shape for the first time.\n\t *\n\t * @param shape - The shape.\n\t * @param shapes - The shapes that are being dragged in.\n\t * @public\n\t */\n\tonDragShapesIn?(shape: Shape, shapes: TLShape[], info: TLDragShapesInInfo): void\n\n\t/**\n\t * A callback called when some other shapes are dragged over this one. This fires when the shapes are dragged over the shape for the first time (after the onDragShapesIn callback), and again on every update while the shapes are being dragged.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * onDragShapesOver = (shape, shapes) => {\n\t * \tthis.editor.reparentShapes(shapes, shape.id)\n\t * }\n\t * ```\n\t *\n\t * @param shape - The shape.\n\t * @param shapes - The shapes that are being dragged over this one.\n\t * @public\n\t */\n\tonDragShapesOver?(shape: Shape, shapes: TLShape[], info: TLDragShapesOverInfo): void\n\n\t/**\n\t * A callback called when some other shapes are dragged out of this one.\n\t *\n\t * @param shape - The shape.\n\t * @param shapes - The shapes that are being dragged out.\n\t * @public\n\t */\n\tonDragShapesOut?(shape: Shape, shapes: TLShape[], info: TLDragShapesOutInfo): void\n\n\t/**\n\t * A callback called when some other shapes are dropped over this one.\n\t *\n\t * @param shape - The shape.\n\t * @param shapes - The shapes that are being dropped over this one.\n\t * @public\n\t */\n\tonDropShapesOver?(shape: Shape, shapes: TLShape[], info: TLDropShapesOverInfo): void\n\n\t/**\n\t * A callback called when a shape starts being resized.\n\t *\n\t * @param shape - The shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonResizeStart?(shape: Shape): TLShapePartial<Shape> | void\n\n\t/**\n\t * A callback called when a shape changes from a resize.\n\t *\n\t * @param shape - The shape at the start of the resize.\n\t * @param info - Info about the resize.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonResize?(\n\t\tshape: Shape,\n\t\tinfo: TLResizeInfo<Shape>\n\t): Omit<TLShapePartial<Shape>, 'id' | 'type'> | undefined | void\n\n\t/**\n\t * A callback called when a shape finishes resizing.\n\t *\n\t * @param initial - The shape at the start of the resize.\n\t * @param current - The current shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonResizeEnd?(initial: Shape, current: Shape): TLShapePartial<Shape> | void\n\n\t/**\n\t * A callback called when a shape resize is cancelled.\n\t *\n\t * @param initial - The shape at the start of the resize.\n\t * @param current - The current shape.\n\t * @public\n\t */\n\tonResizeCancel?(initial: Shape, current: Shape): void\n\n\t/**\n\t * A callback called when a shape starts being translated.\n\t *\n\t * @param shape - The shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonTranslateStart?(shape: Shape): TLShapePartial<Shape> | void\n\n\t/**\n\t * A callback called when a shape changes from a translation.\n\t *\n\t * @param initial - The shape at the start of the translation.\n\t * @param current - The current shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonTranslate?(initial: Shape, current: Shape): TLShapePartial<Shape> | void\n\n\t/**\n\t * A callback called when a shape finishes translating.\n\t *\n\t * @param initial - The shape at the start of the translation.\n\t * @param current - The current shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonTranslateEnd?(initial: Shape, current: Shape): TLShapePartial<Shape> | void\n\n\t/**\n\t * A callback called when a shape translation is cancelled.\n\t *\n\t * @param initial - The shape at the start of the translation.\n\t * @param current - The current shape.\n\t * @public\n\t */\n\tonTranslateCancel?(initial: Shape, current: Shape): void\n\n\t/**\n\t * A callback called when a shape's handle starts being dragged.\n\t *\n\t * @param shape - The shape.\n\t * @param info - An object containing the handle and whether the handle is 'precise' or not.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonHandleDragStart?(shape: Shape, info: TLHandleDragInfo<Shape>): TLShapePartial<Shape> | void\n\n\t/**\n\t * A callback called when a shape's handle changes.\n\t *\n\t * @param shape - The current shape.\n\t * @param info - An object containing the handle and whether the handle is 'precise' or not.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonHandleDrag?(shape: Shape, info: TLHandleDragInfo<Shape>): TLShapePartial<Shape> | void\n\n\t/**\n\t * A callback called when a shape's handle finishes being dragged.\n\t *\n\t * @param current - The current shape.\n\t * @param info - An object containing the handle and whether the handle is 'precise' or not.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonHandleDragEnd?(current: Shape, info: TLHandleDragInfo<Shape>): TLShapePartial<Shape> | void\n\n\t/**\n\t * A callback called when a shape's handle drag is cancelled.\n\t *\n\t * @param current - The current shape.\n\t * @param info - An object containing the handle and whether the handle is 'precise' or not.\n\t * @public\n\t */\n\tonHandleDragCancel?(current: Shape, info: TLHandleDragInfo<Shape>): void\n\n\t/**\n\t * A callback called when a shape starts being rotated.\n\t *\n\t * @param shape - The shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonRotateStart?(shape: Shape): TLShapePartial<Shape> | void\n\n\t/**\n\t * A callback called when a shape changes from a rotation.\n\t *\n\t * @param initial - The shape at the start of the rotation.\n\t * @param current - The current shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonRotate?(initial: Shape, current: Shape): TLShapePartial<Shape> | void\n\n\t/**\n\t * A callback called when a shape finishes rotating.\n\t *\n\t * @param initial - The shape at the start of the rotation.\n\t * @param current - The current shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonRotateEnd?(initial: Shape, current: Shape): TLShapePartial<Shape> | void\n\n\t/**\n\t * A callback called when a shape rotation is cancelled.\n\t *\n\t * @param initial - The shape at the start of the rotation.\n\t * @param current - The current shape.\n\t * @public\n\t */\n\tonRotateCancel?(initial: Shape, current: Shape): void\n\n\t/**\n\t * Not currently used.\n\t *\n\t * @internal\n\t */\n\tonBindingChange?(shape: Shape): TLShapePartial<Shape> | void\n\n\t/**\n\t * A callback called when a shape's children change.\n\t *\n\t * @param shape - The shape.\n\t * @returns An array of shape updates, or void.\n\t * @public\n\t */\n\tonChildrenChange?(shape: Shape): TLShapePartial[] | void\n\n\t/**\n\t * A callback called when a shape's handle is double clicked.\n\t *\n\t * @param shape - The shape.\n\t * @param handle - The handle that is double-clicked.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonDoubleClickHandle?(shape: Shape, handle: TLHandle): TLShapePartial<Shape> | void\n\n\t/**\n\t * A callback called when a shape's edge is double clicked.\n\t *\n\t * @param shape - The shape.\n\t * @param info - Info about the edge.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonDoubleClickEdge?(shape: Shape, info: TLClickEventInfo): TLShapePartial<Shape> | void\n\n\t/**\n\t * A callback called when a shape's corner is double clicked.\n\t *\n\t * @param shape - The shape.\n\t * @param info - Info about the corner.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonDoubleClickCorner?(shape: Shape, info: TLClickEventInfo): TLShapePartial<Shape> | void\n\n\t/**\n\t * A callback called when a shape is double clicked.\n\t *\n\t * @param shape - The shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonDoubleClick?(shape: Shape): TLShapePartial<Shape> | void\n\n\t/**\n\t * A callback called when a shape is clicked.\n\t *\n\t * @param shape - The shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonClick?(shape: Shape): TLShapePartial<Shape> | void\n\n\t/**\n\t * A callback called when a shape starts being edited.\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\tonEditStart?(shape: Shape): void\n\n\t/**\n\t * A callback called when a shape finishes being edited.\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\tonEditEnd?(shape: Shape): void\n}\n\n/**\n * Info about a crop.\n * @param handle - The handle being dragged.\n * @param change - The distance the handle is moved.\n * @param initialShape - The shape at the start of the resize.\n * @public\n */\nexport interface TLCropInfo<T extends TLShape> {\n\thandle: SelectionHandle\n\tchange: Vec\n\tcrop: TLShapeCrop\n\tuncroppedSize: { w: number; h: number }\n\tinitialShape: T\n\taspectRatioLocked?: boolean\n}\n\n/** @public */\nexport interface TLDragShapesInInfo {\n\tinitialDraggingOverShapeId: TLShapeId | null\n\tprevDraggingOverShapeId: TLShapeId | null\n\tinitialParentIds: Map<TLShapeId, TLParentId>\n\tinitialIndices: Map<TLShapeId, IndexKey>\n}\n\n/** @public */\nexport interface TLDragShapesOverInfo {\n\tinitialDraggingOverShapeId: TLShapeId | null\n\tinitialParentIds: Map<TLShapeId, TLParentId>\n\tinitialIndices: Map<TLShapeId, IndexKey>\n}\n\n/** @public */\nexport interface TLDragShapesOutInfo {\n\tnextDraggingOverShapeId: TLShapeId | null\n\tinitialDraggingOverShapeId: TLShapeId | null\n\tinitialParentIds: Map<TLShapeId, TLParentId>\n\tinitialIndices: Map<TLShapeId, IndexKey>\n}\n\n/** @public */\nexport interface TLDropShapesOverInfo {\n\tinitialDraggingOverShapeId: TLShapeId | null\n\tinitialParentIds: Map<TLShapeId, TLParentId>\n\tinitialIndices: Map<TLShapeId, IndexKey>\n}\n\n/**\n * The type of resize.\n *\n * 'scale_shape' - The shape is being scaled, usually as part of a larger selection.\n *\n * 'resize_bounds' - The user is directly manipulating an individual shape's bounds using a resize\n * handle. It is up to shape util implementers to decide how they want to handle the two\n * situations.\n *\n * @public\n */\nexport type TLResizeMode = 'scale_shape' | 'resize_bounds'\n\n/**\n * Info about a resize.\n * @param newPoint - The new local position of the shape.\n * @param handle - The handle being dragged.\n * @param mode - The type of resize.\n * @param scaleX - The scale in the x-axis.\n * @param scaleY - The scale in the y-axis.\n * @param initialBounds - The bounds of the shape at the start of the resize.\n * @param initialShape - The shape at the start of the resize.\n * @public\n */\nexport interface TLResizeInfo<T extends TLShape> {\n\tnewPoint: Vec\n\thandle: TLResizeHandle\n\tmode: TLResizeMode\n\tscaleX: number\n\tscaleY: number\n\tinitialBounds: Box\n\tinitialShape: T\n}\n\n/* -------------------- Dragging -------------------- */\n\n/** @public */\nexport interface TLHandleDragInfo<T extends TLShape> {\n\thandle: TLHandle\n\tisPrecise: boolean\n\tinitial?: T | undefined\n}\n"],"names":[],"mappings":";;;;AACA,SAAS,mBAAmB;;AAgFrB,MAAe,UAAyD;IAa9E,YAAmB,MAAA,CAAgB;QAAhB,IAAA,CAAA,MAAA,GAAA;IAAiB;IAAA,sEAAA,GAXpC,OAAO,UAEN,OAAA,EACI;QAEJ,OAAO,cAAc,IAAA,CAAK;YAAA,mBAAA;YAEzB,UAAU;gBAAE,GAAG,IAAA,CAAK,OAAA;gBAAS,GAAG,OAAA;YAAQ,EAAA;QACzC;IACD;IAAA;;;;GAAA,GASA,UAAU,CAAC,EAAA;IAAA;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA,GA6BX,OAAO,MAAA;IAAA;;;;GAAA,GAOP,OAAO,WAAA;IAAA;;;;GAAA,GAOP,OAAO,KAAA;IAAA;;;;;;GAAA,GAyCP,aAAa,KAAA,EAA4B;QACxC,8KAAO,cAAA;IACR;IAAA;;;;;GAAA,GAQA,QAAQ,MAAA,EAAwB;QAC/B,OAAO;IACR;IAAA;;;;;GAAA,GAQA,SAAS,MAAA,EAAwB;QAChC,OAAO;IACR;IAAA;;;;GAAA,GAOA,UAAU,MAAA,EAAwB;QACjC,OAAO;IACR;IAAA;;;;GAAA,GAOA,QAAQ,KAAA,EAAwC;QAC/C,OAAO;IACR;IAAA;;;;GAAA,GAOA,QAAQ,MAAA,EAAwB;QAC/B,OAAO;IACR;IAAA;;;;GAAA,GAOA,UAAU,MAAA,EAAwB;QACjC,OAAO;IACR;IAAA;;;;GAAA,GAOA,kBAAkB,MAAA,EAAwB;QACzC,OAAO;IACR;IAAA;;;;GAAA,GAOA,kBAAkB,MAAA,EAAwB;QACzC,OAAO;IACR;IAAA;;;;GAAA,GAOA,QAAQ,MAAA,EAAwB;QAC/B,OAAO;IACR;IAAA;;;;;;;;GAAA,GAWA,aAAa,MAAA,EAAe,KAAA,EAA6C;QACxE,OAAO;IACR;IAAA;;;;;;;;GAAA,GAWA,8BAA8B,MAAA,EAAwB;QACrD,OAAO;IACR;IAAA;;;;GAAA,GAOA,kBAAkB,MAAA,EAAwB;QACzC,OAAO;IACR;IAAA;;;;GAAA,GAOA,iBAAiB,MAAA,EAAwB;QACxC,OAAO;IACR;IAAA;;;;GAAA,GAOA,sBAAsB,MAAA,EAAwB;QAC7C,OAAO;IACR;IAAA;;;;GAAA,GAOA,sBAAsB,MAAA,EAAwB;QAC7C,OAAO;IACR;IAAA;;;;GAAA,GAOA,oBAAoB,MAAA,EAAwB;QAC3C,OAAO;IACR;IAAA;;;;;;GAAA,GA+CA,4BAA4B,MAAA,EAAe,KAAA,EAAwB;QAClE,OAAO;IACR;IAAA,cAAA,GA0BA,yBAAyB,KAAA,EAA4B;QACpD,OAAO;IACR;IAAA;;;;;;;GAAA,GAUA,mBAA8C;QAC7C,OAAO,CAAC,CAAA;IACT;IAAA;;;GAAA,GAMA,sBAAsB,MAAA,EAAmC;QACxD,OAAO,CAAC;IACT;IAAA;;;GAAA,GAMA,sBAAsB,MAAA,EAAmC;QACxD,OAAO,CAAC;IACT;IAEA,QAAQ,MAAA,EAAmC;QAC1C,OAAO,KAAA;IACR;IAEA,kBAAkB,MAAA,EAAmC;QACpD,OAAO,KAAA;IACR;AA+UD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 248, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/%40tldraw/editor/src/lib/editor/shapes/shared/getPerfectDashProps.ts"],"sourcesContent":["import { TLDefaultDashStyle } from '@tldraw/tlschema'\n\n/** @public */\nexport type PerfectDashTerminal = 'skip' | 'outset' | 'none'\n\n/** @public */\nexport function getPerfectDashProps(\n\ttotalLength: number,\n\tstrokeWidth: number,\n\topts: {\n\t\tstyle?: TLDefaultDashStyle\n\t\tsnap?: number\n\t\tend?: PerfectDashTerminal\n\t\tstart?: PerfectDashTerminal\n\t\tlengthRatio?: number\n\t\tclosed?: boolean\n\t\tforceSolid?: boolean\n\t} = {}\n): {\n\tstrokeDasharray: string\n\tstrokeDashoffset: string\n} {\n\tconst {\n\t\tclosed = false,\n\t\tsnap = 1,\n\t\tstart = 'outset',\n\t\tend = 'outset',\n\t\tlengthRatio = 2,\n\t\tstyle = 'dashed',\n\t\tforceSolid = false,\n\t} = opts\n\n\tlet dashLength = 0\n\tlet dashCount = 0\n\tlet ratio = 1\n\tlet gapLength = 0\n\tlet strokeDashoffset = 0\n\n\tif (forceSolid) {\n\t\treturn {\n\t\t\tstrokeDasharray: 'none',\n\t\t\tstrokeDashoffset: 'none',\n\t\t}\n\t}\n\n\tswitch (style) {\n\t\tcase 'dashed': {\n\t\t\tratio = 1\n\t\t\tdashLength = Math.min(strokeWidth * lengthRatio, totalLength / 4)\n\t\t\tbreak\n\t\t}\n\t\tcase 'dotted': {\n\t\t\tratio = 100\n\t\t\tdashLength = strokeWidth / ratio\n\t\t\tbreak\n\t\t}\n\t\tdefault: {\n\t\t\treturn {\n\t\t\t\tstrokeDasharray: 'none',\n\t\t\t\tstrokeDashoffset: 'none',\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!closed) {\n\t\tif (start === 'outset') {\n\t\t\ttotalLength += dashLength / 2\n\t\t\tstrokeDashoffset += dashLength / 2\n\t\t} else if (start === 'skip') {\n\t\t\ttotalLength -= dashLength\n\t\t\tstrokeDashoffset -= dashLength\n\t\t}\n\n\t\tif (end === 'outset') {\n\t\t\ttotalLength += dashLength / 2\n\t\t} else if (end === 'skip') {\n\t\t\ttotalLength -= dashLength\n\t\t}\n\t}\n\n\tdashCount = Math.floor(totalLength / dashLength / (2 * ratio))\n\tdashCount -= dashCount % snap\n\n\tif (dashCount < 3 && style === 'dashed') {\n\t\tif (totalLength / strokeWidth < 4) {\n\t\t\tdashLength = totalLength\n\t\t\tdashCount = 1\n\t\t\tgapLength = 0\n\t\t} else {\n\t\t\tdashLength = totalLength * (1 / 3)\n\t\t\tgapLength = totalLength * (1 / 3)\n\t\t}\n\t} else {\n\t\tdashLength = totalLength / dashCount / (2 * ratio)\n\n\t\tif (closed) {\n\t\t\tstrokeDashoffset = dashLength / 2\n\t\t\tgapLength = (totalLength - dashCount * dashLength) / dashCount\n\t\t} else {\n\t\t\tgapLength = (totalLength - dashCount * dashLength) / Math.max(1, dashCount - 1)\n\t\t}\n\t}\n\n\treturn {\n\t\tstrokeDasharray: [dashLength, gapLength].join(' '),\n\t\tstrokeDashoffset: strokeDashoffset.toString(),\n\t}\n}\n"],"names":[],"mappings":";;;AAMO,SAAS,oBACf,WAAA,EACA,WAAA,EACA,OAQI,CAAC,CAAA,EAIJ;IACD,MAAM,EACL,SAAS,KAAA,EACT,OAAO,CAAA,EACP,QAAQ,QAAA,EACR,MAAM,QAAA,EACN,cAAc,CAAA,EACd,QAAQ,QAAA,EACR,aAAa,KAAA,EACd,GAAI;IAEJ,IAAI,aAAa;IACjB,IAAI,YAAY;IAChB,IAAI,QAAQ;IACZ,IAAI,YAAY;IAChB,IAAI,mBAAmB;IAEvB,IAAI,YAAY;QACf,OAAO;YACN,iBAAiB;YACjB,kBAAkB;QACnB;IACD;IAEA,OAAQ,OAAO;QACd,KAAK;YAAU;gBACd,QAAQ;gBACR,aAAa,KAAK,GAAA,CAAI,cAAc,aAAa,cAAc,CAAC;gBAChE;YACD;QACA,KAAK;YAAU;gBACd,QAAQ;gBACR,aAAa,cAAc;gBAC3B;YACD;QACA;YAAS;gBACR,OAAO;oBACN,iBAAiB;oBACjB,kBAAkB;gBACnB;YACD;IACD;IAEA,IAAI,CAAC,QAAQ;QACZ,IAAI,UAAU,UAAU;YACvB,eAAe,aAAa;YAC5B,oBAAoB,aAAa;QAClC,OAAA,IAAW,UAAU,QAAQ;YAC5B,eAAe;YACf,oBAAoB;QACrB;QAEA,IAAI,QAAQ,UAAU;YACrB,eAAe,aAAa;QAC7B,OAAA,IAAW,QAAQ,QAAQ;YAC1B,eAAe;QAChB;IACD;IAEA,YAAY,KAAK,KAAA,CAAM,cAAc,aAAA,CAAc,IAAI,KAAA,CAAM;IAC7D,aAAa,YAAY;IAEzB,IAAI,YAAY,KAAK,UAAU,UAAU;QACxC,IAAI,cAAc,cAAc,GAAG;YAClC,aAAa;YACb,YAAY;YACZ,YAAY;QACb,OAAO;YACN,aAAa,cAAA,CAAe,IAAI,CAAA;YAChC,YAAY,cAAA,CAAe,IAAI,CAAA;QAChC;IACD,OAAO;QACN,aAAa,cAAc,YAAA,CAAa,IAAI,KAAA;QAE5C,IAAI,QAAQ;YACX,mBAAmB,aAAa;YAChC,YAAA,CAAa,cAAc,YAAY,UAAA,IAAc;QACtD,OAAO;YACN,YAAA,CAAa,cAAc,YAAY,UAAA,IAAc,KAAK,GAAA,CAAI,GAAG,YAAY,CAAC;QAC/E;IACD;IAEA,OAAO;QACN,iBAAiB;YAAC;YAAY,SAAS;SAAA,CAAE,IAAA,CAAK,GAAG;QACjD,kBAAkB,iBAAiB,QAAA,CAAS;IAC7C;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 335, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/%40tldraw/editor/src/lib/editor/shapes/group/DashedOutlineBox.tsx"],"sourcesContent":["import { useValue } from '@tldraw/state-react'\nimport { useEditor } from '../../../hooks/useEditor'\nimport { Box } from '../../../primitives/Box'\nimport { getPerfectDashProps } from '../shared/getPerfectDashProps'\n\nexport function DashedOutlineBox({ bounds, className }: { bounds: Box; className: string }) {\n\tconst editor = useEditor()\n\n\tconst zoomLevel = useValue('zoom level', () => editor.getZoomLevel(), [editor])\n\n\treturn (\n\t\t<g className={className} pointerEvents=\"none\" strokeLinecap=\"round\" strokeLinejoin=\"round\">\n\t\t\t{bounds.sides.map((side, i) => {\n\t\t\t\tconst { strokeDasharray, strokeDashoffset } = getPerfectDashProps(\n\t\t\t\t\tside[0].dist(side[1]),\n\t\t\t\t\t1 / zoomLevel,\n\t\t\t\t\t{\n\t\t\t\t\t\tstyle: 'dashed',\n\t\t\t\t\t\tlengthRatio: 4,\n\t\t\t\t\t}\n\t\t\t\t)\n\n\t\t\t\treturn (\n\t\t\t\t\t<line\n\t\t\t\t\t\tkey={i}\n\t\t\t\t\t\tx1={side[0].x}\n\t\t\t\t\t\ty1={side[0].y}\n\t\t\t\t\t\tx2={side[1].x}\n\t\t\t\t\t\ty2={side[1].y}\n\t\t\t\t\t\tstrokeDasharray={strokeDasharray}\n\t\t\t\t\t\tstrokeDashoffset={strokeDashoffset}\n\t\t\t\t\t/>\n\t\t\t\t)\n\t\t\t})}\n\t\t</g>\n\t)\n}\n"],"names":[],"mappings":";;;AAuBK;AAvBL,SAAS,gBAAgB;;AACzB,SAAS,iBAAiB;AAE1B,SAAS,2BAA2B;;;;;AAE7B,SAAS,iBAAiB,EAAE,MAAA,EAAQ,SAAA,CAAU,CAAA,EAAuC;IAC3F,MAAM,gMAAS,YAAA,CAAU;IAEzB,MAAM,YAAY,gMAAA,EAAS;gDAAc,IAAM,OAAO,YAAA,CAAa;+CAAG;QAAC,MAAM;KAAC;IAE9E,OACC,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,KAAA;QAAE;QAAsB,eAAc;QAAO,eAAc;QAAQ,gBAAe;QACjF,UAAA,OAAO,KAAA,CAAM,GAAA,CAAI,CAAC,MAAM,MAAM;YAC9B,MAAM,EAAE,eAAA,EAAiB,gBAAA,CAAiB,CAAA,yNAAI,sBAAA,EAC7C,IAAA,CAAK,CAAC,CAAA,CAAE,IAAA,CAAK,IAAA,CAAK,CAAC,CAAC,GACpB,IAAI,WACJ;gBACC,OAAO;gBACP,aAAa;YACd;YAGD,OACC,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,QAAA;gBAEA,IAAI,IAAA,CAAK,CAAC,CAAA,CAAE,CAAA;gBACZ,IAAI,IAAA,CAAK,CAAC,CAAA,CAAE,CAAA;gBACZ,IAAI,IAAA,CAAK,CAAC,CAAA,CAAE,CAAA;gBACZ,IAAI,IAAA,CAAK,CAAC,CAAA,CAAE,CAAA;gBACZ;gBACA;YAAA,GANK;QASR,CAAC;IAAA,CACF;AAEF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 383, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/%40tldraw/editor/src/lib/editor/shapes/group/GroupShapeUtil.tsx"],"sourcesContent":["import { TLGroupShape, groupShapeMigrations, groupShapeProps } from '@tldraw/tlschema'\nimport { SVGContainer } from '../../../components/SVGContainer'\nimport { Geometry2d } from '../../../primitives/geometry/Geometry2d'\nimport { Group2d } from '../../../primitives/geometry/Group2d'\nimport { Rectangle2d } from '../../../primitives/geometry/Rectangle2d'\nimport { ShapeUtil } from '../ShapeUtil'\nimport { DashedOutlineBox } from './DashedOutlineBox'\n\n/** @public */\nexport class GroupShapeUtil extends ShapeUtil<TLGroupShape> {\n\tstatic override type = 'group' as const\n\tstatic override props = groupShapeProps\n\tstatic override migrations = groupShapeMigrations\n\n\toverride hideSelectionBoundsFg() {\n\t\treturn true\n\t}\n\n\toverride canBind() {\n\t\treturn false\n\t}\n\n\tcanResize() {\n\t\treturn true\n\t}\n\n\tcanResizeChildren() {\n\t\treturn true\n\t}\n\n\tgetDefaultProps(): TLGroupShape['props'] {\n\t\treturn {}\n\t}\n\n\tgetGeometry(shape: TLGroupShape): Geometry2d {\n\t\tconst children = this.editor.getSortedChildIdsForParent(shape.id)\n\t\tif (children.length === 0) {\n\t\t\treturn new Rectangle2d({ width: 1, height: 1, isFilled: false })\n\t\t}\n\n\t\treturn new Group2d({\n\t\t\tchildren: children.map((childId) => {\n\t\t\t\tconst shape = this.editor.getShape(childId)!\n\t\t\t\treturn this.editor\n\t\t\t\t\t.getShapeGeometry(childId)\n\t\t\t\t\t.transform(this.editor.getShapeLocalTransform(shape)!, { isLabel: false })\n\t\t\t}),\n\t\t})\n\t}\n\n\tcomponent(shape: TLGroupShape) {\n\t\tconst isErasing = this.editor.getErasingShapeIds().includes(shape.id)\n\n\t\tconst { hintingShapeIds } = this.editor.getCurrentPageState()\n\t\tconst isHintingOtherGroup =\n\t\t\thintingShapeIds.length > 0 &&\n\t\t\thintingShapeIds.some(\n\t\t\t\t(id) =>\n\t\t\t\t\tid !== shape.id &&\n\t\t\t\t\tthis.editor.isShapeOfType<TLGroupShape>(this.editor.getShape(id)!, 'group')\n\t\t\t)\n\n\t\tconst isFocused = this.editor.getCurrentPageState().focusedGroupId !== shape.id\n\n\t\tif (\n\t\t\t!isErasing && // always show the outline while we're erasing the group\n\t\t\t// show the outline while the group is focused unless something outside of the group is being hinted\n\t\t\t// this happens dropping shapes from a group onto some outside group\n\t\t\t(isFocused || isHintingOtherGroup)\n\t\t) {\n\t\t\treturn null\n\t\t}\n\n\t\tconst bounds = this.editor.getShapeGeometry(shape).bounds\n\n\t\treturn (\n\t\t\t<SVGContainer>\n\t\t\t\t<DashedOutlineBox className=\"tl-group\" bounds={bounds} />\n\t\t\t</SVGContainer>\n\t\t)\n\t}\n\n\tindicator(shape: TLGroupShape) {\n\t\t// Not a class component, but eslint can't tell that :(\n\t\tconst bounds = this.editor.getShapeGeometry(shape).bounds\n\t\treturn <DashedOutlineBox className=\"\" bounds={bounds} />\n\t}\n\n\toverride onChildrenChange(group: TLGroupShape) {\n\t\tconst children = this.editor.getSortedChildIdsForParent(group.id)\n\t\tif (children.length === 0) {\n\t\t\tif (this.editor.getCurrentPageState().focusedGroupId === group.id) {\n\t\t\t\tthis.editor.popFocusedGroupId()\n\t\t\t}\n\t\t\tthis.editor.deleteShapes([group.id])\n\t\t\treturn\n\t\t} else if (children.length === 1) {\n\t\t\tif (this.editor.getCurrentPageState().focusedGroupId === group.id) {\n\t\t\t\tthis.editor.popFocusedGroupId()\n\t\t\t}\n\t\t\tthis.editor.reparentShapes(children, group.parentId)\n\t\t\tthis.editor.deleteShapes([group.id])\n\t\t\treturn\n\t\t}\n\t}\n}\n"],"names":["shape"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 494, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/%40tldraw/editor/src/lib/editor/types/SvgExportContext.tsx"],"sourcesContent":["import { TLAssetId } from '@tldraw/tlschema'\nimport { promiseWithResolve } from '@tldraw/utils'\nimport { ReactElement, ReactNode, createContext, useContext, useEffect, useState } from 'react'\nimport { ContainerProvider } from '../../hooks/useContainer'\nimport { EditorProvider } from '../../hooks/useEditor'\nimport { useEvent } from '../../hooks/useEvent'\nimport { Editor } from '../Editor'\n\n/** @public */\nexport interface SvgExportDef {\n\tkey: string\n\tgetElement(): Promise<ReactElement | null> | ReactElement | null\n}\n\n/** @public */\nexport interface SvgExportContext {\n\t/**\n\t * Add contents to the `<defs>` section of the export SVG. Each export def should have a unique\n\t * key. If multiple defs come with the same key, only one will be added.\n\t */\n\taddExportDef(def: SvgExportDef): void\n\n\t/**\n\t * Cause the SVG export to be delayed until the returned promise is resolved. This is useful if\n\t * e.g. your shape loads data dynamically, and you need to prevent the export from happening\n\t * until after the data is loaded.\n\t *\n\t * See also the {@link useDelaySvgExport} hook, which may be a more convenient way to use this\n\t * method depending on your use-case.\n\t */\n\twaitUntil(promise: Promise<void>): void\n\n\t/**\n\t * Resolve an asset URL in the context of this export. Supply the asset ID and the width in\n\t * shape-pixels it'll be displayed at, and this will resolve the asset according to the export\n\t * options.\n\t */\n\tresolveAssetUrl(assetId: TLAssetId, width: number): Promise<string | null>\n\n\t/**\n\t * Whether the export should be in dark mode.\n\t */\n\treadonly isDarkMode: boolean\n\n\t/**\n\t * The scale of the export - how much CSS pixels will be scaled up/down by.\n\t */\n\treadonly scale: number\n\n\t/**\n\t * Use this value to optionally downscale images in the export. If we're exporting directly to\n\t * an SVG, this will usually be null, and you shouldn't downscale images. If the export is to a\n\t * raster format like PNG, this will be the number of raster pixels in the resulting bitmap per\n\t * CSS pixel in the resulting SVG.\n\t */\n\treadonly pixelRatio: number | null\n}\n\nconst Context = createContext<SvgExportContext | null>(null)\nexport function SvgExportContextProvider({\n\tcontext,\n\teditor,\n\tchildren,\n}: {\n\tcontext: SvgExportContext\n\teditor: Editor\n\tchildren: ReactNode\n}) {\n\tconst Provider = editor.options.exportProvider\n\n\treturn (\n\t\t<EditorProvider editor={editor}>\n\t\t\t<ContainerProvider container={editor.getContainer()}>\n\t\t\t\t<Context.Provider value={context}>\n\t\t\t\t\t<Provider>{children}</Provider>\n\t\t\t\t</Context.Provider>\n\t\t\t</ContainerProvider>\n\t\t</EditorProvider>\n\t)\n}\n\n/**\n * Returns the current SVG export context. Returns null if the component isn't being rendered for an\n * SVG export.\n *\n * @public\n */\nexport function useSvgExportContext() {\n\treturn useContext(Context)\n}\n\n/**\n * Delay an SVG export until the returned function is called. This is useful if e.g. your shape\n * loads data dynamically, and you need to prevent the export from happening until after the data is\n * loaded.\n *\n * If used outside of an SVG export, this hook has no effect.\n *\n * @example\n * ```tsx\n * const readyForExport = useDelaySvgExport()\n *\n * return <MyDynamicComponent onDataLoaded={() => readyForExport()} />\n * ```\n *\n * @public\n */\nexport function useDelaySvgExport() {\n\tconst ctx = useContext(Context)\n\tconst [promise] = useState(promiseWithResolve<void>)\n\n\tuseEffect(() => {\n\t\tctx?.waitUntil(promise)\n\t\treturn () => {\n\t\t\tpromise.resolve()\n\t\t}\n\t}, [promise, ctx])\n\n\treturn useEvent(() => {\n\t\tpromise.resolve()\n\t})\n}\n"],"names":[],"mappings":";;;;;AA0EK;AAzEL,SAAS,0BAA0B;;AACnC,SAAkC,eAAe,YAAY,WAAW,gBAAgB;AACxF,SAAS,yBAAyB;AAClC,SAAS,sBAAsB;AAC/B,SAAS,gBAAgB;;;;;;;AAqDzB,MAAM,4KAAU,gBAAA,EAAuC,IAAI;AACpD,SAAS,yBAAyB,EACxC,OAAA,EACA,MAAA,EACA,QAAA,EACD,EAIG;IACF,MAAM,WAAW,OAAO,OAAA,CAAQ,cAAA;IAEhC,OACC,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,qLAAC,iBAAA,EAAA;QAAe;QACf,UAAA,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,wLAAC,oBAAA,EAAA;YAAkB,WAAW,OAAO,YAAA,CAAa;YACjD,UAAA,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,QAAQ,QAAA,EAAR;gBAAiB,OAAO;gBACxB,UAAA,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,UAAA;oBAAU;gBAAA,CAAS;YAAA,CACrB;QAAA,CACD;IAAA,CACD;AAEF;AAQO,SAAS,sBAAsB;IACrC,yKAAO,aAAA,EAAW,OAAO;AAC1B;AAkBO,SAAS,oBAAoB;IACnC,MAAM,MAAM,+KAAA,EAAW,OAAO;IAC9B,MAAM,CAAC,OAAO,CAAA,qKAAI,WAAA,yKAAS,qBAAwB;IAEnD,CAAA,GAAA,6JAAA,CAAA,YAAA;uCAAU,MAAM;YACf,KAAK,UAAU,OAAO;YACtB;+CAAO,MAAM;oBACZ,QAAQ,OAAA,CAAQ;gBACjB;;QACD;sCAAG;QAAC;QAAS,GAAG;KAAC;IAEjB,6LAAO,WAAA;sCAAS,MAAM;YACrB,QAAQ,OAAA,CAAQ;QACjB,CAAC;;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 561, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/%40tldraw/editor/src/lib/editor/derivations/bindingsIndex.ts"],"sourcesContent":["import { Computed, RESET_VALUE, computed, isUninitialized } from '@tldraw/state'\nimport { TLArrowBinding, TLBinding, TLShapeId, TLUnknownBinding } from '@tldraw/tlschema'\nimport { objectMapValues } from '@tldraw/utils'\nimport { Editor } from '../Editor'\n\ntype TLBindingsIndex = Map<TLShapeId, TLBinding[]>\n\nfunction fromScratch(bindingsQuery: Computed<(TLArrowBinding | TLUnknownBinding)[], unknown>) {\n\tconst allBindings = bindingsQuery.get() as TLBinding[]\n\n\tconst shapesToBindings: TLBindingsIndex = new Map()\n\n\tfor (const binding of allBindings) {\n\t\tconst { fromId, toId } = binding\n\t\tconst bindingsForFromShape = shapesToBindings.get(fromId)\n\t\tif (!bindingsForFromShape) {\n\t\t\tshapesToBindings.set(fromId, [binding])\n\t\t} else {\n\t\t\tbindingsForFromShape.push(binding)\n\t\t}\n\t\tconst bindingsForToShape = shapesToBindings.get(toId)\n\t\tif (!bindingsForToShape) {\n\t\t\tshapesToBindings.set(toId, [binding])\n\t\t} else {\n\t\t\tbindingsForToShape.push(binding)\n\t\t}\n\t}\n\n\treturn shapesToBindings\n}\n\nexport const bindingsIndex = (editor: Editor): Computed<TLBindingsIndex> => {\n\tconst { store } = editor\n\tconst bindingsHistory = store.query.filterHistory('binding')\n\tconst bindingsQuery = store.query.records('binding')\n\n\treturn computed<TLBindingsIndex>('arrowBindingsIndex', (_lastValue, lastComputedEpoch) => {\n\t\tif (isUninitialized(_lastValue)) {\n\t\t\treturn fromScratch(bindingsQuery)\n\t\t}\n\n\t\tconst lastValue = _lastValue\n\n\t\tconst diff = bindingsHistory.getDiffSince(lastComputedEpoch)\n\n\t\tif (diff === RESET_VALUE) {\n\t\t\treturn fromScratch(bindingsQuery)\n\t\t}\n\n\t\tlet nextValue: TLBindingsIndex | undefined = undefined\n\n\t\tfunction removingBinding(binding: TLBinding) {\n\t\t\tnextValue ??= new Map(lastValue)\n\t\t\tconst prevFrom = nextValue.get(binding.fromId)\n\t\t\tconst nextFrom = prevFrom?.filter((b) => b.id !== binding.id)\n\t\t\tif (!nextFrom?.length) {\n\t\t\t\tnextValue.delete(binding.fromId)\n\t\t\t} else {\n\t\t\t\tnextValue.set(binding.fromId, nextFrom)\n\t\t\t}\n\t\t\tconst prevTo = nextValue.get(binding.toId)\n\t\t\tconst nextTo = prevTo?.filter((b) => b.id !== binding.id)\n\t\t\tif (!nextTo?.length) {\n\t\t\t\tnextValue.delete(binding.toId)\n\t\t\t} else {\n\t\t\t\tnextValue.set(binding.toId, nextTo)\n\t\t\t}\n\t\t}\n\n\t\tfunction ensureNewArray(shapeId: TLShapeId) {\n\t\t\tnextValue ??= new Map(lastValue)\n\n\t\t\tlet result = nextValue.get(shapeId)\n\t\t\tif (!result) {\n\t\t\t\tresult = []\n\t\t\t\tnextValue.set(shapeId, result)\n\t\t\t} else if (result === lastValue.get(shapeId)) {\n\t\t\t\tresult = result.slice(0)\n\t\t\t\tnextValue.set(shapeId, result)\n\t\t\t}\n\t\t\treturn result\n\t\t}\n\n\t\tfunction addBinding(binding: TLBinding) {\n\t\t\tensureNewArray(binding.fromId).push(binding)\n\t\t\tensureNewArray(binding.toId).push(binding)\n\t\t}\n\n\t\tfor (const changes of diff) {\n\t\t\tfor (const newBinding of objectMapValues(changes.added)) {\n\t\t\t\taddBinding(newBinding)\n\t\t\t}\n\n\t\t\tfor (const [prev, next] of objectMapValues(changes.updated)) {\n\t\t\t\tremovingBinding(prev)\n\t\t\t\taddBinding(next)\n\t\t\t}\n\n\t\t\tfor (const prev of objectMapValues(changes.removed)) {\n\t\t\t\tremovingBinding(prev)\n\t\t\t}\n\t\t}\n\n\t\t// TODO: add diff entries if we need them\n\t\treturn nextValue ?? lastValue\n\t})\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 665, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/%40tldraw/editor/src/lib/editor/derivations/notVisibleShapes.ts"],"sourcesContent":["import { computed, isUninitialized } from '@tldraw/state'\nimport { TLShapeId } from '@tldraw/tlschema'\nimport { Editor } from '../Editor'\n\nfunction fromScratch(editor: Editor): Set<TLShapeId> {\n\tconst shapesIds = editor.getCurrentPageShapeIds()\n\tconst viewportPageBounds = editor.getViewportPageBounds()\n\tconst notVisibleShapes = new Set<TLShapeId>()\n\tshapesIds.forEach((id) => {\n\t\t// If the shape is fully outside of the viewport page bounds, add it to the set.\n\t\t// We'll ignore masks here, since they're more expensive to compute and the overhead is not worth it.\n\t\tconst pageBounds = editor.getShapePageBounds(id)\n\t\tif (pageBounds === undefined || !viewportPageBounds.includes(pageBounds)) {\n\t\t\tnotVisibleShapes.add(id)\n\t\t}\n\t})\n\treturn notVisibleShapes\n}\n\n/**\n * Incremental derivation of not visible shapes.\n * Non visible shapes are shapes outside of the viewport page bounds.\n *\n * @param editor - Instance of the tldraw Editor.\n * @returns Incremental derivation of non visible shapes.\n */\nexport function notVisibleShapes(editor: Editor) {\n\treturn computed<Set<TLShapeId>>('notVisibleShapes', function updateNotVisibleShapes(prevValue) {\n\t\tconst nextValue = fromScratch(editor)\n\n\t\tif (isUninitialized(prevValue)) {\n\t\t\treturn nextValue\n\t\t}\n\n\t\t// If there are more or less shapes, we know there's a change\n\t\tif (prevValue.size !== nextValue.size) return nextValue\n\n\t\t// If any of the old shapes are not in the new set, we know there's a change\n\t\tfor (const prev of prevValue) {\n\t\t\tif (!nextValue.has(prev)) {\n\t\t\t\treturn nextValue\n\t\t\t}\n\t\t}\n\n\t\t// If we've made it here, we know that the set is the same\n\t\treturn prevValue\n\t})\n}\n"],"names":["notVisibleShapes"],"mappings":";;;AAAA,SAAS,UAAU,uBAAuB;;;AAI1C,SAAS,YAAY,MAAA,EAAgC;IACpD,MAAM,YAAY,OAAO,sBAAA,CAAuB;IAChD,MAAM,qBAAqB,OAAO,qBAAA,CAAsB;IACxD,MAAMA,oBAAmB,aAAA,GAAA,IAAI,IAAe;IAC5C,UAAU,OAAA,CAAQ,CAAC,OAAO;QAGzB,MAAM,aAAa,OAAO,kBAAA,CAAmB,EAAE;QAC/C,IAAI,eAAe,KAAA,KAAa,CAAC,mBAAmB,QAAA,CAAS,UAAU,GAAG;YACzEA,kBAAiB,GAAA,CAAI,EAAE;QACxB;IACD,CAAC;IACD,OAAOA;AACR;AASO,SAAS,iBAAiB,MAAA,EAAgB;IAChD,QAAO,sLAAA,EAAyB,oBAAoB,SAAS,uBAAuB,SAAA,EAAW;QAC9F,MAAM,YAAY,YAAY,MAAM;QAEpC,gLAAI,kBAAA,EAAgB,SAAS,GAAG;YAC/B,OAAO;QACR;QAGA,IAAI,UAAU,IAAA,KAAS,UAAU,IAAA,CAAM,CAAA,OAAO;QAG9C,KAAA,MAAW,QAAQ,UAAW;YAC7B,IAAI,CAAC,UAAU,GAAA,CAAI,IAAI,GAAG;gBACzB,OAAO;YACR;QACD;QAGA,OAAO;IACR,CAAC;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 706, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/%40tldraw/editor/src/lib/editor/derivations/parentsToChildren.ts"],"sourcesContent":["import { Computed, computed, isUninitialized, RESET_VALUE } from '@tldraw/state'\nimport { CollectionDiff, RecordsDiff } from '@tldraw/store'\nimport { isShape, TLParentId, TLRecord, TLShape, TLShapeId, TLStore } from '@tldraw/tlschema'\nimport { compact, sortByIndex } from '@tldraw/utils'\n\ntype ParentShapeIdsToChildShapeIds = Record<TLParentId, TLShapeId[]>\n\nfunction fromScratch(\n\tshapeIdsQuery: Computed<Set<TLShapeId>, CollectionDiff<TLShapeId>>,\n\tstore: TLStore\n) {\n\tconst result: ParentShapeIdsToChildShapeIds = {}\n\tconst shapeIds = shapeIdsQuery.get()\n\tconst shapes = Array(shapeIds.size) as TLShape[]\n\tshapeIds.forEach((id) => shapes.push(store.get(id)!))\n\n\t// Sort the shapes by index\n\tshapes.sort(sortByIndex)\n\n\t// Populate the result object with an array for each parent.\n\tshapes.forEach((shape) => {\n\t\tif (!result[shape.parentId]) {\n\t\t\tresult[shape.parentId] = []\n\t\t}\n\t\tresult[shape.parentId].push(shape.id)\n\t})\n\n\treturn result\n}\n\nexport const parentsToChildren = (store: TLStore) => {\n\tconst shapeIdsQuery = store.query.ids<'shape'>('shape')\n\tconst shapeHistory = store.query.filterHistory('shape')\n\n\treturn computed<ParentShapeIdsToChildShapeIds>(\n\t\t'parentsToChildrenWithIndexes',\n\t\t(lastValue, lastComputedEpoch) => {\n\t\t\tif (isUninitialized(lastValue)) {\n\t\t\t\treturn fromScratch(shapeIdsQuery, store)\n\t\t\t}\n\n\t\t\tconst diff = shapeHistory.getDiffSince(lastComputedEpoch)\n\n\t\t\tif (diff === RESET_VALUE) {\n\t\t\t\treturn fromScratch(shapeIdsQuery, store)\n\t\t\t}\n\n\t\t\tif (diff.length === 0) return lastValue\n\n\t\t\tlet newValue: Record<TLParentId, TLShapeId[]> | null = null\n\n\t\t\tconst ensureNewArray = (parentId: TLParentId) => {\n\t\t\t\tif (!newValue) {\n\t\t\t\t\tnewValue = { ...lastValue }\n\t\t\t\t}\n\t\t\t\tif (!newValue[parentId]) {\n\t\t\t\t\tnewValue[parentId] = []\n\t\t\t\t} else if (newValue[parentId] === lastValue[parentId]) {\n\t\t\t\t\tnewValue[parentId] = [...newValue[parentId]!]\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst toSort = new Set<TLShapeId[]>()\n\n\t\t\tlet changes: RecordsDiff<TLRecord>\n\n\t\t\tfor (let i = 0, n = diff.length; i < n; i++) {\n\t\t\t\tchanges = diff[i]\n\n\t\t\t\t// Iterate through the added shapes, add them to the new value and mark them for sorting\n\t\t\t\tfor (const record of Object.values(changes.added)) {\n\t\t\t\t\tif (!isShape(record)) continue\n\t\t\t\t\tensureNewArray(record.parentId)\n\t\t\t\t\tnewValue![record.parentId].push(record.id)\n\t\t\t\t\ttoSort.add(newValue![record.parentId])\n\t\t\t\t}\n\n\t\t\t\t// Iterate through the updated shapes, add them to their parents in the new value and mark them for sorting\n\t\t\t\tfor (const [from, to] of Object.values(changes.updated)) {\n\t\t\t\t\tif (!isShape(to)) continue\n\t\t\t\t\tif (!isShape(from)) continue\n\n\t\t\t\t\tif (from.parentId !== to.parentId) {\n\t\t\t\t\t\t// If the parents have changed, remove the new value from the old parent and add it to the new parent\n\t\t\t\t\t\tensureNewArray(from.parentId)\n\t\t\t\t\t\tensureNewArray(to.parentId)\n\t\t\t\t\t\tnewValue![from.parentId].splice(newValue![from.parentId].indexOf(to.id), 1)\n\t\t\t\t\t\tnewValue![to.parentId].push(to.id)\n\t\t\t\t\t\ttoSort.add(newValue![to.parentId])\n\t\t\t\t\t} else if (from.index !== to.index) {\n\t\t\t\t\t\t// If the parent is the same but the index has changed (e.g. if they've been reordered), update the parent's array at the new index\n\t\t\t\t\t\tensureNewArray(to.parentId)\n\t\t\t\t\t\tconst idx = newValue![to.parentId].indexOf(to.id)\n\t\t\t\t\t\tnewValue![to.parentId][idx] = to.id\n\t\t\t\t\t\ttoSort.add(newValue![to.parentId])\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Iterate through the removed shapes, remove them from their parents in new value\n\t\t\t\tfor (const record of Object.values(changes.removed)) {\n\t\t\t\t\tif (!isShape(record)) continue\n\t\t\t\t\tensureNewArray(record.parentId)\n\t\t\t\t\tnewValue![record.parentId].splice(newValue![record.parentId].indexOf(record.id), 1)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Sort the arrays that have been marked for sorting\n\t\t\tfor (const arr of toSort) {\n\t\t\t\t// It's possible that some of the shapes may be deleted. But in which case would this be so?\n\t\t\t\tconst shapesInArr = compact(arr.map((id) => store.get(id)))\n\t\t\t\tshapesInArr.sort(sortByIndex)\n\t\t\t\tarr.splice(0, arr.length, ...shapesInArr.map((shape) => shape.id))\n\t\t\t}\n\n\t\t\treturn newValue ?? lastValue\n\t\t}\n\t)\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 809, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/%40tldraw/editor/src/lib/editor/derivations/shapeIdsInCurrentPage.ts"],"sourcesContent":["import { computed, isUninitialized, RESET_VALUE, withDiff } from '@tldraw/state'\nimport { IncrementalSetConstructor } from '@tldraw/store'\nimport {\n\tisPageId,\n\tisShape,\n\tisShapeId,\n\tTLPageId,\n\tTLShape,\n\tTLShapeId,\n\tTLStore,\n} from '@tldraw/tlschema'\n\n/**\n * Get whether a shape is in the current page.\n *\n * @param store - The tldraw store.\n * @param pageId - The id of the page to check.\n * @param shape - The the shape to check.\n */\nconst isShapeInPage = (store: TLStore, pageId: TLPageId, shape: TLShape): boolean => {\n\twhile (!isPageId(shape.parentId)) {\n\t\tconst parent = store.get(shape.parentId)\n\t\tif (!parent) return false\n\t\tshape = parent\n\t}\n\n\treturn shape.parentId === pageId\n}\n\n/**\n * A derivation that returns a list of shape ids in the current page.\n *\n * @param store - The tldraw store.\n * @param getCurrentPageId - A function that returns the current page id.\n */\nexport const deriveShapeIdsInCurrentPage = (store: TLStore, getCurrentPageId: () => TLPageId) => {\n\tconst shapesIndex = store.query.ids('shape')\n\tlet lastPageId: null | TLPageId = null\n\tfunction fromScratch() {\n\t\tconst currentPageId = getCurrentPageId()\n\t\tlastPageId = currentPageId\n\t\treturn new Set(\n\t\t\t[...shapesIndex.get()].filter((id) => isShapeInPage(store, currentPageId, store.get(id)!))\n\t\t)\n\t}\n\treturn computed<Set<TLShapeId>>('_shapeIdsInCurrentPage', (prevValue, lastComputedEpoch) => {\n\t\tif (isUninitialized(prevValue)) {\n\t\t\treturn fromScratch()\n\t\t}\n\n\t\tconst currentPageId = getCurrentPageId()\n\n\t\tif (currentPageId !== lastPageId) {\n\t\t\treturn fromScratch()\n\t\t}\n\n\t\tconst diff = store.history.getDiffSince(lastComputedEpoch)\n\n\t\tif (diff === RESET_VALUE) {\n\t\t\treturn fromScratch()\n\t\t}\n\n\t\tconst builder = new IncrementalSetConstructor<TLShapeId>(\n\t\t\tprevValue\n\t\t) as IncrementalSetConstructor<TLShapeId>\n\n\t\tfor (const changes of diff) {\n\t\t\tfor (const record of Object.values(changes.added)) {\n\t\t\t\tif (isShape(record) && isShapeInPage(store, currentPageId, record)) {\n\t\t\t\t\tbuilder.add(record.id)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const [_from, to] of Object.values(changes.updated)) {\n\t\t\t\tif (isShape(to)) {\n\t\t\t\t\tif (isShapeInPage(store, currentPageId, to)) {\n\t\t\t\t\t\tbuilder.add(to.id)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbuilder.remove(to.id)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const id of Object.keys(changes.removed)) {\n\t\t\t\tif (isShapeId(id)) {\n\t\t\t\t\tbuilder.remove(id)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst result = builder.get()\n\t\tif (!result) {\n\t\t\treturn prevValue\n\t\t}\n\n\t\treturn withDiff(result.value, result.diff)\n\t})\n}\n"],"names":[],"mappings":";;;AAAA,SAAS,UAAU,iBAAiB,aAAa,gBAAgB;;;AACjE,SAAS,iCAAiC;;;;AAC1C;;;;AAiBA,MAAM,gBAAgB,CAAC,OAAgB,QAAkB,UAA4B;IACpF,MAAO,kLAAC,WAAA,EAAS,MAAM,QAAQ,EAAG;QACjC,MAAM,SAAS,MAAM,GAAA,CAAI,MAAM,QAAQ;QACvC,IAAI,CAAC,OAAQ,CAAA,OAAO;QACpB,QAAQ;IACT;IAEA,OAAO,MAAM,QAAA,KAAa;AAC3B;AAQO,MAAM,8BAA8B,CAAC,OAAgB,qBAAqC;IAChG,MAAM,cAAc,MAAM,KAAA,CAAM,GAAA,CAAI,OAAO;IAC3C,IAAI,aAA8B;IAClC,SAAS,cAAc;QACtB,MAAM,gBAAgB,iBAAiB;QACvC,aAAa;QACb,OAAO,IAAI,IACV,CAAC;eAAG,YAAY,GAAA,CAAI,CAAC;SAAA,CAAE,MAAA,CAAO,CAAC,KAAO,cAAc,OAAO,eAAe,MAAM,GAAA,CAAI,EAAE,CAAE,CAAC;IAE3F;IACA,mLAAO,WAAA,EAAyB,0BAA0B,CAAC,WAAW,sBAAsB;QAC3F,QAAI,0LAAA,EAAgB,SAAS,GAAG;YAC/B,OAAO,YAAY;QACpB;QAEA,MAAM,gBAAgB,iBAAiB;QAEvC,IAAI,kBAAkB,YAAY;YACjC,OAAO,YAAY;QACpB;QAEA,MAAM,OAAO,MAAM,OAAA,CAAQ,YAAA,CAAa,iBAAiB;QAEzD,IAAI,8KAAS,cAAA,EAAa;YACzB,OAAO,YAAY;QACpB;QAEA,MAAM,UAAU,6LAAI,4BAAA,CACnB;QAGD,KAAA,MAAW,WAAW,KAAM;YAC3B,KAAA,MAAW,UAAU,OAAO,MAAA,CAAO,QAAQ,KAAK,EAAG;gBAClD,sLAAI,UAAA,EAAQ,MAAM,KAAK,cAAc,OAAO,eAAe,MAAM,GAAG;oBACnE,QAAQ,GAAA,CAAI,OAAO,EAAE;gBACtB;YACD;YAEA,KAAA,MAAW,CAAC,OAAO,EAAE,CAAA,IAAK,OAAO,MAAA,CAAO,QAAQ,OAAO,EAAG;gBACzD,sLAAI,UAAA,EAAQ,EAAE,GAAG;oBAChB,IAAI,cAAc,OAAO,eAAe,EAAE,GAAG;wBAC5C,QAAQ,GAAA,CAAI,GAAG,EAAE;oBAClB,OAAO;wBACN,QAAQ,MAAA,CAAO,GAAG,EAAE;oBACrB;gBACD;YACD;YAEA,KAAA,MAAW,MAAM,OAAO,IAAA,CAAK,QAAQ,OAAO,EAAG;gBAC9C,sLAAI,YAAA,EAAU,EAAE,GAAG;oBAClB,QAAQ,MAAA,CAAO,EAAE;gBAClB;YACD;QACD;QAEA,MAAM,SAAS,QAAQ,GAAA,CAAI;QAC3B,IAAI,CAAC,QAAQ;YACZ,OAAO;QACR;QAEA,mLAAO,WAAA,EAAS,OAAO,KAAA,EAAO,OAAO,IAAI;IAC1C,CAAC;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 890, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/%40tldraw/editor/src/lib/editor/managers/ClickManager/ClickManager.ts"],"sourcesContent":["import { bind, uniqueId } from '@tldraw/utils'\nimport { Vec } from '../../../primitives/Vec'\nimport type { Editor } from '../../Editor'\nimport { TLClickEventInfo, TLPointerEventInfo } from '../../types/event-types'\n\n/** @public */\nexport type TLClickState =\n\t| 'idle'\n\t| 'pendingDouble'\n\t| 'pendingTriple'\n\t| 'pendingQuadruple'\n\t| 'pendingOverflow'\n\t| 'overflow'\n\nconst MAX_CLICK_DISTANCE = 40\n\n/** @public */\nexport class ClickManager {\n\tconstructor(public editor: Editor) {}\n\n\tprivate _clickId = ''\n\n\tprivate _clickTimeout?: any\n\n\tprivate _clickScreenPoint?: Vec\n\n\tprivate _previousScreenPoint?: Vec\n\n\t@bind\n\t_getClickTimeout(state: TLClickState, id = uniqueId()) {\n\t\tthis._clickId = id\n\t\tclearTimeout(this._clickTimeout)\n\t\tthis._clickTimeout = this.editor.timers.setTimeout(\n\t\t\t() => {\n\t\t\t\tif (this._clickState === state && this._clickId === id) {\n\t\t\t\t\tswitch (this._clickState) {\n\t\t\t\t\t\tcase 'pendingTriple': {\n\t\t\t\t\t\t\tthis.editor.dispatch({\n\t\t\t\t\t\t\t\t...this.lastPointerInfo,\n\t\t\t\t\t\t\t\ttype: 'click',\n\t\t\t\t\t\t\t\tname: 'double_click',\n\t\t\t\t\t\t\t\tphase: 'settle',\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'pendingQuadruple': {\n\t\t\t\t\t\t\tthis.editor.dispatch({\n\t\t\t\t\t\t\t\t...this.lastPointerInfo,\n\t\t\t\t\t\t\t\ttype: 'click',\n\t\t\t\t\t\t\t\tname: 'triple_click',\n\t\t\t\t\t\t\t\tphase: 'settle',\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'pendingOverflow': {\n\t\t\t\t\t\t\tthis.editor.dispatch({\n\t\t\t\t\t\t\t\t...this.lastPointerInfo,\n\t\t\t\t\t\t\t\ttype: 'click',\n\t\t\t\t\t\t\t\tname: 'quadruple_click',\n\t\t\t\t\t\t\t\tphase: 'settle',\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\t// noop\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._clickState = 'idle'\n\t\t\t\t}\n\t\t\t},\n\t\t\tstate === 'idle' || state === 'pendingDouble'\n\t\t\t\t? this.editor.options.doubleClickDurationMs\n\t\t\t\t: this.editor.options.multiClickDurationMs\n\t\t)\n\t}\n\n\t/**\n\t * The current click state.\n\t *\n\t * @internal\n\t */\n\tprivate _clickState?: TLClickState = 'idle'\n\n\t/**\n\t * The current click state.\n\t *\n\t * @public\n\t */\n\t// eslint-disable-next-line no-restricted-syntax\n\tget clickState() {\n\t\treturn this._clickState\n\t}\n\n\tlastPointerInfo = {} as TLPointerEventInfo\n\n\thandlePointerEvent(info: TLPointerEventInfo): TLPointerEventInfo | TLClickEventInfo {\n\t\tswitch (info.name) {\n\t\t\tcase 'pointer_down': {\n\t\t\t\tif (!this._clickState) return info\n\t\t\t\tthis._clickScreenPoint = Vec.From(info.point)\n\n\t\t\t\tif (\n\t\t\t\t\tthis._previousScreenPoint &&\n\t\t\t\t\tVec.Dist2(this._previousScreenPoint, this._clickScreenPoint) > MAX_CLICK_DISTANCE ** 2\n\t\t\t\t) {\n\t\t\t\t\tthis._clickState = 'idle'\n\t\t\t\t}\n\n\t\t\t\tthis._previousScreenPoint = this._clickScreenPoint\n\n\t\t\t\tthis.lastPointerInfo = info\n\n\t\t\t\tswitch (this._clickState) {\n\t\t\t\t\tcase 'pendingDouble': {\n\t\t\t\t\t\tthis._clickState = 'pendingTriple'\n\t\t\t\t\t\tthis._clickTimeout = this._getClickTimeout(this._clickState)\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t...info,\n\t\t\t\t\t\t\ttype: 'click',\n\t\t\t\t\t\t\tname: 'double_click',\n\t\t\t\t\t\t\tphase: 'down',\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcase 'pendingTriple': {\n\t\t\t\t\t\tthis._clickState = 'pendingQuadruple'\n\t\t\t\t\t\tthis._clickTimeout = this._getClickTimeout(this._clickState)\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t...info,\n\t\t\t\t\t\t\ttype: 'click',\n\t\t\t\t\t\t\tname: 'triple_click',\n\t\t\t\t\t\t\tphase: 'down',\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcase 'pendingQuadruple': {\n\t\t\t\t\t\tthis._clickState = 'pendingOverflow'\n\t\t\t\t\t\tthis._clickTimeout = this._getClickTimeout(this._clickState)\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t...info,\n\t\t\t\t\t\t\ttype: 'click',\n\t\t\t\t\t\t\tname: 'quadruple_click',\n\t\t\t\t\t\t\tphase: 'down',\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcase 'idle': {\n\t\t\t\t\t\tthis._clickState = 'pendingDouble'\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tcase 'pendingOverflow': {\n\t\t\t\t\t\tthis._clickState = 'overflow'\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\t// overflow\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis._clickTimeout = this._getClickTimeout(this._clickState)\n\t\t\t\treturn info\n\t\t\t}\n\t\t\tcase 'pointer_up': {\n\t\t\t\tif (!this._clickState) return info\n\t\t\t\tthis._clickScreenPoint = Vec.From(info.point)\n\n\t\t\t\tswitch (this._clickState) {\n\t\t\t\t\tcase 'pendingTriple': {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t...this.lastPointerInfo,\n\t\t\t\t\t\t\ttype: 'click',\n\t\t\t\t\t\t\tname: 'double_click',\n\t\t\t\t\t\t\tphase: 'up',\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcase 'pendingQuadruple': {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t...this.lastPointerInfo,\n\t\t\t\t\t\t\ttype: 'click',\n\t\t\t\t\t\t\tname: 'triple_click',\n\t\t\t\t\t\t\tphase: 'up',\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcase 'pendingOverflow': {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t...this.lastPointerInfo,\n\t\t\t\t\t\t\ttype: 'click',\n\t\t\t\t\t\t\tname: 'quadruple_click',\n\t\t\t\t\t\t\tphase: 'up',\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\t// idle, pendingDouble, overflow\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn info\n\t\t\t}\n\t\t\tcase 'pointer_move': {\n\t\t\t\tif (\n\t\t\t\t\tthis._clickState !== 'idle' &&\n\t\t\t\t\tthis._clickScreenPoint &&\n\t\t\t\t\tVec.Dist2(this._clickScreenPoint, this.editor.inputs.currentScreenPoint) >\n\t\t\t\t\t\t(this.editor.getInstanceState().isCoarsePointer\n\t\t\t\t\t\t\t? this.editor.options.coarseDragDistanceSquared\n\t\t\t\t\t\t\t: this.editor.options.dragDistanceSquared)\n\t\t\t\t) {\n\t\t\t\t\tthis.cancelDoubleClickTimeout()\n\t\t\t\t}\n\t\t\t\treturn info\n\t\t\t}\n\t\t}\n\t\treturn info\n\t}\n\n\t/**\n\t * Cancel the double click timeout.\n\t *\n\t * @internal\n\t */\n\t@bind\n\tcancelDoubleClickTimeout() {\n\t\tthis._clickTimeout = clearTimeout(this._clickTimeout)\n\t\tthis._clickState = 'idle'\n\t}\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1181, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/%40tldraw/editor/src/lib/editor/managers/EdgeScrollManager/EdgeScrollManager.ts"],"sourcesContent":["import { Vec } from '../../../primitives/Vec'\nimport { EASINGS } from '../../../primitives/easings'\nimport { Editor } from '../../Editor'\n\n/** @public */\nexport class EdgeScrollManager {\n\tconstructor(public editor: Editor) {}\n\n\tprivate _isEdgeScrolling = false\n\tprivate _edgeScrollDuration = -1\n\n\t/**\n\t * Update the camera position when the mouse is close to the edge of the screen.\n\t * Run this on every tick when in a state where edge scrolling is enabled.\n\t *\n\t * @public\n\t */\n\tupdateEdgeScrolling(elapsed: number) {\n\t\tconst { editor } = this\n\t\tconst edgeScrollProximityFactor = this.getEdgeScroll()\n\t\tif (edgeScrollProximityFactor.x === 0 && edgeScrollProximityFactor.y === 0) {\n\t\t\tif (this._isEdgeScrolling) {\n\t\t\t\tthis._isEdgeScrolling = false\n\t\t\t\tthis._edgeScrollDuration = 0\n\t\t\t}\n\t\t} else {\n\t\t\tif (!this._isEdgeScrolling) {\n\t\t\t\tthis._isEdgeScrolling = true\n\t\t\t\tthis._edgeScrollDuration = 0\n\t\t\t}\n\t\t\tthis._edgeScrollDuration += elapsed\n\t\t\tif (this._edgeScrollDuration > editor.options.edgeScrollDelay) {\n\t\t\t\tconst eased =\n\t\t\t\t\teditor.options.edgeScrollEaseDuration > 0\n\t\t\t\t\t\t? EASINGS.easeInCubic(\n\t\t\t\t\t\t\t\tMath.min(\n\t\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\t\tthis._edgeScrollDuration /\n\t\t\t\t\t\t\t\t\t\t(editor.options.edgeScrollDelay + editor.options.edgeScrollEaseDuration)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t: 1\n\t\t\t\tthis.moveCameraWhenCloseToEdge({\n\t\t\t\t\tx: edgeScrollProximityFactor.x * eased,\n\t\t\t\t\ty: edgeScrollProximityFactor.y * eased,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Helper function to get the scroll proximity factor for a given position.\n\t * @param position - The mouse position on the axis.\n\t * @param dimension - The component dimension on the axis.\n\t * @param isCoarse - Whether the pointer is coarse.\n\t * @param insetStart - Whether the pointer is inset at the start of the axis.\n\t * @param insetEnd - Whether the pointer is inset at the end of the axis.\n\t * @internal\n\t */\n\tprivate getEdgeProximityFactors(\n\t\tposition: number,\n\t\tdimension: number,\n\t\tisCoarse: boolean,\n\t\tinsetStart: boolean,\n\t\tinsetEnd: boolean\n\t) {\n\t\tconst { editor } = this\n\t\tconst dist = editor.options.edgeScrollDistance\n\t\tconst pw = isCoarse ? editor.options.coarsePointerWidth : 0 // pointer width\n\t\tconst pMin = position - pw\n\t\tconst pMax = position + pw\n\t\tconst min = insetStart ? 0 : dist\n\t\tconst max = insetEnd ? dimension : dimension - dist\n\t\tif (pMin < min) {\n\t\t\treturn Math.min(1, (min - pMin) / dist)\n\t\t} else if (pMax > max) {\n\t\t\treturn -Math.min(1, (pMax - max) / dist)\n\t\t}\n\t\treturn 0\n\t}\n\n\tprivate getEdgeScroll() {\n\t\tconst { editor } = this\n\t\tconst {\n\t\t\tinputs: {\n\t\t\t\tcurrentScreenPoint: { x, y },\n\t\t\t},\n\t\t} = editor\n\t\tconst screenBounds = editor.getViewportScreenBounds()\n\n\t\tconst {\n\t\t\tisCoarsePointer,\n\t\t\tinsets: [t, r, b, l],\n\t\t} = editor.getInstanceState()\n\t\tconst proximityFactorX = this.getEdgeProximityFactors(x, screenBounds.w, isCoarsePointer, l, r)\n\t\tconst proximityFactorY = this.getEdgeProximityFactors(y, screenBounds.h, isCoarsePointer, t, b)\n\n\t\treturn {\n\t\t\tx: proximityFactorX,\n\t\t\ty: proximityFactorY,\n\t\t}\n\t}\n\n\t/**\n\t * Moves the camera when the mouse is close to the edge of the screen.\n\t * @public\n\t */\n\tprivate moveCameraWhenCloseToEdge(proximityFactor: { x: number; y: number }) {\n\t\tconst { editor } = this\n\t\tif (!editor.inputs.isDragging || editor.inputs.isPanning || editor.getCameraOptions().isLocked)\n\t\t\treturn\n\n\t\tif (proximityFactor.x === 0 && proximityFactor.y === 0) return\n\n\t\tconst screenBounds = editor.getViewportScreenBounds()\n\n\t\t// Determines how much the speed is affected by the screen size\n\t\tconst screenSizeFactorX = screenBounds.w < 1000 ? 0.612 : 1\n\t\tconst screenSizeFactorY = screenBounds.h < 1000 ? 0.612 : 1\n\n\t\t// Determines the base speed of the scroll\n\t\tconst zoomLevel = editor.getZoomLevel()\n\t\tconst pxSpeed = editor.user.getEdgeScrollSpeed() * editor.options.edgeScrollSpeed\n\t\tconst scrollDeltaX = (pxSpeed * proximityFactor.x * screenSizeFactorX) / zoomLevel\n\t\tconst scrollDeltaY = (pxSpeed * proximityFactor.y * screenSizeFactorY) / zoomLevel\n\n\t\t// update the camera\n\t\tconst { x, y, z } = editor.getCamera()\n\t\teditor.setCamera(new Vec(x + scrollDeltaX, y + scrollDeltaY, z))\n\t}\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1283, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/%40tldraw/editor/src/lib/editor/managers/FocusManager/FocusManager.ts"],"sourcesContent":["import type { Editor } from '../../Editor'\n\n/**\n * A manager for ensuring correct focus across the editor.\n * It will listen for changes in the instance state to make sure the\n * container is focused when the editor is focused.\n * Also, it will make sure that the focus is on things like text\n * labels when the editor is in editing mode.\n *\n * @internal\n */\nexport class FocusManager {\n\tprivate disposeSideEffectListener?: () => void\n\n\tconstructor(\n\t\tpublic editor: Editor,\n\t\tautoFocus?: boolean\n\t) {\n\t\tthis.disposeSideEffectListener = editor.sideEffects.registerAfterChangeHandler(\n\t\t\t'instance',\n\t\t\t(prev, next) => {\n\t\t\t\tif (prev.isFocused !== next.isFocused) {\n\t\t\t\t\tthis.updateContainerClass()\n\t\t\t\t}\n\t\t\t}\n\t\t)\n\n\t\tconst currentFocusState = editor.getInstanceState().isFocused\n\t\tif (autoFocus !== currentFocusState) {\n\t\t\teditor.updateInstanceState({ isFocused: !!autoFocus })\n\t\t}\n\t\tthis.updateContainerClass()\n\n\t\tdocument.body.addEventListener('keydown', this.handleKeyDown.bind(this))\n\t\tdocument.body.addEventListener('mousedown', this.handleMouseDown.bind(this))\n\t}\n\n\t/**\n\t * The editor's focus state and the container's focus state\n\t * are not necessarily always in sync. For that reason we\n\t * can't rely on the css `:focus` or `:focus-within` selectors to style the\n\t * editor when it is in focus.\n\t *\n\t * For that reason we synchronize the editor's focus state with a\n\t * special class on the container: tl-container__focused\n\t */\n\tprivate updateContainerClass() {\n\t\tconst container = this.editor.getContainer()\n\t\tconst instanceState = this.editor.getInstanceState()\n\n\t\tif (instanceState.isFocused) {\n\t\t\tcontainer.classList.add('tl-container__focused')\n\t\t} else {\n\t\t\tcontainer.classList.remove('tl-container__focused')\n\t\t}\n\t\tcontainer.classList.add('tl-container__no-focus-ring')\n\t}\n\n\tprivate handleKeyDown(keyEvent: KeyboardEvent) {\n\t\tconst container = this.editor.getContainer()\n\t\tif (this.editor.isIn('select.editing_shape')) return\n\t\tif (document.activeElement === container && this.editor.getSelectedShapeIds().length > 0) return\n\t\tif (['Tab', 'ArrowUp', 'ArrowDown'].includes(keyEvent.key)) {\n\t\t\tcontainer.classList.remove('tl-container__no-focus-ring')\n\t\t}\n\t}\n\n\tprivate handleMouseDown() {\n\t\tconst container = this.editor.getContainer()\n\t\tcontainer.classList.add('tl-container__no-focus-ring')\n\t}\n\n\tfocus() {\n\t\tthis.editor.getContainer().focus()\n\t}\n\n\tblur() {\n\t\tthis.editor.complete() // stop any interaction\n\t\tthis.editor.getContainer().blur() // blur the container\n\t}\n\n\tdispose() {\n\t\tdocument.body.removeEventListener('keydown', this.handleKeyDown.bind(this))\n\t\tdocument.body.removeEventListener('mousedown', this.handleMouseDown.bind(this))\n\t\tthis.disposeSideEffectListener?.()\n\t}\n}\n"],"names":[],"mappings":";;;AAWO,MAAM,aAAa;IAGzB,YACQ,MAAA,EACP,SAAA,CACC;QAFM,IAAA,CAAA,MAAA,GAAA;QAGP,IAAA,CAAK,yBAAA,GAA4B,OAAO,WAAA,CAAY,0BAAA,CACnD,YACA,CAAC,MAAM,SAAS;YACf,IAAI,KAAK,SAAA,KAAc,KAAK,SAAA,EAAW;gBACtC,IAAA,CAAK,oBAAA,CAAqB;YAC3B;QACD;QAGD,MAAM,oBAAoB,OAAO,gBAAA,CAAiB,EAAE,SAAA;QACpD,IAAI,cAAc,mBAAmB;YACpC,OAAO,mBAAA,CAAoB;gBAAE,WAAW,CAAC,CAAC;YAAU,CAAC;QACtD;QACA,IAAA,CAAK,oBAAA,CAAqB;QAE1B,SAAS,IAAA,CAAK,gBAAA,CAAiB,WAAW,IAAA,CAAK,aAAA,CAAc,IAAA,CAAK,IAAI,CAAC;QACvE,SAAS,IAAA,CAAK,gBAAA,CAAiB,aAAa,IAAA,CAAK,eAAA,CAAgB,IAAA,CAAK,IAAI,CAAC;IAC5E;IAvBQ,0BAAA;IAAA;;;;;;;;GAAA,GAkCA,uBAAuB;QAC9B,MAAM,YAAY,IAAA,CAAK,MAAA,CAAO,YAAA,CAAa;QAC3C,MAAM,gBAAgB,IAAA,CAAK,MAAA,CAAO,gBAAA,CAAiB;QAEnD,IAAI,cAAc,SAAA,EAAW;YAC5B,UAAU,SAAA,CAAU,GAAA,CAAI,uBAAuB;QAChD,OAAO;YACN,UAAU,SAAA,CAAU,MAAA,CAAO,uBAAuB;QACnD;QACA,UAAU,SAAA,CAAU,GAAA,CAAI,6BAA6B;IACtD;IAEQ,cAAc,QAAA,EAAyB;QAC9C,MAAM,YAAY,IAAA,CAAK,MAAA,CAAO,YAAA,CAAa;QAC3C,IAAI,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,sBAAsB,EAAG,CAAA;QAC9C,IAAI,SAAS,aAAA,KAAkB,aAAa,IAAA,CAAK,MAAA,CAAO,mBAAA,CAAoB,EAAE,MAAA,GAAS,EAAG,CAAA;QAC1F,IAAI;YAAC;YAAO;YAAW,WAAW;SAAA,CAAE,QAAA,CAAS,SAAS,GAAG,GAAG;YAC3D,UAAU,SAAA,CAAU,MAAA,CAAO,6BAA6B;QACzD;IACD;IAEQ,kBAAkB;QACzB,MAAM,YAAY,IAAA,CAAK,MAAA,CAAO,YAAA,CAAa;QAC3C,UAAU,SAAA,CAAU,GAAA,CAAI,6BAA6B;IACtD;IAEA,QAAQ;QACP,IAAA,CAAK,MAAA,CAAO,YAAA,CAAa,EAAE,KAAA,CAAM;IAClC;IAEA,OAAO;QACN,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS;QACrB,IAAA,CAAK,MAAA,CAAO,YAAA,CAAa,EAAE,IAAA,CAAK;IACjC;IAEA,UAAU;QACT,SAAS,IAAA,CAAK,mBAAA,CAAoB,WAAW,IAAA,CAAK,aAAA,CAAc,IAAA,CAAK,IAAI,CAAC;QAC1E,SAAS,IAAA,CAAK,mBAAA,CAAoB,aAAa,IAAA,CAAK,eAAA,CAAgB,IAAA,CAAK,IAAI,CAAC;QAC9E,IAAA,CAAK,yBAAA,GAA4B;IAClC;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1360, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/%40tldraw/editor/src/lib/editor/managers/FontManager/FontManager.ts"],"sourcesContent":["import { computed, EMPTY_ARRAY, transact } from '@tldraw/state'\nimport { AtomMap } from '@tldraw/store'\nimport { TLShape, TLShapeId } from '@tldraw/tlschema'\nimport {\n\tareArraysShallowEqual,\n\tcompact,\n\tFileHelpers,\n\tmapObjectMapValues,\n\tobjectMapEntries,\n} from '@tldraw/utils'\nimport { Editor } from '../../Editor'\n\n/**\n * Represents the `src` property of a {@link TLFontFace}.\n * See {@link https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src | `src`} for details of the properties here.\n * @public\n */\nexport interface TLFontFaceSource {\n\t/**\n\t * A URL from which to load the font. If the value here is a key in\n\t * {@link tldraw#TLEditorAssetUrls.fonts}, the value from there will be used instead.\n\t */\n\turl: string\n\tformat?: string\n\ttech?: string\n}\n\n/**\n * A font face that can be used in the editor. The properties of this are largely the same as the\n * ones in the\n * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face | css `@font-face` rule}.\n * @public\n */\nexport interface TLFontFace {\n\t/**\n\t * How this font can be referred to in CSS.\n\t * See {@link https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-family | `font-family`}.\n\t */\n\treadonly family: string\n\t/**\n\t * The source of the font. This\n\t * See {@link https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src | `src`}.\n\t */\n\treadonly src: TLFontFaceSource\n\t/**\n\t * See {@link https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/ascent-override | `ascent-override`}.\n\t */\n\treadonly ascentOverride?: string\n\t/**\n\t * See {@link https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/descent-override | `descent-override`}.\n\t */\n\treadonly descentOverride?: string\n\t/**\n\t * See {@link https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-stretch | `font-stretch`}.\n\t */\n\treadonly stretch?: string\n\t/**\n\t * See {@link https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-style | `font-style`}.\n\t */\n\treadonly style?: string\n\t/**\n\t * See {@link https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-weight | `font-weight`}.\n\t */\n\treadonly weight?: string\n\t/**\n\t * See {@link https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-feature-settings | `font-feature-settings`}.\n\t */\n\treadonly featureSettings?: string\n\t/**\n\t * See {@link https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/line-gap-override | `line-gap-override`}.\n\t */\n\treadonly lineGapOverride?: string\n\t/**\n\t * See {@link https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/unicode-range | `unicode-range`}.\n\t */\n\treadonly unicodeRange?: string\n}\n\ninterface FontState {\n\treadonly state: 'loading' | 'ready' | 'error'\n\treadonly instance: FontFace\n\treadonly loadingPromise: Promise<void>\n}\n\n/** @public */\nexport class FontManager {\n\tconstructor(\n\t\tprivate readonly editor: Editor,\n\t\tprivate readonly assetUrls?: { [key: string]: string | undefined }\n\t) {\n\t\tthis.shapeFontFacesCache = editor.store.createComputedCache(\n\t\t\t'shape font faces',\n\t\t\t(shape: TLShape) => {\n\t\t\t\tconst shapeUtil = this.editor.getShapeUtil(shape)\n\t\t\t\treturn shapeUtil.getFontFaces(shape)\n\t\t\t},\n\t\t\t{\n\t\t\t\tareResultsEqual: areArraysShallowEqual,\n\t\t\t\tareRecordsEqual: (a, b) => a.props === b.props && a.meta === b.meta,\n\t\t\t}\n\t\t)\n\n\t\tthis.shapeFontLoadStateCache = editor.store.createCache<(FontState | null)[], TLShape>(\n\t\t\t(id: TLShapeId) => {\n\t\t\t\tconst fontFacesComputed = computed('font faces', () => this.getShapeFontFaces(id))\n\t\t\t\treturn computed(\n\t\t\t\t\t'font load state',\n\t\t\t\t\t() => {\n\t\t\t\t\t\tconst states = fontFacesComputed.get().map((face) => this.getFontState(face))\n\t\t\t\t\t\treturn states\n\t\t\t\t\t},\n\t\t\t\t\t{ isEqual: areArraysShallowEqual }\n\t\t\t\t)\n\t\t\t}\n\t\t)\n\t}\n\n\tprivate readonly shapeFontFacesCache\n\tprivate readonly shapeFontLoadStateCache\n\n\tgetShapeFontFaces(shape: TLShape | TLShapeId): TLFontFace[] {\n\t\tconst shapeId = typeof shape === 'string' ? shape : shape.id\n\t\treturn this.shapeFontFacesCache.get(shapeId) ?? EMPTY_ARRAY\n\t}\n\n\ttrackFontsForShape(shape: TLShape | TLShapeId) {\n\t\tconst shapeId = typeof shape === 'string' ? shape : shape.id\n\t\tthis.shapeFontLoadStateCache.get(shapeId)\n\t}\n\n\tasync loadRequiredFontsForCurrentPage(limit = Infinity) {\n\t\tconst neededFonts = new Set<TLFontFace>()\n\t\tfor (const shapeId of this.editor.getCurrentPageShapeIds()) {\n\t\t\tfor (const font of this.getShapeFontFaces(this.editor.getShape(shapeId)!)) {\n\t\t\t\tneededFonts.add(font)\n\t\t\t}\n\t\t}\n\n\t\tif (neededFonts.size > limit) {\n\t\t\treturn\n\t\t}\n\n\t\tconst promises = Array.from(neededFonts, (font) => this.ensureFontIsLoaded(font))\n\t\tawait Promise.all(promises)\n\t}\n\n\tprivate readonly fontStates = new AtomMap<TLFontFace, FontState>('font states')\n\tprivate getFontState(font: TLFontFace): FontState | null {\n\t\treturn this.fontStates.get(font) ?? null\n\t}\n\n\tensureFontIsLoaded(font: TLFontFace): Promise<void> {\n\t\tconst existingState = this.getFontState(font)\n\t\tif (existingState) return existingState.loadingPromise\n\n\t\tconst instance = this.findOrCreateFontFace(font)\n\t\tconst state: FontState = {\n\t\t\tstate: 'loading',\n\t\t\tinstance,\n\t\t\tloadingPromise: instance\n\t\t\t\t.load()\n\t\t\t\t.then(() => {\n\t\t\t\t\tdocument.fonts.add(instance)\n\t\t\t\t\tthis.fontStates.update(font, (s) => ({ ...s, state: 'ready' }))\n\t\t\t\t})\n\t\t\t\t.catch((err) => {\n\t\t\t\t\tconsole.error(err)\n\t\t\t\t\tthis.fontStates.update(font, (s) => ({ ...s, state: 'error' }))\n\t\t\t\t}),\n\t\t}\n\n\t\tthis.fontStates.set(font, state)\n\t\treturn state.loadingPromise\n\t}\n\n\tprivate fontsToLoad = new Set<TLFontFace>()\n\trequestFonts(fonts: TLFontFace[]) {\n\t\tif (!this.fontsToLoad.size) {\n\t\t\tqueueMicrotask(() => {\n\t\t\t\tif (this.editor.isDisposed) return\n\t\t\t\tconst toLoad = this.fontsToLoad\n\t\t\t\tthis.fontsToLoad = new Set()\n\t\t\t\ttransact(() => {\n\t\t\t\t\tfor (const font of toLoad) {\n\t\t\t\t\t\tthis.ensureFontIsLoaded(font)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t})\n\t\t}\n\t\tfor (const font of fonts) {\n\t\t\tthis.fontsToLoad.add(font)\n\t\t}\n\t}\n\n\tprivate findOrCreateFontFace(font: TLFontFace) {\n\t\tfor (const existing of document.fonts) {\n\t\t\tif (\n\t\t\t\texisting.family === font.family &&\n\t\t\t\tobjectMapEntries(defaultFontFaceDescriptors).every(\n\t\t\t\t\t([key, defaultValue]) => existing[key] === (font[key] ?? defaultValue)\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\treturn existing\n\t\t\t}\n\t\t}\n\n\t\tconst url = this.assetUrls?.[font.src.url] ?? font.src.url\n\t\tconst instance = new FontFace(font.family, `url(${JSON.stringify(url)})`, {\n\t\t\t...mapObjectMapValues(defaultFontFaceDescriptors, (key) => font[key]),\n\t\t\tdisplay: 'swap',\n\t\t})\n\n\t\tdocument.fonts.add(instance)\n\n\t\treturn instance\n\t}\n\n\tasync toEmbeddedCssDeclaration(font: TLFontFace) {\n\t\tconst url = this.assetUrls?.[font.src.url] ?? font.src.url\n\t\tconst dataUrl = await FileHelpers.urlToDataUrl(url)\n\n\t\tconst src = compact([\n\t\t\t`url(\"${dataUrl}\")`,\n\t\t\tfont.src.format ? `format(${font.src.format})` : null,\n\t\t\tfont.src.tech ? `tech(${font.src.tech})` : null,\n\t\t]).join(' ')\n\t\treturn compact([\n\t\t\t`@font-face {`,\n\t\t\t`  font-family: \"${font.family}\";`,\n\t\t\tfont.ascentOverride ? `  ascent-override: ${font.ascentOverride};` : null,\n\t\t\tfont.descentOverride ? `  descent-override: ${font.descentOverride};` : null,\n\t\t\tfont.stretch ? `  font-stretch: ${font.stretch};` : null,\n\t\t\tfont.style ? `  font-style: ${font.style};` : null,\n\t\t\tfont.weight ? `  font-weight: ${font.weight};` : null,\n\t\t\tfont.featureSettings ? `  font-feature-settings: ${font.featureSettings};` : null,\n\t\t\tfont.lineGapOverride ? `  line-gap-override: ${font.lineGapOverride};` : null,\n\t\t\tfont.unicodeRange ? `  unicode-range: ${font.unicodeRange};` : null,\n\t\t\t`  src: ${src};`,\n\t\t\t`}`,\n\t\t]).join('\\n')\n\t}\n}\n\n// From https://drafts.csswg.org/css-font-loading/#fontface-interface\nconst defaultFontFaceDescriptors = {\n\tstyle: 'normal',\n\tweight: 'normal',\n\tstretch: 'normal',\n\tunicodeRange: 'U+0-10FFFF',\n\tfeatureSettings: 'normal',\n\tascentOverride: 'normal',\n\tdescentOverride: 'normal',\n\tlineGapOverride: 'normal',\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1522, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/%40tldraw/editor/src/lib/editor/managers/HistoryManager/HistoryManager.ts"],"sourcesContent":["import { atom, transact } from '@tldraw/state'\nimport {\n\tRecordsDiff,\n\tStore,\n\tUnknownRecord,\n\tcreateEmptyRecordsDiff,\n\tisRecordsDiffEmpty,\n\treverseRecordsDiff,\n\tsquashRecordDiffsMutable,\n} from '@tldraw/store'\nimport { exhaustiveSwitchError, noop } from '@tldraw/utils'\nimport { TLHistoryBatchOptions, TLHistoryEntry } from '../../types/history-types'\n\nenum HistoryRecorderState {\n\tRecording = 'recording',\n\tRecordingPreserveRedoStack = 'recordingPreserveRedoStack',\n\tPaused = 'paused',\n}\n\n/** @public */\nexport class HistoryManager<R extends UnknownRecord> {\n\tprivate readonly store: Store<R>\n\n\treadonly dispose: () => void\n\n\tprivate state: HistoryRecorderState = HistoryRecorderState.Recording\n\tprivate readonly pendingDiff = new PendingDiff<R>()\n\tprivate stacks = atom(\n\t\t'HistoryManager.stacks',\n\t\t{\n\t\t\tundos: stack<TLHistoryEntry<R>>(),\n\t\t\tredos: stack<TLHistoryEntry<R>>(),\n\t\t},\n\t\t{\n\t\t\tisEqual: (a, b) => a.undos === b.undos && a.redos === b.redos,\n\t\t}\n\t)\n\n\tprivate readonly annotateError: (error: unknown) => void\n\n\tconstructor(opts: { store: Store<R>; annotateError?(error: unknown): void }) {\n\t\tthis.store = opts.store\n\t\tthis.annotateError = opts.annotateError ?? noop\n\t\tthis.dispose = this.store.addHistoryInterceptor((entry, source) => {\n\t\t\tif (source !== 'user') return\n\n\t\t\tswitch (this.state) {\n\t\t\t\tcase HistoryRecorderState.Recording:\n\t\t\t\t\tthis.pendingDiff.apply(entry.changes)\n\t\t\t\t\tthis.stacks.update(({ undos }) => ({ undos, redos: stack() }))\n\t\t\t\t\tbreak\n\t\t\t\tcase HistoryRecorderState.RecordingPreserveRedoStack:\n\t\t\t\t\tthis.pendingDiff.apply(entry.changes)\n\t\t\t\t\tbreak\n\t\t\t\tcase HistoryRecorderState.Paused:\n\t\t\t\t\tbreak\n\t\t\t\tdefault:\n\t\t\t\t\texhaustiveSwitchError(this.state)\n\t\t\t}\n\t\t})\n\t}\n\n\tprivate flushPendingDiff() {\n\t\tif (this.pendingDiff.isEmpty()) return\n\n\t\tconst diff = this.pendingDiff.clear()\n\t\tthis.stacks.update(({ undos, redos }) => ({\n\t\t\tundos: undos.push({ type: 'diff', diff }),\n\t\t\tredos,\n\t\t}))\n\t}\n\n\tgetNumUndos() {\n\t\treturn this.stacks.get().undos.length + (this.pendingDiff.isEmpty() ? 0 : 1)\n\t}\n\n\tgetNumRedos() {\n\t\treturn this.stacks.get().redos.length\n\t}\n\n\t/** @internal */\n\t_isInBatch = false\n\n\tbatch(fn: () => void, opts?: TLHistoryBatchOptions) {\n\t\tconst previousState = this.state\n\n\t\t// we move to the new state only if we haven't explicitly paused\n\t\tif (previousState !== HistoryRecorderState.Paused && opts?.history) {\n\t\t\tthis.state = modeToState[opts.history]\n\t\t}\n\n\t\ttry {\n\t\t\tif (this._isInBatch) {\n\t\t\t\ttransact(fn)\n\t\t\t\treturn this\n\t\t\t}\n\n\t\t\tthis._isInBatch = true\n\t\t\ttry {\n\t\t\t\ttransact(fn)\n\t\t\t} catch (error) {\n\t\t\t\tthis.annotateError(error)\n\t\t\t\tthrow error\n\t\t\t} finally {\n\t\t\t\tthis._isInBatch = false\n\t\t\t}\n\n\t\t\treturn this\n\t\t} finally {\n\t\t\tthis.state = previousState\n\t\t}\n\t}\n\n\t// History\n\t_undo({ pushToRedoStack, toMark = undefined }: { pushToRedoStack: boolean; toMark?: string }) {\n\t\tconst previousState = this.state\n\t\tthis.state = HistoryRecorderState.Paused\n\t\ttry {\n\t\t\tlet { undos, redos } = this.stacks.get()\n\n\t\t\t// start by collecting the pending diff (everything since the last mark).\n\t\t\t// we'll accumulate the diff to undo in this variable so we can apply it atomically.\n\t\t\tconst pendingDiff = this.pendingDiff.clear()\n\t\t\tconst isPendingDiffEmpty = isRecordsDiffEmpty(pendingDiff)\n\t\t\tconst diffToUndo = reverseRecordsDiff(pendingDiff)\n\n\t\t\tif (pushToRedoStack && !isPendingDiffEmpty) {\n\t\t\t\tredos = redos.push({ type: 'diff', diff: pendingDiff })\n\t\t\t}\n\n\t\t\tlet didFindMark = false\n\t\t\tif (isPendingDiffEmpty) {\n\t\t\t\t// if nothing has happened since the last mark, pop any intermediate marks off the stack\n\t\t\t\twhile (undos.head?.type === 'stop') {\n\t\t\t\t\tconst mark = undos.head\n\t\t\t\t\tundos = undos.tail\n\t\t\t\t\tif (pushToRedoStack) {\n\t\t\t\t\t\tredos = redos.push(mark)\n\t\t\t\t\t}\n\t\t\t\t\tif (mark.id === toMark) {\n\t\t\t\t\t\tdidFindMark = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!didFindMark) {\n\t\t\t\tloop: while (undos.head) {\n\t\t\t\t\tconst undo = undos.head\n\t\t\t\t\tundos = undos.tail\n\n\t\t\t\t\tif (pushToRedoStack) {\n\t\t\t\t\t\tredos = redos.push(undo)\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch (undo.type) {\n\t\t\t\t\t\tcase 'diff':\n\t\t\t\t\t\t\tsquashRecordDiffsMutable(diffToUndo, [reverseRecordsDiff(undo.diff)])\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tcase 'stop':\n\t\t\t\t\t\t\tif (!toMark) break loop\n\t\t\t\t\t\t\tif (undo.id === toMark) {\n\t\t\t\t\t\t\t\tdidFindMark = true\n\t\t\t\t\t\t\t\tbreak loop\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\texhaustiveSwitchError(undo)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!didFindMark && toMark) {\n\t\t\t\t// whoops, we didn't find the mark we were looking for\n\t\t\t\t// don't do anything\n\t\t\t\treturn this\n\t\t\t}\n\n\t\t\tthis.store.applyDiff(diffToUndo, { ignoreEphemeralKeys: true })\n\t\t\tthis.store.ensureStoreIsUsable()\n\t\t\tthis.stacks.set({ undos, redos })\n\t\t} finally {\n\t\t\tthis.state = previousState\n\t\t}\n\n\t\treturn this\n\t}\n\n\tundo() {\n\t\tthis._undo({ pushToRedoStack: true })\n\n\t\treturn this\n\t}\n\n\tredo() {\n\t\tconst previousState = this.state\n\t\tthis.state = HistoryRecorderState.Paused\n\t\ttry {\n\t\t\tthis.flushPendingDiff()\n\n\t\t\tlet { undos, redos } = this.stacks.get()\n\t\t\tif (redos.length === 0) {\n\t\t\t\treturn this\n\t\t\t}\n\n\t\t\t// ignore any intermediate marks - this should take us to the first `diff` entry\n\t\t\twhile (redos.head?.type === 'stop') {\n\t\t\t\tundos = undos.push(redos.head)\n\t\t\t\tredos = redos.tail\n\t\t\t}\n\n\t\t\t// accumulate diffs to be redone so they can be applied atomically\n\t\t\tconst diffToRedo = createEmptyRecordsDiff<R>()\n\n\t\t\twhile (redos.head) {\n\t\t\t\tconst redo = redos.head\n\t\t\t\tundos = undos.push(redo)\n\t\t\t\tredos = redos.tail\n\n\t\t\t\tif (redo.type === 'diff') {\n\t\t\t\t\tsquashRecordDiffsMutable(diffToRedo, [redo.diff])\n\t\t\t\t} else {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.store.applyDiff(diffToRedo, { ignoreEphemeralKeys: true })\n\t\t\tthis.store.ensureStoreIsUsable()\n\t\t\tthis.stacks.set({ undos, redos })\n\t\t} finally {\n\t\t\tthis.state = previousState\n\t\t}\n\n\t\treturn this\n\t}\n\n\tbail() {\n\t\tthis._undo({ pushToRedoStack: false })\n\n\t\treturn this\n\t}\n\n\tbailToMark(id: string) {\n\t\tif (id) {\n\t\t\tthis._undo({ pushToRedoStack: false, toMark: id })\n\t\t}\n\n\t\treturn this\n\t}\n\n\tsquashToMark(id: string) {\n\t\t// remove marks between head and the mark\n\n\t\tlet top = this.stacks.get().undos\n\t\tconst popped: Array<RecordsDiff<R>> = []\n\n\t\twhile (top.head && !(top.head.type === 'stop' && top.head.id === id)) {\n\t\t\tif (top.head.type === 'diff') {\n\t\t\t\tpopped.push(top.head.diff)\n\t\t\t}\n\t\t\ttop = top.tail\n\t\t}\n\n\t\tif (!top.head || top.head?.id !== id) {\n\t\t\tconsole.error('Could not find mark to squash to: ', id)\n\t\t\treturn this\n\t\t}\n\t\tif (popped.length === 0) {\n\t\t\treturn this\n\t\t}\n\n\t\tconst diff = createEmptyRecordsDiff<R>()\n\t\tsquashRecordDiffsMutable(diff, popped.reverse())\n\n\t\tthis.stacks.update(({ redos }) => ({\n\t\t\tundos: top.push({\n\t\t\t\ttype: 'diff',\n\t\t\t\tdiff,\n\t\t\t}),\n\t\t\tredos,\n\t\t}))\n\n\t\treturn this\n\t}\n\n\t/** @internal */\n\t_mark(id: string) {\n\t\ttransact(() => {\n\t\t\tthis.flushPendingDiff()\n\t\t\tthis.stacks.update(({ undos, redos }) => ({ undos: undos.push({ type: 'stop', id }), redos }))\n\t\t})\n\t}\n\n\tclear() {\n\t\tthis.stacks.set({ undos: stack(), redos: stack() })\n\t\tthis.pendingDiff.clear()\n\t}\n\n\t/** @internal */\n\tgetMarkIdMatching(idSubstring: string) {\n\t\tlet top = this.stacks.get().undos\n\t\twhile (top.head) {\n\t\t\tif (top.head.type === 'stop' && top.head.id.includes(idSubstring)) {\n\t\t\t\treturn top.head.id\n\t\t\t}\n\t\t\ttop = top.tail\n\t\t}\n\t\treturn null\n\t}\n\n\t/** @internal */\n\tdebug() {\n\t\tconst { undos, redos } = this.stacks.get()\n\t\treturn {\n\t\t\tundos: undos.toArray(),\n\t\t\tredos: redos.toArray(),\n\t\t\tpendingDiff: this.pendingDiff.debug(),\n\t\t\tstate: this.state as string,\n\t\t}\n\t}\n}\n\nconst modeToState = {\n\trecord: HistoryRecorderState.Recording,\n\t'record-preserveRedoStack': HistoryRecorderState.RecordingPreserveRedoStack,\n\tignore: HistoryRecorderState.Paused,\n} as const\n\nclass PendingDiff<R extends UnknownRecord> {\n\tprivate diff = createEmptyRecordsDiff<R>()\n\tprivate isEmptyAtom = atom('PendingDiff.isEmpty', true)\n\n\tclear() {\n\t\tconst diff = this.diff\n\t\tthis.diff = createEmptyRecordsDiff<R>()\n\t\tthis.isEmptyAtom.set(true)\n\t\treturn diff\n\t}\n\n\tisEmpty() {\n\t\treturn this.isEmptyAtom.get()\n\t}\n\n\tapply(diff: RecordsDiff<R>) {\n\t\tsquashRecordDiffsMutable(this.diff, [diff])\n\t\tthis.isEmptyAtom.set(isRecordsDiffEmpty(this.diff))\n\t}\n\n\tdebug() {\n\t\treturn { diff: this.diff, isEmpty: this.isEmpty() }\n\t}\n}\n\nimport { EMPTY_ARRAY } from '@tldraw/state'\n\nexport type Stack<T> = StackItem<T> | EmptyStackItem<T>\n\nexport function stack<T>(items?: Array<T>): Stack<T> {\n\tif (items) {\n\t\tlet result = EMPTY_STACK_ITEM as Stack<T>\n\t\twhile (items.length) {\n\t\t\tresult = result.push(items.pop()!)\n\t\t}\n\t\treturn result\n\t}\n\treturn EMPTY_STACK_ITEM as any\n}\n\nclass EmptyStackItem<T> implements Iterable<T> {\n\treadonly length = 0\n\treadonly head = null\n\treadonly tail: Stack<T> = this\n\n\tpush(head: T): Stack<T> {\n\t\treturn new StackItem<T>(head, this)\n\t}\n\n\ttoArray() {\n\t\treturn EMPTY_ARRAY\n\t}\n\n\t[Symbol.iterator]() {\n\t\treturn {\n\t\t\tnext() {\n\t\t\t\treturn { value: undefined, done: true as const }\n\t\t\t},\n\t\t}\n\t}\n}\n\nconst EMPTY_STACK_ITEM = new EmptyStackItem()\n\nclass StackItem<T> implements Iterable<T> {\n\tlength: number\n\tconstructor(\n\t\tpublic readonly head: T,\n\t\tpublic readonly tail: Stack<T>\n\t) {\n\t\tthis.length = tail.length + 1\n\t}\n\n\tpush(head: T): Stack<T> {\n\t\treturn new StackItem(head, this)\n\t}\n\n\ttoArray() {\n\t\treturn Array.from(this)\n\t}\n\n\t[Symbol.iterator]() {\n\t\tlet stack = this as Stack<T>\n\t\treturn {\n\t\t\tnext() {\n\t\t\t\tif (stack.length) {\n\t\t\t\t\tconst value = stack.head!\n\t\t\t\t\tstack = stack.tail\n\t\t\t\t\treturn { value, done: false as const }\n\t\t\t\t} else {\n\t\t\t\t\treturn { value: undefined, done: true as const }\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t}\n}\n"],"names":["HistoryRecorderState","stack"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1922, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/%40tldraw/editor/src/lib/editor/managers/ScribbleManager/ScribbleManager.ts"],"sourcesContent":["import { TLScribble, VecModel } from '@tldraw/tlschema'\nimport { uniqueId } from '@tldraw/utils'\nimport { Vec } from '../../../primitives/Vec'\nimport { Editor } from '../../Editor'\n\n/** @public */\nexport interface ScribbleItem {\n\tid: string\n\tscribble: TLScribble\n\ttimeoutMs: number\n\tdelayRemaining: number\n\tprev: null | VecModel\n\tnext: null | VecModel\n}\n\n/** @public */\nexport class ScribbleManager {\n\tscribbleItems = new Map<string, ScribbleItem>()\n\tstate = 'paused' as 'paused' | 'running'\n\n\tconstructor(private editor: Editor) {}\n\n\taddScribble(scribble: Partial<TLScribble>, id = uniqueId()) {\n\t\tconst item: ScribbleItem = {\n\t\t\tid,\n\t\t\tscribble: {\n\t\t\t\tid,\n\t\t\t\tsize: 20,\n\t\t\t\tcolor: 'accent',\n\t\t\t\topacity: 0.8,\n\t\t\t\tdelay: 0,\n\t\t\t\tpoints: [],\n\t\t\t\tshrink: 0.1,\n\t\t\t\ttaper: true,\n\t\t\t\t...scribble,\n\t\t\t\tstate: 'starting',\n\t\t\t},\n\t\t\ttimeoutMs: 0,\n\t\t\tdelayRemaining: scribble.delay ?? 0,\n\t\t\tprev: null,\n\t\t\tnext: null,\n\t\t}\n\t\tthis.scribbleItems.set(id, item)\n\t\treturn item\n\t}\n\n\treset() {\n\t\tthis.editor.updateInstanceState({ scribbles: [] })\n\t\tthis.scribbleItems.clear()\n\t}\n\n\t/**\n\t * Start stopping the scribble. The scribble won't be removed until its last point is cleared.\n\t *\n\t * @public\n\t */\n\tstop(id: ScribbleItem['id']) {\n\t\tconst item = this.scribbleItems.get(id)\n\t\tif (!item) throw Error(`Scribble with id ${id} not found`)\n\t\titem.delayRemaining = Math.min(item.delayRemaining, 200)\n\t\titem.scribble.state = 'stopping'\n\t\treturn item\n\t}\n\n\t/**\n\t * Set the scribble's next point.\n\t *\n\t * @param id - The id of the scribble to add a point to.\n\t * @param x - The x coordinate of the point.\n\t * @param y - The y coordinate of the point.\n\t * @param z - The z coordinate of the point.\n\t * @public\n\t */\n\taddPoint(id: ScribbleItem['id'], x: number, y: number, z = 0.5) {\n\t\tconst item = this.scribbleItems.get(id)\n\t\tif (!item) throw Error(`Scribble with id ${id} not found`)\n\t\tconst { prev } = item\n\t\tconst point = { x, y, z }\n\t\tif (!prev || Vec.Dist(prev, point) >= 1) {\n\t\t\titem.next = point\n\t\t}\n\t\treturn item\n\t}\n\n\t/**\n\t * Update on each animation frame.\n\t *\n\t * @param elapsed - The number of milliseconds since the last tick.\n\t * @public\n\t */\n\ttick(elapsed: number) {\n\t\tif (this.scribbleItems.size === 0) return\n\t\tthis.editor.run(() => {\n\t\t\tthis.scribbleItems.forEach((item) => {\n\t\t\t\t// let the item get at least eight points before\n\t\t\t\t//  switching from starting to active\n\t\t\t\tif (item.scribble.state === 'starting') {\n\t\t\t\t\tconst { next, prev } = item\n\t\t\t\t\tif (next && next !== prev) {\n\t\t\t\t\t\titem.prev = next\n\t\t\t\t\t\titem.scribble.points.push(next)\n\t\t\t\t\t}\n\n\t\t\t\t\tif (item.scribble.points.length > 8) {\n\t\t\t\t\t\titem.scribble.state = 'active'\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif (item.delayRemaining > 0) {\n\t\t\t\t\titem.delayRemaining = Math.max(0, item.delayRemaining - elapsed)\n\t\t\t\t}\n\n\t\t\t\titem.timeoutMs += elapsed\n\t\t\t\tif (item.timeoutMs >= 16) {\n\t\t\t\t\titem.timeoutMs = 0\n\t\t\t\t}\n\n\t\t\t\tconst { delayRemaining, timeoutMs, prev, next, scribble } = item\n\n\t\t\t\tswitch (scribble.state) {\n\t\t\t\t\tcase 'active': {\n\t\t\t\t\t\tif (next && next !== prev) {\n\t\t\t\t\t\t\titem.prev = next\n\t\t\t\t\t\t\tscribble.points.push(next)\n\n\t\t\t\t\t\t\t// If we've run out of delay, then shrink the scribble from the start\n\t\t\t\t\t\t\tif (delayRemaining === 0) {\n\t\t\t\t\t\t\t\tif (scribble.points.length > 8) {\n\t\t\t\t\t\t\t\t\tscribble.points.shift()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// While not moving, shrink the scribble from the start\n\t\t\t\t\t\t\tif (timeoutMs === 0) {\n\t\t\t\t\t\t\t\tif (scribble.points.length > 1) {\n\t\t\t\t\t\t\t\t\tscribble.points.shift()\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// Reset the item's delay\n\t\t\t\t\t\t\t\t\titem.delayRemaining = scribble.delay\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tcase 'stopping': {\n\t\t\t\t\t\tif (item.delayRemaining === 0) {\n\t\t\t\t\t\t\tif (timeoutMs === 0) {\n\t\t\t\t\t\t\t\t// If the scribble is down to one point, we're done!\n\t\t\t\t\t\t\t\tif (scribble.points.length === 1) {\n\t\t\t\t\t\t\t\t\tthis.scribbleItems.delete(item.id) // Remove the scribble\n\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (scribble.shrink) {\n\t\t\t\t\t\t\t\t\t// Drop the scribble's size as it shrinks\n\t\t\t\t\t\t\t\t\tscribble.size = Math.max(1, scribble.size * (1 - scribble.shrink))\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Drop the scribble's first point (its tail)\n\t\t\t\t\t\t\t\tscribble.points.shift()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tcase 'paused': {\n\t\t\t\t\t\t// Nothing to do while paused.\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\n\t\t\t// The object here will get frozen into the record, so we need to\n\t\t\t// create a copies of the parts that what we'll be mutating later.\n\t\t\tthis.editor.updateInstanceState({\n\t\t\t\tscribbles: Array.from(this.scribbleItems.values())\n\t\t\t\t\t.map(({ scribble }) => ({\n\t\t\t\t\t\t...scribble,\n\t\t\t\t\t\tpoints: [...scribble.points],\n\t\t\t\t\t}))\n\t\t\t\t\t.slice(-5), // limit to three as a minor sanity check\n\t\t\t})\n\t\t})\n\t}\n}\n"],"names":["next","prev"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2089, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/%40tldraw/editor/src/lib/editor/managers/SnapManager/BoundsSnaps.ts"],"sourcesContent":["import { computed } from '@tldraw/state'\nimport { TLShape, TLShapeId, VecModel } from '@tldraw/tlschema'\nimport { assertExists, dedupe, uniqueId } from '@tldraw/utils'\nimport {\n\tBox,\n\tSelectionCorner,\n\tSelectionEdge,\n\tflipSelectionHandleX,\n\tflipSelectionHandleY,\n\tisSelectionCorner,\n} from '../../../primitives/Box'\nimport { Mat } from '../../../primitives/Mat'\nimport { Vec } from '../../../primitives/Vec'\nimport { rangeIntersection, rangesOverlap } from '../../../primitives/utils'\nimport { Editor } from '../../Editor'\nimport {\n\tGapsSnapIndicator,\n\tPointsSnapIndicator,\n\tSnapData,\n\tSnapIndicator,\n\tSnapManager,\n} from './SnapManager'\n\n/**\n * When moving or resizing shapes, the bounds of the shape can snap to key geometry on other nearby\n * shapes. Customize how a shape snaps to others with {@link ShapeUtil.getBoundsSnapGeometry}.\n *\n * @public\n */\nexport interface BoundsSnapGeometry {\n\t/**\n\t * Points that this shape will snap to. By default, this will be the corners and center of the\n\t * shapes bounding box. To disable snapping to a specific point, use an empty array.\n\t */\n\tpoints?: VecModel[]\n}\n\n/** @public */\nexport interface BoundsSnapPoint {\n\tid: string\n\tx: number\n\ty: number\n\thandle?: SelectionCorner\n}\n\ninterface SnapPair {\n\tthisPoint: BoundsSnapPoint\n\totherPoint: BoundsSnapPoint\n}\n\ninterface NearestPointsSnap {\n\t// selection snaps to a nearby snap point\n\ttype: 'points'\n\tpoints: SnapPair\n\tnudge: number\n}\n\ntype NearestSnap =\n\t| NearestPointsSnap\n\t| {\n\t\t\t// selection snaps to the center of a gap\n\t\t\ttype: 'gap_center'\n\t\t\tgap: Gap\n\t\t\tnudge: number\n\t  }\n\t| {\n\t\t\t// selection snaps to create a new gap of equal size to another gap\n\t\t\t// on the opposite side of some shape\n\t\t\ttype: 'gap_duplicate'\n\t\t\tgap: Gap\n\t\t\tprotrusionDirection: 'left' | 'right' | 'top' | 'bottom'\n\t\t\tnudge: number\n\t  }\n\ninterface GapNode {\n\tid: TLShapeId\n\tpageBounds: Box\n}\n\ninterface Gap {\n\t// e.g.\n\t//      start\n\t//      edge              breadth\n\t//                      intersection\n\t//                       [40,100]           end\n\t//                                         edge\n\t//   100,0                  \n\t//                                     \n\t//             \n\t//   start                      200,40  \n\t//   node                                          \n\t//                end      \n\t//                                        node     \n\t//   100,100                            \n\t//                                                     \n\t//                                 200,120  \n\t//\n\t//                       length 100\n\t//               \n\tstartNode: GapNode\n\tendNode: GapNode\n\tstartEdge: [Vec, Vec]\n\tendEdge: [Vec, Vec]\n\tlength: number\n\tbreadthIntersection: [number, number]\n}\n\nconst round = (x: number) => {\n\t// round numbers to avoid glitches for floating point rounding errors\n\tconst decimalPlacesTolerance = 8\n\treturn Math.round(x * 10 ** decimalPlacesTolerance) / 10 ** decimalPlacesTolerance\n}\n\nfunction findAdjacentGaps(\n\tgaps: Gap[],\n\tshapeId: TLShapeId,\n\tgapLength: number,\n\tdirection: 'forward' | 'backward',\n\tintersection: [number, number]\n): Gap[] {\n\t// TODO: take advantage of the fact that gaps is sorted by starting position?\n\tconst matches = gaps.filter(\n\t\t(gap) =>\n\t\t\t(direction === 'forward' ? gap.startNode.id === shapeId : gap.endNode.id === shapeId) &&\n\t\t\tround(gap.length) === round(gapLength) &&\n\t\t\trangeIntersection(\n\t\t\t\tgap.breadthIntersection[0],\n\t\t\t\tgap.breadthIntersection[1],\n\t\t\t\tintersection[0],\n\t\t\t\tintersection[1]\n\t\t\t)\n\t)\n\n\tif (matches.length === 0) return []\n\n\tconst nextNodes = new Set<TLShapeId>()\n\n\tmatches.forEach((match) => {\n\t\tconst node = direction === 'forward' ? match.endNode.id : match.startNode.id\n\t\tif (!nextNodes.has(node)) {\n\t\t\tnextNodes.add(node)\n\t\t\tconst foundGaps = findAdjacentGaps(\n\t\t\t\tgaps,\n\t\t\t\tnode,\n\t\t\t\tgapLength,\n\t\t\t\tdirection,\n\t\t\t\trangeIntersection(\n\t\t\t\t\tmatch.breadthIntersection[0],\n\t\t\t\t\tmatch.breadthIntersection[1],\n\t\t\t\t\tintersection[0],\n\t\t\t\t\tintersection[1]\n\t\t\t\t)!\n\t\t\t)\n\n\t\t\tmatches.push(...foundGaps)\n\t\t}\n\t})\n\n\treturn matches\n}\n\nfunction dedupeGapSnaps(snaps: Array<Extract<SnapIndicator, { type: 'gaps' }>>) {\n\t// sort by descending order of number of gaps\n\tsnaps.sort((a, b) => b.gaps.length - a.gaps.length)\n\t// pop off any that are included already\n\tfor (let i = snaps.length - 1; i > 0; i--) {\n\t\tconst snap = snaps[i]\n\t\tfor (let j = i - 1; j >= 0; j--) {\n\t\t\tconst otherSnap = snaps[j]\n\t\t\t// if every edge in this snap is included in the other snap somewhere, then it's redundant\n\t\t\tif (\n\t\t\t\totherSnap.direction === snap.direction &&\n\t\t\t\tsnap.gaps.every(\n\t\t\t\t\t(gap) =>\n\t\t\t\t\t\totherSnap.gaps.some(\n\t\t\t\t\t\t\t(otherGap) =>\n\t\t\t\t\t\t\t\tround(gap.startEdge[0].x) === round(otherGap.startEdge[0].x) &&\n\t\t\t\t\t\t\t\tround(gap.startEdge[0].y) === round(otherGap.startEdge[0].y) &&\n\t\t\t\t\t\t\t\tround(gap.startEdge[1].x) === round(otherGap.startEdge[1].x) &&\n\t\t\t\t\t\t\t\tround(gap.startEdge[1].y) === round(otherGap.startEdge[1].y)\n\t\t\t\t\t\t) &&\n\t\t\t\t\t\totherSnap.gaps.some(\n\t\t\t\t\t\t\t(otherGap) =>\n\t\t\t\t\t\t\t\tround(gap.endEdge[0].x) === round(otherGap.endEdge[0].x) &&\n\t\t\t\t\t\t\t\tround(gap.endEdge[0].y) === round(otherGap.endEdge[0].y) &&\n\t\t\t\t\t\t\t\tround(gap.endEdge[1].x) === round(otherGap.endEdge[1].x) &&\n\t\t\t\t\t\t\t\tround(gap.endEdge[1].y) === round(otherGap.endEdge[1].y)\n\t\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tsnaps.splice(i, 1)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n\n/** @public */\nexport class BoundsSnaps {\n\treadonly editor: Editor\n\tconstructor(readonly manager: SnapManager) {\n\t\tthis.editor = manager.editor\n\t}\n\n\t@computed private getSnapPointsCache() {\n\t\tconst { editor } = this\n\t\treturn editor.store.createComputedCache<BoundsSnapPoint[], TLShape>('snapPoints', (shape) => {\n\t\t\tconst pageTransform = editor.getShapePageTransform(shape.id)\n\t\t\tif (!pageTransform) return undefined\n\t\t\tconst boundsSnapGeometry = editor.getShapeUtil(shape).getBoundsSnapGeometry(shape)\n\t\t\tconst snapPoints =\n\t\t\t\tboundsSnapGeometry.points ?? editor.getShapeGeometry(shape).bounds.cornersAndCenter\n\n\t\t\tif (!pageTransform || !snapPoints) return undefined\n\t\t\treturn snapPoints.map((point, i) => {\n\t\t\t\tconst { x, y } = Mat.applyToPoint(pageTransform, point)\n\t\t\t\treturn { x, y, id: `${shape.id}:${i}` }\n\t\t\t})\n\t\t})\n\t}\n\n\tgetSnapPoints(shapeId: TLShapeId) {\n\t\treturn this.getSnapPointsCache().get(shapeId) ?? []\n\t}\n\n\t// Points which belong to snappable shapes\n\t@computed private getSnappablePoints() {\n\t\tconst snapPointsCache = this.getSnapPointsCache()\n\t\tconst snappableShapes = this.manager.getSnappableShapes()\n\t\tconst result: BoundsSnapPoint[] = []\n\n\t\tfor (const shapeId of snappableShapes) {\n\t\t\tconst snapPoints = snapPointsCache.get(shapeId)\n\t\t\tif (snapPoints) {\n\t\t\t\tresult.push(...snapPoints)\n\t\t\t}\n\t\t}\n\n\t\treturn result\n\t}\n\n\t@computed private getSnappableGapNodes(): Array<GapNode> {\n\t\treturn Array.from(this.manager.getSnappableShapes(), (shapeId) => ({\n\t\t\tid: shapeId,\n\t\t\tpageBounds: assertExists(this.editor.getShapePageBounds(shapeId)),\n\t\t}))\n\t}\n\n\t@computed private getVisibleGaps(): { horizontal: Gap[]; vertical: Gap[] } {\n\t\tconst horizontal: Gap[] = []\n\t\tconst vertical: Gap[] = []\n\n\t\tlet startNode: GapNode, endNode: GapNode\n\n\t\tconst sortedShapesOnCurrentPageHorizontal = this.getSnappableGapNodes().sort((a, b) => {\n\t\t\treturn a.pageBounds.minX - b.pageBounds.minX\n\t\t})\n\n\t\t// Collect horizontal gaps\n\t\tfor (let i = 0; i < sortedShapesOnCurrentPageHorizontal.length; i++) {\n\t\t\tstartNode = sortedShapesOnCurrentPageHorizontal[i]\n\t\t\tfor (let j = i + 1; j < sortedShapesOnCurrentPageHorizontal.length; j++) {\n\t\t\t\tendNode = sortedShapesOnCurrentPageHorizontal[j]\n\n\t\t\t\tif (\n\t\t\t\t\t// is there space between the boxes\n\t\t\t\t\tstartNode.pageBounds.maxX < endNode.pageBounds.minX &&\n\t\t\t\t\t// and they overlap in the y axis\n\t\t\t\t\trangesOverlap(\n\t\t\t\t\t\tstartNode.pageBounds.minY,\n\t\t\t\t\t\tstartNode.pageBounds.maxY,\n\t\t\t\t\t\tendNode.pageBounds.minY,\n\t\t\t\t\t\tendNode.pageBounds.maxY\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\thorizontal.push({\n\t\t\t\t\t\tstartNode,\n\t\t\t\t\t\tendNode,\n\t\t\t\t\t\tstartEdge: [\n\t\t\t\t\t\t\tnew Vec(startNode.pageBounds.maxX, startNode.pageBounds.minY),\n\t\t\t\t\t\t\tnew Vec(startNode.pageBounds.maxX, startNode.pageBounds.maxY),\n\t\t\t\t\t\t],\n\t\t\t\t\t\tendEdge: [\n\t\t\t\t\t\t\tnew Vec(endNode.pageBounds.minX, endNode.pageBounds.minY),\n\t\t\t\t\t\t\tnew Vec(endNode.pageBounds.minX, endNode.pageBounds.maxY),\n\t\t\t\t\t\t],\n\t\t\t\t\t\tlength: endNode.pageBounds.minX - startNode.pageBounds.maxX,\n\t\t\t\t\t\tbreadthIntersection: rangeIntersection(\n\t\t\t\t\t\t\tstartNode.pageBounds.minY,\n\t\t\t\t\t\t\tstartNode.pageBounds.maxY,\n\t\t\t\t\t\t\tendNode.pageBounds.minY,\n\t\t\t\t\t\t\tendNode.pageBounds.maxY\n\t\t\t\t\t\t)!,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Collect vertical gaps\n\t\tconst sortedShapesOnCurrentPageVertical = sortedShapesOnCurrentPageHorizontal.sort((a, b) => {\n\t\t\treturn a.pageBounds.minY - b.pageBounds.minY\n\t\t})\n\n\t\tfor (let i = 0; i < sortedShapesOnCurrentPageVertical.length; i++) {\n\t\t\tstartNode = sortedShapesOnCurrentPageVertical[i]\n\t\t\tfor (let j = i + 1; j < sortedShapesOnCurrentPageVertical.length; j++) {\n\t\t\t\tendNode = sortedShapesOnCurrentPageVertical[j]\n\n\t\t\t\tif (\n\t\t\t\t\t// is there space between the boxes\n\t\t\t\t\tstartNode.pageBounds.maxY < endNode.pageBounds.minY &&\n\t\t\t\t\t// do they overlap in the x axis\n\t\t\t\t\trangesOverlap(\n\t\t\t\t\t\tstartNode.pageBounds.minX,\n\t\t\t\t\t\tstartNode.pageBounds.maxX,\n\t\t\t\t\t\tendNode.pageBounds.minX,\n\t\t\t\t\t\tendNode.pageBounds.maxX\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tvertical.push({\n\t\t\t\t\t\tstartNode,\n\t\t\t\t\t\tendNode,\n\t\t\t\t\t\tstartEdge: [\n\t\t\t\t\t\t\tnew Vec(startNode.pageBounds.minX, startNode.pageBounds.maxY),\n\t\t\t\t\t\t\tnew Vec(startNode.pageBounds.maxX, startNode.pageBounds.maxY),\n\t\t\t\t\t\t],\n\t\t\t\t\t\tendEdge: [\n\t\t\t\t\t\t\tnew Vec(endNode.pageBounds.minX, endNode.pageBounds.minY),\n\t\t\t\t\t\t\tnew Vec(endNode.pageBounds.maxX, endNode.pageBounds.minY),\n\t\t\t\t\t\t],\n\t\t\t\t\t\tlength: endNode.pageBounds.minY - startNode.pageBounds.maxY,\n\t\t\t\t\t\tbreadthIntersection: rangeIntersection(\n\t\t\t\t\t\t\tstartNode.pageBounds.minX,\n\t\t\t\t\t\t\tstartNode.pageBounds.maxX,\n\t\t\t\t\t\t\tendNode.pageBounds.minX,\n\t\t\t\t\t\t\tendNode.pageBounds.maxX\n\t\t\t\t\t\t)!,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn { horizontal, vertical }\n\t}\n\n\tsnapTranslateShapes({\n\t\tlockedAxis,\n\t\tinitialSelectionPageBounds,\n\t\tinitialSelectionSnapPoints,\n\t\tdragDelta,\n\t}: {\n\t\tlockedAxis: 'x' | 'y' | null\n\t\tinitialSelectionSnapPoints: BoundsSnapPoint[]\n\t\tinitialSelectionPageBounds: Box\n\t\tdragDelta: Vec\n\t}): SnapData {\n\t\tconst snapThreshold = this.manager.getSnapThreshold()\n\t\tconst visibleSnapPointsNotInSelection = this.getSnappablePoints()\n\n\t\tconst selectionPageBounds = initialSelectionPageBounds.clone().translate(dragDelta)\n\n\t\tconst selectionSnapPoints: BoundsSnapPoint[] = initialSelectionSnapPoints.map(\n\t\t\t({ x, y }, i) => ({\n\t\t\t\tid: 'selection:' + i,\n\t\t\t\tx: x + dragDelta.x,\n\t\t\t\ty: y + dragDelta.y,\n\t\t\t})\n\t\t)\n\n\t\tconst otherNodeSnapPoints = visibleSnapPointsNotInSelection\n\n\t\tconst nearestSnapsX: NearestSnap[] = []\n\t\tconst nearestSnapsY: NearestSnap[] = []\n\t\tconst minOffset = new Vec(snapThreshold, snapThreshold)\n\n\t\tthis.collectPointSnaps({\n\t\t\tminOffset,\n\t\t\tnearestSnapsX,\n\t\t\tnearestSnapsY,\n\t\t\totherNodeSnapPoints,\n\t\t\tselectionSnapPoints,\n\t\t})\n\n\t\tthis.collectGapSnaps({\n\t\t\tselectionPageBounds,\n\t\t\tnearestSnapsX,\n\t\t\tnearestSnapsY,\n\t\t\tminOffset,\n\t\t})\n\n\t\t// at the same time, calculate how far we need to nudge the shape to 'snap' to the target point(s)\n\t\tconst nudge = new Vec(\n\t\t\tlockedAxis === 'x' ? 0 : (nearestSnapsX[0]?.nudge ?? 0),\n\t\t\tlockedAxis === 'y' ? 0 : (nearestSnapsY[0]?.nudge ?? 0)\n\t\t)\n\n\t\t// ok we've figured out how much the box should be nudged, now let's find all the snap points\n\t\t// that are exact after making that translation, so we can render all of them.\n\t\t// first reset everything and adjust the original shapes to conform to the nudge\n\t\tminOffset.x = 0\n\t\tminOffset.y = 0\n\t\tnearestSnapsX.length = 0\n\t\tnearestSnapsY.length = 0\n\t\tselectionSnapPoints.forEach((s) => {\n\t\t\ts.x += nudge.x\n\t\t\ts.y += nudge.y\n\t\t})\n\t\tselectionPageBounds.translate(nudge)\n\n\t\tthis.collectPointSnaps({\n\t\t\tminOffset,\n\t\t\tnearestSnapsX,\n\t\t\tnearestSnapsY,\n\t\t\totherNodeSnapPoints,\n\t\t\tselectionSnapPoints,\n\t\t})\n\n\t\tthis.collectGapSnaps({\n\t\t\tselectionPageBounds,\n\t\t\tnearestSnapsX,\n\t\t\tnearestSnapsY,\n\t\t\tminOffset,\n\t\t})\n\n\t\tconst pointSnapsLines = this.getPointSnapLines({\n\t\t\tnearestSnapsX,\n\t\t\tnearestSnapsY,\n\t\t})\n\n\t\tconst gapSnapLines = this.getGapSnapLines({\n\t\t\tselectionPageBounds,\n\t\t\tnearestSnapsX,\n\t\t\tnearestSnapsY,\n\t\t})\n\n\t\tthis.manager.setIndicators([...gapSnapLines, ...pointSnapsLines])\n\n\t\treturn { nudge }\n\t}\n\n\tsnapResizeShapes({\n\t\tinitialSelectionPageBounds,\n\t\tdragDelta,\n\t\thandle: originalHandle,\n\t\tisAspectRatioLocked,\n\t\tisResizingFromCenter,\n\t}: {\n\t\t// the page bounds when the pointer went down, before any dragging\n\t\tinitialSelectionPageBounds: Box\n\t\t// how far the pointer has been dragged\n\t\tdragDelta: Vec\n\n\t\thandle: SelectionCorner | SelectionEdge\n\t\tisAspectRatioLocked: boolean\n\t\tisResizingFromCenter: boolean\n\t}): SnapData {\n\t\tconst snapThreshold = this.manager.getSnapThreshold()\n\n\t\t// first figure out the new bounds of the selection\n\t\tconst {\n\t\t\tbox: unsnappedResizedPageBounds,\n\t\t\tscaleX,\n\t\t\tscaleY,\n\t\t} = Box.Resize(\n\t\t\tinitialSelectionPageBounds,\n\t\t\toriginalHandle,\n\t\t\tisResizingFromCenter ? dragDelta.x * 2 : dragDelta.x,\n\t\t\tisResizingFromCenter ? dragDelta.y * 2 : dragDelta.y,\n\t\t\tisAspectRatioLocked\n\t\t)\n\n\t\tlet handle = originalHandle\n\n\t\tif (scaleX < 0) {\n\t\t\thandle = flipSelectionHandleX(handle)\n\t\t}\n\t\tif (scaleY < 0) {\n\t\t\thandle = flipSelectionHandleY(handle)\n\t\t}\n\n\t\tif (isResizingFromCenter) {\n\t\t\t// reposition if resizing from center\n\t\t\tunsnappedResizedPageBounds.center = initialSelectionPageBounds.center\n\t\t}\n\n\t\tconst isXLocked = handle === 'top' || handle === 'bottom'\n\t\tconst isYLocked = handle === 'left' || handle === 'right'\n\n\t\tconst selectionSnapPoints = getResizeSnapPointsForHandle(handle, unsnappedResizedPageBounds)\n\n\t\tconst otherNodeSnapPoints = this.getSnappablePoints()\n\n\t\tconst nearestSnapsX: NearestPointsSnap[] = []\n\t\tconst nearestSnapsY: NearestPointsSnap[] = []\n\t\tconst minOffset = new Vec(snapThreshold, snapThreshold)\n\n\t\tthis.collectPointSnaps({\n\t\t\tminOffset,\n\t\t\tnearestSnapsX,\n\t\t\tnearestSnapsY,\n\t\t\totherNodeSnapPoints,\n\t\t\tselectionSnapPoints,\n\t\t})\n\n\t\t// at the same time, calculate how far we need to nudge the shape to 'snap' to the target point(s)\n\t\tconst nudge = new Vec(\n\t\t\tisXLocked ? 0 : (nearestSnapsX[0]?.nudge ?? 0),\n\t\t\tisYLocked ? 0 : (nearestSnapsY[0]?.nudge ?? 0)\n\t\t)\n\n\t\tif (isAspectRatioLocked && isSelectionCorner(handle) && nudge.len() !== 0) {\n\t\t\t// if the aspect ratio is locked we need to make the nudge diagonal rather than independent in each axis\n\t\t\t// so we use the aspect ratio along with one axis value to set the other axis value, but which axis we use\n\t\t\t// as a source of truth depends what we have snapped to and how far.\n\n\t\t\t// if we found a snap in both axes, pick the closest one and discard the other\n\t\t\tconst primaryNudgeAxis: 'x' | 'y' =\n\t\t\t\tnearestSnapsX.length && nearestSnapsY.length\n\t\t\t\t\t? Math.abs(nudge.x) < Math.abs(nudge.y)\n\t\t\t\t\t\t? 'x'\n\t\t\t\t\t\t: 'y'\n\t\t\t\t\t: nearestSnapsX.length\n\t\t\t\t\t\t? 'x'\n\t\t\t\t\t\t: 'y'\n\n\t\t\tconst ratio = initialSelectionPageBounds.aspectRatio\n\n\t\t\tif (primaryNudgeAxis === 'x') {\n\t\t\t\tnearestSnapsY.length = 0\n\t\t\t\tnudge.y = nudge.x / ratio\n\t\t\t\tif (handle === 'bottom_left' || handle === 'top_right') {\n\t\t\t\t\tnudge.y = -nudge.y\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnearestSnapsX.length = 0\n\t\t\t\tnudge.x = nudge.y * ratio\n\t\t\t\tif (handle === 'bottom_left' || handle === 'top_right') {\n\t\t\t\t\tnudge.x = -nudge.x\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// now resize the box after nudging, calculate the snaps again, and return the snap lines to match\n\t\t// the fully resized box\n\t\tconst snappedDelta = Vec.Add(dragDelta, nudge)\n\n\t\t// first figure out the new bounds of the selection\n\t\tconst { box: snappedResizedPageBounds } = Box.Resize(\n\t\t\tinitialSelectionPageBounds,\n\t\t\toriginalHandle,\n\t\t\tisResizingFromCenter ? snappedDelta.x * 2 : snappedDelta.x,\n\t\t\tisResizingFromCenter ? snappedDelta.y * 2 : snappedDelta.y,\n\t\t\tisAspectRatioLocked\n\t\t)\n\n\t\tif (isResizingFromCenter) {\n\t\t\t// reposition if resizing from center\n\t\t\tsnappedResizedPageBounds.center = initialSelectionPageBounds.center\n\t\t}\n\n\t\tconst snappedSelectionPoints = getResizeSnapPointsForHandle('any', snappedResizedPageBounds)\n\t\t// calculate snaps again using all points\n\t\tnearestSnapsX.length = 0\n\t\tnearestSnapsY.length = 0\n\t\tminOffset.x = 0\n\t\tminOffset.y = 0\n\n\t\tthis.collectPointSnaps({\n\t\t\tminOffset,\n\t\t\tnearestSnapsX,\n\t\t\tnearestSnapsY,\n\t\t\totherNodeSnapPoints,\n\t\t\tselectionSnapPoints: snappedSelectionPoints,\n\t\t})\n\t\tconst pointSnaps = this.getPointSnapLines({\n\t\t\tnearestSnapsX,\n\t\t\tnearestSnapsY,\n\t\t})\n\n\t\tthis.manager.setIndicators([...pointSnaps])\n\n\t\treturn { nudge }\n\t}\n\n\tprivate collectPointSnaps({\n\t\tselectionSnapPoints,\n\t\totherNodeSnapPoints,\n\t\tminOffset,\n\t\tnearestSnapsX,\n\t\tnearestSnapsY,\n\t}: {\n\t\tselectionSnapPoints: BoundsSnapPoint[]\n\t\totherNodeSnapPoints: BoundsSnapPoint[]\n\t\tminOffset: Vec\n\t\tnearestSnapsX: NearestSnap[]\n\t\tnearestSnapsY: NearestSnap[]\n\t}) {\n\t\t// for each snap point on the bounding box of the selection, find the set of points\n\t\t// which are closest to it in each axis\n\t\tfor (const thisSnapPoint of selectionSnapPoints) {\n\t\t\tfor (const otherSnapPoint of otherNodeSnapPoints) {\n\t\t\t\tconst offset = Vec.Sub(thisSnapPoint, otherSnapPoint)\n\t\t\t\tconst offsetX = Math.abs(offset.x)\n\t\t\t\tconst offsetY = Math.abs(offset.y)\n\n\t\t\t\tif (round(offsetX) <= round(minOffset.x)) {\n\t\t\t\t\tif (round(offsetX) < round(minOffset.x)) {\n\t\t\t\t\t\t// we found a point that is significantly closer than all previous points\n\t\t\t\t\t\t// so wipe the slate clean and start over\n\t\t\t\t\t\tnearestSnapsX.length = 0\n\t\t\t\t\t}\n\n\t\t\t\t\tnearestSnapsX.push({\n\t\t\t\t\t\ttype: 'points',\n\t\t\t\t\t\tpoints: { thisPoint: thisSnapPoint, otherPoint: otherSnapPoint },\n\t\t\t\t\t\tnudge: otherSnapPoint.x - thisSnapPoint.x,\n\t\t\t\t\t})\n\t\t\t\t\tminOffset.x = offsetX\n\t\t\t\t}\n\n\t\t\t\tif (round(offsetY) <= round(minOffset.y)) {\n\t\t\t\t\tif (round(offsetY) < round(minOffset.y)) {\n\t\t\t\t\t\t// we found a point that is significantly closer than all previous points\n\t\t\t\t\t\t// so wipe the slate clean and start over\n\t\t\t\t\t\tnearestSnapsY.length = 0\n\t\t\t\t\t}\n\t\t\t\t\tnearestSnapsY.push({\n\t\t\t\t\t\ttype: 'points',\n\t\t\t\t\t\tpoints: { thisPoint: thisSnapPoint, otherPoint: otherSnapPoint },\n\t\t\t\t\t\tnudge: otherSnapPoint.y - thisSnapPoint.y,\n\t\t\t\t\t})\n\t\t\t\t\tminOffset.y = offsetY\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate collectGapSnaps({\n\t\tselectionPageBounds,\n\t\tminOffset,\n\t\tnearestSnapsX,\n\t\tnearestSnapsY,\n\t}: {\n\t\tselectionPageBounds: Box\n\t\tminOffset: Vec\n\t\tnearestSnapsX: NearestSnap[]\n\t\tnearestSnapsY: NearestSnap[]\n\t}) {\n\t\tconst { horizontal, vertical } = this.getVisibleGaps()\n\n\t\tfor (const gap of horizontal) {\n\t\t\t// ignore this gap if the selection doesn't overlap with it in the y axis\n\t\t\tif (\n\t\t\t\t!rangesOverlap(\n\t\t\t\t\tgap.breadthIntersection[0],\n\t\t\t\t\tgap.breadthIntersection[1],\n\t\t\t\t\tselectionPageBounds.minY,\n\t\t\t\t\tselectionPageBounds.maxY\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// check for center match\n\t\t\tconst gapMidX = gap.startEdge[0].x + gap.length / 2\n\t\t\tconst centerNudge = gapMidX - selectionPageBounds.center.x\n\t\t\tconst gapIsLargerThanSelection = gap.length > selectionPageBounds.width\n\n\t\t\tif (gapIsLargerThanSelection && round(Math.abs(centerNudge)) <= round(minOffset.x)) {\n\t\t\t\tif (round(Math.abs(centerNudge)) < round(minOffset.x)) {\n\t\t\t\t\t// reset if we found a closer snap\n\t\t\t\t\tnearestSnapsX.length = 0\n\t\t\t\t}\n\t\t\t\tminOffset.x = Math.abs(centerNudge)\n\n\t\t\t\tconst snap: NearestSnap = {\n\t\t\t\t\ttype: 'gap_center',\n\t\t\t\t\tgap,\n\t\t\t\t\tnudge: centerNudge,\n\t\t\t\t}\n\n\t\t\t\t// we need to avoid creating visual noise with too many center snaps in situations\n\t\t\t\t// where there are lots of adjacent items with even spacing\n\t\t\t\t// so let's only show other center snaps where the gap's breadth does not overlap with this one\n\t\t\t\t// i.e.\n\t\t\t\t//                \n\t\t\t\t//                               \n\t\t\t\t//                \n\t\t\t\t//                           \n\t\t\t\t//                    \n\t\t\t\t//                          \n\t\t\t\t//                    \n\t\t\t\t//                           \n\t\t\t\t//                   \n\t\t\t\t//                                       i'm dragging this one\n\t\t\t\t//                   \n\t\t\t\t//                     \n\t\t\t\t//                                    don't show these\n\t\t\t\t// show these                               larger gaps since\n\t\t\t\t// smaller              the smaller ones\n\t\t\t\t// gaps                                      cover the same\n\t\t\t\t//                          information\n\t\t\t\t//                                 \n\t\t\t\t//                      \n\t\t\t\t//\n\t\t\t\t// but we want to show all of these ones since the gap breadths don't overlap\n\t\t\t\t//            \n\t\t\t\t//                         \n\t\t\t\t//      \n\t\t\t\t//              \n\t\t\t\t//          \n\t\t\t\t//               \n\t\t\t\t// \n\t\t\t\t//                   i'm dragging this one\n\t\t\t\t// \n\t\t\t\t//               \n\t\t\t\t//       \n\t\t\t\t//              \n\t\t\t\t//     \n\t\t\t\t//                       \n\t\t\t\t//              \n\n\t\t\t\tconst otherCenterSnap = nearestSnapsX.find(({ type }) => type === 'gap_center') as\n\t\t\t\t\t| Extract<NearestSnap, { type: 'gap_center' }>\n\t\t\t\t\t| undefined\n\n\t\t\t\tconst gapBreadthsOverlap =\n\t\t\t\t\totherCenterSnap &&\n\t\t\t\t\trangeIntersection(\n\t\t\t\t\t\tgap.breadthIntersection[0],\n\t\t\t\t\t\tgap.breadthIntersection[1],\n\t\t\t\t\t\totherCenterSnap.gap.breadthIntersection[0],\n\t\t\t\t\t\totherCenterSnap.gap.breadthIntersection[1]\n\t\t\t\t\t)\n\n\t\t\t\t// if there is another center snap and it's bigger than this one, and it overlaps with this one, replace it\n\t\t\t\tif (otherCenterSnap && otherCenterSnap.gap.length > gap.length && gapBreadthsOverlap) {\n\t\t\t\t\tnearestSnapsX[nearestSnapsX.indexOf(otherCenterSnap)] = snap\n\t\t\t\t} else if (!otherCenterSnap || !gapBreadthsOverlap) {\n\t\t\t\t\tnearestSnapsX.push(snap)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// check for duplication left match\n\t\t\tconst duplicationLeftX = gap.startNode.pageBounds.minX - gap.length\n\t\t\tconst selectionRightX = selectionPageBounds.maxX\n\n\t\t\tconst duplicationLeftNudge = duplicationLeftX - selectionRightX\n\t\t\tif (round(Math.abs(duplicationLeftNudge)) <= round(minOffset.x)) {\n\t\t\t\tif (round(Math.abs(duplicationLeftNudge)) < round(minOffset.x)) {\n\t\t\t\t\t// reset if we found a closer snap\n\t\t\t\t\tnearestSnapsX.length = 0\n\t\t\t\t}\n\t\t\t\tminOffset.x = Math.abs(duplicationLeftNudge)\n\n\t\t\t\tnearestSnapsX.push({\n\t\t\t\t\ttype: 'gap_duplicate',\n\t\t\t\t\tgap,\n\t\t\t\t\tprotrusionDirection: 'left',\n\t\t\t\t\tnudge: duplicationLeftNudge,\n\t\t\t\t})\n\t\t\t}\n\n\t\t\t// check for duplication right match\n\t\t\tconst duplicationRightX = gap.endNode.pageBounds.maxX + gap.length\n\t\t\tconst selectionLeftX = selectionPageBounds.minX\n\n\t\t\tconst duplicationRightNudge = duplicationRightX - selectionLeftX\n\t\t\tif (round(Math.abs(duplicationRightNudge)) <= round(minOffset.x)) {\n\t\t\t\tif (round(Math.abs(duplicationRightNudge)) < round(minOffset.x)) {\n\t\t\t\t\t// reset if we found a closer snap\n\t\t\t\t\tnearestSnapsX.length = 0\n\t\t\t\t}\n\t\t\t\tminOffset.x = Math.abs(duplicationRightNudge)\n\n\t\t\t\tnearestSnapsX.push({\n\t\t\t\t\ttype: 'gap_duplicate',\n\t\t\t\t\tgap,\n\t\t\t\t\tprotrusionDirection: 'right',\n\t\t\t\t\tnudge: duplicationRightNudge,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\tfor (const gap of vertical) {\n\t\t\t// ignore this gap if the selection doesn't overlap with it in the y axis\n\t\t\tif (\n\t\t\t\t!rangesOverlap(\n\t\t\t\t\tgap.breadthIntersection[0],\n\t\t\t\t\tgap.breadthIntersection[1],\n\t\t\t\t\tselectionPageBounds.minX,\n\t\t\t\t\tselectionPageBounds.maxX\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// check for center match\n\t\t\tconst gapMidY = gap.startEdge[0].y + gap.length / 2\n\t\t\tconst centerNudge = gapMidY - selectionPageBounds.center.y\n\n\t\t\tconst gapIsLargerThanSelection = gap.length > selectionPageBounds.height\n\n\t\t\tif (gapIsLargerThanSelection && round(Math.abs(centerNudge)) <= round(minOffset.y)) {\n\t\t\t\tif (round(Math.abs(centerNudge)) < round(minOffset.y)) {\n\t\t\t\t\t// reset if we found a closer snap\n\t\t\t\t\tnearestSnapsY.length = 0\n\t\t\t\t}\n\t\t\t\tminOffset.y = Math.abs(centerNudge)\n\n\t\t\t\tconst snap: NearestSnap = {\n\t\t\t\t\ttype: 'gap_center',\n\t\t\t\t\tgap,\n\t\t\t\t\tnudge: centerNudge,\n\t\t\t\t}\n\n\t\t\t\t// we need to avoid creating visual noise with too many center snaps in situations\n\t\t\t\t// where there are lots of adjacent items with even spacing\n\t\t\t\t// so let's only show other center snaps where the gap's breadth does not overlap with this one\n\t\t\t\t// i.e.\n\t\t\t\t//                \n\t\t\t\t//                               \n\t\t\t\t//                \n\t\t\t\t//                           \n\t\t\t\t//                    \n\t\t\t\t//                          \n\t\t\t\t//                    \n\t\t\t\t//                           \n\t\t\t\t//                   \n\t\t\t\t//                                       i'm dragging this one\n\t\t\t\t//                   \n\t\t\t\t//                     \n\t\t\t\t//                                    don't show these\n\t\t\t\t// show these                               larger gaps since\n\t\t\t\t// smaller              the smaller ones\n\t\t\t\t// gaps                                      cover the same\n\t\t\t\t//                          information\n\t\t\t\t//                                 \n\t\t\t\t//                      \n\t\t\t\t//\n\t\t\t\t// but we want to show all of these ones since the gap breadths don't overlap\n\t\t\t\t//            \n\t\t\t\t//                         \n\t\t\t\t//      \n\t\t\t\t//              \n\t\t\t\t//          \n\t\t\t\t//               \n\t\t\t\t// \n\t\t\t\t//                   i'm dragging this one\n\t\t\t\t// \n\t\t\t\t//               \n\t\t\t\t//       \n\t\t\t\t//              \n\t\t\t\t//     \n\t\t\t\t//                       \n\t\t\t\t//              \n\n\t\t\t\tconst otherCenterSnap = nearestSnapsY.find(({ type }) => type === 'gap_center') as\n\t\t\t\t\t| Extract<NearestSnap, { type: 'gap_center' }>\n\t\t\t\t\t| undefined\n\n\t\t\t\tconst gapBreadthsOverlap =\n\t\t\t\t\totherCenterSnap &&\n\t\t\t\t\trangesOverlap(\n\t\t\t\t\t\totherCenterSnap.gap.breadthIntersection[0],\n\t\t\t\t\t\totherCenterSnap.gap.breadthIntersection[1],\n\t\t\t\t\t\tgap.breadthIntersection[0],\n\t\t\t\t\t\tgap.breadthIntersection[1]\n\t\t\t\t\t)\n\n\t\t\t\t// if there is another center snap and it's bigger than this one, and it overlaps with this one, replace it\n\t\t\t\tif (otherCenterSnap && otherCenterSnap.gap.length > gap.length && gapBreadthsOverlap) {\n\t\t\t\t\tnearestSnapsY[nearestSnapsY.indexOf(otherCenterSnap)] = snap\n\t\t\t\t} else if (!otherCenterSnap || !gapBreadthsOverlap) {\n\t\t\t\t\tnearestSnapsY.push(snap)\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// check for duplication top match\n\t\t\tconst duplicationTopY = gap.startNode.pageBounds.minY - gap.length\n\t\t\tconst selectionBottomY = selectionPageBounds.maxY\n\n\t\t\tconst duplicationTopNudge = duplicationTopY - selectionBottomY\n\t\t\tif (round(Math.abs(duplicationTopNudge)) <= round(minOffset.y)) {\n\t\t\t\tif (round(Math.abs(duplicationTopNudge)) < round(minOffset.y)) {\n\t\t\t\t\t// reset if we found a closer snap\n\t\t\t\t\tnearestSnapsY.length = 0\n\t\t\t\t}\n\t\t\t\tminOffset.y = Math.abs(duplicationTopNudge)\n\n\t\t\t\tnearestSnapsY.push({\n\t\t\t\t\ttype: 'gap_duplicate',\n\t\t\t\t\tgap,\n\t\t\t\t\tprotrusionDirection: 'top',\n\t\t\t\t\tnudge: duplicationTopNudge,\n\t\t\t\t})\n\t\t\t}\n\n\t\t\t// check for duplication bottom match\n\t\t\tconst duplicationBottomY = gap.endNode.pageBounds.maxY + gap.length\n\t\t\tconst selectionTopY = selectionPageBounds.minY\n\n\t\t\tconst duplicationBottomNudge = duplicationBottomY - selectionTopY\n\t\t\tif (round(Math.abs(duplicationBottomNudge)) <= round(minOffset.y)) {\n\t\t\t\tif (round(Math.abs(duplicationBottomNudge)) < round(minOffset.y)) {\n\t\t\t\t\t// reset if we found a closer snap\n\t\t\t\t\tnearestSnapsY.length = 0\n\t\t\t\t}\n\t\t\t\tminOffset.y = Math.abs(duplicationBottomNudge)\n\n\t\t\t\tnearestSnapsY.push({\n\t\t\t\t\ttype: 'gap_duplicate',\n\t\t\t\t\tgap,\n\t\t\t\t\tprotrusionDirection: 'bottom',\n\t\t\t\t\tnudge: duplicationBottomNudge,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate getPointSnapLines({\n\t\tnearestSnapsX,\n\t\tnearestSnapsY,\n\t}: {\n\t\tnearestSnapsX: NearestSnap[]\n\t\tnearestSnapsY: NearestSnap[]\n\t}): PointsSnapIndicator[] {\n\t\t// point snaps may align on multiple parallel lines so we need to split the pairs\n\t\t// into groups based on where they are in their their snap axes\n\t\tconst snapGroupsX = {} as { [key: string]: SnapPair[] }\n\t\tconst snapGroupsY = {} as { [key: string]: SnapPair[] }\n\n\t\tif (nearestSnapsX.length > 0) {\n\t\t\tfor (const snap of nearestSnapsX) {\n\t\t\t\tif (snap.type === 'points') {\n\t\t\t\t\tconst key = round(snap.points.otherPoint.x)\n\t\t\t\t\tif (!snapGroupsX[key]) {\n\t\t\t\t\t\tsnapGroupsX[key] = []\n\t\t\t\t\t}\n\t\t\t\t\tsnapGroupsX[key].push(snap.points)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (nearestSnapsY.length > 0) {\n\t\t\tfor (const snap of nearestSnapsY) {\n\t\t\t\tif (snap.type === 'points') {\n\t\t\t\t\tconst key = round(snap.points.otherPoint.y)\n\t\t\t\t\tif (!snapGroupsY[key]) {\n\t\t\t\t\t\tsnapGroupsY[key] = []\n\t\t\t\t\t}\n\t\t\t\t\tsnapGroupsY[key].push(snap.points)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// and finally create all the snap lines for the UI to render\n\t\treturn Object.values(snapGroupsX)\n\t\t\t.concat(Object.values(snapGroupsY))\n\t\t\t.map((snapGroup) => ({\n\t\t\t\tid: uniqueId(),\n\t\t\t\ttype: 'points',\n\t\t\t\tpoints: dedupe(\n\t\t\t\t\tsnapGroup\n\t\t\t\t\t\t.map((snap) => Vec.From(snap.otherPoint))\n\t\t\t\t\t\t// be sure to nudge over the selection snap points\n\t\t\t\t\t\t.concat(snapGroup.map((snap) => Vec.From(snap.thisPoint))),\n\t\t\t\t\t(a: Vec, b: Vec) => a.equals(b)\n\t\t\t\t),\n\t\t\t}))\n\t}\n\n\tprivate getGapSnapLines({\n\t\tselectionPageBounds,\n\t\tnearestSnapsX,\n\t\tnearestSnapsY,\n\t}: {\n\t\tselectionPageBounds: Box\n\t\tnearestSnapsX: NearestSnap[]\n\t\tnearestSnapsY: NearestSnap[]\n\t}): GapsSnapIndicator[] {\n\t\tconst { vertical, horizontal } = this.getVisibleGaps()\n\n\t\tconst selectionSides: Record<SelectionEdge, [Vec, Vec]> = {\n\t\t\ttop: selectionPageBounds.sides[0],\n\t\t\tright: selectionPageBounds.sides[1],\n\t\t\t// need bottom and left to be sorted asc, which .sides is not.\n\t\t\tbottom: [selectionPageBounds.corners[3], selectionPageBounds.corners[2]],\n\t\t\tleft: [selectionPageBounds.corners[0], selectionPageBounds.corners[3]],\n\t\t}\n\n\t\tconst result: GapsSnapIndicator[] = []\n\n\t\tif (nearestSnapsX.length > 0) {\n\t\t\tfor (const snap of nearestSnapsX) {\n\t\t\t\tif (snap.type === 'points') continue\n\n\t\t\t\tconst {\n\t\t\t\t\tgap: { breadthIntersection, startEdge, startNode, endNode, length, endEdge },\n\t\t\t\t} = snap\n\n\t\t\t\tswitch (snap.type) {\n\t\t\t\t\tcase 'gap_center': {\n\t\t\t\t\t\t// create\n\t\t\t\t\t\tconst newGapsLength = (length - selectionPageBounds.width) / 2\n\t\t\t\t\t\tconst gapBreadthIntersection = rangeIntersection(\n\t\t\t\t\t\t\tbreadthIntersection[0],\n\t\t\t\t\t\t\tbreadthIntersection[1],\n\t\t\t\t\t\t\tselectionPageBounds.minY,\n\t\t\t\t\t\t\tselectionPageBounds.maxY\n\t\t\t\t\t\t)!\n\t\t\t\t\t\tresult.push({\n\t\t\t\t\t\t\ttype: 'gaps',\n\t\t\t\t\t\t\tdirection: 'horizontal',\n\t\t\t\t\t\t\tid: uniqueId(),\n\t\t\t\t\t\t\tgaps: [\n\t\t\t\t\t\t\t\t...findAdjacentGaps(\n\t\t\t\t\t\t\t\t\thorizontal,\n\t\t\t\t\t\t\t\t\tstartNode.id,\n\t\t\t\t\t\t\t\t\tnewGapsLength,\n\t\t\t\t\t\t\t\t\t'backward',\n\t\t\t\t\t\t\t\t\tgapBreadthIntersection\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tstartEdge,\n\t\t\t\t\t\t\t\t\tendEdge: selectionSides.left,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tstartEdge: selectionSides.right,\n\t\t\t\t\t\t\t\t\tendEdge,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t...findAdjacentGaps(\n\t\t\t\t\t\t\t\t\thorizontal,\n\t\t\t\t\t\t\t\t\tendNode.id,\n\t\t\t\t\t\t\t\t\tnewGapsLength,\n\t\t\t\t\t\t\t\t\t'forward',\n\t\t\t\t\t\t\t\t\tgapBreadthIntersection\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t})\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tcase 'gap_duplicate': {\n\t\t\t\t\t\t// create\n\t\t\t\t\t\tconst gapBreadthIntersection = rangeIntersection(\n\t\t\t\t\t\t\tbreadthIntersection[0],\n\t\t\t\t\t\t\tbreadthIntersection[1],\n\t\t\t\t\t\t\tselectionPageBounds.minY,\n\t\t\t\t\t\t\tselectionPageBounds.maxY\n\t\t\t\t\t\t)!\n\t\t\t\t\t\tresult.push({\n\t\t\t\t\t\t\ttype: 'gaps',\n\t\t\t\t\t\t\tdirection: 'horizontal',\n\t\t\t\t\t\t\tid: uniqueId(),\n\t\t\t\t\t\t\tgaps:\n\t\t\t\t\t\t\t\tsnap.protrusionDirection === 'left'\n\t\t\t\t\t\t\t\t\t? [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tstartEdge: selectionSides.right,\n\t\t\t\t\t\t\t\t\t\t\t\tendEdge: startEdge.map((v) =>\n\t\t\t\t\t\t\t\t\t\t\t\t\tv.clone().addXY(-startNode.pageBounds.width, 0)\n\t\t\t\t\t\t\t\t\t\t\t\t) as [Vec, Vec],\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{ startEdge, endEdge },\n\t\t\t\t\t\t\t\t\t\t\t...findAdjacentGaps(\n\t\t\t\t\t\t\t\t\t\t\t\thorizontal,\n\t\t\t\t\t\t\t\t\t\t\t\tendNode.id,\n\t\t\t\t\t\t\t\t\t\t\t\tlength,\n\t\t\t\t\t\t\t\t\t\t\t\t'forward',\n\t\t\t\t\t\t\t\t\t\t\t\tgapBreadthIntersection\n\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t: [\n\t\t\t\t\t\t\t\t\t\t\t...findAdjacentGaps(\n\t\t\t\t\t\t\t\t\t\t\t\thorizontal,\n\t\t\t\t\t\t\t\t\t\t\t\tstartNode.id,\n\t\t\t\t\t\t\t\t\t\t\t\tlength,\n\t\t\t\t\t\t\t\t\t\t\t\t'backward',\n\t\t\t\t\t\t\t\t\t\t\t\tgapBreadthIntersection\n\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\t{ startEdge, endEdge },\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tstartEdge: endEdge.map((v) =>\n\t\t\t\t\t\t\t\t\t\t\t\t\tv.clone().addXY(snap.gap.endNode.pageBounds.width, 0)\n\t\t\t\t\t\t\t\t\t\t\t\t) as [Vec, Vec],\n\t\t\t\t\t\t\t\t\t\t\t\tendEdge: selectionSides.left,\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (nearestSnapsY.length > 0) {\n\t\t\tfor (const snap of nearestSnapsY) {\n\t\t\t\tif (snap.type === 'points') continue\n\n\t\t\t\tconst {\n\t\t\t\t\tgap: { breadthIntersection, startEdge, startNode, endNode, length, endEdge },\n\t\t\t\t} = snap\n\n\t\t\t\tswitch (snap.type) {\n\t\t\t\t\tcase 'gap_center': {\n\t\t\t\t\t\tconst newGapsLength = (length - selectionPageBounds.height) / 2\n\t\t\t\t\t\tconst gapBreadthIntersection = rangeIntersection(\n\t\t\t\t\t\t\tbreadthIntersection[0],\n\t\t\t\t\t\t\tbreadthIntersection[1],\n\t\t\t\t\t\t\tselectionPageBounds.minX,\n\t\t\t\t\t\t\tselectionPageBounds.maxX\n\t\t\t\t\t\t)!\n\n\t\t\t\t\t\tresult.push({\n\t\t\t\t\t\t\ttype: 'gaps',\n\t\t\t\t\t\t\tdirection: 'vertical',\n\t\t\t\t\t\t\tid: uniqueId(),\n\t\t\t\t\t\t\tgaps: [\n\t\t\t\t\t\t\t\t...findAdjacentGaps(\n\t\t\t\t\t\t\t\t\tvertical,\n\t\t\t\t\t\t\t\t\tstartNode.id,\n\t\t\t\t\t\t\t\t\tnewGapsLength,\n\t\t\t\t\t\t\t\t\t'backward',\n\t\t\t\t\t\t\t\t\tgapBreadthIntersection\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tstartEdge,\n\t\t\t\t\t\t\t\t\tendEdge: selectionSides.top,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tstartEdge: selectionSides.bottom,\n\t\t\t\t\t\t\t\t\tendEdge,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t...findAdjacentGaps(\n\t\t\t\t\t\t\t\t\tvertical,\n\t\t\t\t\t\t\t\t\tsnap.gap.endNode.id,\n\t\t\t\t\t\t\t\t\tnewGapsLength,\n\t\t\t\t\t\t\t\t\t'forward',\n\t\t\t\t\t\t\t\t\tgapBreadthIntersection\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t})\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tcase 'gap_duplicate':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst gapBreadthIntersection = rangeIntersection(\n\t\t\t\t\t\t\t\tbreadthIntersection[0],\n\t\t\t\t\t\t\t\tbreadthIntersection[1],\n\t\t\t\t\t\t\t\tselectionPageBounds.minX,\n\t\t\t\t\t\t\t\tselectionPageBounds.maxX\n\t\t\t\t\t\t\t)!\n\n\t\t\t\t\t\t\tresult.push({\n\t\t\t\t\t\t\t\ttype: 'gaps',\n\t\t\t\t\t\t\t\tdirection: 'vertical',\n\t\t\t\t\t\t\t\tid: uniqueId(),\n\t\t\t\t\t\t\t\tgaps:\n\t\t\t\t\t\t\t\t\tsnap.protrusionDirection === 'top'\n\t\t\t\t\t\t\t\t\t\t? [\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tstartEdge: selectionSides.bottom,\n\t\t\t\t\t\t\t\t\t\t\t\t\tendEdge: startEdge.map((v) =>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tv.clone().addXY(0, -startNode.pageBounds.height)\n\t\t\t\t\t\t\t\t\t\t\t\t\t) as [Vec, Vec],\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t{ startEdge, endEdge },\n\t\t\t\t\t\t\t\t\t\t\t\t...findAdjacentGaps(\n\t\t\t\t\t\t\t\t\t\t\t\t\tvertical,\n\t\t\t\t\t\t\t\t\t\t\t\t\tendNode.id,\n\t\t\t\t\t\t\t\t\t\t\t\t\tlength,\n\t\t\t\t\t\t\t\t\t\t\t\t\t'forward',\n\t\t\t\t\t\t\t\t\t\t\t\t\tgapBreadthIntersection\n\t\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t: [\n\t\t\t\t\t\t\t\t\t\t\t\t...findAdjacentGaps(\n\t\t\t\t\t\t\t\t\t\t\t\t\tvertical,\n\t\t\t\t\t\t\t\t\t\t\t\t\tstartNode.id,\n\t\t\t\t\t\t\t\t\t\t\t\t\tlength,\n\t\t\t\t\t\t\t\t\t\t\t\t\t'backward',\n\t\t\t\t\t\t\t\t\t\t\t\t\tgapBreadthIntersection\n\t\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\t\t{ startEdge, endEdge },\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tstartEdge: endEdge.map((v) =>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tv.clone().addXY(0, endNode.pageBounds.height)\n\t\t\t\t\t\t\t\t\t\t\t\t\t) as [Vec, Vec],\n\t\t\t\t\t\t\t\t\t\t\t\t\tendEdge: selectionSides.top,\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdedupeGapSnaps(result)\n\t\treturn result\n\t}\n}\n\nfunction getResizeSnapPointsForHandle(\n\thandle: SelectionCorner | SelectionEdge | 'any',\n\tselectionPageBounds: Box\n): BoundsSnapPoint[] {\n\tconst { minX, maxX, minY, maxY } = selectionPageBounds\n\tconst result: BoundsSnapPoint[] = []\n\n\t// top left corner\n\tswitch (handle) {\n\t\tcase 'top':\n\t\tcase 'left':\n\t\tcase 'top_left':\n\t\tcase 'any':\n\t\t\tresult.push({\n\t\t\t\tid: 'top_left',\n\t\t\t\thandle: 'top_left',\n\t\t\t\tx: minX,\n\t\t\t\ty: minY,\n\t\t\t})\n\t}\n\n\t// top right corner\n\tswitch (handle) {\n\t\tcase 'top':\n\t\tcase 'right':\n\t\tcase 'top_right':\n\t\tcase 'any':\n\t\t\tresult.push({\n\t\t\t\tid: 'top_right',\n\t\t\t\thandle: 'top_right',\n\t\t\t\tx: maxX,\n\t\t\t\ty: minY,\n\t\t\t})\n\t}\n\n\t// bottom right corner\n\tswitch (handle) {\n\t\tcase 'bottom':\n\t\tcase 'right':\n\t\tcase 'bottom_right':\n\t\tcase 'any':\n\t\t\tresult.push({\n\t\t\t\tid: 'bottom_right',\n\t\t\t\thandle: 'bottom_right',\n\t\t\t\tx: maxX,\n\t\t\t\ty: maxY,\n\t\t\t})\n\t}\n\n\t// bottom left corner\n\tswitch (handle) {\n\t\tcase 'bottom':\n\t\tcase 'left':\n\t\tcase 'bottom_left':\n\t\tcase 'any':\n\t\t\tresult.push({\n\t\t\t\tid: 'bottom_left',\n\t\t\t\thandle: 'bottom_left',\n\t\t\t\tx: minX,\n\t\t\t\ty: maxY,\n\t\t\t})\n\t}\n\n\treturn result\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2876, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/%40tldraw/editor/src/lib/editor/managers/SnapManager/HandleSnaps.ts"],"sourcesContent":["import { computed } from '@tldraw/state'\nimport { TLHandle, TLShape, TLShapeId, VecModel } from '@tldraw/tlschema'\nimport { assertExists, uniqueId } from '@tldraw/utils'\nimport { Vec } from '../../../primitives/Vec'\nimport { Geometry2d } from '../../../primitives/geometry/Geometry2d'\nimport { Editor } from '../../Editor'\nimport { SnapData, SnapManager } from './SnapManager'\n\n/**\n * When dragging a handle, users can snap the handle to key geometry on other nearby shapes.\n * Customize how handles snap to a shape by returning this from\n * {@link ShapeUtil.getHandleSnapGeometry}.\n *\n * Any co-ordinates here should be in the shape's local space.\n *\n * @public\n */\nexport interface HandleSnapGeometry {\n\t/**\n\t * A `Geometry2d` that describe the outline of the shape that the handle will snap to - fills\n\t * are ignored. By default, this is the same geometry returned by {@link ShapeUtil.getGeometry}.\n\t * Set this to `null` to disable handle snapping to this shape's outline.\n\t */\n\toutline?: Geometry2d | null\n\t/**\n\t * Key points on the shape that the handle will snap to. For example, the corners of a\n\t * rectangle, or the centroid of a triangle. By default, no points are used.\n\t */\n\tpoints?: VecModel[]\n\t/**\n\t * By default, handles can't snap to their own shape because moving the handle might change the\n\t * snapping location which can cause feedback loops. You can override this by returning a\n\t * version of `outline` that won't be affected by the current handle's position to use for\n\t * self-snapping.\n\t */\n\tgetSelfSnapOutline?(handle: TLHandle): Geometry2d | null\n\t/**\n\t * By default, handles can't snap to their own shape because moving the handle might change the\n\t * snapping location which can cause feedback loops. You can override this by returning a\n\t * version of `points` that won't be affected by the current handle's position to use for\n\t * self-snapping.\n\t */\n\tgetSelfSnapPoints?(handle: TLHandle): VecModel[]\n}\n\nconst defaultGetSelfSnapOutline = () => null\nconst defaultGetSelfSnapPoints = () => []\n/** @public */\nexport class HandleSnaps {\n\treadonly editor: Editor\n\tconstructor(readonly manager: SnapManager) {\n\t\tthis.editor = manager.editor\n\t}\n\n\t@computed private getSnapGeometryCache() {\n\t\tconst { editor } = this\n\t\treturn editor.store.createComputedCache('handle snap geometry', (shape: TLShape) => {\n\t\t\tconst snapGeometry = editor.getShapeUtil(shape).getHandleSnapGeometry(shape)\n\t\t\tconst getSelfSnapOutline = snapGeometry.getSelfSnapOutline\n\t\t\t\t? snapGeometry.getSelfSnapOutline.bind(snapGeometry)\n\t\t\t\t: defaultGetSelfSnapOutline\n\t\t\tconst getSelfSnapPoints = snapGeometry.getSelfSnapPoints\n\t\t\t\t? snapGeometry.getSelfSnapPoints.bind(snapGeometry)\n\t\t\t\t: defaultGetSelfSnapPoints\n\n\t\t\treturn {\n\t\t\t\toutline:\n\t\t\t\t\tsnapGeometry.outline === undefined\n\t\t\t\t\t\t? editor.getShapeGeometry(shape)\n\t\t\t\t\t\t: snapGeometry.outline,\n\n\t\t\t\tpoints: snapGeometry.points ?? [],\n\t\t\t\tgetSelfSnapOutline,\n\t\t\t\tgetSelfSnapPoints,\n\t\t\t}\n\t\t})\n\t}\n\n\tprivate *iterateSnapPointsInPageSpace(currentShapeId: TLShapeId, currentHandle: TLHandle) {\n\t\tconst selfSnapPoints = this.getSnapGeometryCache()\n\t\t\t.get(currentShapeId)\n\t\t\t?.getSelfSnapPoints(currentHandle)\n\t\tif (selfSnapPoints && selfSnapPoints.length) {\n\t\t\tconst shapePageTransform = assertExists(this.editor.getShapePageTransform(currentShapeId))\n\t\t\tfor (const point of selfSnapPoints) {\n\t\t\t\tyield shapePageTransform.applyToPoint(point)\n\t\t\t}\n\t\t}\n\n\t\tfor (const shapeId of this.manager.getSnappableShapes()) {\n\t\t\tif (shapeId === currentShapeId) continue\n\t\t\tconst snapPoints = this.getSnapGeometryCache().get(shapeId)?.points\n\t\t\tif (!snapPoints || !snapPoints.length) continue\n\n\t\t\tconst shapePageTransform = assertExists(this.editor.getShapePageTransform(shapeId))\n\t\t\tfor (const point of snapPoints) {\n\t\t\t\tyield shapePageTransform.applyToPoint(point)\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate *iterateSnapOutlines(currentShapeId: TLShapeId, currentHandle: TLHandle) {\n\t\tconst selfSnapOutline = this.getSnapGeometryCache()\n\t\t\t.get(currentShapeId)\n\t\t\t?.getSelfSnapOutline(currentHandle)\n\t\tif (selfSnapOutline) {\n\t\t\tyield { shapeId: currentShapeId, outline: selfSnapOutline }\n\t\t}\n\n\t\tfor (const shapeId of this.manager.getSnappableShapes()) {\n\t\t\tif (shapeId === currentShapeId) continue\n\n\t\t\tconst snapOutline = this.getSnapGeometryCache().get(shapeId)?.outline\n\t\t\tif (!snapOutline) continue\n\n\t\t\tyield { shapeId, outline: snapOutline }\n\t\t}\n\t}\n\n\tprivate getHandleSnapPosition({\n\t\tcurrentShapeId,\n\t\thandle,\n\t\thandleInPageSpace,\n\t}: {\n\t\tcurrentShapeId: TLShapeId\n\t\thandle: TLHandle\n\t\thandleInPageSpace: Vec\n\t}): Vec | null {\n\t\tconst snapThreshold = this.manager.getSnapThreshold()\n\n\t\t// We snap to two different parts of the shape's handle snap geometry:\n\t\t// 1. The `points`. These are handles or other key points that we want to snap to with a\n\t\t//    higher priority than the normal outline snapping.\n\t\t// 2. The `outline`. This describes the outline of the shape, and we just snap to the\n\t\t//    nearest point on that outline.\n\n\t\t// Start with the points:\n\t\tlet minDistanceForSnapPoint = snapThreshold\n\t\tlet nearestSnapPoint: Vec | null = null\n\t\tfor (const snapPoint of this.iterateSnapPointsInPageSpace(currentShapeId, handle)) {\n\t\t\tif (Vec.DistMin(handleInPageSpace, snapPoint, minDistanceForSnapPoint)) {\n\t\t\t\tminDistanceForSnapPoint = Vec.Dist(handleInPageSpace, snapPoint)\n\t\t\t\tnearestSnapPoint = snapPoint\n\t\t\t}\n\t\t}\n\n\t\t// if we found a snap point, return it - we don't need to check the outlines because points\n\t\t// have a higher priority\n\t\tif (nearestSnapPoint) return nearestSnapPoint\n\n\t\tlet minDistanceForOutline = snapThreshold\n\t\tlet nearestPointOnOutline: Vec | null = null\n\n\t\tfor (const { shapeId, outline } of this.iterateSnapOutlines(currentShapeId, handle)) {\n\t\t\tconst shapePageTransform = assertExists(this.editor.getShapePageTransform(shapeId))\n\t\t\tconst pointInShapeSpace = this.editor.getPointInShapeSpace(shapeId, handleInPageSpace)\n\n\t\t\tconst nearestShapePointInShapeSpace = outline.nearestPoint(pointInShapeSpace)\n\t\t\tconst nearestInPageSpace = shapePageTransform.applyToPoint(nearestShapePointInShapeSpace)\n\n\t\t\tif (Vec.DistMin(handleInPageSpace, nearestInPageSpace, minDistanceForOutline)) {\n\t\t\t\tminDistanceForOutline = Vec.Dist(handleInPageSpace, nearestInPageSpace)\n\t\t\t\tnearestPointOnOutline = nearestInPageSpace\n\t\t\t}\n\t\t}\n\n\t\t// if we found a point on the outline, return it\n\t\tif (nearestPointOnOutline) return nearestPointOnOutline\n\n\t\t// if not, there's no nearby snap point\n\t\treturn null\n\t}\n\n\tsnapHandle({\n\t\tcurrentShapeId,\n\t\thandle,\n\t}: {\n\t\tcurrentShapeId: TLShapeId\n\t\thandle: TLHandle\n\t}): SnapData | null {\n\t\tconst currentShapeTransform = assertExists(this.editor.getShapePageTransform(currentShapeId))\n\t\tconst handleInPageSpace = currentShapeTransform.applyToPoint(handle)\n\t\tconst snapPosition = this.getHandleSnapPosition({ currentShapeId, handle, handleInPageSpace })\n\n\t\t// If we found a point, display snap lines, and return the nudge\n\t\tif (snapPosition) {\n\t\t\tthis.manager.setIndicators([\n\t\t\t\t{\n\t\t\t\t\tid: uniqueId(),\n\t\t\t\t\ttype: 'points',\n\t\t\t\t\tpoints: [snapPosition],\n\t\t\t\t},\n\t\t\t])\n\n\t\t\treturn { nudge: Vec.Sub(snapPosition, handleInPageSpace) }\n\t\t}\n\n\t\treturn null\n\t}\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3097, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/%40tldraw/editor/src/lib/editor/managers/SnapManager/SnapManager.ts"],"sourcesContent":["import { EMPTY_ARRAY, atom, computed } from '@tldraw/state'\nimport { TLFrameShape, TLGroupShape, TLParentId, TLShapeId, isShapeId } from '@tldraw/tlschema'\nimport { Vec, VecLike } from '../../../primitives/Vec'\nimport type { Editor } from '../../Editor'\nimport { BoundsSnaps } from './BoundsSnaps'\nimport { HandleSnaps } from './HandleSnaps'\n\n/** @public */\nexport interface PointsSnapIndicator {\n\tid: string\n\ttype: 'points'\n\tpoints: VecLike[]\n}\n\n/** @public */\nexport interface GapsSnapIndicator {\n\tid: string\n\ttype: 'gaps'\n\tdirection: 'horizontal' | 'vertical'\n\tgaps: Array<{\n\t\tstartEdge: [VecLike, VecLike]\n\t\tendEdge: [VecLike, VecLike]\n\t}>\n}\n\n/** @public */\nexport type SnapIndicator = PointsSnapIndicator | GapsSnapIndicator\n\n/** @public */\nexport interface SnapData {\n\tnudge: Vec\n}\n\n/** @public */\nexport class SnapManager {\n\treadonly shapeBounds: BoundsSnaps\n\treadonly handles: HandleSnaps\n\n\tprivate _snapIndicators = atom<SnapIndicator[] | undefined>('snapLines', undefined)\n\n\tconstructor(public readonly editor: Editor) {\n\t\tthis.shapeBounds = new BoundsSnaps(this)\n\t\tthis.handles = new HandleSnaps(this)\n\t}\n\n\tgetIndicators() {\n\t\treturn this._snapIndicators.get() ?? (EMPTY_ARRAY as SnapIndicator[])\n\t}\n\n\tclearIndicators() {\n\t\tif (this.getIndicators().length) {\n\t\t\tthis._snapIndicators.set(undefined)\n\t\t}\n\t}\n\n\tsetIndicators(indicators: SnapIndicator[]) {\n\t\tthis._snapIndicators.set(indicators)\n\t}\n\n\t@computed getSnapThreshold() {\n\t\treturn 8 / this.editor.getZoomLevel()\n\t}\n\n\t// TODO: make this an incremental derivation\n\t@computed getSnappableShapes(): Set<TLShapeId> {\n\t\tconst { editor } = this\n\t\tconst renderingBounds = editor.getViewportPageBounds()\n\t\tconst selectedShapeIds = editor.getSelectedShapeIds()\n\n\t\tconst snappableShapes: Set<TLShapeId> = new Set()\n\n\t\tconst collectSnappableShapesFromParent = (parentId: TLParentId) => {\n\t\t\tif (isShapeId(parentId)) {\n\t\t\t\tconst parent = editor.getShape(parentId)\n\t\t\t\tif (parent && editor.isShapeOfType<TLFrameShape>(parent, 'frame')) {\n\t\t\t\t\tsnappableShapes.add(parentId)\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst sortedChildIds = editor.getSortedChildIdsForParent(parentId)\n\t\t\tfor (const childId of sortedChildIds) {\n\t\t\t\t// Skip any selected ids\n\t\t\t\tif (selectedShapeIds.includes(childId)) continue\n\t\t\t\tconst childShape = editor.getShape(childId)\n\t\t\t\tif (!childShape) continue\n\t\t\t\tconst util = editor.getShapeUtil(childShape)\n\t\t\t\t// Skip any shapes that don't allow snapping\n\t\t\t\tif (!util.canSnap(childShape)) continue\n\t\t\t\t// Only consider shapes if they're inside of the viewport page bounds\n\t\t\t\tconst pageBounds = editor.getShapePageBounds(childId)\n\t\t\t\tif (!(pageBounds && renderingBounds.includes(pageBounds))) continue\n\t\t\t\t// Snap to children of groups but not group itself\n\t\t\t\tif (editor.isShapeOfType<TLGroupShape>(childShape, 'group')) {\n\t\t\t\t\tcollectSnappableShapesFromParent(childId)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tsnappableShapes.add(childId)\n\t\t\t}\n\t\t}\n\n\t\tcollectSnappableShapesFromParent(this.getCurrentCommonAncestor() ?? editor.getCurrentPageId())\n\n\t\treturn snappableShapes\n\t}\n\n\t// This needs to be external from any expensive work\n\t@computed getCurrentCommonAncestor() {\n\t\treturn this.editor.findCommonAncestor(this.editor.getSelectedShapes())\n\t}\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3276, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/%40tldraw/editor/src/lib/editor/managers/TextManager/TextManager.ts"],"sourcesContent":["import { BoxModel, TLDefaultHorizontalAlignStyle } from '@tldraw/tlschema'\nimport { objectMapKeys } from '@tldraw/utils'\nimport { Editor } from '../../Editor'\n\nconst fixNewLines = /\\r?\\n|\\r/g\n\nfunction normalizeTextForDom(text: string) {\n\treturn text\n\t\t.replace(fixNewLines, '\\n')\n\t\t.split('\\n')\n\t\t.map((x) => x || ' ')\n\t\t.join('\\n')\n}\n\nconst textAlignmentsForLtr = {\n\tstart: 'left',\n\t'start-legacy': 'left',\n\tmiddle: 'center',\n\t'middle-legacy': 'center',\n\tend: 'right',\n\t'end-legacy': 'right',\n}\n\n/** @public */\nexport interface TLMeasureTextOpts {\n\tfontStyle: string\n\tfontWeight: string\n\tfontFamily: string\n\tfontSize: number\n\t/** This must be a number, e.g. 1.35, not a pixel value. */\n\tlineHeight: number\n\t/**\n\t * When maxWidth is a number, the text will be wrapped to that maxWidth. When maxWidth\n\t * is null, the text will be measured without wrapping, but explicit line breaks and\n\t * space are preserved.\n\t */\n\tmaxWidth: null | number\n\tminWidth?: null | number\n\t// todo: make this a number so that it is consistent with other TLMeasureTextSpanOpts\n\tpadding: string\n\totherStyles?: Record<string, string>\n\tdisableOverflowWrapBreaking?: boolean\n\tmeasureScrollWidth?: boolean\n}\n\n/** @public */\nexport interface TLMeasureTextSpanOpts {\n\toverflow: 'wrap' | 'truncate-ellipsis' | 'truncate-clip'\n\twidth: number\n\theight: number\n\tpadding: number\n\tfontSize: number\n\tfontWeight: string\n\tfontFamily: string\n\tfontStyle: string\n\tlineHeight: number\n\ttextAlign: TLDefaultHorizontalAlignStyle\n\totherStyles?: Record<string, string>\n\tmeasureScrollWidth?: boolean\n}\n\nconst spaceCharacterRegex = /\\s/\n\nconst initialDefaultStyles = Object.freeze({\n\t'overflow-wrap': 'break-word',\n\t'word-break': 'auto',\n\twidth: null,\n\theight: null,\n\t'max-width': null,\n\t'min-width': null,\n})\n\n/** @public */\nexport class TextManager {\n\tprivate elm: HTMLDivElement\n\n\tconstructor(public editor: Editor) {\n\t\tconst elm = document.createElement('div')\n\t\telm.classList.add('tl-text')\n\t\telm.classList.add('tl-text-measure')\n\t\telm.setAttribute('dir', 'auto')\n\t\telm.tabIndex = -1\n\t\tthis.editor.getContainer().appendChild(elm)\n\n\t\tthis.elm = elm\n\n\t\tfor (const key of objectMapKeys(initialDefaultStyles)) {\n\t\t\telm.style.setProperty(key, initialDefaultStyles[key])\n\t\t}\n\t}\n\n\tprivate setElementStyles(styles: Record<string, string | undefined>) {\n\t\tconst stylesToReinstate = {} as any\n\t\tfor (const key of objectMapKeys(styles)) {\n\t\t\tif (typeof styles[key] === 'string') {\n\t\t\t\tconst oldValue = this.elm.style.getPropertyValue(key)\n\t\t\t\tif (oldValue === styles[key]) continue\n\t\t\t\tstylesToReinstate[key] = oldValue\n\t\t\t\tthis.elm.style.setProperty(key, styles[key])\n\t\t\t}\n\t\t}\n\t\treturn () => {\n\t\t\tfor (const key of objectMapKeys(stylesToReinstate)) {\n\t\t\t\tthis.elm.style.setProperty(key, stylesToReinstate[key])\n\t\t\t}\n\t\t}\n\t}\n\n\tdispose() {\n\t\treturn this.elm.remove()\n\t}\n\n\tmeasureText(textToMeasure: string, opts: TLMeasureTextOpts): BoxModel & { scrollWidth: number } {\n\t\tconst div = document.createElement('div')\n\t\tdiv.textContent = normalizeTextForDom(textToMeasure)\n\t\treturn this.measureHtml(div.innerHTML, opts)\n\t}\n\n\tmeasureHtml(html: string, opts: TLMeasureTextOpts): BoxModel & { scrollWidth: number } {\n\t\tconst { elm } = this\n\n\t\tconst newStyles = {\n\t\t\t'font-family': opts.fontFamily,\n\t\t\t'font-style': opts.fontStyle,\n\t\t\t'font-weight': opts.fontWeight,\n\t\t\t'font-size': opts.fontSize + 'px',\n\t\t\t'line-height': opts.lineHeight.toString(),\n\t\t\tpadding: opts.padding,\n\t\t\t'max-width': opts.maxWidth ? opts.maxWidth + 'px' : undefined,\n\t\t\t'min-width': opts.minWidth ? opts.minWidth + 'px' : undefined,\n\t\t\t'overflow-wrap': opts.disableOverflowWrapBreaking ? 'normal' : undefined,\n\t\t\t...opts.otherStyles,\n\t\t}\n\n\t\tconst restoreStyles = this.setElementStyles(newStyles)\n\n\t\ttry {\n\t\t\telm.innerHTML = html\n\n\t\t\tconst scrollWidth = opts.measureScrollWidth ? elm.scrollWidth : 0\n\t\t\tconst rect = elm.getBoundingClientRect()\n\n\t\t\treturn {\n\t\t\t\tx: 0,\n\t\t\t\ty: 0,\n\t\t\t\tw: rect.width,\n\t\t\t\th: rect.height,\n\t\t\t\tscrollWidth,\n\t\t\t}\n\t\t} finally {\n\t\t\trestoreStyles()\n\t\t}\n\t}\n\n\t/**\n\t * Given an html element, measure the position of each span of unbroken\n\t * word/white-space characters within any text nodes it contains.\n\t */\n\tmeasureElementTextNodeSpans(\n\t\telement: HTMLElement,\n\t\t{ shouldTruncateToFirstLine = false }: { shouldTruncateToFirstLine?: boolean } = {}\n\t): { spans: { box: BoxModel; text: string }[]; didTruncate: boolean } {\n\t\tconst spans = []\n\n\t\t// Measurements of individual spans are relative to the containing element\n\t\tconst elmBounds = element.getBoundingClientRect()\n\t\tconst offsetX = -elmBounds.left\n\t\tconst offsetY = -elmBounds.top\n\n\t\t// we measure by creating a range that spans each character in the elements text node\n\t\tconst range = new Range()\n\t\tconst textNode = element.childNodes[0]\n\t\tlet idx = 0\n\n\t\tlet currentSpan = null\n\t\tlet prevCharWasSpaceCharacter = null\n\t\tlet prevCharTop = 0\n\t\tlet prevCharLeftForRTLTest = 0\n\t\tlet didTruncate = false\n\t\tfor (const childNode of element.childNodes) {\n\t\t\tif (childNode.nodeType !== Node.TEXT_NODE) continue\n\n\t\t\tfor (const char of childNode.textContent ?? '') {\n\t\t\t\t// place the range around the characters we're interested in\n\t\t\t\trange.setStart(textNode, idx)\n\t\t\t\trange.setEnd(textNode, idx + char.length)\n\t\t\t\t// measure the range. some browsers return multiple rects for the\n\t\t\t\t// first char in a new line - one for the line break, and one for\n\t\t\t\t// the character itself. we're only interested in the character.\n\t\t\t\tconst rects = range.getClientRects()\n\t\t\t\tconst rect = rects[rects.length - 1]!\n\n\t\t\t\t// calculate the position of the character relative to the element\n\t\t\t\tconst top = rect.top + offsetY\n\t\t\t\tconst left = rect.left + offsetX\n\t\t\t\tconst right = rect.right + offsetX\n\t\t\t\tconst isRTL = left < prevCharLeftForRTLTest\n\n\t\t\t\tconst isSpaceCharacter = spaceCharacterRegex.test(char)\n\t\t\t\tif (\n\t\t\t\t\t// If we're at a word boundary...\n\t\t\t\t\tisSpaceCharacter !== prevCharWasSpaceCharacter ||\n\t\t\t\t\t// ...or we're on a different line...\n\t\t\t\t\ttop !== prevCharTop ||\n\t\t\t\t\t// ...or we're at the start of the text and haven't created a span yet...\n\t\t\t\t\t!currentSpan\n\t\t\t\t) {\n\t\t\t\t\t// ...then we're at a span boundary!\n\n\t\t\t\t\tif (currentSpan) {\n\t\t\t\t\t\t// if we're truncating to a single line & we just finished the first line, stop there\n\t\t\t\t\t\tif (shouldTruncateToFirstLine && top !== prevCharTop) {\n\t\t\t\t\t\t\tdidTruncate = true\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// otherwise add the span to the list ready to start a new one\n\t\t\t\t\t\tspans.push(currentSpan)\n\t\t\t\t\t}\n\n\t\t\t\t\t// start a new span\n\t\t\t\t\tcurrentSpan = {\n\t\t\t\t\t\tbox: { x: left, y: top, w: rect.width, h: rect.height },\n\t\t\t\t\t\ttext: char,\n\t\t\t\t\t}\n\t\t\t\t\tprevCharLeftForRTLTest = left\n\t\t\t\t} else {\n\t\t\t\t\t// Looks like we're in RTL mode, so we need to adjust the left position.\n\t\t\t\t\tif (isRTL) {\n\t\t\t\t\t\tcurrentSpan.box.x = left\n\t\t\t\t\t}\n\n\t\t\t\t\t// otherwise we just need to extend the current span with the next character\n\t\t\t\t\tcurrentSpan.box.w = isRTL ? currentSpan.box.w + rect.width : right - currentSpan.box.x\n\t\t\t\t\tcurrentSpan.text += char\n\t\t\t\t}\n\n\t\t\t\tif (char === '\\n') {\n\t\t\t\t\tprevCharLeftForRTLTest = 0\n\t\t\t\t}\n\n\t\t\t\tprevCharWasSpaceCharacter = isSpaceCharacter\n\t\t\t\tprevCharTop = top\n\t\t\t\tidx += char.length\n\t\t\t}\n\t\t}\n\n\t\t// Add the last span\n\t\tif (currentSpan) {\n\t\t\tspans.push(currentSpan)\n\t\t}\n\n\t\treturn { spans, didTruncate }\n\t}\n\n\t/**\n\t * Measure text into individual spans. Spans are created by rendering the\n\t * text, then dividing it up according to line breaks and word boundaries.\n\t *\n\t * It works by having the browser render the text, then measuring the\n\t * position of each character. You can use this to replicate the text-layout\n\t * algorithm of the current browser in e.g. an SVG export.\n\t */\n\tmeasureTextSpans(\n\t\ttextToMeasure: string,\n\t\topts: TLMeasureTextSpanOpts\n\t): { text: string; box: BoxModel }[] {\n\t\tif (textToMeasure === '') return []\n\n\t\tconst { elm } = this\n\n\t\tconst shouldTruncateToFirstLine =\n\t\t\topts.overflow === 'truncate-ellipsis' || opts.overflow === 'truncate-clip'\n\t\tconst elementWidth = Math.ceil(opts.width - opts.padding * 2)\n\t\tconst newStyles = {\n\t\t\t'font-family': opts.fontFamily,\n\t\t\t'font-style': opts.fontStyle,\n\t\t\t'font-weight': opts.fontWeight,\n\t\t\t'font-size': opts.fontSize + 'px',\n\t\t\t'line-height': opts.lineHeight.toString(),\n\t\t\twidth: `${elementWidth}px`,\n\t\t\theight: 'min-content',\n\t\t\t'text-align': textAlignmentsForLtr[opts.textAlign],\n\t\t\t'overflow-wrap': shouldTruncateToFirstLine ? 'anywhere' : undefined,\n\t\t\t'word-break': shouldTruncateToFirstLine ? 'break-all' : undefined,\n\t\t\t...opts.otherStyles,\n\t\t}\n\t\tconst restoreStyles = this.setElementStyles(newStyles)\n\n\t\ttry {\n\t\t\tconst normalizedText = normalizeTextForDom(textToMeasure)\n\n\t\t\t// Render the text into the measurement element:\n\t\t\telm.textContent = normalizedText\n\n\t\t\t// actually measure the text:\n\t\t\tconst { spans, didTruncate } = this.measureElementTextNodeSpans(elm, {\n\t\t\t\tshouldTruncateToFirstLine,\n\t\t\t})\n\n\t\t\tif (opts.overflow === 'truncate-ellipsis' && didTruncate) {\n\t\t\t\t// we need to measure the ellipsis to know how much space it takes up\n\t\t\t\telm.textContent = ''\n\t\t\t\tconst ellipsisWidth = Math.ceil(this.measureElementTextNodeSpans(elm).spans[0].box.w)\n\n\t\t\t\t// then, we need to subtract that space from the width we have and measure again:\n\t\t\t\telm.style.setProperty('width', `${elementWidth - ellipsisWidth}px`)\n\t\t\t\telm.textContent = normalizedText\n\t\t\t\tconst truncatedSpans = this.measureElementTextNodeSpans(elm, {\n\t\t\t\t\tshouldTruncateToFirstLine: true,\n\t\t\t\t}).spans\n\n\t\t\t\t// Finally, we add in our ellipsis at the end of the last span. We\n\t\t\t\t// have to do this after measuring, not before, because adding the\n\t\t\t\t// ellipsis changes how whitespace might be getting collapsed by the\n\t\t\t\t// browser.\n\t\t\t\tconst lastSpan = truncatedSpans[truncatedSpans.length - 1]!\n\t\t\t\ttruncatedSpans.push({\n\t\t\t\t\ttext: '',\n\t\t\t\t\tbox: {\n\t\t\t\t\t\tx: Math.min(lastSpan.box.x + lastSpan.box.w, opts.width - opts.padding - ellipsisWidth),\n\t\t\t\t\t\ty: lastSpan.box.y,\n\t\t\t\t\t\tw: ellipsisWidth,\n\t\t\t\t\t\th: lastSpan.box.h,\n\t\t\t\t\t},\n\t\t\t\t})\n\n\t\t\t\treturn truncatedSpans\n\t\t\t}\n\n\t\t\treturn spans\n\t\t} finally {\n\t\t\trestoreStyles()\n\t\t}\n\t}\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3510, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/%40tldraw/editor/src/lib/editor/managers/TickManager/TickManager.ts"],"sourcesContent":["import { throttleToNextFrame as _throttleToNextFrame, bind } from '@tldraw/utils'\nimport { Vec } from '../../../primitives/Vec'\nimport { Editor } from '../../Editor'\n\nconst throttleToNextFrame =\n\ttypeof process !== 'undefined' && process.env.NODE_ENV === 'test'\n\t\t? // At test time we should use actual raf and not throttle, because throttle was set up to evaluate immediately during tests, which causes stack overflow\n\t\t\t// for the tick manager since it sets up a raf loop.\n\t\t\tfunction mockThrottle(cb: any) {\n\t\t\t\t// eslint-disable-next-line no-restricted-globals\n\t\t\t\tconst frame = requestAnimationFrame(cb)\n\t\t\t\treturn () => cancelAnimationFrame(frame)\n\t\t\t}\n\t\t: _throttleToNextFrame\n\nexport class TickManager {\n\tconstructor(public editor: Editor) {\n\t\tthis.editor.disposables.add(this.dispose)\n\t\tthis.start()\n\t}\n\n\tcancelRaf?: null | (() => void)\n\tisPaused = true\n\tnow = 0\n\n\tstart() {\n\t\tthis.isPaused = false\n\t\tthis.cancelRaf?.()\n\t\tthis.cancelRaf = throttleToNextFrame(this.tick)\n\t\tthis.now = Date.now()\n\t}\n\n\t@bind\n\ttick() {\n\t\tif (this.isPaused) {\n\t\t\treturn\n\t\t}\n\n\t\tconst now = Date.now()\n\t\tconst elapsed = now - this.now\n\t\tthis.now = now\n\n\t\tthis.updatePointerVelocity(elapsed)\n\t\tthis.editor.emit('frame', elapsed)\n\t\tthis.editor.emit('tick', elapsed)\n\t\tthis.cancelRaf = throttleToNextFrame(this.tick)\n\t}\n\n\t// Clear the listener\n\t@bind\n\tdispose() {\n\t\tthis.isPaused = true\n\n\t\tthis.cancelRaf?.()\n\t}\n\n\tprivate prevPoint = new Vec()\n\n\tupdatePointerVelocity(elapsed: number) {\n\t\tconst {\n\t\t\tprevPoint,\n\t\t\teditor: {\n\t\t\t\tinputs: { currentScreenPoint, pointerVelocity },\n\t\t\t},\n\t\t} = this\n\n\t\tif (elapsed === 0) return\n\n\t\tconst delta = Vec.Sub(currentScreenPoint, prevPoint)\n\t\tthis.prevPoint = currentScreenPoint.clone()\n\n\t\tconst length = delta.len()\n\t\tconst direction = length ? delta.div(length) : new Vec(0, 0)\n\n\t\t// consider adjusting this with an easing rather than a linear interpolation\n\t\tconst next = pointerVelocity.clone().lrp(direction.mul(length / elapsed), 0.5)\n\n\t\t// if the velocity is very small, just set it to 0\n\t\tif (Math.abs(next.x) < 0.01) next.x = 0\n\t\tif (Math.abs(next.y) < 0.01) next.y = 0\n\n\t\tif (!pointerVelocity.equals(next)) {\n\t\t\tthis.editor.inputs.pointerVelocity = next\n\t\t}\n\t}\n}\n"],"names":[],"mappings":";;;AAKQ,YAAY,eAAe,QAAQ,IAAI,aAAa;AAL5D,SAAS,uBAAuB,sBAAsB,YAAY;;;AAClE,SAAS,WAAW;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AADpB,IAAA,cAAA,WAAA;;;AAIA,MAAM,sBACL,qPAQG,sBAAA;AAmBH,YAAA;wKAAC,OAAA;CAAA,EAiBD,eAAA;wKAAC,OAAA;CAAA;AAlCK,MAAM,YAAY;IACxB,YAAmB,MAAA,CAAgB;QAAhB,IAAA,CAAA,MAAA,GAAA;QADb,kBAAA,OAAA,GAAA,IAAA;QAMN,cAAA,IAAA,EAAA;QACA,cAAA,IAAA,EAAA,YAAW;QACX,cAAA,IAAA,EAAA,OAAM;QAiCN,cAAA,IAAA,EAAQ,aAAY,IAAI,wLAAA,CAAI;QAvC3B,IAAA,CAAK,MAAA,CAAO,WAAA,CAAY,GAAA,CAAI,IAAA,CAAK,OAAO;QACxC,IAAA,CAAK,KAAA,CAAM;IACZ;IAMA,QAAQ;QACP,IAAA,CAAK,QAAA,GAAW;QAChB,IAAA,CAAK,SAAA,GAAY;QACjB,IAAA,CAAK,SAAA,GAAY,oBAAoB,IAAA,CAAK,IAAI;QAC9C,IAAA,CAAK,GAAA,GAAM,KAAK,GAAA,CAAI;IACrB;IAGA,OAAO;QACN,IAAI,IAAA,CAAK,QAAA,EAAU;YAClB;QACD;QAEA,MAAM,MAAM,KAAK,GAAA,CAAI;QACrB,MAAM,UAAU,MAAM,IAAA,CAAK,GAAA;QAC3B,IAAA,CAAK,GAAA,GAAM;QAEX,IAAA,CAAK,qBAAA,CAAsB,OAAO;QAClC,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,SAAS,OAAO;QACjC,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,QAAQ,OAAO;QAChC,IAAA,CAAK,SAAA,GAAY,oBAAoB,IAAA,CAAK,IAAI;IAC/C;IAIA,UAAU;QACT,IAAA,CAAK,QAAA,GAAW;QAEhB,IAAA,CAAK,SAAA,GAAY;IAClB;IAIA,sBAAsB,OAAA,EAAiB;QACtC,MAAM,EACL,SAAA,EACA,QAAQ,EACP,QAAQ,EAAE,kBAAA,EAAoB,eAAA,CAAgB,CAAA,EAC/C,EACD,GAAI,IAAA;QAEJ,IAAI,YAAY,EAAG,CAAA;QAEnB,MAAM,0LAAQ,MAAA,CAAI,GAAA,CAAI,oBAAoB,SAAS;QACnD,IAAA,CAAK,SAAA,GAAY,mBAAmB,KAAA,CAAM;QAE1C,MAAM,SAAS,MAAM,GAAA,CAAI;QACzB,MAAM,YAAY,SAAS,MAAM,GAAA,CAAI,MAAM,IAAI,sLAAI,MAAA,CAAI,GAAG,CAAC;QAG3D,MAAM,OAAO,gBAAgB,KAAA,CAAM,EAAE,GAAA,CAAI,UAAU,GAAA,CAAI,SAAS,OAAO,GAAG,GAAG;QAG7E,IAAI,KAAK,GAAA,CAAI,KAAK,CAAC,IAAI,KAAM,CAAA,KAAK,CAAA,GAAI;QACtC,IAAI,KAAK,GAAA,CAAI,KAAK,CAAC,IAAI,KAAM,CAAA,KAAK,CAAA,GAAI;QAEtC,IAAI,CAAC,gBAAgB,MAAA,CAAO,IAAI,GAAG;YAClC,IAAA,CAAK,MAAA,CAAO,MAAA,CAAO,eAAA,GAAkB;QACtC;IACD;AACD;AAtEO,QAAA,iBAAA;AAkBN,kBAAA,OAAA,GAAA,QADA,WAjBY;AAmCZ,kBAAA,OAAA,GAAA,WADA,cAlCY;AAAN,oBAAA,OAAM","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3671, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/%40tldraw/editor/src/lib/editor/managers/UserPreferencesManager/UserPreferencesManager.ts"],"sourcesContent":["import { atom, computed } from '@tldraw/state'\nimport { TLUserPreferences, defaultUserPreferences } from '../../../config/TLUserPreferences'\nimport { TLUser } from '../../../config/createTLUser'\n\n/** @public */\nexport class UserPreferencesManager {\n\tsystemColorScheme = atom<'dark' | 'light'>('systemColorScheme', 'light')\n\tdisposables = new Set<() => void>()\n\tdispose() {\n\t\tthis.disposables.forEach((d) => d())\n\t}\n\tconstructor(\n\t\tprivate readonly user: TLUser,\n\t\tprivate readonly inferDarkMode: boolean\n\t) {\n\t\tif (typeof window === 'undefined' || !('matchMedia' in window)) return\n\n\t\tconst darkModeMediaQuery = window.matchMedia('(prefers-color-scheme: dark)')\n\t\tif (darkModeMediaQuery?.matches) {\n\t\t\tthis.systemColorScheme.set('dark')\n\t\t}\n\t\tconst handleChange = (e: MediaQueryListEvent) => {\n\t\t\tif (e.matches) {\n\t\t\t\tthis.systemColorScheme.set('dark')\n\t\t\t} else {\n\t\t\t\tthis.systemColorScheme.set('light')\n\t\t\t}\n\t\t}\n\t\tdarkModeMediaQuery?.addEventListener('change', handleChange)\n\t\tthis.disposables.add(() => darkModeMediaQuery?.removeEventListener('change', handleChange))\n\t}\n\n\tupdateUserPreferences(userPreferences: Partial<TLUserPreferences>) {\n\t\tthis.user.setUserPreferences({\n\t\t\t...this.user.userPreferences.get(),\n\t\t\t...userPreferences,\n\t\t})\n\t}\n\t@computed getUserPreferences() {\n\t\treturn {\n\t\t\tid: this.getId(),\n\t\t\tname: this.getName(),\n\t\t\tlocale: this.getLocale(),\n\t\t\tcolor: this.getColor(),\n\t\t\tanimationSpeed: this.getAnimationSpeed(),\n\t\t\tareKeyboardShortcutsEnabled: this.getAreKeyboardShortcutsEnabled(),\n\t\t\tisSnapMode: this.getIsSnapMode(),\n\t\t\tcolorScheme: this.user.userPreferences.get().colorScheme,\n\t\t\tisDarkMode: this.getIsDarkMode(),\n\t\t\tisWrapMode: this.getIsWrapMode(),\n\t\t\tisDynamicResizeMode: this.getIsDynamicResizeMode(),\n\t\t}\n\t}\n\n\t@computed getIsDarkMode() {\n\t\tswitch (this.user.userPreferences.get().colorScheme) {\n\t\t\tcase 'dark':\n\t\t\t\treturn true\n\t\t\tcase 'light':\n\t\t\t\treturn false\n\t\t\tcase 'system':\n\t\t\t\treturn this.systemColorScheme.get() === 'dark'\n\t\t\tdefault:\n\t\t\t\treturn this.inferDarkMode ? this.systemColorScheme.get() === 'dark' : false\n\t\t}\n\t}\n\n\t/**\n\t * The speed at which the user can scroll by dragging toward the edge of the screen.\n\t */\n\t@computed getEdgeScrollSpeed() {\n\t\treturn this.user.userPreferences.get().edgeScrollSpeed ?? defaultUserPreferences.edgeScrollSpeed\n\t}\n\n\t@computed getAnimationSpeed() {\n\t\treturn this.user.userPreferences.get().animationSpeed ?? defaultUserPreferences.animationSpeed\n\t}\n\n\t@computed getAreKeyboardShortcutsEnabled() {\n\t\treturn (\n\t\t\tthis.user.userPreferences.get().areKeyboardShortcutsEnabled ??\n\t\t\tdefaultUserPreferences.areKeyboardShortcutsEnabled\n\t\t)\n\t}\n\n\t@computed getId() {\n\t\treturn this.user.userPreferences.get().id\n\t}\n\n\t@computed getName() {\n\t\treturn this.user.userPreferences.get().name?.trim() ?? defaultUserPreferences.name\n\t}\n\n\t@computed getLocale() {\n\t\treturn this.user.userPreferences.get().locale ?? defaultUserPreferences.locale\n\t}\n\n\t@computed getColor() {\n\t\treturn this.user.userPreferences.get().color ?? defaultUserPreferences.color\n\t}\n\n\t@computed getIsSnapMode() {\n\t\treturn this.user.userPreferences.get().isSnapMode ?? defaultUserPreferences.isSnapMode\n\t}\n\n\t@computed getIsWrapMode() {\n\t\treturn this.user.userPreferences.get().isWrapMode ?? defaultUserPreferences.isWrapMode\n\t}\n\n\t@computed getIsDynamicResizeMode() {\n\t\treturn (\n\t\t\tthis.user.userPreferences.get().isDynamicSizeMode ?? defaultUserPreferences.isDynamicSizeMode\n\t\t)\n\t}\n\n\t@computed getIsPasteAtCursorMode() {\n\t\treturn (\n\t\t\tthis.user.userPreferences.get().isPasteAtCursorMode ??\n\t\t\tdefaultUserPreferences.isPasteAtCursorMode\n\t\t)\n\t}\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3907, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/%40tldraw/editor/src/lib/editor/types/event-types.ts"],"sourcesContent":["import { TLHandle, TLShape, VecModel } from '@tldraw/tlschema'\nimport { VecLike } from '../../primitives/Vec'\nimport { TLSelectionHandle } from './selection-types'\n\n/** @public */\nexport type UiEventType = 'pointer' | 'click' | 'keyboard' | 'wheel' | 'pinch' | 'zoom'\n\n/** @public */\nexport type TLPointerEventTarget =\n\t| { target: 'canvas'; shape?: undefined }\n\t| { target: 'selection'; handle?: TLSelectionHandle; shape?: undefined }\n\t| { target: 'shape'; shape: TLShape }\n\t| { target: 'handle'; shape: TLShape; handle: TLHandle }\n\n/** @public */\nexport type TLPointerEventName =\n\t| 'pointer_down'\n\t| 'pointer_move'\n\t| 'long_press'\n\t| 'pointer_up'\n\t| 'right_click'\n\t| 'middle_click'\n\n/** @public */\nexport type TLCLickEventName = 'double_click' | 'triple_click' | 'quadruple_click'\n\n/** @public */\nexport type TLPinchEventName = 'pinch_start' | 'pinch' | 'pinch_end'\n\n/** @public */\nexport type TLKeyboardEventName = 'key_down' | 'key_up' | 'key_repeat'\n\n/** @public */\nexport type TLEventName =\n\t| TLPointerEventName\n\t| TLCLickEventName\n\t| TLPinchEventName\n\t| TLKeyboardEventName\n\t| 'wheel'\n\t| 'cancel'\n\t| 'complete'\n\t| 'interrupt'\n\t| 'tick'\n\n/** @public */\nexport interface TLBaseEventInfo {\n\ttype: UiEventType\n\tshiftKey: boolean\n\taltKey: boolean\n\tctrlKey: boolean\n\tmetaKey: boolean\n\taccelKey: boolean\n}\n\n/** @public */\nexport type TLPointerEventInfo = TLBaseEventInfo & {\n\ttype: 'pointer'\n\tname: TLPointerEventName\n\t// The pointer position in client space, i.e. clientX / clientY\n\tpoint: VecLike\n\tpointerId: number\n\tbutton: number\n\tisPen: boolean\n} & TLPointerEventTarget\n\n/** @public */\nexport type TLClickEventInfo = TLBaseEventInfo & {\n\ttype: 'click'\n\tname: TLCLickEventName\n\tpoint: VecLike\n\tpointerId: number\n\tbutton: number\n\tphase: 'down' | 'up' | 'settle'\n} & TLPointerEventTarget\n\n/** @public */\nexport type TLKeyboardEventInfo = TLBaseEventInfo & {\n\ttype: 'keyboard'\n\tname: TLKeyboardEventName\n\tkey: string\n\tcode: string\n}\n\n/** @public */\nexport type TLPinchEventInfo = TLBaseEventInfo & {\n\ttype: 'pinch'\n\tname: TLPinchEventName\n\tpoint: VecModel\n\tdelta: VecModel\n}\n\n/** @public */\nexport type TLWheelEventInfo = TLBaseEventInfo & {\n\ttype: 'wheel'\n\tname: 'wheel'\n\tdelta: VecModel\n\tpoint: VecModel\n}\n\n/** @public */\nexport interface TLCancelEventInfo {\n\ttype: 'misc'\n\tname: 'cancel'\n}\n/** @public */\nexport interface TLCompleteEventInfo {\n\ttype: 'misc'\n\tname: 'complete'\n}\n/** @public */\nexport interface TLInterruptEventInfo {\n\ttype: 'misc'\n\tname: 'interrupt'\n}\n/** @public */\nexport interface TLTickEventInfo {\n\ttype: 'misc'\n\tname: 'tick'\n\telapsed: number\n}\n\n/** @public */\nexport type TLEventInfo =\n\t| TLPointerEventInfo\n\t| TLClickEventInfo\n\t| TLKeyboardEventInfo\n\t| TLPinchEventInfo\n\t| TLWheelEventInfo\n\t| TLCancelEventInfo\n\t| TLCompleteEventInfo\n\t| TLInterruptEventInfo\n\t| TLTickEventInfo\n\n/** @public */\nexport type TLPointerEvent = (info: TLPointerEventInfo) => void\n/** @public */\nexport type TLClickEvent = (info: TLClickEventInfo) => void\n/** @public */\nexport type TLKeyboardEvent = (info: TLKeyboardEventInfo) => void\n/** @public */\nexport type TLPinchEvent = (info: TLPinchEventInfo) => void\n/** @public */\nexport type TLWheelEvent = (info: TLWheelEventInfo) => void\n/** @public */\nexport type TLCancelEvent = (info: TLCancelEventInfo) => void\n/** @public */\nexport type TLCompleteEvent = (info: TLCompleteEventInfo) => void\n/** @public */\nexport type TLInterruptEvent = (info: TLInterruptEventInfo) => void\n/** @public */\nexport type TLTickEvent = (info: TLTickEventInfo) => void\n\n/** @public */\nexport type UiEvent =\n\t| TLPointerEvent\n\t| TLClickEvent\n\t| TLKeyboardEvent\n\t| TLPinchEvent\n\t| TLCancelEvent\n\t| TLCompleteEvent\n\n/** @public */\nexport type TLEnterEventHandler = (info: any, from: string) => void\n/** @public */\nexport type TLExitEventHandler = (info: any, to: string) => void\n\n/** @public */\nexport interface TLEventHandlers {\n\tonPointerDown: TLPointerEvent\n\tonPointerMove: TLPointerEvent\n\tonLongPress: TLPointerEvent\n\tonRightClick: TLPointerEvent\n\tonDoubleClick: TLClickEvent\n\tonTripleClick: TLClickEvent\n\tonQuadrupleClick: TLClickEvent\n\tonMiddleClick: TLPointerEvent\n\tonPointerUp: TLPointerEvent\n\tonKeyDown: TLKeyboardEvent\n\tonKeyUp: TLKeyboardEvent\n\tonKeyRepeat: TLKeyboardEvent\n\tonWheel: TLWheelEvent\n\tonCancel: TLCancelEvent\n\tonComplete: TLCompleteEvent\n\tonInterrupt: TLInterruptEvent\n\tonTick: TLTickEvent\n}\n\n/** @public */\nexport const EVENT_NAME_MAP: Record<\n\tExclude<TLEventName, TLPinchEventName>,\n\tkeyof TLEventHandlers\n> = {\n\twheel: 'onWheel',\n\tpointer_down: 'onPointerDown',\n\tpointer_move: 'onPointerMove',\n\tlong_press: 'onLongPress',\n\tpointer_up: 'onPointerUp',\n\tright_click: 'onRightClick',\n\tmiddle_click: 'onMiddleClick',\n\tkey_down: 'onKeyDown',\n\tkey_up: 'onKeyUp',\n\tkey_repeat: 'onKeyRepeat',\n\tcancel: 'onCancel',\n\tcomplete: 'onComplete',\n\tinterrupt: 'onInterrupt',\n\tdouble_click: 'onDoubleClick',\n\ttriple_click: 'onTripleClick',\n\tquadruple_click: 'onQuadrupleClick',\n\ttick: 'onTick',\n}\n"],"names":[],"mappings":";;;AA4LO,MAAM,iBAGT;IACH,OAAO;IACP,cAAc;IACd,cAAc;IACd,YAAY;IACZ,YAAY;IACZ,aAAa;IACb,cAAc;IACd,UAAU;IACV,QAAQ;IACR,YAAY;IACZ,QAAQ;IACR,UAAU;IACV,WAAW;IACX,cAAc;IACd,cAAc;IACd,iBAAiB;IACjB,MAAM;AACP","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3937, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/%40tldraw/editor/src/lib/editor/tools/StateNode.ts"],"sourcesContent":["import { Atom, Computed, atom, computed } from '@tldraw/state'\nimport { PerformanceTracker } from '@tldraw/utils'\nimport { debugFlags } from '../../utils/debug-flags'\nimport type { Editor } from '../Editor'\nimport {\n\tEVENT_NAME_MAP,\n\tTLCancelEventInfo,\n\tTLClickEventInfo,\n\tTLCompleteEventInfo,\n\tTLEventHandlers,\n\tTLEventInfo,\n\tTLInterruptEventInfo,\n\tTLKeyboardEventInfo,\n\tTLPinchEventInfo,\n\tTLPointerEventInfo,\n\tTLTickEventInfo,\n\tTLWheelEventInfo,\n} from '../types/event-types'\n\nconst STATE_NODES_TO_MEASURE = [\n\t'brushing',\n\t'cropping',\n\t'dragging',\n\t'dragging_handle',\n\t'drawing',\n\t'erasing',\n\t'lasering',\n\t'resizing',\n\t'rotating',\n\t'scribble_brushing',\n\t'translating',\n]\n\n/** @public */\nexport interface TLStateNodeConstructor {\n\tnew (editor: Editor, parent?: StateNode): StateNode\n\tid: string\n\tinitial?: string\n\tchildren?(): TLStateNodeConstructor[]\n\tisLockable: boolean\n\tuseCoalescedEvents: boolean\n}\n\n/** @public */\nexport abstract class StateNode implements Partial<TLEventHandlers> {\n\tperformanceTracker: PerformanceTracker\n\tconstructor(\n\t\tpublic editor: Editor,\n\t\tparent?: StateNode\n\t) {\n\t\tconst { id, children, initial, isLockable, useCoalescedEvents } = this\n\t\t\t.constructor as TLStateNodeConstructor\n\n\t\tthis.id = id\n\t\tthis._isActive = atom<boolean>('toolIsActive' + this.id, false)\n\t\tthis._current = atom<StateNode | undefined>('toolState' + this.id, undefined)\n\n\t\tthis._path = computed('toolPath' + this.id, () => {\n\t\t\tconst current = this.getCurrent()\n\t\t\treturn this.id + (current ? `.${current.getPath()}` : '')\n\t\t})\n\n\t\tthis.parent = parent ?? ({} as any)\n\n\t\tif (parent) {\n\t\t\tif (children && initial) {\n\t\t\t\tthis.type = 'branch'\n\t\t\t\tthis.initial = initial\n\t\t\t\tthis.children = Object.fromEntries(\n\t\t\t\t\tchildren().map((Ctor) => [Ctor.id, new Ctor(this.editor, this)])\n\t\t\t\t)\n\t\t\t\tthis._current.set(this.children[this.initial])\n\t\t\t} else {\n\t\t\t\tthis.type = 'leaf'\n\t\t\t}\n\t\t} else {\n\t\t\tthis.type = 'root'\n\n\t\t\tif (children && initial) {\n\t\t\t\tthis.initial = initial\n\t\t\t\tthis.children = Object.fromEntries(\n\t\t\t\t\tchildren().map((Ctor) => [Ctor.id, new Ctor(this.editor, this)])\n\t\t\t\t)\n\t\t\t\tthis._current.set(this.children[this.initial])\n\t\t\t}\n\t\t}\n\t\tthis.isLockable = isLockable\n\t\tthis.useCoalescedEvents = useCoalescedEvents\n\t\tthis.performanceTracker = new PerformanceTracker()\n\t}\n\n\tstatic id: string\n\tstatic initial?: string\n\tstatic children?: () => TLStateNodeConstructor[]\n\tstatic isLockable = true\n\tstatic useCoalescedEvents = false\n\n\tid: string\n\ttype: 'branch' | 'leaf' | 'root'\n\tshapeType?: string\n\tinitial?: string\n\tchildren?: Record<string, StateNode>\n\tisLockable: boolean\n\tuseCoalescedEvents: boolean\n\tparent: StateNode\n\n\t/**\n\t * This node's path of active state nodes\n\t *\n\t * @public\n\t */\n\tgetPath() {\n\t\treturn this._path.get()\n\t}\n\t_path: Computed<string>\n\n\t/**\n\t * This node's current active child node, if any.\n\t *\n\t * @public\n\t */\n\tgetCurrent() {\n\t\treturn this._current.get()\n\t}\n\tprivate _current: Atom<StateNode | undefined>\n\n\t/**\n\t * Whether this node is active.\n\t *\n\t * @public\n\t */\n\tgetIsActive() {\n\t\treturn this._isActive.get()\n\t}\n\tprivate _isActive: Atom<boolean>\n\n\t/**\n\t * Transition to a new active child state node.\n\t *\n\t * @example\n\t * ```ts\n\t * parentState.transition('childStateA')\n\t * parentState.transition('childStateB', { myData: 4 })\n\t *```\n\t *\n\t * @param id - The id of the child state node to transition to.\n\t * @param info - Any data to pass to the `onEnter` and `onExit` handlers.\n\t *\n\t * @public\n\t */\n\ttransition(id: string, info: any = {}) {\n\t\tconst path = id.split('.')\n\n\t\tlet currState = this as StateNode\n\n\t\tfor (let i = 0; i < path.length; i++) {\n\t\t\tconst id = path[i]\n\t\t\tconst prevChildState = currState.getCurrent()\n\t\t\tconst nextChildState = currState.children?.[id]\n\n\t\t\tif (!nextChildState) {\n\t\t\t\tthrow Error(`${currState.id} - no child state exists with the id ${id}.`)\n\t\t\t}\n\n\t\t\tif (prevChildState?.id !== nextChildState.id) {\n\t\t\t\tprevChildState?.exit(info, id)\n\t\t\t\tcurrState._current.set(nextChildState)\n\t\t\t\tnextChildState.enter(info, prevChildState?.id || 'initial')\n\t\t\t\tif (!nextChildState.getIsActive()) break\n\t\t\t}\n\n\t\t\tcurrState = nextChildState\n\t\t}\n\n\t\treturn this\n\t}\n\n\thandleEvent(info: Exclude<TLEventInfo, TLPinchEventInfo>) {\n\t\tconst cbName = EVENT_NAME_MAP[info.name]\n\t\tconst currentActiveChild = this._current.__unsafe__getWithoutCapture()\n\n\t\tthis[cbName]?.(info as any)\n\t\tif (\n\t\t\tthis._isActive.__unsafe__getWithoutCapture() &&\n\t\t\tcurrentActiveChild &&\n\t\t\tcurrentActiveChild === this._current.__unsafe__getWithoutCapture()\n\t\t) {\n\t\t\tcurrentActiveChild.handleEvent(info)\n\t\t}\n\t}\n\n\t// todo: move this logic into transition\n\tenter(info: any, from: string) {\n\t\tif (debugFlags.measurePerformance.get() && STATE_NODES_TO_MEASURE.includes(this.id)) {\n\t\t\tthis.performanceTracker.start(this.id)\n\t\t}\n\n\t\tthis._isActive.set(true)\n\t\tthis.onEnter?.(info, from)\n\n\t\tif (this.children && this.initial && this.getIsActive()) {\n\t\t\tconst initial = this.children[this.initial]\n\t\t\tthis._current.set(initial)\n\t\t\tinitial.enter(info, from)\n\t\t}\n\t}\n\n\t// todo: move this logic into transition\n\texit(info: any, to: string) {\n\t\tif (debugFlags.measurePerformance.get() && this.performanceTracker.isStarted()) {\n\t\t\tthis.performanceTracker.stop()\n\t\t}\n\t\tthis._isActive.set(false)\n\t\tthis.onExit?.(info, to)\n\n\t\tif (!this.getIsActive()) {\n\t\t\tthis.getCurrent()?.exit(info, to)\n\t\t}\n\t}\n\n\t/**\n\t * This is a hack / escape hatch that will tell the editor to\n\t * report a different state as active (in `getCurrentToolId()`) when\n\t * this state is active. This is usually used when a tool transitions\n\t * to a child of a different state for a certain interaction and then\n\t * returns to the original tool when that interaction completes; and\n\t * where we would want to show the original tool as active in the UI.\n\t *\n\t * @public\n\t */\n\t_currentToolIdMask = atom('curent tool id mask', undefined as string | undefined)\n\n\tgetCurrentToolIdMask() {\n\t\treturn this._currentToolIdMask.get()\n\t}\n\n\tsetCurrentToolIdMask(id: string | undefined) {\n\t\tthis._currentToolIdMask.set(id)\n\t}\n\n\t/**\n\t * Add a child node to this state node.\n\t *\n\t * @public\n\t */\n\taddChild(childConstructor: TLStateNodeConstructor): this {\n\t\tif (this.type === 'leaf') {\n\t\t\tthrow new Error('StateNode.addChild: cannot add child to a leaf node')\n\t\t}\n\n\t\t// Initialize children if it's undefined (for root nodes without static children)\n\t\tif (!this.children) {\n\t\t\tthis.children = {}\n\t\t}\n\n\t\tconst child = new childConstructor(this.editor, this)\n\n\t\t// Check if a child with this ID already exists\n\t\tif (this.children[child.id]) {\n\t\t\tthrow new Error(`StateNode.addChild: a child with id '${child.id}' already exists`)\n\t\t}\n\n\t\tthis.children[child.id] = child\n\t\treturn this\n\t}\n\n\tonWheel?(info: TLWheelEventInfo): void\n\tonPointerDown?(info: TLPointerEventInfo): void\n\tonPointerMove?(info: TLPointerEventInfo): void\n\tonLongPress?(info: TLPointerEventInfo): void\n\tonPointerUp?(info: TLPointerEventInfo): void\n\tonDoubleClick?(info: TLClickEventInfo): void\n\tonTripleClick?(info: TLClickEventInfo): void\n\tonQuadrupleClick?(info: TLClickEventInfo): void\n\tonRightClick?(info: TLPointerEventInfo): void\n\tonMiddleClick?(info: TLPointerEventInfo): void\n\tonKeyDown?(info: TLKeyboardEventInfo): void\n\tonKeyUp?(info: TLKeyboardEventInfo): void\n\tonKeyRepeat?(info: TLKeyboardEventInfo): void\n\tonCancel?(info: TLCancelEventInfo): void\n\tonComplete?(info: TLCompleteEventInfo): void\n\tonInterrupt?(info: TLInterruptEventInfo): void\n\tonTick?(info: TLTickEventInfo): void\n\n\tonEnter?(info: any, from: string): void\n\tonExit?(info: any, to: string): void\n}\n"],"names":["id"],"mappings":";;;AAAA,SAAyB,MAAM,gBAAgB;;;AAC/C,SAAS,0BAA0B;;AACnC,SAAS,kBAAkB;AAE3B;;;;;AAeA,MAAM,yBAAyB;IAC9B;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AAaO,MAAe,UAA8C;IAEnE,YACQ,MAAA,EACP,MAAA,CACC;QAFM,IAAA,CAAA,MAAA,GAAA;QAGP,MAAM,EAAE,EAAA,EAAI,QAAA,EAAU,OAAA,EAAS,UAAA,EAAY,kBAAA,CAAmB,CAAA,GAAI,IAAA,CAChE,WAAA;QAEF,IAAA,CAAK,EAAA,GAAK;QACV,IAAA,CAAK,SAAA,2KAAY,OAAA,EAAc,iBAAiB,IAAA,CAAK,EAAA,EAAI,KAAK;QAC9D,IAAA,CAAK,QAAA,GAAW,+KAAA,EAA4B,cAAc,IAAA,CAAK,EAAA,EAAI,KAAA,CAAS;QAE5E,IAAA,CAAK,KAAA,+KAAQ,WAAA,EAAS,aAAa,IAAA,CAAK,EAAA,EAAI,MAAM;YACjD,MAAM,UAAU,IAAA,CAAK,UAAA,CAAW;YAChC,OAAO,IAAA,CAAK,EAAA,GAAA,CAAM,UAAU,CAAA,CAAA,EAAI,QAAQ,OAAA,CAAQ,CAAC,EAAA,GAAK,EAAA;QACvD,CAAC;QAED,IAAA,CAAK,MAAA,GAAS,UAAW,CAAC;QAE1B,IAAI,QAAQ;YACX,IAAI,YAAY,SAAS;gBACxB,IAAA,CAAK,IAAA,GAAO;gBACZ,IAAA,CAAK,OAAA,GAAU;gBACf,IAAA,CAAK,QAAA,GAAW,OAAO,WAAA,CACtB,SAAS,EAAE,GAAA,CAAI,CAAC,OAAS;wBAAC,KAAK,EAAA;wBAAI,IAAI,KAAK,IAAA,CAAK,MAAA,EAAQ,IAAI,CAAC;qBAAC;gBAEhE,IAAA,CAAK,QAAA,CAAS,GAAA,CAAI,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,OAAO,CAAC;YAC9C,OAAO;gBACN,IAAA,CAAK,IAAA,GAAO;YACb;QACD,OAAO;YACN,IAAA,CAAK,IAAA,GAAO;YAEZ,IAAI,YAAY,SAAS;gBACxB,IAAA,CAAK,OAAA,GAAU;gBACf,IAAA,CAAK,QAAA,GAAW,OAAO,WAAA,CACtB,SAAS,EAAE,GAAA,CAAI,CAAC,OAAS;wBAAC,KAAK,EAAA;wBAAI,IAAI,KAAK,IAAA,CAAK,MAAA,EAAQ,IAAI,CAAC;qBAAC;gBAEhE,IAAA,CAAK,QAAA,CAAS,GAAA,CAAI,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,OAAO,CAAC;YAC9C;QACD;QACA,IAAA,CAAK,UAAA,GAAa;QAClB,IAAA,CAAK,kBAAA,GAAqB;QAC1B,IAAA,CAAK,kBAAA,GAAqB,sLAAI,qBAAA,CAAmB;IAClD;IA5CA,mBAAA;IA8CA,OAAO,GAAA;IACP,OAAO,QAAA;IACP,OAAO,SAAA;IACP,OAAO,aAAa,KAAA;IACpB,OAAO,qBAAqB,MAAA;IAE5B,GAAA;IACA,KAAA;IACA,UAAA;IACA,QAAA;IACA,SAAA;IACA,WAAA;IACA,mBAAA;IACA,OAAA;IAAA;;;;GAAA,GAOA,UAAU;QACT,OAAO,IAAA,CAAK,KAAA,CAAM,GAAA,CAAI;IACvB;IACA,MAAA;IAAA;;;;GAAA,GAOA,aAAa;QACZ,OAAO,IAAA,CAAK,QAAA,CAAS,GAAA,CAAI;IAC1B;IACQ,SAAA;IAAA;;;;GAAA,GAOR,cAAc;QACb,OAAO,IAAA,CAAK,SAAA,CAAU,GAAA,CAAI;IAC3B;IACQ,UAAA;IAAA;;;;;;;;;;;;;GAAA,GAgBR,WAAW,EAAA,EAAY,OAAY,CAAC,CAAA,EAAG;QACtC,MAAM,OAAO,GAAG,KAAA,CAAM,GAAG;QAEzB,IAAI,YAAY,IAAA;QAEhB,IAAA,IAAS,IAAI,GAAG,IAAI,KAAK,MAAA,EAAQ,IAAK;YACrC,MAAMA,MAAK,IAAA,CAAK,CAAC,CAAA;YACjB,MAAM,iBAAiB,UAAU,UAAA,CAAW;YAC5C,MAAM,iBAAiB,UAAU,QAAA,EAAA,CAAWA,GAAE,CAAA;YAE9C,IAAI,CAAC,gBAAgB;gBACpB,MAAM,MAAM,GAAG,UAAU,EAAE,CAAA,qCAAA,EAAwCA,GAAE,CAAA,CAAA,CAAG;YACzE;YAEA,IAAI,gBAAgB,OAAO,eAAe,EAAA,EAAI;gBAC7C,gBAAgB,KAAK,MAAMA,GAAE;gBAC7B,UAAU,QAAA,CAAS,GAAA,CAAI,cAAc;gBACrC,eAAe,KAAA,CAAM,MAAM,gBAAgB,MAAM,SAAS;gBAC1D,IAAI,CAAC,eAAe,WAAA,CAAY,EAAG,CAAA;YACpC;YAEA,YAAY;QACb;QAEA,OAAO,IAAA;IACR;IAEA,YAAY,IAAA,EAA8C;QACzD,MAAM,2MAAS,iBAAA,CAAe,KAAK,IAAI,CAAA;QACvC,MAAM,qBAAqB,IAAA,CAAK,QAAA,CAAS,2BAAA,CAA4B;QAErE,IAAA,CAAK,MAAM,CAAA,GAAI,IAAW;QAC1B,IACC,IAAA,CAAK,SAAA,CAAU,2BAAA,CAA4B,KAC3C,sBACA,uBAAuB,IAAA,CAAK,QAAA,CAAS,2BAAA,CAA4B,GAChE;YACD,mBAAmB,WAAA,CAAY,IAAI;QACpC;IACD;IAAA,wCAAA;IAGA,MAAM,IAAA,EAAW,IAAA,EAAc;QAC9B,4LAAI,aAAA,CAAW,kBAAA,CAAmB,GAAA,CAAI,KAAK,uBAAuB,QAAA,CAAS,IAAA,CAAK,EAAE,GAAG;YACpF,IAAA,CAAK,kBAAA,CAAmB,KAAA,CAAM,IAAA,CAAK,EAAE;QACtC;QAEA,IAAA,CAAK,SAAA,CAAU,GAAA,CAAI,IAAI;QACvB,IAAA,CAAK,OAAA,GAAU,MAAM,IAAI;QAEzB,IAAI,IAAA,CAAK,QAAA,IAAY,IAAA,CAAK,OAAA,IAAW,IAAA,CAAK,WAAA,CAAY,GAAG;YACxD,MAAM,UAAU,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,OAAO,CAAA;YAC1C,IAAA,CAAK,QAAA,CAAS,GAAA,CAAI,OAAO;YACzB,QAAQ,KAAA,CAAM,MAAM,IAAI;QACzB;IACD;IAAA,wCAAA;IAGA,KAAK,IAAA,EAAW,EAAA,EAAY;QAC3B,IAAI,qMAAA,CAAW,kBAAA,CAAmB,GAAA,CAAI,KAAK,IAAA,CAAK,kBAAA,CAAmB,SAAA,CAAU,GAAG;YAC/E,IAAA,CAAK,kBAAA,CAAmB,IAAA,CAAK;QAC9B;QACA,IAAA,CAAK,SAAA,CAAU,GAAA,CAAI,KAAK;QACxB,IAAA,CAAK,MAAA,GAAS,MAAM,EAAE;QAEtB,IAAI,CAAC,IAAA,CAAK,WAAA,CAAY,GAAG;YACxB,IAAA,CAAK,UAAA,CAAW,GAAG,KAAK,MAAM,EAAE;QACjC;IACD;IAAA;;;;;;;;;GAAA,GAYA,6LAAqB,OAAA,EAAK,uBAAuB,KAAA,CAA+B,EAAA;IAEhF,uBAAuB;QACtB,OAAO,IAAA,CAAK,kBAAA,CAAmB,GAAA,CAAI;IACpC;IAEA,qBAAqB,EAAA,EAAwB;QAC5C,IAAA,CAAK,kBAAA,CAAmB,GAAA,CAAI,EAAE;IAC/B;IAAA;;;;GAAA,GAOA,SAAS,gBAAA,EAAgD;QACxD,IAAI,IAAA,CAAK,IAAA,KAAS,QAAQ;YACzB,MAAM,IAAI,MAAM,qDAAqD;QACtE;QAGA,IAAI,CAAC,IAAA,CAAK,QAAA,EAAU;YACnB,IAAA,CAAK,QAAA,GAAW,CAAC;QAClB;QAEA,MAAM,QAAQ,IAAI,iBAAiB,IAAA,CAAK,MAAA,EAAQ,IAAI;QAGpD,IAAI,IAAA,CAAK,QAAA,CAAS,MAAM,EAAE,CAAA,EAAG;YAC5B,MAAM,IAAI,MAAM,CAAA,qCAAA,EAAwC,MAAM,EAAE,CAAA,gBAAA,CAAkB;QACnF;QAEA,IAAA,CAAK,QAAA,CAAS,MAAM,EAAE,CAAA,GAAI;QAC1B,OAAO,IAAA;IACR;AAsBD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4149, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/%40tldraw/editor/src/lib/editor/tools/RootState.ts"],"sourcesContent":["import { TLKeyboardEventInfo } from '../types/event-types'\nimport { StateNode } from './StateNode'\n\nexport class RootState extends StateNode {\n\tstatic override id = 'root'\n\tstatic override initial = ''\n\tstatic override children() {\n\t\treturn []\n\t}\n\n\toverride onKeyDown(info: TLKeyboardEventInfo) {\n\t\t// todo: move this logic up to the tldraw library, as the \"zoom\" tool only exists there\n\t\tswitch (info.code) {\n\t\t\tcase 'KeyZ': {\n\t\t\t\tif (!(info.shiftKey || info.ctrlKey)) {\n\t\t\t\t\tconst currentTool = this.getCurrent()\n\t\t\t\t\tif (currentTool && currentTool.getCurrent()?.id === 'idle' && this.children!['zoom']) {\n\t\t\t\t\t\tthis.editor.setCurrentTool('zoom', { ...info, onInteractionEnd: currentTool.id })\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n"],"names":[],"mappings":";;;AACA,SAAS,iBAAiB;;AAEnB,MAAM,+MAAkB,YAAA,CAAU;IACxC,OAAgB,KAAK,OAAA;IACrB,OAAgB,UAAU,GAAA;IAC1B,OAAgB,WAAW;QAC1B,OAAO,CAAC,CAAA;IACT;IAES,UAAU,IAAA,EAA2B;QAE7C,OAAQ,KAAK,IAAA,EAAM;YAClB,KAAK;gBAAQ;oBACZ,IAAI,CAAA,CAAE,KAAK,QAAA,IAAY,KAAK,OAAA,GAAU;wBACrC,MAAM,cAAc,IAAA,CAAK,UAAA,CAAW;wBACpC,IAAI,eAAe,YAAY,UAAA,CAAW,GAAG,OAAO,UAAU,IAAA,CAAK,QAAA,CAAU,MAAM,CAAA,EAAG;4BACrF,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,QAAQ;gCAAE,GAAG,IAAA;gCAAM,kBAAkB,YAAY,EAAA;4BAAG,CAAC;wBACjF;oBACD;oBACA;gBACD;QACD;IACD;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4186, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/%40tldraw/editor/src/lib/editor/Editor.ts"],"sourcesContent":["import {\n\tAtom,\n\tEMPTY_ARRAY,\n\tatom,\n\tcomputed,\n\treact,\n\ttransact,\n\tunsafe__withoutCapture,\n} from '@tldraw/state'\nimport {\n\tComputedCache,\n\tRecordType,\n\tStoreSideEffects,\n\tStoreSnapshot,\n\tUnknownRecord,\n\treverseRecordsDiff,\n} from '@tldraw/store'\nimport {\n\tCameraRecordType,\n\tInstancePageStateRecordType,\n\tPageRecordType,\n\tStyleProp,\n\tStylePropValue,\n\tTLArrowShape,\n\tTLAsset,\n\tTLAssetId,\n\tTLAssetPartial,\n\tTLBinding,\n\tTLBindingCreate,\n\tTLBindingId,\n\tTLBindingUpdate,\n\tTLCamera,\n\tTLCursor,\n\tTLCursorType,\n\tTLDOCUMENT_ID,\n\tTLDocument,\n\tTLFrameShape,\n\tTLGeoShape,\n\tTLGroupShape,\n\tTLHandle,\n\tTLINSTANCE_ID,\n\tTLImageAsset,\n\tTLInstance,\n\tTLInstancePageState,\n\tTLInstancePresence,\n\tTLNoteShape,\n\tTLPOINTER_ID,\n\tTLPage,\n\tTLPageId,\n\tTLParentId,\n\tTLRecord,\n\tTLShape,\n\tTLShapeId,\n\tTLShapePartial,\n\tTLStore,\n\tTLStoreSnapshot,\n\tTLUnknownBinding,\n\tTLUnknownShape,\n\tTLVideoAsset,\n\tcreateBindingId,\n\tcreateShapeId,\n\tgetShapePropKeysByStyle,\n\tisPageId,\n\tisShapeId,\n} from '@tldraw/tlschema'\nimport {\n\tFileHelpers,\n\tIndexKey,\n\tJsonObject,\n\tPerformanceTracker,\n\tResult,\n\tannotateError,\n\tassert,\n\tassertExists,\n\tbind,\n\tcompact,\n\tdebounce,\n\tdedupe,\n\texhaustiveSwitchError,\n\tfetch,\n\tgetIndexAbove,\n\tgetIndexBetween,\n\tgetIndices,\n\tgetIndicesAbove,\n\tgetIndicesBetween,\n\tgetOwnProperty,\n\thasOwnProperty,\n\tlast,\n\tlerp,\n\tmaxBy,\n\tminBy,\n\tsortById,\n\tsortByIndex,\n\tstructuredClone,\n\tuniqueId,\n} from '@tldraw/utils'\nimport EventEmitter from 'eventemitter3'\nimport {\n\tTLEditorSnapshot,\n\tTLLoadSnapshotOptions,\n\tgetSnapshot,\n\tloadSnapshot,\n} from '../config/TLEditorSnapshot'\nimport { TLUser, createTLUser } from '../config/createTLUser'\nimport { TLAnyBindingUtilConstructor, checkBindings } from '../config/defaultBindings'\nimport { TLAnyShapeUtilConstructor, checkShapesAndAddCore } from '../config/defaultShapes'\nimport {\n\tDEFAULT_ANIMATION_OPTIONS,\n\tDEFAULT_CAMERA_OPTIONS,\n\tINTERNAL_POINTER_IDS,\n\tLEFT_MOUSE_BUTTON,\n\tMIDDLE_MOUSE_BUTTON,\n\tRIGHT_MOUSE_BUTTON,\n\tSTYLUS_ERASER_BUTTON,\n\tZOOM_TO_FIT_PADDING,\n} from '../constants'\nimport { exportToSvg } from '../exports/exportToSvg'\nimport { getSvgAsImage } from '../exports/getSvgAsImage'\nimport { tlenv } from '../globals/environment'\nimport { tlmenus } from '../globals/menus'\nimport { tltime } from '../globals/time'\nimport { TldrawOptions, defaultTldrawOptions } from '../options'\nimport { Box, BoxLike } from '../primitives/Box'\nimport { Mat, MatLike } from '../primitives/Mat'\nimport { Vec, VecLike } from '../primitives/Vec'\nimport { EASINGS } from '../primitives/easings'\nimport { Geometry2d } from '../primitives/geometry/Geometry2d'\nimport { Group2d } from '../primitives/geometry/Group2d'\nimport { intersectPolygonPolygon } from '../primitives/intersect'\nimport { PI, approximately, areAnglesCompatible, clamp, pointInPolygon } from '../primitives/utils'\nimport { ReadonlySharedStyleMap, SharedStyle, SharedStyleMap } from '../utils/SharedStylesMap'\nimport { areShapesContentEqual } from '../utils/areShapesContentEqual'\nimport { dataUrlToFile } from '../utils/assets'\nimport { debugFlags } from '../utils/debug-flags'\nimport {\n\tTLDeepLink,\n\tTLDeepLinkOptions,\n\tcreateDeepLinkString,\n\tparseDeepLinkString,\n} from '../utils/deepLinks'\nimport { getIncrementedName } from '../utils/getIncrementedName'\nimport { isAccelKey } from '../utils/keyboard'\nimport { getReorderingShapesChanges } from '../utils/reorderShapes'\nimport { TLTextOptions, TiptapEditor } from '../utils/richText'\nimport { applyRotationToSnapshotShapes, getRotationSnapshot } from '../utils/rotation'\nimport { BindingOnDeleteOptions, BindingUtil } from './bindings/BindingUtil'\nimport { bindingsIndex } from './derivations/bindingsIndex'\nimport { notVisibleShapes } from './derivations/notVisibleShapes'\nimport { parentsToChildren } from './derivations/parentsToChildren'\nimport { deriveShapeIdsInCurrentPage } from './derivations/shapeIdsInCurrentPage'\nimport { ClickManager } from './managers/ClickManager/ClickManager'\nimport { EdgeScrollManager } from './managers/EdgeScrollManager/EdgeScrollManager'\nimport { FocusManager } from './managers/FocusManager/FocusManager'\nimport { FontManager } from './managers/FontManager/FontManager'\nimport { HistoryManager } from './managers/HistoryManager/HistoryManager'\nimport { ScribbleManager } from './managers/ScribbleManager/ScribbleManager'\nimport { SnapManager } from './managers/SnapManager/SnapManager'\nimport { TextManager } from './managers/TextManager/TextManager'\nimport { TickManager } from './managers/TickManager/TickManager'\nimport { UserPreferencesManager } from './managers/UserPreferencesManager/UserPreferencesManager'\nimport { ShapeUtil, TLGeometryOpts, TLResizeMode } from './shapes/ShapeUtil'\nimport { RootState } from './tools/RootState'\nimport { StateNode, TLStateNodeConstructor } from './tools/StateNode'\nimport { TLContent } from './types/clipboard-types'\nimport { TLEventMap } from './types/emit-types'\nimport {\n\tTLEventInfo,\n\tTLPinchEventInfo,\n\tTLPointerEventInfo,\n\tTLWheelEventInfo,\n} from './types/event-types'\nimport { TLExternalAsset, TLExternalContent } from './types/external-content'\nimport { TLHistoryBatchOptions } from './types/history-types'\nimport {\n\tOptionalKeys,\n\tRequiredKeys,\n\tTLCameraMoveOptions,\n\tTLCameraOptions,\n\tTLImageExportOptions,\n\tTLSvgExportOptions,\n} from './types/misc-types'\nimport { TLAdjacentDirection, TLResizeHandle } from './types/selection-types'\n\n/** @public */\nexport type TLResizeShapeOptions = Partial<{\n\tinitialBounds: Box\n\tscaleOrigin: VecLike\n\tscaleAxisRotation: number\n\tinitialShape: TLShape\n\tinitialPageTransform: MatLike\n\tdragHandle: TLResizeHandle\n\tisAspectRatioLocked: boolean\n\tmode: TLResizeMode\n\tskipStartAndEndCallbacks: boolean\n}>\n\n/** @public */\nexport interface TLEditorOptions {\n\t/**\n\t * The Store instance to use for keeping the app's data. This may be prepopulated, e.g. by loading\n\t * from a server or database.\n\t */\n\tstore: TLStore\n\t/**\n\t * An array of shapes to use in the editor. These will be used to create and manage shapes in the editor.\n\t */\n\tshapeUtils: readonly TLAnyShapeUtilConstructor[]\n\t/**\n\t * An array of bindings to use in the editor. These will be used to create and manage bindings in the editor.\n\t */\n\tbindingUtils: readonly TLAnyBindingUtilConstructor[]\n\t/**\n\t * An array of tools to use in the editor. These will be used to handle events and manage user interactions in the editor.\n\t */\n\ttools: readonly TLStateNodeConstructor[]\n\t/**\n\t * Should return a containing html element which has all the styles applied to the editor. If not\n\t * given, the body element will be used.\n\t */\n\tgetContainer(): HTMLElement\n\t/**\n\t * A user defined externally to replace the default user.\n\t */\n\tuser?: TLUser\n\t/**\n\t * The editor's initial active tool (or other state node id).\n\t */\n\tinitialState?: string\n\t/**\n\t * Whether to automatically focus the editor when it mounts.\n\t */\n\tautoFocus?: boolean\n\t/**\n\t * Whether to infer dark mode from the user's system preferences. Defaults to false.\n\t */\n\tinferDarkMode?: boolean\n\t/**\n\t * Options for the editor's camera.\n\t */\n\tcameraOptions?: Partial<TLCameraOptions>\n\ttextOptions?: TLTextOptions\n\toptions?: Partial<TldrawOptions>\n\tlicenseKey?: string\n\tfontAssetUrls?: { [key: string]: string | undefined }\n\t/**\n\t * A predicate that should return true if the given shape should be hidden.\n\t *\n\t * @deprecated Use {@link Editor#getShapeVisibility} instead.\n\t *\n\t * @param shape - The shape to check.\n\t * @param editor - The editor instance.\n\t */\n\tisShapeHidden?(shape: TLShape, editor: Editor): boolean\n\n\t/**\n\t * Provides a way to hide shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * getShapeVisibility={(shape, editor) => shape.meta.hidden ? 'hidden' : 'inherit'}\n\t * ```\n\t *\n\t * - `'inherit' | undefined` - (default) The shape will be visible unless its parent is hidden.\n\t * - `'hidden'` - The shape will be hidden.\n\t * - `'visible'` - The shape will be visible.\n\t *\n\t * @param shape - The shape to check.\n\t * @param editor - The editor instance.\n\t */\n\tgetShapeVisibility?(\n\t\tshape: TLShape,\n\t\teditor: Editor\n\t): 'visible' | 'hidden' | 'inherit' | null | undefined\n}\n\n/**\n * Options for {@link Editor.(run:1)}.\n * @public\n */\nexport interface TLEditorRunOptions extends TLHistoryBatchOptions {\n\tignoreShapeLock?: boolean\n}\n\n/** @public */\nexport interface TLRenderingShape {\n\tid: TLShapeId\n\tshape: TLShape\n\tutil: ShapeUtil\n\tindex: number\n\tbackgroundIndex: number\n\topacity: number\n}\n\n/** @public */\nexport class Editor extends EventEmitter<TLEventMap> {\n\treadonly id = uniqueId()\n\tconstructor({\n\t\tstore,\n\t\tuser,\n\t\tshapeUtils,\n\t\tbindingUtils,\n\t\ttools,\n\t\tgetContainer,\n\t\tcameraOptions,\n\t\ttextOptions,\n\t\tinitialState,\n\t\tautoFocus,\n\t\tinferDarkMode,\n\t\toptions,\n\t\t// eslint-disable-next-line @typescript-eslint/no-deprecated\n\t\tisShapeHidden,\n\t\tgetShapeVisibility,\n\t\tfontAssetUrls,\n\t}: TLEditorOptions) {\n\t\tsuper()\n\t\tassert(\n\t\t\t!(isShapeHidden && getShapeVisibility),\n\t\t\t'Cannot use both isShapeHidden and getShapeVisibility'\n\t\t)\n\n\t\tthis._getShapeVisibility = isShapeHidden\n\t\t\t? // eslint-disable-next-line @typescript-eslint/no-deprecated\n\t\t\t\t(shape: TLShape, editor: Editor) => (isShapeHidden(shape, editor) ? 'hidden' : 'inherit')\n\t\t\t: getShapeVisibility\n\n\t\tthis.options = { ...defaultTldrawOptions, ...options }\n\n\t\tthis.store = store\n\t\tthis.history = new HistoryManager<TLRecord>({\n\t\t\tstore,\n\t\t\tannotateError: (error: any) => {\n\t\t\t\tthis.annotateError(error, { origin: 'history.batch', willCrashApp: true })\n\t\t\t\tthis.crash(error)\n\t\t\t},\n\t\t})\n\n\t\tthis.snaps = new SnapManager(this)\n\n\t\tthis.disposables.add(this.timers.dispose)\n\n\t\tthis._cameraOptions.set({ ...DEFAULT_CAMERA_OPTIONS, ...cameraOptions })\n\n\t\tthis._textOptions = atom('text options', textOptions ?? null)\n\n\t\tthis.user = new UserPreferencesManager(user ?? createTLUser(), inferDarkMode ?? false)\n\t\tthis.disposables.add(() => this.user.dispose())\n\n\t\tthis.getContainer = getContainer\n\n\t\tthis.textMeasure = new TextManager(this)\n\t\tthis.disposables.add(() => this.textMeasure.dispose())\n\n\t\tthis.fonts = new FontManager(this, fontAssetUrls)\n\n\t\tthis._tickManager = new TickManager(this)\n\n\t\tclass NewRoot extends RootState {\n\t\t\tstatic override initial = initialState ?? ''\n\t\t}\n\n\t\tthis.root = new NewRoot(this)\n\t\tthis.root.children = {}\n\n\t\tconst allShapeUtils = checkShapesAndAddCore(shapeUtils)\n\n\t\tconst _shapeUtils = {} as Record<string, ShapeUtil<any>>\n\t\tconst _styleProps = {} as Record<string, Map<StyleProp<unknown>, string>>\n\t\tconst allStylesById = new Map<string, StyleProp<unknown>>()\n\n\t\tfor (const Util of allShapeUtils) {\n\t\t\tconst util = new Util(this)\n\t\t\t_shapeUtils[Util.type] = util\n\n\t\t\tconst propKeysByStyle = getShapePropKeysByStyle(Util.props ?? {})\n\t\t\t_styleProps[Util.type] = propKeysByStyle\n\n\t\t\tfor (const style of propKeysByStyle.keys()) {\n\t\t\t\tif (!allStylesById.has(style.id)) {\n\t\t\t\t\tallStylesById.set(style.id, style)\n\t\t\t\t} else if (allStylesById.get(style.id) !== style) {\n\t\t\t\t\tthrow Error(\n\t\t\t\t\t\t`Multiple style props with id \"${style.id}\" in use. Style prop IDs must be unique.`\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.shapeUtils = _shapeUtils\n\t\tthis.styleProps = _styleProps\n\n\t\tconst allBindingUtils = checkBindings(bindingUtils)\n\t\tconst _bindingUtils = {} as Record<string, BindingUtil<any>>\n\t\tfor (const Util of allBindingUtils) {\n\t\t\tconst util = new Util(this)\n\t\t\t_bindingUtils[Util.type] = util\n\t\t}\n\t\tthis.bindingUtils = _bindingUtils\n\n\t\t// Tools.\n\t\t// Accept tools from constructor parameters which may not conflict with the root note's default or\n\t\t// \"baked in\" tools, select and zoom.\n\t\tfor (const Tool of [...tools]) {\n\t\t\tif (hasOwnProperty(this.root.children!, Tool.id)) {\n\t\t\t\tthrow Error(`Can't override tool with id \"${Tool.id}\"`)\n\t\t\t}\n\t\t\tthis.root.children![Tool.id] = new Tool(this, this.root)\n\t\t}\n\n\t\tthis.scribbles = new ScribbleManager(this)\n\n\t\t// Cleanup\n\n\t\tconst cleanupInstancePageState = (\n\t\t\tprevPageState: TLInstancePageState,\n\t\t\tshapesNoLongerInPage: Set<TLShapeId>\n\t\t) => {\n\t\t\tlet nextPageState = null as null | TLInstancePageState\n\n\t\t\tconst selectedShapeIds = prevPageState.selectedShapeIds.filter(\n\t\t\t\t(id) => !shapesNoLongerInPage.has(id)\n\t\t\t)\n\t\t\tif (selectedShapeIds.length !== prevPageState.selectedShapeIds.length) {\n\t\t\t\tif (!nextPageState) nextPageState = { ...prevPageState }\n\t\t\t\tnextPageState.selectedShapeIds = selectedShapeIds\n\t\t\t}\n\n\t\t\tconst erasingShapeIds = prevPageState.erasingShapeIds.filter(\n\t\t\t\t(id) => !shapesNoLongerInPage.has(id)\n\t\t\t)\n\t\t\tif (erasingShapeIds.length !== prevPageState.erasingShapeIds.length) {\n\t\t\t\tif (!nextPageState) nextPageState = { ...prevPageState }\n\t\t\t\tnextPageState.erasingShapeIds = erasingShapeIds\n\t\t\t}\n\n\t\t\tif (prevPageState.hoveredShapeId && shapesNoLongerInPage.has(prevPageState.hoveredShapeId)) {\n\t\t\t\tif (!nextPageState) nextPageState = { ...prevPageState }\n\t\t\t\tnextPageState.hoveredShapeId = null\n\t\t\t}\n\n\t\t\tif (prevPageState.editingShapeId && shapesNoLongerInPage.has(prevPageState.editingShapeId)) {\n\t\t\t\tif (!nextPageState) nextPageState = { ...prevPageState }\n\t\t\t\tnextPageState.editingShapeId = null\n\t\t\t}\n\n\t\t\tconst hintingShapeIds = prevPageState.hintingShapeIds.filter(\n\t\t\t\t(id) => !shapesNoLongerInPage.has(id)\n\t\t\t)\n\t\t\tif (hintingShapeIds.length !== prevPageState.hintingShapeIds.length) {\n\t\t\t\tif (!nextPageState) nextPageState = { ...prevPageState }\n\t\t\t\tnextPageState.hintingShapeIds = hintingShapeIds\n\t\t\t}\n\n\t\t\tif (prevPageState.focusedGroupId && shapesNoLongerInPage.has(prevPageState.focusedGroupId)) {\n\t\t\t\tif (!nextPageState) nextPageState = { ...prevPageState }\n\t\t\t\tnextPageState.focusedGroupId = null\n\t\t\t}\n\t\t\treturn nextPageState\n\t\t}\n\n\t\tthis.sideEffects = this.store.sideEffects\n\n\t\tlet deletedBindings = new Map<TLBindingId, BindingOnDeleteOptions<any>>()\n\t\tconst deletedShapeIds = new Set<TLShapeId>()\n\t\tconst invalidParents = new Set<TLShapeId>()\n\t\tlet invalidBindingTypes = new Set<string>()\n\t\tthis.disposables.add(\n\t\t\tthis.sideEffects.registerOperationCompleteHandler(() => {\n\t\t\t\t// this needs to be cleared here because further effects may delete more shapes\n\t\t\t\t// and we want the next invocation of this handler to handle those separately\n\t\t\t\tdeletedShapeIds.clear()\n\n\t\t\t\tfor (const parentId of invalidParents) {\n\t\t\t\t\tinvalidParents.delete(parentId)\n\t\t\t\t\tconst parent = this.getShape(parentId)\n\t\t\t\t\tif (!parent) continue\n\n\t\t\t\t\tconst util = this.getShapeUtil(parent)\n\t\t\t\t\tconst changes = util.onChildrenChange?.(parent)\n\n\t\t\t\t\tif (changes?.length) {\n\t\t\t\t\t\tthis.updateShapes(changes)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (invalidBindingTypes.size) {\n\t\t\t\t\tconst t = invalidBindingTypes\n\t\t\t\t\tinvalidBindingTypes = new Set()\n\t\t\t\t\tfor (const type of t) {\n\t\t\t\t\t\tconst util = this.getBindingUtil(type)\n\t\t\t\t\t\tutil.onOperationComplete?.()\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (deletedBindings.size) {\n\t\t\t\t\tconst t = deletedBindings\n\t\t\t\t\tdeletedBindings = new Map()\n\t\t\t\t\tfor (const opts of t.values()) {\n\t\t\t\t\t\tthis.getBindingUtil(opts.binding).onAfterDelete?.(opts)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.emit('update')\n\t\t\t})\n\t\t)\n\n\t\tthis.disposables.add(\n\t\t\tthis.sideEffects.register({\n\t\t\t\tshape: {\n\t\t\t\t\tafterChange: (shapeBefore, shapeAfter) => {\n\t\t\t\t\t\tfor (const binding of this.getBindingsInvolvingShape(shapeAfter)) {\n\t\t\t\t\t\t\tinvalidBindingTypes.add(binding.type)\n\t\t\t\t\t\t\tif (binding.fromId === shapeAfter.id) {\n\t\t\t\t\t\t\t\tthis.getBindingUtil(binding).onAfterChangeFromShape?.({\n\t\t\t\t\t\t\t\t\tbinding,\n\t\t\t\t\t\t\t\t\tshapeBefore,\n\t\t\t\t\t\t\t\t\tshapeAfter,\n\t\t\t\t\t\t\t\t\treason: 'self',\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (binding.toId === shapeAfter.id) {\n\t\t\t\t\t\t\t\tthis.getBindingUtil(binding).onAfterChangeToShape?.({\n\t\t\t\t\t\t\t\t\tbinding,\n\t\t\t\t\t\t\t\t\tshapeBefore,\n\t\t\t\t\t\t\t\t\tshapeAfter,\n\t\t\t\t\t\t\t\t\treason: 'self',\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if the shape's parent changed and it has a binding, update the binding\n\t\t\t\t\t\tif (shapeBefore.parentId !== shapeAfter.parentId) {\n\t\t\t\t\t\t\tconst notifyBindingAncestryChange = (id: TLShapeId) => {\n\t\t\t\t\t\t\t\tconst descendantShape = this.getShape(id)\n\t\t\t\t\t\t\t\tif (!descendantShape) return\n\n\t\t\t\t\t\t\t\tfor (const binding of this.getBindingsInvolvingShape(descendantShape)) {\n\t\t\t\t\t\t\t\t\tinvalidBindingTypes.add(binding.type)\n\n\t\t\t\t\t\t\t\t\tif (binding.fromId === descendantShape.id) {\n\t\t\t\t\t\t\t\t\t\tthis.getBindingUtil(binding).onAfterChangeFromShape?.({\n\t\t\t\t\t\t\t\t\t\t\tbinding,\n\t\t\t\t\t\t\t\t\t\t\tshapeBefore: descendantShape,\n\t\t\t\t\t\t\t\t\t\t\tshapeAfter: descendantShape,\n\t\t\t\t\t\t\t\t\t\t\treason: 'ancestry',\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (binding.toId === descendantShape.id) {\n\t\t\t\t\t\t\t\t\t\tthis.getBindingUtil(binding).onAfterChangeToShape?.({\n\t\t\t\t\t\t\t\t\t\t\tbinding,\n\t\t\t\t\t\t\t\t\t\t\tshapeBefore: descendantShape,\n\t\t\t\t\t\t\t\t\t\t\tshapeAfter: descendantShape,\n\t\t\t\t\t\t\t\t\t\t\treason: 'ancestry',\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnotifyBindingAncestryChange(shapeAfter.id)\n\t\t\t\t\t\t\tthis.visitDescendants(shapeAfter.id, notifyBindingAncestryChange)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if this shape moved to a new page, clean up any previous page's instance state\n\t\t\t\t\t\tif (shapeBefore.parentId !== shapeAfter.parentId && isPageId(shapeAfter.parentId)) {\n\t\t\t\t\t\t\tconst allMovingIds = new Set([shapeBefore.id])\n\t\t\t\t\t\t\tthis.visitDescendants(shapeBefore.id, (id) => {\n\t\t\t\t\t\t\t\tallMovingIds.add(id)\n\t\t\t\t\t\t\t})\n\n\t\t\t\t\t\t\tfor (const instancePageState of this.getPageStates()) {\n\t\t\t\t\t\t\t\tif (instancePageState.pageId === shapeAfter.parentId) continue\n\t\t\t\t\t\t\t\tconst nextPageState = cleanupInstancePageState(instancePageState, allMovingIds)\n\n\t\t\t\t\t\t\t\tif (nextPageState) {\n\t\t\t\t\t\t\t\t\tthis.store.put([nextPageState])\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (shapeBefore.parentId && isShapeId(shapeBefore.parentId)) {\n\t\t\t\t\t\t\tinvalidParents.add(shapeBefore.parentId)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (shapeAfter.parentId !== shapeBefore.parentId && isShapeId(shapeAfter.parentId)) {\n\t\t\t\t\t\t\tinvalidParents.add(shapeAfter.parentId)\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tbeforeDelete: (shape) => {\n\t\t\t\t\t\t// if we triggered this delete with a recursive call, don't do anything\n\t\t\t\t\t\tif (deletedShapeIds.has(shape.id)) return\n\t\t\t\t\t\t// if the deleted shape has a parent shape make sure we call it's onChildrenChange callback\n\t\t\t\t\t\tif (shape.parentId && isShapeId(shape.parentId)) {\n\t\t\t\t\t\t\tinvalidParents.add(shape.parentId)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdeletedShapeIds.add(shape.id)\n\n\t\t\t\t\t\tconst deleteBindingIds: TLBindingId[] = []\n\t\t\t\t\t\tfor (const binding of this.getBindingsInvolvingShape(shape)) {\n\t\t\t\t\t\t\tinvalidBindingTypes.add(binding.type)\n\t\t\t\t\t\t\tdeleteBindingIds.push(binding.id)\n\t\t\t\t\t\t\tconst util = this.getBindingUtil(binding)\n\t\t\t\t\t\t\tif (binding.fromId === shape.id) {\n\t\t\t\t\t\t\t\tutil.onBeforeIsolateToShape?.({ binding, removedShape: shape })\n\t\t\t\t\t\t\t\tutil.onBeforeDeleteFromShape?.({ binding, shape })\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tutil.onBeforeIsolateFromShape?.({ binding, removedShape: shape })\n\t\t\t\t\t\t\t\tutil.onBeforeDeleteToShape?.({ binding, shape })\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (deleteBindingIds.length) {\n\t\t\t\t\t\t\tthis.deleteBindings(deleteBindingIds)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst deletedIds = new Set([shape.id])\n\t\t\t\t\t\tconst updates = compact(\n\t\t\t\t\t\t\tthis.getPageStates().map((pageState) => {\n\t\t\t\t\t\t\t\treturn cleanupInstancePageState(pageState, deletedIds)\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\tif (updates.length) {\n\t\t\t\t\t\t\tthis.store.put(updates)\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tbinding: {\n\t\t\t\t\tbeforeCreate: (binding) => {\n\t\t\t\t\t\tconst next = this.getBindingUtil(binding).onBeforeCreate?.({ binding })\n\t\t\t\t\t\tif (next) return next\n\t\t\t\t\t\treturn binding\n\t\t\t\t\t},\n\t\t\t\t\tafterCreate: (binding) => {\n\t\t\t\t\t\tinvalidBindingTypes.add(binding.type)\n\t\t\t\t\t\tthis.getBindingUtil(binding).onAfterCreate?.({ binding })\n\t\t\t\t\t},\n\t\t\t\t\tbeforeChange: (bindingBefore, bindingAfter) => {\n\t\t\t\t\t\tconst updated = this.getBindingUtil(bindingAfter).onBeforeChange?.({\n\t\t\t\t\t\t\tbindingBefore,\n\t\t\t\t\t\t\tbindingAfter,\n\t\t\t\t\t\t})\n\t\t\t\t\t\tif (updated) return updated\n\t\t\t\t\t\treturn bindingAfter\n\t\t\t\t\t},\n\t\t\t\t\tafterChange: (bindingBefore, bindingAfter) => {\n\t\t\t\t\t\tinvalidBindingTypes.add(bindingAfter.type)\n\t\t\t\t\t\tthis.getBindingUtil(bindingAfter).onAfterChange?.({ bindingBefore, bindingAfter })\n\t\t\t\t\t},\n\t\t\t\t\tbeforeDelete: (binding) => {\n\t\t\t\t\t\tthis.getBindingUtil(binding).onBeforeDelete?.({ binding })\n\t\t\t\t\t},\n\t\t\t\t\tafterDelete: (binding) => {\n\t\t\t\t\t\tthis.getBindingUtil(binding).onAfterDelete?.({ binding })\n\t\t\t\t\t\tinvalidBindingTypes.add(binding.type)\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tpage: {\n\t\t\t\t\tafterCreate: (record) => {\n\t\t\t\t\t\tconst cameraId = CameraRecordType.createId(record.id)\n\t\t\t\t\t\tconst _pageStateId = InstancePageStateRecordType.createId(record.id)\n\t\t\t\t\t\tif (!this.store.has(cameraId)) {\n\t\t\t\t\t\t\tthis.store.put([CameraRecordType.create({ id: cameraId })])\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!this.store.has(_pageStateId)) {\n\t\t\t\t\t\t\tthis.store.put([\n\t\t\t\t\t\t\t\tInstancePageStateRecordType.create({ id: _pageStateId, pageId: record.id }),\n\t\t\t\t\t\t\t])\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tafterDelete: (record, source) => {\n\t\t\t\t\t\t// page was deleted, need to check whether it's the current page and select another one if so\n\t\t\t\t\t\tif (this.getInstanceState()?.currentPageId === record.id) {\n\t\t\t\t\t\t\tconst backupPageId = this.getPages().find((p) => p.id !== record.id)?.id\n\t\t\t\t\t\t\tif (backupPageId) {\n\t\t\t\t\t\t\t\tthis.store.put([{ ...this.getInstanceState(), currentPageId: backupPageId }])\n\t\t\t\t\t\t\t} else if (source === 'user') {\n\t\t\t\t\t\t\t\t// fall back to ensureStoreIsUsable:\n\t\t\t\t\t\t\t\tthis.store.ensureStoreIsUsable()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// delete the camera and state for the page if necessary\n\t\t\t\t\t\tconst cameraId = CameraRecordType.createId(record.id)\n\t\t\t\t\t\tconst instance_PageStateId = InstancePageStateRecordType.createId(record.id)\n\t\t\t\t\t\tthis.store.remove([cameraId, instance_PageStateId])\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tinstance: {\n\t\t\t\t\tafterChange: (prev, next, source) => {\n\t\t\t\t\t\t// instance should never be updated to a page that no longer exists (this can\n\t\t\t\t\t\t// happen when undoing a change that involves switching to a page that has since\n\t\t\t\t\t\t// been deleted by another user)\n\t\t\t\t\t\tif (!this.store.has(next.currentPageId)) {\n\t\t\t\t\t\t\tconst backupPageId = this.store.has(prev.currentPageId)\n\t\t\t\t\t\t\t\t? prev.currentPageId\n\t\t\t\t\t\t\t\t: this.getPages()[0]?.id\n\t\t\t\t\t\t\tif (backupPageId) {\n\t\t\t\t\t\t\t\tthis.store.update(next.id, (instance) => ({\n\t\t\t\t\t\t\t\t\t...instance,\n\t\t\t\t\t\t\t\t\tcurrentPageId: backupPageId,\n\t\t\t\t\t\t\t\t}))\n\t\t\t\t\t\t\t} else if (source === 'user') {\n\t\t\t\t\t\t\t\t// fall back to ensureStoreIsUsable:\n\t\t\t\t\t\t\t\tthis.store.ensureStoreIsUsable()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tinstance_page_state: {\n\t\t\t\t\tafterChange: (prev, next) => {\n\t\t\t\t\t\tif (prev?.selectedShapeIds !== next?.selectedShapeIds) {\n\t\t\t\t\t\t\t// ensure that descendants and ancestors are not selected at the same time\n\t\t\t\t\t\t\tconst filtered = next.selectedShapeIds.filter((id) => {\n\t\t\t\t\t\t\t\tlet parentId = this.getShape(id)?.parentId\n\t\t\t\t\t\t\t\twhile (isShapeId(parentId)) {\n\t\t\t\t\t\t\t\t\tif (next.selectedShapeIds.includes(parentId)) {\n\t\t\t\t\t\t\t\t\t\treturn false\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tparentId = this.getShape(parentId)?.parentId\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn true\n\t\t\t\t\t\t\t})\n\n\t\t\t\t\t\t\tlet nextFocusedGroupId: null | TLShapeId = null\n\n\t\t\t\t\t\t\tif (filtered.length > 0) {\n\t\t\t\t\t\t\t\tconst commonGroupAncestor = this.findCommonAncestor(\n\t\t\t\t\t\t\t\t\tcompact(filtered.map((id) => this.getShape(id))),\n\t\t\t\t\t\t\t\t\t(shape) => this.isShapeOfType<TLGroupShape>(shape, 'group')\n\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\tif (commonGroupAncestor) {\n\t\t\t\t\t\t\t\t\tnextFocusedGroupId = commonGroupAncestor\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (next?.focusedGroupId) {\n\t\t\t\t\t\t\t\t\tnextFocusedGroupId = next.focusedGroupId\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tfiltered.length !== next.selectedShapeIds.length ||\n\t\t\t\t\t\t\t\tnextFocusedGroupId !== next.focusedGroupId\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tthis.store.put([\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t...next,\n\t\t\t\t\t\t\t\t\t\tselectedShapeIds: filtered,\n\t\t\t\t\t\t\t\t\t\tfocusedGroupId: nextFocusedGroupId ?? null,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t])\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t})\n\t\t)\n\n\t\tthis._currentPageShapeIds = deriveShapeIdsInCurrentPage(this.store, () =>\n\t\t\tthis.getCurrentPageId()\n\t\t)\n\t\tthis._parentIdsToChildIds = parentsToChildren(this.store)\n\n\t\tthis.disposables.add(\n\t\t\tthis.store.listen((changes) => {\n\t\t\t\tthis.emit('change', changes)\n\t\t\t})\n\t\t)\n\t\tthis.disposables.add(this.history.dispose)\n\n\t\tthis.run(\n\t\t\t() => {\n\t\t\t\tthis.store.ensureStoreIsUsable()\n\n\t\t\t\t// clear ephemeral state\n\t\t\t\tthis._updateCurrentPageState({\n\t\t\t\t\teditingShapeId: null,\n\t\t\t\t\thoveredShapeId: null,\n\t\t\t\t\terasingShapeIds: [],\n\t\t\t\t})\n\t\t\t},\n\t\t\t{ history: 'ignore' }\n\t\t)\n\n\t\tif (initialState && this.root.children[initialState] === undefined) {\n\t\t\tthrow Error(`No state found for initialState \"${initialState}\".`)\n\t\t}\n\n\t\tthis.root.enter(undefined, 'initial')\n\n\t\tthis.edgeScrollManager = new EdgeScrollManager(this)\n\t\tthis.focusManager = new FocusManager(this, autoFocus)\n\t\tthis.disposables.add(this.focusManager.dispose.bind(this.focusManager))\n\n\t\tif (this.getInstanceState().followingUserId) {\n\t\t\tthis.stopFollowingUser()\n\t\t}\n\n\t\tthis.on('tick', this._flushEventsForTick)\n\n\t\tthis.timers.requestAnimationFrame(() => {\n\t\t\tthis._tickManager.start()\n\t\t})\n\n\t\tthis.performanceTracker = new PerformanceTracker()\n\n\t\tif (this.store.props.collaboration?.mode) {\n\t\t\tconst mode = this.store.props.collaboration.mode\n\t\t\tthis.disposables.add(\n\t\t\t\treact('update collaboration mode', () => {\n\t\t\t\t\tthis.store.put([{ ...this.getInstanceState(), isReadonly: mode.get() === 'readonly' }])\n\t\t\t\t})\n\t\t\t)\n\t\t}\n\t}\n\n\tprivate readonly _getShapeVisibility?: TLEditorOptions['getShapeVisibility']\n\t@computed\n\tprivate getIsShapeHiddenCache() {\n\t\tif (!this._getShapeVisibility) return null\n\t\treturn this.store.createComputedCache<boolean, TLShape>('isShapeHidden', (shape: TLShape) => {\n\t\t\tconst visibility = this._getShapeVisibility!(shape, this)\n\t\t\tconst isParentHidden = PageRecordType.isId(shape.parentId)\n\t\t\t\t? false\n\t\t\t\t: this.isShapeHidden(shape.parentId)\n\n\t\t\tif (isParentHidden) return visibility !== 'visible'\n\t\t\treturn visibility === 'hidden'\n\t\t})\n\t}\n\tisShapeHidden(shapeOrId: TLShape | TLShapeId): boolean {\n\t\tif (!this._getShapeVisibility) return false\n\t\treturn !!this.getIsShapeHiddenCache!()!.get(\n\t\t\ttypeof shapeOrId === 'string' ? shapeOrId : shapeOrId.id\n\t\t)\n\t}\n\n\treadonly options: TldrawOptions\n\n\treadonly contextId = uniqueId()\n\n\t/**\n\t * The editor's store\n\t *\n\t * @public\n\t */\n\treadonly store: TLStore\n\n\t/**\n\t * The root state of the statechart.\n\t *\n\t * @public\n\t */\n\treadonly root: StateNode\n\n\t/**\n\t * A set of functions to call when the app is disposed.\n\t *\n\t * @public\n\t */\n\treadonly disposables = new Set<() => void>()\n\n\t/**\n\t * Whether the editor is disposed.\n\t *\n\t * @public\n\t */\n\tisDisposed = false\n\n\t/** @internal */\n\tprivate readonly _tickManager\n\n\t/**\n\t * A manager for the app's snapping feature.\n\t *\n\t * @public\n\t */\n\treadonly snaps: SnapManager\n\n\t/**\n\t * A manager for the any asynchronous events and making sure they're\n\t * cleaned up upon disposal.\n\t *\n\t * @public\n\t */\n\treadonly timers = tltime.forContext(this.contextId)\n\n\t/**\n\t * A manager for the user and their preferences.\n\t *\n\t * @public\n\t */\n\treadonly user: UserPreferencesManager\n\n\t/**\n\t * A helper for measuring text.\n\t *\n\t * @public\n\t */\n\treadonly textMeasure: TextManager\n\n\t/**\n\t * A utility for managing the set of fonts that should be rendered in the document.\n\t *\n\t * @public\n\t */\n\treadonly fonts: FontManager\n\n\t/**\n\t * A manager for the editor's environment.\n\t *\n\t * @deprecated This is deprecated and will be removed in a future version. Use the `tlenv` global export instead.\n\t * @public\n\t */\n\treadonly environment = tlenv\n\n\t/**\n\t * A manager for the editor's scribbles.\n\t *\n\t * @public\n\t */\n\treadonly scribbles: ScribbleManager\n\n\t/**\n\t * A manager for side effects and correct state enforcement. See {@link @tldraw/store#StoreSideEffects} for details.\n\t *\n\t * @public\n\t */\n\treadonly sideEffects: StoreSideEffects<TLRecord>\n\n\t/**\n\t * A manager for moving the camera when the mouse is at the edge of the screen.\n\t *\n\t * @public\n\t */\n\tedgeScrollManager: EdgeScrollManager\n\n\t/**\n\t * A manager for ensuring correct focus. See FocusManager for details.\n\t *\n\t * @internal\n\t */\n\tprivate focusManager: FocusManager\n\n\t/**\n\t * The current HTML element containing the editor.\n\t *\n\t * @example\n\t * ```ts\n\t * const container = editor.getContainer()\n\t * ```\n\t *\n\t * @public\n\t */\n\tgetContainer: () => HTMLElement\n\n\t/**\n\t * Dispose the editor.\n\t *\n\t * @public\n\t */\n\tdispose() {\n\t\tthis.disposables.forEach((dispose) => dispose())\n\t\tthis.disposables.clear()\n\t\tthis.store.dispose()\n\t\tthis.isDisposed = true\n\t}\n\n\t/* ------------------- Shape Utils ------------------ */\n\n\t/**\n\t * A map of shape utility classes (TLShapeUtils) by shape type.\n\t *\n\t * @public\n\t */\n\tshapeUtils: { readonly [K in string]?: ShapeUtil<TLUnknownShape> }\n\n\tstyleProps: { [key: string]: Map<StyleProp<any>, string> }\n\n\t/**\n\t * Get a shape util from a shape itself.\n\t *\n\t * @example\n\t * ```ts\n\t * const util = editor.getShapeUtil(myArrowShape)\n\t * const util = editor.getShapeUtil('arrow')\n\t * const util = editor.getShapeUtil<TLArrowShape>(myArrowShape)\n\t * const util = editor.getShapeUtil(TLArrowShape)('arrow')\n\t * ```\n\t *\n\t * @param shape - A shape, shape partial, or shape type.\n\t *\n\t * @public\n\t */\n\tgetShapeUtil<S extends TLUnknownShape>(shape: S | TLShapePartial<S>): ShapeUtil<S>\n\tgetShapeUtil<S extends TLUnknownShape>(type: S['type']): ShapeUtil<S>\n\tgetShapeUtil<T extends ShapeUtil>(type: T extends ShapeUtil<infer R> ? R['type'] : string): T\n\tgetShapeUtil(arg: string | { type: string }) {\n\t\tconst type = typeof arg === 'string' ? arg : arg.type\n\t\tconst shapeUtil = getOwnProperty(this.shapeUtils, type)\n\t\tassert(shapeUtil, `No shape util found for type \"${type}\"`)\n\t\treturn shapeUtil\n\t}\n\n\t/**\n\t * Returns true if the editor has a shape util for the given shape / shape type.\n\t *\n\t * @param shape - A shape, shape partial, or shape type.\n\t */\n\thasShapeUtil<S extends TLUnknownShape>(shape: S | TLShapePartial<S>): boolean\n\thasShapeUtil<S extends TLUnknownShape>(type: S['type']): boolean\n\thasShapeUtil<T extends ShapeUtil>(\n\t\ttype: T extends ShapeUtil<infer R> ? R['type'] : string\n\t): boolean\n\thasShapeUtil(arg: string | { type: string }): boolean {\n\t\tconst type = typeof arg === 'string' ? arg : arg.type\n\t\treturn hasOwnProperty(this.shapeUtils, type)\n\t}\n\n\t/* ------------------- Binding Utils ------------------ */\n\t/**\n\t * A map of shape utility classes (TLShapeUtils) by shape type.\n\t *\n\t * @public\n\t */\n\tbindingUtils: { readonly [K in string]?: BindingUtil<TLUnknownBinding> }\n\n\t/**\n\t * Get a binding util from a binding itself.\n\t *\n\t * @example\n\t * ```ts\n\t * const util = editor.getBindingUtil(myArrowBinding)\n\t * const util = editor.getBindingUtil('arrow')\n\t * const util = editor.getBindingUtil<TLArrowBinding>(myArrowBinding)\n\t * const util = editor.getBindingUtil(TLArrowBinding)('arrow')\n\t * ```\n\t *\n\t * @param binding - A binding, binding partial, or binding type.\n\t *\n\t * @public\n\t */\n\tgetBindingUtil<S extends TLUnknownBinding>(binding: S | { type: S['type'] }): BindingUtil<S>\n\tgetBindingUtil<S extends TLUnknownBinding>(type: S['type']): BindingUtil<S>\n\tgetBindingUtil<T extends BindingUtil>(\n\t\ttype: T extends BindingUtil<infer R> ? R['type'] : string\n\t): T\n\tgetBindingUtil(arg: string | { type: string }) {\n\t\tconst type = typeof arg === 'string' ? arg : arg.type\n\t\tconst bindingUtil = getOwnProperty(this.bindingUtils, type)\n\t\tassert(bindingUtil, `No binding util found for type \"${type}\"`)\n\t\treturn bindingUtil\n\t}\n\n\t/* --------------------- History -------------------- */\n\n\t/**\n\t * A manager for the app's history.\n\t *\n\t * @readonly\n\t */\n\tprotected readonly history: HistoryManager<TLRecord>\n\n\t/**\n\t * Undo to the last mark.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.undo()\n\t * ```\n\t *\n\t * @public\n\t */\n\tundo(): this {\n\t\tthis._flushEventsForTick(0)\n\t\tthis.complete()\n\t\tthis.history.undo()\n\t\treturn this\n\t}\n\n\t/**\n\t * Whether the app can undo.\n\t *\n\t * @public\n\t */\n\t@computed getCanUndo(): boolean {\n\t\treturn this.history.getNumUndos() > 0\n\t}\n\n\t/**\n\t * Redo to the next mark.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.redo()\n\t * ```\n\t *\n\t * @public\n\t */\n\tredo(): this {\n\t\tthis._flushEventsForTick(0)\n\t\tthis.complete()\n\t\tthis.history.redo()\n\t\treturn this\n\t}\n\n\tclearHistory() {\n\t\tthis.history.clear()\n\t\treturn this\n\t}\n\n\t/**\n\t * Whether the app can redo.\n\t *\n\t * @public\n\t */\n\t@computed getCanRedo(): boolean {\n\t\treturn this.history.getNumRedos() > 0\n\t}\n\n\t/**\n\t * Create a new \"mark\", or stopping point, in the undo redo history. Creating a mark will clear\n\t * any redos.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.mark()\n\t * editor.mark('flip shapes')\n\t * ```\n\t *\n\t * @param markId - The mark's id, usually the reason for adding the mark.\n\t *\n\t * @public\n\t * @deprecated use {@link Editor.markHistoryStoppingPoint} instead\n\t */\n\tmark(markId?: string): this {\n\t\tif (typeof markId === 'string') {\n\t\t\tconsole.warn(\n\t\t\t\t`[tldraw] \\`editor.history.mark(\"${markId}\")\\` is deprecated. Please use \\`const myMarkId = editor.markHistoryStoppingPoint()\\` instead.`\n\t\t\t)\n\t\t} else {\n\t\t\tconsole.warn(\n\t\t\t\t'[tldraw] `editor.mark()` is deprecated. Use `editor.markHistoryStoppingPoint()` instead.'\n\t\t\t)\n\t\t}\n\t\tthis.history._mark(markId ?? uniqueId())\n\t\treturn this\n\t}\n\n\t/**\n\t * Create a new \"mark\", or stopping point, in the undo redo history. Creating a mark will clear\n\t * any redos. You typically want to do this just before a user interaction begins or is handled.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.markHistoryStoppingPoint()\n\t * editor.flipShapes(editor.getSelectedShapes())\n\t * ```\n\t * @example\n\t * ```ts\n\t * const beginRotateMark = editor.markHistoryStoppingPoint()\n\t * // if the use cancels the rotation, you can bail back to this mark\n\t * editor.bailToMark(beginRotateMark)\n\t * ```\n\t *\n\t * @public\n\t * @param name - The name of the mark, useful for debugging the undo/redo stacks\n\t * @returns a unique id for the mark that can be used with `squashToMark` or `bailToMark`.\n\t */\n\tmarkHistoryStoppingPoint(name?: string): string {\n\t\tconst id = `[${name ?? 'stop'}]_${uniqueId()}`\n\t\tthis.history._mark(id)\n\t\treturn id\n\t}\n\n\t/**\n\t * @internal this is only used to implement some backwards-compatibility logic. Should be fine to delete after 6 months or whatever.\n\t */\n\tgetMarkIdMatching(idSubstring: string) {\n\t\treturn this.history.getMarkIdMatching(idSubstring)\n\t}\n\n\t/**\n\t * Coalesces all changes since the given mark into a single change, removing any intermediate marks.\n\t *\n\t * This is useful if you need to 'compress' the recent history to simplify the undo/redo experience of a complex interaction.\n\t *\n\t * @example\n\t * ```ts\n\t * const bumpShapesMark = editor.markHistoryStoppingPoint()\n\t * // ... some changes\n\t * editor.squashToMark(bumpShapesMark)\n\t * ```\n\t *\n\t * @param markId - The mark id to squash to.\n\t */\n\tsquashToMark(markId: string): this {\n\t\tthis.history.squashToMark(markId)\n\t\treturn this\n\t}\n\n\t/**\n\t * Undo to the closest mark, discarding the changes so they cannot be redone.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.bail()\n\t * ```\n\t *\n\t * @public\n\t */\n\tbail() {\n\t\tthis.history.bail()\n\t\treturn this\n\t}\n\n\t/**\n\t * Undo to the given mark, discarding the changes so they cannot be redone.\n\t *\n\t * @example\n\t * ```ts\n\t * const beginDrag = editor.markHistoryStoppingPoint()\n\t * // ... some changes\n\t * editor.bailToMark(beginDrag)\n\t * ```\n\t *\n\t * @public\n\t */\n\tbailToMark(id: string): this {\n\t\tthis.history.bailToMark(id)\n\t\treturn this\n\t}\n\n\tprivate _shouldIgnoreShapeLock = false\n\n\t/**\n\t * Run a function in a transaction with optional options for context.\n\t * You can use the options to change the way that history is treated\n\t * or allow changes to locked shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * // updating with\n\t * editor.run(() => {\n\t * \teditor.updateShape({ ...myShape, x: 100 })\n\t * }, { history: \"ignore\" })\n\t *\n\t * // forcing changes / deletions for locked shapes\n\t * editor.toggleLock([myShape])\n\t * editor.run(() => {\n\t * \teditor.updateShape({ ...myShape, x: 100 })\n\t * \teditor.deleteShape(myShape)\n\t * }, { ignoreShapeLock: true }, )\n\t * ```\n\t *\n\t * @param fn - The callback function to run.\n\t * @param opts - The options for the batch.\n\t *\n\t *\n\t * @public\n\t */\n\trun(fn: () => void, opts?: TLEditorRunOptions): this {\n\t\tconst previousIgnoreShapeLock = this._shouldIgnoreShapeLock\n\t\tthis._shouldIgnoreShapeLock = opts?.ignoreShapeLock ?? previousIgnoreShapeLock\n\t\ttry {\n\t\t\tthis.history.batch(fn, opts)\n\t\t} finally {\n\t\t\tthis._shouldIgnoreShapeLock = previousIgnoreShapeLock\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * @deprecated Use `Editor.run` instead.\n\t */\n\tbatch(fn: () => void, opts?: TLEditorRunOptions): this {\n\t\treturn this.run(fn, opts)\n\t}\n\n\t/* --------------------- Errors --------------------- */\n\n\t/** @internal */\n\tannotateError(\n\t\terror: unknown,\n\t\t{\n\t\t\torigin,\n\t\t\twillCrashApp,\n\t\t\ttags,\n\t\t\textras,\n\t\t}: {\n\t\t\torigin: string\n\t\t\twillCrashApp: boolean\n\t\t\ttags?: Record<string, string | boolean | number>\n\t\t\textras?: Record<string, unknown>\n\t\t}\n\t): this {\n\t\tconst defaultAnnotations = this.createErrorAnnotations(origin, willCrashApp)\n\t\tannotateError(error, {\n\t\t\ttags: { ...defaultAnnotations.tags, ...tags },\n\t\t\textras: { ...defaultAnnotations.extras, ...extras },\n\t\t})\n\t\tif (willCrashApp) {\n\t\t\tthis.store.markAsPossiblyCorrupted()\n\t\t}\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tcreateErrorAnnotations(origin: string, willCrashApp: boolean | 'unknown') {\n\t\ttry {\n\t\t\tconst editingShapeId = this.getEditingShapeId()\n\t\t\treturn {\n\t\t\t\ttags: {\n\t\t\t\t\torigin: origin,\n\t\t\t\t\twillCrashApp,\n\t\t\t\t},\n\t\t\t\textras: {\n\t\t\t\t\tactiveStateNode: this.root.getPath(),\n\t\t\t\t\tselectedShapes: this.getSelectedShapes().map((s) => {\n\t\t\t\t\t\tconst { props, ...rest } = s\n\t\t\t\t\t\tconst { text: _text, richText: _richText, ...restProps } = props as any\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t...rest,\n\t\t\t\t\t\t\tprops: restProps,\n\t\t\t\t\t\t}\n\t\t\t\t\t}),\n\t\t\t\t\tselectionCount: this.getSelectedShapes().length,\n\t\t\t\t\teditingShape: editingShapeId ? this.getShape(editingShapeId) : undefined,\n\t\t\t\t\tinputs: this.inputs,\n\t\t\t\t\tpageState: this.getCurrentPageState(),\n\t\t\t\t\tinstanceState: this.getInstanceState(),\n\t\t\t\t\tcollaboratorCount: this.getCollaboratorsOnCurrentPage().length,\n\t\t\t\t},\n\t\t\t}\n\t\t} catch {\n\t\t\treturn {\n\t\t\t\ttags: {\n\t\t\t\t\torigin: origin,\n\t\t\t\t\twillCrashApp,\n\t\t\t\t},\n\t\t\t\textras: {},\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @internal */\n\tprivate _crashingError: unknown | null = null\n\n\t/**\n\t * We can't use an `atom` here because there's a chance that when `crashAndReportError` is called,\n\t * we're in a transaction that's about to be rolled back due to the same error we're currently\n\t * reporting.\n\t *\n\t * Instead, to listen to changes to this value, you need to listen to app's `crash` event.\n\t *\n\t * @internal\n\t */\n\tgetCrashingError() {\n\t\treturn this._crashingError\n\t}\n\n\t/** @internal */\n\tcrash(error: unknown): this {\n\t\tthis._crashingError = error\n\t\tthis.store.markAsPossiblyCorrupted()\n\t\tthis.emit('crash', { error })\n\t\treturn this\n\t}\n\n\t/* ------------------- Statechart ------------------- */\n\n\t/**\n\t * The editor's current path of active states.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getPath() // \"select.idle\"\n\t * ```\n\t *\n\t * @public\n\t */\n\t@computed getPath() {\n\t\treturn this.root.getPath().split('root.')[1]\n\t}\n\n\t/**\n\t * Get whether a certain tool (or other state node) is currently active.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.isIn('select')\n\t * editor.isIn('select.brushing')\n\t * ```\n\t *\n\t * @param path - The path of active states, separated by periods.\n\t *\n\t * @public\n\t */\n\tisIn(path: string): boolean {\n\t\tconst ids = path.split('.').reverse()\n\t\tlet state = this.root as StateNode\n\t\twhile (ids.length > 0) {\n\t\t\tconst id = ids.pop()\n\t\t\tif (!id) return true\n\t\t\tconst current = state.getCurrent()\n\t\t\tif (current?.id === id) {\n\t\t\t\tif (ids.length === 0) return true\n\t\t\t\tstate = current\n\t\t\t\tcontinue\n\t\t\t} else return false\n\t\t}\n\t\treturn false\n\t}\n\n\t/**\n\t * Get whether the state node is in any of the given active paths.\n\t *\n\t * @example\n\t * ```ts\n\t * state.isInAny('select', 'erase')\n\t * state.isInAny('select.brushing', 'erase.idle')\n\t * ```\n\t *\n\t * @public\n\t */\n\tisInAny(...paths: string[]): boolean {\n\t\treturn paths.some((path) => this.isIn(path))\n\t}\n\n\t/**\n\t * Set the selected tool.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setCurrentTool('hand')\n\t * editor.setCurrentTool('hand', { date: Date.now() })\n\t * ```\n\t *\n\t * @param id - The id of the tool to select.\n\t * @param info - Arbitrary data to pass along into the transition.\n\t *\n\t * @public\n\t */\n\tsetCurrentTool(id: string, info = {}): this {\n\t\tthis.root.transition(id, info)\n\t\treturn this\n\t}\n\n\t/**\n\t * The current selected tool.\n\t *\n\t * @public\n\t */\n\t@computed getCurrentTool(): StateNode {\n\t\treturn this.root.getCurrent()!\n\t}\n\n\t/**\n\t * The id of the current selected tool.\n\t *\n\t * @public\n\t */\n\t@computed getCurrentToolId(): string {\n\t\tconst currentTool = this.getCurrentTool()\n\t\tif (!currentTool) return ''\n\t\treturn currentTool.getCurrentToolIdMask() ?? currentTool.id\n\t}\n\n\t/**\n\t * Get a descendant by its path.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getStateDescendant('select')\n\t * editor.getStateDescendant('select.brushing')\n\t * ```\n\t *\n\t * @param path - The descendant's path of state ids, separated by periods.\n\t *\n\t * @public\n\t */\n\tgetStateDescendant<T extends StateNode>(path: string): T | undefined {\n\t\tconst ids = path.split('.').reverse()\n\t\tlet state = this.root as StateNode\n\t\twhile (ids.length > 0) {\n\t\t\tconst id = ids.pop()\n\t\t\tif (!id) return state as T\n\t\t\tconst childState = state.children?.[id]\n\t\t\tif (!childState) return undefined\n\t\t\tstate = childState\n\t\t}\n\t\treturn state as T\n\t}\n\n\t/* ---------------- Document Settings --------------- */\n\n\t/**\n\t * The global document settings that apply to all users.\n\t *\n\t * @public\n\t **/\n\t@computed getDocumentSettings() {\n\t\treturn this.store.get(TLDOCUMENT_ID)!\n\t}\n\n\t/**\n\t * Update the global document settings that apply to all users.\n\t *\n\t * @public\n\t **/\n\tupdateDocumentSettings(settings: Partial<TLDocument>): this {\n\t\tthis.run(\n\t\t\t() => {\n\t\t\t\tthis.store.put([{ ...this.getDocumentSettings(), ...settings }])\n\t\t\t},\n\t\t\t{ history: 'ignore' }\n\t\t)\n\t\treturn this\n\t}\n\n\t/* ----------------- Instance State ----------------- */\n\n\t/**\n\t * The current instance's state.\n\t *\n\t * @public\n\t */\n\t@computed getInstanceState(): TLInstance {\n\t\treturn this.store.get(TLINSTANCE_ID)!\n\t}\n\n\t/**\n\t * Update the instance's state.\n\t *\n\t * @param partial - A partial object to update the instance state with.\n\t * @param historyOptions - History batch options.\n\t *\n\t * @public\n\t */\n\tupdateInstanceState(\n\t\tpartial: Partial<Omit<TLInstance, 'currentPageId'>>,\n\t\thistoryOptions?: TLHistoryBatchOptions\n\t): this {\n\t\tthis._updateInstanceState(partial, { history: 'ignore', ...historyOptions })\n\n\t\tif (partial.isChangingStyle !== undefined) {\n\t\t\tclearTimeout(this._isChangingStyleTimeout)\n\t\t\tif (partial.isChangingStyle === true) {\n\t\t\t\t// If we've set to true, set a new reset timeout to change the value back to false after 1 seconds\n\t\t\t\tthis._isChangingStyleTimeout = this.timers.setTimeout(() => {\n\t\t\t\t\tthis._updateInstanceState({ isChangingStyle: false }, { history: 'ignore' })\n\t\t\t\t}, 1000)\n\t\t\t}\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/** @internal */\n\t_updateInstanceState(\n\t\tpartial: Partial<Omit<TLInstance, 'currentPageId'>>,\n\t\topts?: TLHistoryBatchOptions\n\t) {\n\t\tthis.run(() => {\n\t\t\tthis.store.put([\n\t\t\t\t{\n\t\t\t\t\t...this.getInstanceState(),\n\t\t\t\t\t...partial,\n\t\t\t\t},\n\t\t\t])\n\t\t}, opts)\n\t}\n\n\t/** @internal */\n\tprivate _isChangingStyleTimeout = -1 as any\n\n\t// Menus\n\n\tmenus = tlmenus.forContext(this.contextId)\n\n\t/**\n\t * @deprecated Use `editor.menus.getOpenMenus` instead.\n\t *\n\t * @public\n\t */\n\t@computed getOpenMenus(): string[] {\n\t\treturn this.menus.getOpenMenus()\n\t}\n\n\t/**\n\t * @deprecated Use `editor.menus.addOpenMenu` instead.\n\t *\n\t * @public\n\t */\n\taddOpenMenu(id: string): this {\n\t\tthis.menus.addOpenMenu(id)\n\t\treturn this\n\t}\n\n\t/**\n\t * @deprecated Use `editor.menus.deleteOpenMenu` instead.\n\t *\n\t * @public\n\t */\n\tdeleteOpenMenu(id: string): this {\n\t\tthis.menus.deleteOpenMenu(id)\n\t\treturn this\n\t}\n\n\t/**\n\t * @deprecated Use `editor.menus.clearOpenMenus` instead.\n\t *\n\t * @public\n\t */\n\tclearOpenMenus(): this {\n\t\tthis.menus.clearOpenMenus()\n\t\treturn this\n\t}\n\n\t/**\n\t * @deprecated Use `editor.menus.hasAnyOpenMenus` instead.\n\t *\n\t * @public\n\t */\n\t@computed getIsMenuOpen(): boolean {\n\t\treturn this.menus.hasAnyOpenMenus()\n\t}\n\n\t/* --------------------- Cursor --------------------- */\n\n\t/**\n\t * Set the cursor.\n\t *\n\t * @param cursor - The cursor to set.\n\t * @public\n\t */\n\tsetCursor(cursor: Partial<TLCursor>) {\n\t\tthis.updateInstanceState({ cursor: { ...this.getInstanceState().cursor, ...cursor } })\n\t\treturn this\n\t}\n\n\t/* ------------------- Page State ------------------- */\n\n\t/**\n\t * Page states.\n\t *\n\t * @public\n\t */\n\t@computed getPageStates(): TLInstancePageState[] {\n\t\treturn this._getPageStatesQuery().get()\n\t}\n\n\t/** @internal */\n\t@computed private _getPageStatesQuery() {\n\t\treturn this.store.query.records('instance_page_state')\n\t}\n\n\t/**\n\t * The current page state.\n\t *\n\t * @public\n\t */\n\t@computed getCurrentPageState(): TLInstancePageState {\n\t\treturn this.store.get(this._getCurrentPageStateId())!\n\t}\n\n\t/** @internal */\n\t@computed private _getCurrentPageStateId() {\n\t\treturn InstancePageStateRecordType.createId(this.getCurrentPageId())\n\t}\n\n\t/**\n\t * Update this instance's page state.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.updateCurrentPageState({ id: 'page1', editingShapeId: 'shape:123' })\n\t * ```\n\t *\n\t * @param partial - The partial of the page state object containing the changes.\n\t *\n\t * @public\n\t */\n\tupdateCurrentPageState(\n\t\tpartial: Partial<\n\t\t\tOmit<TLInstancePageState, 'selectedShapeIds' | 'editingShapeId' | 'pageId' | 'focusedGroupId'>\n\t\t>\n\t): this {\n\t\tthis._updateCurrentPageState(partial)\n\t\treturn this\n\t}\n\t_updateCurrentPageState(partial: Partial<Omit<TLInstancePageState, 'selectedShapeIds'>>) {\n\t\tthis.store.update(partial.id ?? this.getCurrentPageState().id, (state) => ({\n\t\t\t...state,\n\t\t\t...partial,\n\t\t}))\n\t}\n\n\t/**\n\t * The current selected ids.\n\t *\n\t * @public\n\t */\n\t@computed getSelectedShapeIds() {\n\t\treturn this.getCurrentPageState().selectedShapeIds\n\t}\n\n\t/**\n\t * An array containing all of the currently selected shapes.\n\t *\n\t * @public\n\t * @readonly\n\t */\n\t@computed getSelectedShapes(): TLShape[] {\n\t\treturn compact(this.getSelectedShapeIds().map((id) => this.store.get(id)))\n\t}\n\n\t/**\n\t * Select one or more shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setSelectedShapes(['id1'])\n\t * editor.setSelectedShapes(['id1', 'id2'])\n\t * ```\n\t *\n\t * @param shapes - The shape (or shape ids) to select.\n\t *\n\t * @public\n\t */\n\tsetSelectedShapes(shapes: TLShapeId[] | TLShape[]): this {\n\t\treturn this.run(\n\t\t\t() => {\n\t\t\t\tconst ids = shapes.map((shape) => (typeof shape === 'string' ? shape : shape.id))\n\t\t\t\tconst { selectedShapeIds: prevSelectedShapeIds } = this.getCurrentPageState()\n\t\t\t\tconst prevSet = new Set(prevSelectedShapeIds)\n\n\t\t\t\tif (ids.length === prevSet.size && ids.every((id) => prevSet.has(id))) return null\n\n\t\t\t\tthis.store.put([{ ...this.getCurrentPageState(), selectedShapeIds: ids }])\n\t\t\t},\n\t\t\t{ history: 'record-preserveRedoStack' }\n\t\t)\n\t}\n\n\t/**\n\t * Determine whether or not any of a shape's ancestors are selected.\n\t *\n\t * @param shape - The shape (or shape id) of the shape to check.\n\t *\n\t * @public\n\t */\n\tisAncestorSelected(shape: TLShape | TLShapeId): boolean {\n\t\tconst id = typeof shape === 'string' ? shape : (shape?.id ?? null)\n\t\tconst _shape = this.getShape(id)\n\t\tif (!_shape) return false\n\t\tconst selectedShapeIds = this.getSelectedShapeIds()\n\t\treturn !!this.findShapeAncestor(_shape, (parent) => selectedShapeIds.includes(parent.id))\n\t}\n\n\t/**\n\t * Select one or more shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.select('id1')\n\t * editor.select('id1', 'id2')\n\t * ```\n\t *\n\t * @param shapes - The shape (or the shape ids) to select.\n\t *\n\t * @public\n\t */\n\tselect(...shapes: TLShapeId[] | TLShape[]): this {\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((shape) => shape.id)\n\t\tthis.setSelectedShapes(ids)\n\t\treturn this\n\t}\n\n\t/**\n\t * Remove a shape from the existing set of selected shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.deselect(shape.id)\n\t * ```\n\t *\n\t * @public\n\t */\n\tdeselect(...shapes: TLShapeId[] | TLShape[]): this {\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((shape) => shape.id)\n\t\tconst selectedShapeIds = this.getSelectedShapeIds()\n\t\tif (selectedShapeIds.length > 0 && ids.length > 0) {\n\t\t\tthis.setSelectedShapes(selectedShapeIds.filter((id) => !ids.includes(id)))\n\t\t}\n\t\treturn this\n\t}\n\n\t/**\n\t * Select all shapes. If the user has selected shapes that share a parent,\n\t * select all shapes within that parent. If the user has not selected any shapes,\n\t * or if the shapes shapes are only on select all shapes on the current page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.selectAll()\n\t * ```\n\t *\n\t * @public\n\t */\n\tselectAll(): this {\n\t\tlet parentToSelectWithinId: TLParentId | null = null\n\n\t\tconst selectedShapeIds = this.getSelectedShapeIds()\n\n\t\t// If we have selected shapes, try to find a parent to select within\n\t\tif (selectedShapeIds.length > 0) {\n\t\t\tfor (const id of selectedShapeIds) {\n\t\t\t\tconst shape = this.getShape(id)\n\t\t\t\tif (!shape) continue\n\t\t\t\tif (parentToSelectWithinId === null) {\n\t\t\t\t\t// If we haven't found a parent yet, set this parent as the parent to select within\n\t\t\t\t\tparentToSelectWithinId = shape.parentId\n\t\t\t\t} else if (parentToSelectWithinId !== shape.parentId) {\n\t\t\t\t\t// If we've found two different parents, we can't select all, do nothing\n\t\t\t\t\treturn this\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If we haven't found a parent from our selected shapes, select the current page\n\t\tif (!parentToSelectWithinId) {\n\t\t\tparentToSelectWithinId = this.getCurrentPageId()\n\t\t}\n\n\t\t// Select all the unlocked shapes within the parent\n\t\tconst ids = this.getSortedChildIdsForParent(parentToSelectWithinId)\n\t\tif (ids.length <= 0) return this\n\t\tthis.setSelectedShapes(this._getUnlockedShapeIds(ids))\n\t\treturn this\n\t}\n\n\t/**\n\t * Select the next shape in the reading order or in cardinal order.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.selectAdjacentShape('next')\n\t * ```\n\t *\n\t * @public\n\t */\n\tselectAdjacentShape(direction: TLAdjacentDirection) {\n\t\tconst selectedShapeIds = this.getSelectedShapeIds()\n\t\tconst firstParentId = selectedShapeIds[0] ? this.getShape(selectedShapeIds[0])?.parentId : null\n\t\tconst isSelectedWithinContainer =\n\t\t\tfirstParentId &&\n\t\t\tselectedShapeIds.every((shapeId) => this.getShape(shapeId)?.parentId === firstParentId) &&\n\t\t\t!isPageId(firstParentId)\n\t\tconst filteredShapes = isSelectedWithinContainer\n\t\t\t? this.getCurrentPageShapes().filter((shape) => shape.parentId === firstParentId)\n\t\t\t: this.getCurrentPageShapes().filter((shape) => isPageId(shape.parentId))\n\t\tconst readingOrderShapes = isSelectedWithinContainer\n\t\t\t? this._getShapesInReadingOrder(filteredShapes)\n\t\t\t: this.getCurrentPageShapesInReadingOrder()\n\t\tconst currentShapeId: TLShapeId | undefined =\n\t\t\tselectedShapeIds.length === 1\n\t\t\t\t? selectedShapeIds[0]\n\t\t\t\t: readingOrderShapes.find((shape) => selectedShapeIds.includes(shape.id))?.id\n\n\t\tlet adjacentShapeId: TLShapeId\n\t\tif (direction === 'next' || direction === 'prev') {\n\t\t\tconst shapeIds = readingOrderShapes.map((shape) => shape.id)\n\n\t\t\tconst currentIndex = currentShapeId ? shapeIds.indexOf(currentShapeId) : -1\n\t\t\tconst adjacentIndex =\n\t\t\t\t(currentIndex + (direction === 'next' ? 1 : -1) + shapeIds.length) % shapeIds.length\n\t\t\tadjacentShapeId = shapeIds[adjacentIndex]\n\t\t} else {\n\t\t\tif (!currentShapeId) return\n\t\t\tadjacentShapeId = this.getNearestAdjacentShape(filteredShapes, currentShapeId, direction)\n\t\t}\n\n\t\tconst shape = this.getShape(adjacentShapeId)\n\t\tif (!shape) return\n\n\t\tthis._selectShapesAndZoom([shape.id])\n\t}\n\n\t/**\n\t * Generates a reading order for shapes based on rows grouping.\n\t * Tries to keep a natural reading order (left-to-right, top-to-bottom).\n\t *\n\t * @public\n\t */\n\t@computed getCurrentPageShapesInReadingOrder(): TLShape[] {\n\t\tconst shapes = this.getCurrentPageShapes().filter((shape) => isPageId(shape.parentId))\n\t\treturn this._getShapesInReadingOrder(shapes)\n\t}\n\n\tprivate _getShapesInReadingOrder(shapes: TLShape[]): TLShape[] {\n\t\tconst SHALLOW_ANGLE = 20\n\t\tconst ROW_THRESHOLD = 100\n\n\t\tconst tabbableShapes = shapes.filter((shape) => this.getShapeUtil(shape).canTabTo(shape))\n\n\t\tif (tabbableShapes.length <= 1) return tabbableShapes\n\n\t\tconst shapesWithCenters = tabbableShapes.map((shape) => ({\n\t\t\tshape,\n\t\t\tcenter: this.getShapePageBounds(shape)!.center,\n\t\t}))\n\t\tshapesWithCenters.sort((a, b) => a.center.y - b.center.y)\n\n\t\tconst rows: Array<typeof shapesWithCenters> = []\n\n\t\t// First, group shapes into rows based on y-coordinates.\n\t\tfor (const shapeWithCenter of shapesWithCenters) {\n\t\t\tlet rowIndex = -1\n\t\t\tfor (let i = rows.length - 1; i >= 0; i--) {\n\t\t\t\tconst row = rows[i]\n\t\t\t\tconst lastShapeInRow = row[row.length - 1]\n\n\t\t\t\t// If the shape is close enough vertically to the last shape in this row.\n\t\t\t\tif (Math.abs(shapeWithCenter.center.y - lastShapeInRow.center.y) < ROW_THRESHOLD) {\n\t\t\t\t\trowIndex = i\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If no suitable row found, create a new row.\n\t\t\tif (rowIndex === -1) {\n\t\t\t\trows.push([shapeWithCenter])\n\t\t\t} else {\n\t\t\t\trows[rowIndex].push(shapeWithCenter)\n\t\t\t}\n\t\t}\n\n\t\t// Then, sort each row by x-coordinate (left-to-right).\n\t\tfor (const row of rows) {\n\t\t\trow.sort((a, b) => a.center.x - b.center.x)\n\t\t}\n\n\t\t// Finally, apply angle/distance weight adjustments within rows for closely positioned shapes.\n\t\tfor (const row of rows) {\n\t\t\tif (row.length <= 2) continue\n\n\t\t\tfor (let i = 0; i < row.length - 2; i++) {\n\t\t\t\tconst currentShape = row[i]\n\t\t\t\tconst nextShape = row[i + 1]\n\t\t\t\tconst nextNextShape = row[i + 2]\n\n\t\t\t\t// Only consider adjustment if the next two shapes are relatively close to each other.\n\t\t\t\tconst dist1 = Vec.Dist2(currentShape.center, nextShape.center)\n\t\t\t\tconst dist2 = Vec.Dist2(currentShape.center, nextNextShape.center)\n\n\t\t\t\t// Check if the 2nd shape is actually closer to the current shape.\n\t\t\t\tif (dist2 < dist1 * 0.9) {\n\t\t\t\t\t// Check if it's a shallow enough angle.\n\t\t\t\t\tconst angle = Math.abs(\n\t\t\t\t\t\tVec.Angle(currentShape.center, nextNextShape.center) * (180 / Math.PI)\n\t\t\t\t\t)\n\t\t\t\t\tif (angle <= SHALLOW_ANGLE) {\n\t\t\t\t\t\t// Swap swap.\n\t\t\t\t\t\t;[row[i + 1], row[i + 2]] = [row[i + 2], row[i + 1]]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn rows.flat().map((item) => item.shape)\n\t}\n\n\t/**\n\t * Find the nearest adjacent shape in a specific direction.\n\t *\n\t * @public\n\t */\n\tgetNearestAdjacentShape(\n\t\tshapes: TLShape[],\n\t\tcurrentShapeId: TLShapeId,\n\t\tdirection: 'left' | 'right' | 'up' | 'down'\n\t): TLShapeId {\n\t\tconst directionToAngle = { right: 0, left: 180, down: 90, up: 270 }\n\t\tconst currentShape = this.getShape(currentShapeId)\n\t\tif (!currentShape) return currentShapeId\n\n\t\tconst tabbableShapes = shapes.filter(\n\t\t\t(shape) => this.getShapeUtil(shape).canTabTo(shape) && shape.id !== currentShapeId\n\t\t)\n\t\tif (!tabbableShapes.length) return currentShapeId\n\n\t\tconst currentCenter = this.getShapePageBounds(currentShape)!.center\n\t\tconst shapesWithCenters = tabbableShapes.map((shape) => ({\n\t\t\tshape,\n\t\t\tcenter: this.getShapePageBounds(shape)!.center,\n\t\t}))\n\n\t\t// Filter shapes that are in the same direction.\n\t\tconst shapesInDirection = shapesWithCenters.filter(({ center }) => {\n\t\t\tconst isRight = center.x > currentCenter.x\n\t\t\tconst isDown = center.y > currentCenter.y\n\t\t\tconst xDist = center.x - currentCenter.x\n\t\t\tconst yDist = center.y - currentCenter.y\n\t\t\tconst isInXDirection = Math.abs(yDist) < Math.abs(xDist) * 2\n\t\t\tconst isInYDirection = Math.abs(xDist) < Math.abs(yDist) * 2\n\t\t\tif (direction === 'left' || direction === 'right') {\n\t\t\t\treturn isInXDirection && (direction === 'right' ? isRight : !isRight)\n\t\t\t}\n\t\t\tif (direction === 'up' || direction === 'down') {\n\t\t\t\treturn isInYDirection && (direction === 'down' ? isDown : !isDown)\n\t\t\t}\n\t\t})\n\n\t\tif (shapesInDirection.length === 0) return currentShapeId\n\n\t\t// Ok, now score that subset of shapes.\n\t\tconst lowestScoringShape = minBy(shapesInDirection, ({ center }) => {\n\t\t\t// Distance is the primary weighting factor.\n\t\t\tconst distance = Vec.Dist2(currentCenter, center)\n\n\t\t\t// Distance along the primary axis.\n\t\t\tconst dirProp = ['left', 'right'].includes(direction) ? 'x' : 'y'\n\t\t\tconst directionalDistance = Math.abs(center[dirProp] - currentCenter[dirProp])\n\n\t\t\t// Distance off the perpendicular to the primary axis.\n\t\t\tconst offProp = ['left', 'right'].includes(direction) ? 'y' : 'x'\n\t\t\tconst offAxisDeviation = Math.abs(center[offProp] - currentCenter[offProp])\n\n\t\t\t// Angle in degrees\n\t\t\tconst angle = Math.abs(Vec.Angle(currentCenter, center) * (180 / Math.PI))\n\t\t\tconst angleDeviation = Math.abs(angle - directionToAngle[direction])\n\n\t\t\t// Calculate final score (lower is better).\n\t\t\t// Weight factors to prioritize:\n\t\t\t// 1. Shapes directly in line with the current shape\n\t\t\t// 2. Shapes closer to the current shape\n\t\t\t// 3. Shapes with less angular deviation from the primary direction\n\t\t\treturn (\n\t\t\t\tdistance * 1.0 + // Base distance\n\t\t\t\toffAxisDeviation * 2.0 + // Heavy penalty for off-axis deviation\n\t\t\t\t(distance - directionalDistance) * 1.5 + // Penalty for diagonal distance\n\t\t\t\tangleDeviation * 0.5\n\t\t\t) // Slight penalty for angular deviation\n\t\t})\n\n\t\treturn lowestScoringShape!.shape.id\n\t}\n\n\tselectParentShape() {\n\t\tconst selectedShape = this.getOnlySelectedShape()\n\t\tif (!selectedShape) return\n\t\tconst parentShape = this.getShape(selectedShape.parentId)\n\t\tif (!parentShape) return\n\t\tthis._selectShapesAndZoom([parentShape.id])\n\t}\n\n\tselectFirstChildShape() {\n\t\tconst selectedShapes = this.getSelectedShapes()\n\t\tif (!selectedShapes.length) return\n\t\tconst selectedShape = selectedShapes[0]\n\t\tconst children = this.getSortedChildIdsForParent(selectedShape.id)\n\t\t\t.map((id) => this.getShape(id))\n\t\t\t.filter((i) => i) as TLShape[]\n\t\tconst sortedChildren = this._getShapesInReadingOrder(children)\n\t\tif (sortedChildren.length === 0) return\n\t\tthis._selectShapesAndZoom([sortedChildren[0].id])\n\t}\n\n\tprivate _selectShapesAndZoom(ids: TLShapeId[]) {\n\t\tthis.setSelectedShapes(ids)\n\t\tthis.zoomToSelectionIfOffscreen(256, {\n\t\t\tanimation: {\n\t\t\t\tduration: this.options.animationMediumMs,\n\t\t\t},\n\t\t\tinset: 0,\n\t\t})\n\t}\n\n\t/**\n\t * Clear the selection.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.selectNone()\n\t * ```\n\t *\n\t * @public\n\t */\n\tselectNone(): this {\n\t\tif (this.getSelectedShapeIds().length > 0) {\n\t\t\tthis.setSelectedShapes([])\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * The id of the app's only selected shape.\n\t *\n\t * @returns Null if there is no shape or more than one selected shape, otherwise the selected shape's id.\n\t *\n\t * @public\n\t * @readonly\n\t */\n\t@computed getOnlySelectedShapeId(): TLShapeId | null {\n\t\treturn this.getOnlySelectedShape()?.id ?? null\n\t}\n\n\t/**\n\t * The app's only selected shape.\n\t *\n\t * @returns Null if there is no shape or more than one selected shape, otherwise the selected shape.\n\t *\n\t * @public\n\t * @readonly\n\t */\n\t@computed getOnlySelectedShape(): TLShape | null {\n\t\tconst selectedShapes = this.getSelectedShapes()\n\t\treturn selectedShapes.length === 1 ? selectedShapes[0] : null\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tgetShapesPageBounds(shapeIds: TLShapeId[]): Box | null {\n\t\tconst bounds = compact(shapeIds.map((id) => this.getShapePageBounds(id)))\n\t\tif (bounds.length === 0) return null\n\t\treturn Box.Common(bounds)\n\t}\n\n\t/**\n\t * The current page bounds of all the selected shapes. If the\n\t * selection is rotated, then these bounds are the axis-aligned\n\t * box that the rotated bounds would fit inside of.\n\t *\n\t * @readonly\n\t *\n\t * @public\n\t */\n\t@computed getSelectionPageBounds(): Box | null {\n\t\treturn this.getShapesPageBounds(this.getSelectedShapeIds())\n\t}\n\n\t/**\n\t * The bounds of the selection bounding box in the current page space.\n\t *\n\t * @readonly\n\t * @public\n\t */\n\tgetSelectionScreenBounds(): Box | undefined {\n\t\tconst bounds = this.getSelectionPageBounds()\n\t\tif (!bounds) return undefined\n\t\tconst { x, y } = this.pageToScreen(bounds.point)\n\t\tconst zoom = this.getZoomLevel()\n\t\treturn new Box(x, y, bounds.width * zoom, bounds.height * zoom)\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tgetShapesSharedRotation(shapeIds: TLShapeId[]) {\n\t\tlet foundFirst = false // annoying but we can't use an i===0 check because we need to skip over undefineds\n\t\tlet rotation = 0\n\t\tfor (let i = 0, n = shapeIds.length; i < n; i++) {\n\t\t\tconst pageTransform = this.getShapePageTransform(shapeIds[i])\n\t\t\tif (!pageTransform) continue\n\t\t\tif (foundFirst) {\n\t\t\t\tif (pageTransform.rotation() !== rotation) {\n\t\t\t\t\t// There are at least 2 different rotations, so the common rotation is zero\n\t\t\t\t\treturn 0\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// First rotation found\n\t\t\t\tfoundFirst = true\n\t\t\t\trotation = pageTransform.rotation()\n\t\t\t}\n\t\t}\n\n\t\treturn rotation\n\t}\n\n\t/**\n\t * The rotation of the selection bounding box in the current page space.\n\t *\n\t * @readonly\n\t * @public\n\t */\n\t@computed getSelectionRotation(): number {\n\t\treturn this.getShapesSharedRotation(this.getSelectedShapeIds())\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tgetShapesRotatedPageBounds(shapeIds: TLShapeId[]): Box | undefined {\n\t\tif (shapeIds.length === 0) {\n\t\t\treturn undefined\n\t\t}\n\n\t\tconst selectionRotation = this.getShapesSharedRotation(shapeIds)\n\t\tif (selectionRotation === 0) {\n\t\t\treturn this.getShapesPageBounds(shapeIds) ?? undefined\n\t\t}\n\n\t\tif (shapeIds.length === 1) {\n\t\t\tconst bounds = this.getShapeGeometry(shapeIds[0]).bounds.clone()\n\t\t\tconst pageTransform = this.getShapePageTransform(shapeIds[0])!\n\t\t\tbounds.point = pageTransform.applyToPoint(bounds.point)\n\t\t\treturn bounds\n\t\t}\n\n\t\t// need to 'un-rotate' all the outlines of the existing nodes so we can fit them inside a box\n\t\tconst boxFromRotatedVertices = Box.FromPoints(\n\t\t\tshapeIds\n\t\t\t\t.flatMap((id) => {\n\t\t\t\t\tconst pageTransform = this.getShapePageTransform(id)\n\t\t\t\t\tif (!pageTransform) return []\n\t\t\t\t\treturn pageTransform.applyToPoints(this.getShapeGeometry(id).bounds.corners)\n\t\t\t\t})\n\t\t\t\t.map((p) => p.rot(-selectionRotation))\n\t\t)\n\t\t// now position box so that it's top-left corner is in the right place\n\t\tboxFromRotatedVertices.point = boxFromRotatedVertices.point.rot(selectionRotation)\n\t\treturn boxFromRotatedVertices\n\t}\n\n\t/**\n\t * The bounds of the selection bounding box in the current page space.\n\t *\n\t * @readonly\n\t * @public\n\t */\n\t@computed getSelectionRotatedPageBounds(): Box | undefined {\n\t\treturn this.getShapesRotatedPageBounds(this.getSelectedShapeIds())\n\t}\n\n\t/**\n\t * The bounds of the selection bounding box in the current page space.\n\t *\n\t * @readonly\n\t * @public\n\t */\n\t@computed getSelectionRotatedScreenBounds(): Box | undefined {\n\t\tconst bounds = this.getSelectionRotatedPageBounds()\n\t\tif (!bounds) return undefined\n\t\tconst { x, y } = this.pageToScreen(bounds.point)\n\t\tconst zoom = this.getZoomLevel()\n\t\treturn new Box(x, y, bounds.width * zoom, bounds.height * zoom)\n\t}\n\n\t// Focus Group\n\n\t/**\n\t * The current focused group id.\n\t *\n\t * @public\n\t */\n\t@computed getFocusedGroupId(): TLShapeId | TLPageId {\n\t\treturn this.getCurrentPageState().focusedGroupId ?? this.getCurrentPageId()\n\t}\n\n\t/**\n\t * The current focused group.\n\t *\n\t * @public\n\t */\n\t@computed getFocusedGroup(): TLShape | undefined {\n\t\tconst focusedGroupId = this.getFocusedGroupId()\n\t\treturn focusedGroupId ? this.getShape(focusedGroupId) : undefined\n\t}\n\n\t/**\n\t * Set the current focused group shape.\n\t *\n\t * @param shape - The group shape id (or group shape's id) to set as the focused group shape.\n\t *\n\t * @public\n\t */\n\tsetFocusedGroup(shape: TLShapeId | TLGroupShape | null): this {\n\t\tconst id = typeof shape === 'string' ? shape : (shape?.id ?? null)\n\n\t\tif (id !== null) {\n\t\t\tconst shape = this.getShape(id)\n\t\t\tif (!shape) {\n\t\t\t\tthrow Error(`Editor.setFocusedGroup: Shape with id ${id} does not exist`)\n\t\t\t}\n\n\t\t\tif (!this.isShapeOfType<TLGroupShape>(shape, 'group')) {\n\t\t\t\tthrow Error(\n\t\t\t\t\t`Editor.setFocusedGroup: Cannot set focused group to shape of type ${shape.type}`\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\n\t\tif (id === this.getFocusedGroupId()) return this\n\n\t\treturn this.run(\n\t\t\t() => {\n\t\t\t\tthis.store.update(this.getCurrentPageState().id, (s) => ({ ...s, focusedGroupId: id }))\n\t\t\t},\n\t\t\t{ history: 'record-preserveRedoStack' }\n\t\t)\n\t}\n\n\t/**\n\t * Exit the current focused group, moving up to the next parent group if there is one.\n\t *\n\t * @public\n\t */\n\tpopFocusedGroupId(): this {\n\t\tconst focusedGroup = this.getFocusedGroup()\n\n\t\tif (focusedGroup) {\n\t\t\t// If we have a focused layer, look for an ancestor of the focused shape that is a group\n\t\t\tconst match = this.findShapeAncestor(focusedGroup, (shape) =>\n\t\t\t\tthis.isShapeOfType<TLGroupShape>(shape, 'group')\n\t\t\t)\n\t\t\t// If we have an ancestor that can become a focused layer, set it as the focused layer\n\t\t\tthis.setFocusedGroup(match?.id ?? null)\n\t\t\tthis.select(focusedGroup.id)\n\t\t} else {\n\t\t\t// If there's no parent focused group, then clear the focus layer and clear selection\n\t\t\tthis.setFocusedGroup(null)\n\t\t\tthis.selectNone()\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * The current editing shape's id.\n\t *\n\t * @public\n\t */\n\t@computed getEditingShapeId(): TLShapeId | null {\n\t\treturn this.getCurrentPageState().editingShapeId\n\t}\n\n\t/**\n\t * The current editing shape.\n\t *\n\t * @public\n\t */\n\t@computed getEditingShape(): TLShape | undefined {\n\t\tconst editingShapeId = this.getEditingShapeId()\n\t\treturn editingShapeId ? this.getShape(editingShapeId) : undefined\n\t}\n\n\t/**\n\t * Set the current editing shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setEditingShape(myShape)\n\t * editor.setEditingShape(myShape.id)\n\t * ```\n\t *\n\t * @param shape - The shape (or shape id) to set as editing.\n\t *\n\t * @public\n\t */\n\tsetEditingShape(shape: TLShapeId | TLShape | null): this {\n\t\tconst id = typeof shape === 'string' ? shape : (shape?.id ?? null)\n\t\tthis.setRichTextEditor(null)\n\t\tconst prevEditingShapeId = this.getEditingShapeId()\n\t\tif (id !== prevEditingShapeId) {\n\t\t\tif (id) {\n\t\t\t\tconst shape = this.getShape(id)\n\t\t\t\tif (shape && this.getShapeUtil(shape).canEdit(shape)) {\n\t\t\t\t\tthis.run(\n\t\t\t\t\t\t() => {\n\t\t\t\t\t\t\tthis._updateCurrentPageState({ editingShapeId: id })\n\t\t\t\t\t\t\tif (prevEditingShapeId) {\n\t\t\t\t\t\t\t\tconst prevEditingShape = this.getShape(prevEditingShapeId)\n\t\t\t\t\t\t\t\tif (prevEditingShape) {\n\t\t\t\t\t\t\t\t\tthis.getShapeUtil(prevEditingShape).onEditEnd?.(prevEditingShape)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.getShapeUtil(shape).onEditStart?.(shape)\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{ history: 'ignore' }\n\t\t\t\t\t)\n\t\t\t\t\treturn this\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Either we just set the editing id to null, or the shape was missing or not editable\n\t\t\tthis.run(\n\t\t\t\t() => {\n\t\t\t\t\tthis._updateCurrentPageState({ editingShapeId: null })\n\t\t\t\t\tthis._currentRichTextEditor.set(null)\n\t\t\t\t\tif (prevEditingShapeId) {\n\t\t\t\t\t\tconst prevEditingShape = this.getShape(prevEditingShapeId)\n\t\t\t\t\t\tif (prevEditingShape) {\n\t\t\t\t\t\t\tthis.getShapeUtil(prevEditingShape).onEditEnd?.(prevEditingShape)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{ history: 'ignore' }\n\t\t\t)\n\t\t}\n\t\treturn this\n\t}\n\n\t// Rich text editor\n\n\tprivate _currentRichTextEditor = atom('rich text editor', null as TiptapEditor | null)\n\n\t/**\n\t * The current editing shape's text editor.\n\t *\n\t * @public\n\t */\n\t@computed getRichTextEditor(): TiptapEditor | null {\n\t\treturn this._currentRichTextEditor.get()\n\t}\n\n\t/**\n\t * Set the current editing shape's rich text editor.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setRichTextEditor(richTextEditorView)\n\t * ```\n\t *\n\t * @param textEditor - The text editor to set as the current editing shape's text editor.\n\t *\n\t * @public\n\t */\n\tsetRichTextEditor(textEditor: TiptapEditor | null) {\n\t\tthis._currentRichTextEditor.set(textEditor)\n\t\treturn this\n\t}\n\n\t// Hovered\n\n\t/**\n\t * The current hovered shape id.\n\t *\n\t * @readonly\n\t * @public\n\t */\n\t@computed getHoveredShapeId(): TLShapeId | null {\n\t\treturn this.getCurrentPageState().hoveredShapeId\n\t}\n\n\t/**\n\t * The current hovered shape.\n\t *\n\t * @public\n\t */\n\t@computed getHoveredShape(): TLShape | undefined {\n\t\tconst hoveredShapeId = this.getHoveredShapeId()\n\t\treturn hoveredShapeId ? this.getShape(hoveredShapeId) : undefined\n\t}\n\t/**\n\t * Set the editor's current hovered shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setHoveredShape(myShape)\n\t * editor.setHoveredShape(myShape.id)\n\t * ```\n\t *\n\t * @param shape - The shape (or shape id) to set as hovered.\n\t *\n\t * @public\n\t */\n\tsetHoveredShape(shape: TLShapeId | TLShape | null): this {\n\t\tconst id = typeof shape === 'string' ? shape : (shape?.id ?? null)\n\t\tif (id === this.getHoveredShapeId()) return this\n\t\tthis.run(\n\t\t\t() => {\n\t\t\t\tthis.updateCurrentPageState({ hoveredShapeId: id })\n\t\t\t},\n\t\t\t{ history: 'ignore' }\n\t\t)\n\t\treturn this\n\t}\n\n\t// Hinting\n\n\t/**\n\t * The editor's current hinting shape ids.\n\t *\n\t * @public\n\t */\n\t@computed getHintingShapeIds() {\n\t\treturn this.getCurrentPageState().hintingShapeIds\n\t}\n\n\t/**\n\t * The editor's current hinting shapes.\n\t *\n\t * @public\n\t */\n\t@computed getHintingShape() {\n\t\tconst hintingShapeIds = this.getHintingShapeIds()\n\t\treturn compact(hintingShapeIds.map((id) => this.getShape(id)))\n\t}\n\n\t/**\n\t * Set the editor's current hinting shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setHintingShapes([myShape])\n\t * editor.setHintingShapes([myShape.id])\n\t * ```\n\t *\n\t * @param shapes - The shapes (or shape ids) to set as hinting.\n\t *\n\t * @public\n\t */\n\tsetHintingShapes(shapes: TLShapeId[] | TLShape[]): this {\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((shape) => shape.id)\n\t\t// always ephemeral\n\t\tthis.run(\n\t\t\t() => {\n\t\t\t\tthis._updateCurrentPageState({ hintingShapeIds: dedupe(ids) })\n\t\t\t},\n\t\t\t{ history: 'ignore' }\n\t\t)\n\t\treturn this\n\t}\n\n\t// Erasing\n\n\t/**\n\t * The editor's current erasing ids.\n\t *\n\t * @public\n\t */\n\t@computed getErasingShapeIds() {\n\t\treturn this.getCurrentPageState().erasingShapeIds\n\t}\n\n\t/**\n\t * The editor's current erasing shapes.\n\t *\n\t * @public\n\t */\n\t@computed getErasingShapes() {\n\t\tconst erasingShapeIds = this.getErasingShapeIds()\n\t\treturn compact(erasingShapeIds.map((id) => this.getShape(id)))\n\t}\n\n\t/**\n\t * Set the editor's current erasing shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setErasingShapes([myShape])\n\t * editor.setErasingShapes([myShape.id])\n\t * ```\n\t *\n\t * @param shapes - The shapes (or shape ids) to set as hinting.\n\t *\n\t * @public\n\t */\n\tsetErasingShapes(shapes: TLShapeId[] | TLShape[]): this {\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((shape) => shape.id)\n\t\tids.sort() // sort the incoming ids\n\t\tconst erasingShapeIds = this.getErasingShapeIds()\n\t\tthis.run(\n\t\t\t() => {\n\t\t\t\tif (ids.length === erasingShapeIds.length) {\n\t\t\t\t\t// if the new ids are the same length as the current ids, they might be the same.\n\t\t\t\t\t// presuming the current ids are also sorted, check each item to see if it's the same;\n\t\t\t\t\t// if we find any unequal, then we know the new ids are different.\n\t\t\t\t\tfor (let i = 0; i < ids.length; i++) {\n\t\t\t\t\t\tif (ids[i] !== erasingShapeIds[i]) {\n\t\t\t\t\t\t\tthis._updateCurrentPageState({ erasingShapeIds: ids })\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// if the ids are a different length, then we know they're different.\n\t\t\t\t\tthis._updateCurrentPageState({ erasingShapeIds: ids })\n\t\t\t\t}\n\t\t\t},\n\t\t\t{ history: 'ignore' }\n\t\t)\n\n\t\treturn this\n\t}\n\n\t// Cropping\n\n\t/**\n\t * The current cropping shape's id.\n\t *\n\t * @public\n\t */\n\tgetCroppingShapeId() {\n\t\treturn this.getCurrentPageState().croppingShapeId\n\t}\n\n\t/**\n\t * Set the current cropping shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setCroppingShape(myShape)\n\t * editor.setCroppingShape(myShape.id)\n\t * ```\n\t *\n\t *\n\t * @param shape - The shape (or shape id) to set as cropping.\n\t *\n\t * @public\n\t */\n\tsetCroppingShape(shape: TLShapeId | TLShape | null): this {\n\t\tconst id = typeof shape === 'string' ? shape : (shape?.id ?? null)\n\t\tif (id !== this.getCroppingShapeId()) {\n\t\t\tthis.run(\n\t\t\t\t() => {\n\t\t\t\t\tif (!id) {\n\t\t\t\t\t\tthis.updateCurrentPageState({ croppingShapeId: null })\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst shape = this.getShape(id)!\n\t\t\t\t\t\tconst util = this.getShapeUtil(shape)\n\t\t\t\t\t\tif (shape && util.canCrop(shape)) {\n\t\t\t\t\t\t\tthis.updateCurrentPageState({ croppingShapeId: id })\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{ history: 'ignore' }\n\t\t\t)\n\t\t}\n\t\treturn this\n\t}\n\n\tprivate _textOptions: Atom<TLTextOptions | null>\n\n\t/**\n\t * Get the current text options.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getTextOptions()\n\t * ```\n\t *\n\t *  @public */\n\tgetTextOptions() {\n\t\treturn assertExists(this._textOptions.get(), 'Cannot use text without setting textOptions')\n\t}\n\n\t/* --------------------- Camera --------------------- */\n\n\t/** @internal */\n\t@computed\n\tprivate _unsafe_getCameraId() {\n\t\treturn CameraRecordType.createId(this.getCurrentPageId())\n\t}\n\n\t/**\n\t * The current camera.\n\t *\n\t * @public\n\t */\n\t@computed getCamera(): TLCamera {\n\t\tconst baseCamera = this.store.get(this._unsafe_getCameraId())!\n\t\tif (this._isLockedOnFollowingUser.get()) {\n\t\t\tconst followingCamera = this.getCameraForFollowing()\n\t\t\tif (followingCamera) {\n\t\t\t\treturn { ...baseCamera, ...followingCamera }\n\t\t\t}\n\t\t}\n\t\treturn baseCamera\n\t}\n\n\tprivate _getFollowingPresence(targetUserId: string | null) {\n\t\tconst visited = [this.user.getId()]\n\t\tconst collaborators = this.getCollaborators()\n\t\tlet leaderPresence = null as null | TLInstancePresence\n\t\twhile (targetUserId && !visited.includes(targetUserId)) {\n\t\t\tleaderPresence = collaborators.find((c) => c.userId === targetUserId) ?? null\n\t\t\ttargetUserId = leaderPresence?.followingUserId ?? null\n\t\t\tif (leaderPresence) {\n\t\t\t\tvisited.push(leaderPresence.userId)\n\t\t\t}\n\t\t}\n\t\treturn leaderPresence\n\t}\n\n\t@computed\n\tprivate getViewportPageBoundsForFollowing(): null | Box {\n\t\tconst leaderPresence = this._getFollowingPresence(this.getInstanceState().followingUserId)\n\n\t\tif (!leaderPresence?.camera || !leaderPresence?.screenBounds) return null\n\n\t\t// Fit their viewport inside of our screen bounds\n\t\t// 1. calculate their viewport in page space\n\t\tconst { w: lw, h: lh } = leaderPresence.screenBounds\n\t\tconst { x: lx, y: ly, z: lz } = leaderPresence.camera\n\t\tconst theirViewport = new Box(-lx, -ly, lw / lz, lh / lz)\n\n\t\t// resize our screenBounds to contain their viewport\n\t\tconst ourViewport = this.getViewportScreenBounds().clone()\n\t\tconst ourAspectRatio = ourViewport.width / ourViewport.height\n\n\t\tourViewport.width = theirViewport.width\n\t\tourViewport.height = ourViewport.width / ourAspectRatio\n\t\tif (ourViewport.height < theirViewport.height) {\n\t\t\tourViewport.height = theirViewport.height\n\t\t\tourViewport.width = ourViewport.height * ourAspectRatio\n\t\t}\n\n\t\tourViewport.center = theirViewport.center\n\t\treturn ourViewport\n\t}\n\n\t@computed\n\tprivate getCameraForFollowing(): null | { x: number; y: number; z: number } {\n\t\tconst viewport = this.getViewportPageBoundsForFollowing()\n\t\tif (!viewport) return null\n\n\t\treturn {\n\t\t\tx: -viewport.x,\n\t\t\ty: -viewport.y,\n\t\t\tz: this.getViewportScreenBounds().w / viewport.width,\n\t\t}\n\t}\n\n\t/**\n\t * The current camera zoom level.\n\t *\n\t * @public\n\t */\n\t@computed getZoomLevel() {\n\t\treturn this.getCamera().z\n\t}\n\n\t/**\n\t * Get the camera's initial or reset zoom level.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getInitialZoom()\n\t * ```\n\t *\n\t * @public */\n\tgetInitialZoom() {\n\t\tconst cameraOptions = this.getCameraOptions()\n\t\t// If no camera constraints are provided, the default zoom is 100%\n\t\tif (!cameraOptions.constraints) return 1\n\n\t\t// When defaultZoom is default, the default zoom is 100%\n\t\tif (cameraOptions.constraints.initialZoom === 'default') return 1\n\n\t\tconst { zx, zy } = getCameraFitXFitY(this, cameraOptions)\n\n\t\tswitch (cameraOptions.constraints.initialZoom) {\n\t\t\tcase 'fit-min': {\n\t\t\t\treturn Math.max(zx, zy)\n\t\t\t}\n\t\t\tcase 'fit-max': {\n\t\t\t\treturn Math.min(zx, zy)\n\t\t\t}\n\t\t\tcase 'fit-x': {\n\t\t\t\treturn zx\n\t\t\t}\n\t\t\tcase 'fit-y': {\n\t\t\t\treturn zy\n\t\t\t}\n\t\t\tcase 'fit-min-100': {\n\t\t\t\treturn Math.min(1, Math.max(zx, zy))\n\t\t\t}\n\t\t\tcase 'fit-max-100': {\n\t\t\t\treturn Math.min(1, Math.min(zx, zy))\n\t\t\t}\n\t\t\tcase 'fit-x-100': {\n\t\t\t\treturn Math.min(1, zx)\n\t\t\t}\n\t\t\tcase 'fit-y-100': {\n\t\t\t\treturn Math.min(1, zy)\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow exhaustiveSwitchError(cameraOptions.constraints.initialZoom)\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the camera's base level for calculating actual zoom levels based on the zoom steps.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getBaseZoom()\n\t * ```\n\t *\n\t * @public */\n\tgetBaseZoom() {\n\t\tconst cameraOptions = this.getCameraOptions()\n\t\t// If no camera constraints are provided, the default zoom is 100%\n\t\tif (!cameraOptions.constraints) return 1\n\n\t\t// When defaultZoom is default, the default zoom is 100%\n\t\tif (cameraOptions.constraints.baseZoom === 'default') return 1\n\n\t\tconst { zx, zy } = getCameraFitXFitY(this, cameraOptions)\n\n\t\tswitch (cameraOptions.constraints.baseZoom) {\n\t\t\tcase 'fit-min': {\n\t\t\t\treturn Math.max(zx, zy)\n\t\t\t}\n\t\t\tcase 'fit-max': {\n\t\t\t\treturn Math.min(zx, zy)\n\t\t\t}\n\t\t\tcase 'fit-x': {\n\t\t\t\treturn zx\n\t\t\t}\n\t\t\tcase 'fit-y': {\n\t\t\t\treturn zy\n\t\t\t}\n\t\t\tcase 'fit-min-100': {\n\t\t\t\treturn Math.min(1, Math.max(zx, zy))\n\t\t\t}\n\t\t\tcase 'fit-max-100': {\n\t\t\t\treturn Math.min(1, Math.min(zx, zy))\n\t\t\t}\n\t\t\tcase 'fit-x-100': {\n\t\t\t\treturn Math.min(1, zx)\n\t\t\t}\n\t\t\tcase 'fit-y-100': {\n\t\t\t\treturn Math.min(1, zy)\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow exhaustiveSwitchError(cameraOptions.constraints.baseZoom)\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _cameraOptions = atom('camera options', DEFAULT_CAMERA_OPTIONS)\n\n\t/**\n\t * Get the current camera options.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getCameraOptions()\n\t * ```\n\t *\n\t *  @public */\n\tgetCameraOptions() {\n\t\treturn this._cameraOptions.get()\n\t}\n\n\t/**\n\t * Set the camera options. Changing the options won't immediately change the camera itself, so you may want to call `setCamera` after changing the options.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setCameraOptions(myCameraOptions)\n\t * editor.setCamera(editor.getCamera())\n\t * ```\n\t *\n\t * @param opts - The camera options to set.\n\t *\n\t * @public */\n\tsetCameraOptions(opts: Partial<TLCameraOptions>) {\n\t\tconst next = structuredClone({\n\t\t\t...this._cameraOptions.__unsafe__getWithoutCapture(),\n\t\t\t...opts,\n\t\t})\n\t\tif (next.zoomSteps?.length < 1) next.zoomSteps = [1]\n\t\tthis._cameraOptions.set(next)\n\t\tthis.setCamera(this.getCamera())\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate getConstrainedCamera(\n\t\tpoint: VecLike,\n\t\topts?: TLCameraMoveOptions\n\t): {\n\t\tx: number\n\t\ty: number\n\t\tz: number\n\t} {\n\t\tconst currentCamera = this.getCamera()\n\n\t\tlet { x, y, z = currentCamera.z } = point\n\n\t\t// If force is true, then we'll set the camera to the point regardless of\n\t\t// the camera options, so that we can handle gestures that permit elasticity\n\t\t// or decay, or animations that occur while the camera is locked.\n\t\tif (!opts?.force) {\n\t\t\t// Apply any adjustments based on the camera options\n\n\t\t\tconst cameraOptions = this.getCameraOptions()\n\n\t\t\tconst zoomMin = cameraOptions.zoomSteps[0]\n\t\t\tconst zoomMax = last(cameraOptions.zoomSteps)!\n\n\t\t\tconst vsb = this.getViewportScreenBounds()\n\n\t\t\t// If bounds are provided, then we'll keep those bounds on screen\n\t\t\tif (cameraOptions.constraints) {\n\t\t\t\tconst { constraints } = cameraOptions\n\n\t\t\t\t// Clamp padding to half the viewport size on either dimension\n\t\t\t\tconst py = Math.min(constraints.padding.y, vsb.w / 2)\n\t\t\t\tconst px = Math.min(constraints.padding.x, vsb.h / 2)\n\n\t\t\t\t// Expand the bounds by the padding\n\t\t\t\tconst bounds = Box.From(cameraOptions.constraints.bounds)\n\n\t\t\t\t// For each axis, the \"natural zoom\" is the zoom at\n\t\t\t\t// which the expanded bounds (with padding) would fit\n\t\t\t\t// the current viewport screen bounds. Paddings are\n\t\t\t\t// equal to screen pixels at 100%\n\t\t\t\t// The min and max zooms are factors of the smaller natural zoom axis\n\n\t\t\t\tconst zx = (vsb.w - px * 2) / bounds.w\n\t\t\t\tconst zy = (vsb.h - py * 2) / bounds.h\n\n\t\t\t\tconst baseZoom = this.getBaseZoom()\n\t\t\t\tconst maxZ = zoomMax * baseZoom\n\t\t\t\tconst minZ = zoomMin * baseZoom\n\n\t\t\t\tif (opts?.reset) {\n\t\t\t\t\tz = this.getInitialZoom()\n\t\t\t\t}\n\n\t\t\t\tif (z < minZ || z > maxZ) {\n\t\t\t\t\t// We're trying to zoom out past the minimum zoom level,\n\t\t\t\t\t// or in past the maximum zoom level, so stop the camera\n\t\t\t\t\t// but keep the current center\n\t\t\t\t\tconst { x: cx, y: cy, z: cz } = currentCamera\n\t\t\t\t\tconst cxA = -cx + vsb.w / cz / 2\n\t\t\t\t\tconst cyA = -cy + vsb.h / cz / 2\n\t\t\t\t\tz = clamp(z, minZ, maxZ)\n\t\t\t\t\tconst cxB = -cx + vsb.w / z / 2\n\t\t\t\t\tconst cyB = -cy + vsb.h / z / 2\n\t\t\t\t\tx = cx + cxB - cxA\n\t\t\t\t\ty = cy + cyB - cyA\n\t\t\t\t}\n\n\t\t\t\t// Calculate available space\n\t\t\t\tconst minX = px / z - bounds.x\n\t\t\t\tconst minY = py / z - bounds.y\n\t\t\t\tconst freeW = (vsb.w - px * 2) / z - bounds.w\n\t\t\t\tconst freeH = (vsb.h - py * 2) / z - bounds.h\n\t\t\t\tconst originX = minX + freeW * constraints.origin.x\n\t\t\t\tconst originY = minY + freeH * constraints.origin.y\n\n\t\t\t\tconst behaviorX =\n\t\t\t\t\ttypeof constraints.behavior === 'string' ? constraints.behavior : constraints.behavior.x\n\t\t\t\tconst behaviorY =\n\t\t\t\t\ttypeof constraints.behavior === 'string' ? constraints.behavior : constraints.behavior.y\n\n\t\t\t\t// x axis\n\n\t\t\t\tif (opts?.reset) {\n\t\t\t\t\t// Reset the camera according to the origin\n\t\t\t\t\tx = originX\n\t\t\t\t\ty = originY\n\t\t\t\t} else {\n\t\t\t\t\t// Apply constraints to the camera\n\t\t\t\t\tswitch (behaviorX) {\n\t\t\t\t\t\tcase 'fixed': {\n\t\t\t\t\t\t\t// Center according to the origin\n\t\t\t\t\t\t\tx = originX\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'contain': {\n\t\t\t\t\t\t\t// When below fit zoom, center the camera\n\t\t\t\t\t\t\tif (z < zx) x = originX\n\t\t\t\t\t\t\t// When above fit zoom, keep the bounds within padding distance of the viewport edge\n\t\t\t\t\t\t\telse x = clamp(x, minX + freeW, minX)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'inside': {\n\t\t\t\t\t\t\t// When below fit zoom, constrain the camera so that the bounds stay completely within the viewport\n\t\t\t\t\t\t\tif (z < zx) x = clamp(x, minX, (vsb.w - px) / z - bounds.w)\n\t\t\t\t\t\t\t// When above fit zoom, keep the bounds within padding distance of the viewport edge\n\t\t\t\t\t\t\telse x = clamp(x, minX + freeW, minX)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'outside': {\n\t\t\t\t\t\t\t// Constrain the camera so that the bounds never leaves the viewport\n\t\t\t\t\t\t\tx = clamp(x, px / z - bounds.w, (vsb.w - px) / z)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'free': {\n\t\t\t\t\t\t\t// noop, use whatever x is provided\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\tthrow exhaustiveSwitchError(behaviorX)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// y axis\n\n\t\t\t\t\tswitch (behaviorY) {\n\t\t\t\t\t\tcase 'fixed': {\n\t\t\t\t\t\t\ty = originY\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'contain': {\n\t\t\t\t\t\t\tif (z < zy) y = originY\n\t\t\t\t\t\t\telse y = clamp(y, minY + freeH, minY)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'inside': {\n\t\t\t\t\t\t\tif (z < zy) y = clamp(y, minY, (vsb.h - py) / z - bounds.h)\n\t\t\t\t\t\t\telse y = clamp(y, minY + freeH, minY)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'outside': {\n\t\t\t\t\t\t\ty = clamp(y, py / z - bounds.h, (vsb.h - py) / z)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'free': {\n\t\t\t\t\t\t\t// noop, use whatever x is provided\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\tthrow exhaustiveSwitchError(behaviorY)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// constrain the zoom, preserving the center\n\t\t\t\tif (z > zoomMax || z < zoomMin) {\n\t\t\t\t\tconst { x: cx, y: cy, z: cz } = currentCamera\n\t\t\t\t\tz = clamp(z, zoomMin, zoomMax)\n\t\t\t\t\tx = cx + (-cx + vsb.w / z / 2) - (-cx + vsb.w / cz / 2)\n\t\t\t\t\ty = cy + (-cy + vsb.h / z / 2) - (-cy + vsb.h / cz / 2)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn { x, y, z }\n\t}\n\n\t/** @internal */\n\tprivate _setCamera(point: VecLike, opts?: TLCameraMoveOptions): this {\n\t\tconst currentCamera = this.getCamera()\n\n\t\tconst { x, y, z } = this.getConstrainedCamera(point, opts)\n\n\t\tif (currentCamera.x === x && currentCamera.y === y && currentCamera.z === z) {\n\t\t\treturn this\n\t\t}\n\n\t\ttransact(() => {\n\t\t\tconst camera = { ...currentCamera, x, y, z }\n\t\t\tthis.run(\n\t\t\t\t() => {\n\t\t\t\t\tthis.store.put([camera]) // include id and meta here\n\t\t\t\t},\n\t\t\t\t{ history: 'ignore' }\n\t\t\t)\n\n\t\t\t// Dispatch a new pointer move because the pointer's page will have changed\n\t\t\t// (its screen position will compute to a new page position given the new camera position)\n\t\t\tconst { currentScreenPoint, currentPagePoint } = this.inputs\n\t\t\tconst { screenBounds } = this.store.unsafeGetWithoutCapture(TLINSTANCE_ID)!\n\n\t\t\t// compare the next page point (derived from the current camera) to the current page point\n\t\t\tif (\n\t\t\t\tcurrentScreenPoint.x / z - x !== currentPagePoint.x ||\n\t\t\t\tcurrentScreenPoint.y / z - y !== currentPagePoint.y\n\t\t\t) {\n\t\t\t\t// If it's changed, dispatch a pointer event\n\t\t\t\tconst event: TLPointerEventInfo = {\n\t\t\t\t\ttype: 'pointer',\n\t\t\t\t\ttarget: 'canvas',\n\t\t\t\t\tname: 'pointer_move',\n\t\t\t\t\t// weird but true: we need to put the screen point back into client space\n\t\t\t\t\tpoint: Vec.AddXY(currentScreenPoint, screenBounds.x, screenBounds.y),\n\t\t\t\t\tpointerId: INTERNAL_POINTER_IDS.CAMERA_MOVE,\n\t\t\t\t\tctrlKey: this.inputs.ctrlKey,\n\t\t\t\t\taltKey: this.inputs.altKey,\n\t\t\t\t\tshiftKey: this.inputs.shiftKey,\n\t\t\t\t\tmetaKey: this.inputs.metaKey,\n\t\t\t\t\taccelKey: isAccelKey(this.inputs),\n\t\t\t\t\tbutton: 0,\n\t\t\t\t\tisPen: this.getInstanceState().isPenMode ?? false,\n\t\t\t\t}\n\n\t\t\t\tif (opts?.immediate) {\n\t\t\t\t\tthis._flushEventForTick(event)\n\t\t\t\t} else {\n\t\t\t\t\tthis.dispatch(event)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._tickCameraState()\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Set the current camera.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setCamera({ x: 0, y: 0})\n\t * editor.setCamera({ x: 0, y: 0, z: 1.5})\n\t * editor.setCamera({ x: 0, y: 0, z: 1.5}, { animation: { duration: 1000, easing: (t) => t * t } })\n\t * ```\n\t *\n\t * @param point - The new camera position.\n\t * @param opts - The camera move options.\n\t *\n\t * @public\n\t */\n\tsetCamera(point: VecLike, opts?: TLCameraMoveOptions): this {\n\t\tconst { isLocked } = this._cameraOptions.__unsafe__getWithoutCapture()\n\t\tif (isLocked && !opts?.force) return this\n\n\t\t// Stop any camera animations\n\t\tthis.stopCameraAnimation()\n\n\t\t// Stop following any user\n\t\tif (this.getInstanceState().followingUserId) {\n\t\t\tthis.stopFollowingUser()\n\t\t}\n\n\t\tconst _point = Vec.Cast(point)\n\n\t\tif (!Number.isFinite(_point.x)) _point.x = 0\n\t\tif (!Number.isFinite(_point.y)) _point.y = 0\n\t\tif (_point.z === undefined || !Number.isFinite(_point.z)) point.z = this.getZoomLevel()\n\n\t\tconst camera = this.getConstrainedCamera(_point, opts)\n\n\t\tif (opts?.animation) {\n\t\t\tconst { width, height } = this.getViewportScreenBounds()\n\t\t\tthis._animateToViewport(\n\t\t\t\tnew Box(-camera.x, -camera.y, width / camera.z, height / camera.z),\n\t\t\t\topts\n\t\t\t)\n\t\t} else {\n\t\t\tthis._setCamera(camera, {\n\t\t\t\t...opts,\n\t\t\t\t// we already did the constraining, so we don't need to do it again\n\t\t\t\tforce: true,\n\t\t\t})\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Center the camera on a point (in the current page space).\n\t *\n\t * @example\n\t * ```ts\n\t * editor.centerOnPoint({ x: 100, y: 100 })\n\t * editor.centerOnPoint({ x: 100, y: 100 }, { animation: { duration: 200 } })\n\t * ```\n\t *\n\t * @param point - The point in the current page space to center on.\n\t * @param opts - The camera move options.\n\t *\n\t * @public\n\t */\n\tcenterOnPoint(point: VecLike, opts?: TLCameraMoveOptions): this {\n\t\tconst { isLocked } = this.getCameraOptions()\n\t\tif (isLocked && !opts?.force) return this\n\n\t\tconst { width: pw, height: ph } = this.getViewportPageBounds()\n\t\tthis.setCamera(new Vec(-(point.x - pw / 2), -(point.y - ph / 2), this.getCamera().z), opts)\n\t\treturn this\n\t}\n\n\t/**\n\t * Zoom the camera to fit the current page's content in the viewport.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.zoomToFit()\n\t * editor.zoomToFit({ animation: { duration: 200 } })\n\t * ```\n\t *\n\t * @param opts - The camera move options.\n\t *\n\t * @public\n\t */\n\tzoomToFit(opts?: TLCameraMoveOptions): this {\n\t\tconst ids = [...this.getCurrentPageShapeIds()]\n\t\tif (ids.length <= 0) return this\n\t\tconst pageBounds = Box.Common(compact(ids.map((id) => this.getShapePageBounds(id))))\n\t\tthis.zoomToBounds(pageBounds, opts)\n\t\treturn this\n\t}\n\n\t/**\n\t * Set the zoom back to 100%.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.resetZoom()\n\t * editor.resetZoom(editor.getViewportScreenCenter(), { animation: { duration: 200 } })\n\t * editor.resetZoom(editor.getViewportScreenCenter(), { animation: { duration: 200 } })\n\t * ```\n\t *\n\t * @param point - The screen point to zoom out on. Defaults to the viewport screen center.\n\t * @param opts - The camera move options.\n\t *\n\t * @public\n\t */\n\tresetZoom(point = this.getViewportScreenCenter(), opts?: TLCameraMoveOptions): this {\n\t\tconst { isLocked, constraints: constraints } = this.getCameraOptions()\n\t\tif (isLocked && !opts?.force) return this\n\n\t\tconst currentCamera = this.getCamera()\n\t\tconst { x: cx, y: cy, z: cz } = currentCamera\n\t\tconst { x, y } = point\n\n\t\tlet z = 1\n\n\t\tif (constraints) {\n\t\t\t// For non-infinite fit, we'll set the camera to the natural zoom level...\n\t\t\t// unless it's already there, in which case we'll set zoom to 100%\n\t\t\tconst initialZoom = this.getInitialZoom()\n\t\t\tif (cz !== initialZoom) {\n\t\t\t\tz = initialZoom\n\t\t\t}\n\t\t}\n\n\t\tthis.setCamera(\n\t\t\tnew Vec(cx + (x / z - x) - (x / cz - x), cy + (y / z - y) - (y / cz - y), z),\n\t\t\topts\n\t\t)\n\t\treturn this\n\t}\n\n\t/**\n\t * Zoom the camera in.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.zoomIn()\n\t * editor.zoomIn(editor.getViewportScreenCenter(), { animation: { duration: 200 } })\n\t * editor.zoomIn(editor.inputs.currentScreenPoint, { animation: { duration: 200 } })\n\t * ```\n\t *\n\t * @param point - The screen point to zoom in on. Defaults to the screen center\n\t * @param opts - The camera move options.\n\t *\n\t * @public\n\t */\n\tzoomIn(point = this.getViewportScreenCenter(), opts?: TLCameraMoveOptions): this {\n\t\tconst { isLocked } = this.getCameraOptions()\n\t\tif (isLocked && !opts?.force) return this\n\n\t\tconst { x: cx, y: cy, z: cz } = this.getCamera()\n\n\t\tconst { zoomSteps } = this.getCameraOptions()\n\t\tif (zoomSteps !== null && zoomSteps.length > 1) {\n\t\t\tconst baseZoom = this.getBaseZoom()\n\t\t\tlet zoom = last(zoomSteps)! * baseZoom\n\t\t\tfor (let i = 1; i < zoomSteps.length; i++) {\n\t\t\t\tconst z1 = zoomSteps[i - 1] * baseZoom\n\t\t\t\tconst z2 = zoomSteps[i] * baseZoom\n\t\t\t\tif (z2 - cz <= (z2 - z1) / 2) continue\n\t\t\t\tzoom = z2\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tthis.setCamera(\n\t\t\t\tnew Vec(\n\t\t\t\t\tcx + (point.x / zoom - point.x) - (point.x / cz - point.x),\n\t\t\t\t\tcy + (point.y / zoom - point.y) - (point.y / cz - point.y),\n\t\t\t\t\tzoom\n\t\t\t\t),\n\t\t\t\topts\n\t\t\t)\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Zoom the camera out.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.zoomOut()\n\t * editor.zoomOut(editor.getViewportScreenCenter(), { animation: { duration: 120 } })\n\t * editor.zoomOut(editor.inputs.currentScreenPoint, { animation: { duration: 120 } })\n\t * ```\n\t *\n\t * @param point - The point to zoom out on. Defaults to the viewport screen center.\n\t * @param opts - The camera move options.\n\t *\n\t * @public\n\t */\n\tzoomOut(point = this.getViewportScreenCenter(), opts?: TLCameraMoveOptions): this {\n\t\tconst { isLocked } = this.getCameraOptions()\n\t\tif (isLocked && !opts?.force) return this\n\n\t\tconst { zoomSteps } = this.getCameraOptions()\n\t\tif (zoomSteps !== null && zoomSteps.length > 1) {\n\t\t\tconst baseZoom = this.getBaseZoom()\n\t\t\tconst { x: cx, y: cy, z: cz } = this.getCamera()\n\t\t\t// start at the max\n\t\t\tlet zoom = zoomSteps[0] * baseZoom\n\t\t\tfor (let i = zoomSteps.length - 1; i > 0; i--) {\n\t\t\t\tconst z1 = zoomSteps[i - 1] * baseZoom\n\t\t\t\tconst z2 = zoomSteps[i] * baseZoom\n\t\t\t\tif (z2 - cz >= (z2 - z1) / 2) continue\n\t\t\t\tzoom = z1\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tthis.setCamera(\n\t\t\t\tnew Vec(\n\t\t\t\t\tcx + (point.x / zoom - point.x) - (point.x / cz - point.x),\n\t\t\t\t\tcy + (point.y / zoom - point.y) - (point.y / cz - point.y),\n\t\t\t\t\tzoom\n\t\t\t\t),\n\t\t\t\topts\n\t\t\t)\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Zoom the camera to fit the current selection in the viewport.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.zoomToSelection()\n\t * editor.zoomToSelection({ animation: { duration: 200 } })\n\t * ```\n\t *\n\t * @param opts - The camera move options.\n\t *\n\t * @public\n\t */\n\tzoomToSelection(opts?: TLCameraMoveOptions): this {\n\t\tconst { isLocked } = this.getCameraOptions()\n\t\tif (isLocked && !opts?.force) return this\n\n\t\tconst selectionPageBounds = this.getSelectionPageBounds()\n\t\tif (selectionPageBounds) {\n\t\t\tthis.zoomToBounds(selectionPageBounds, {\n\t\t\t\ttargetZoom: Math.max(1, this.getZoomLevel()),\n\t\t\t\t...opts,\n\t\t\t})\n\t\t}\n\t\treturn this\n\t}\n\n\t/**\n\t * Zoom the camera to the current selection if offscreen.\n\t *\n\t * @public\n\t */\n\tzoomToSelectionIfOffscreen(\n\t\tpadding = 16,\n\t\topts?: { targetZoom?: number; inset?: number } & TLCameraMoveOptions\n\t) {\n\t\tconst selectionPageBounds = this.getSelectionPageBounds()\n\t\tconst viewportPageBounds = this.getViewportPageBounds()\n\t\tif (selectionPageBounds && !viewportPageBounds.contains(selectionPageBounds)) {\n\t\t\tconst eb = selectionPageBounds\n\t\t\t\t.clone()\n\t\t\t\t// Expand the bounds by the padding\n\t\t\t\t.expandBy(padding / this.getZoomLevel())\n\t\t\t\t// then expand the bounds to include the viewport bounds\n\t\t\t\t.expand(viewportPageBounds)\n\n\t\t\t// then use the difference between the centers to calculate the offset\n\t\t\tconst nextBounds = viewportPageBounds.clone().translate({\n\t\t\t\tx: (eb.center.x - viewportPageBounds.center.x) * 2,\n\t\t\t\ty: (eb.center.y - viewportPageBounds.center.y) * 2,\n\t\t\t})\n\t\t\tthis.zoomToBounds(nextBounds, opts)\n\t\t}\n\t}\n\n\t/**\n\t * Zoom the camera to fit a bounding box (in the current page space).\n\t *\n\t * @example\n\t * ```ts\n\t * editor.zoomToBounds(myBounds)\n\t * editor.zoomToBounds(myBounds, { animation: { duration: 200 } })\n\t * editor.zoomToBounds(myBounds, { animation: { duration: 200 }, inset: 0, targetZoom: 1 })\n\t * ```\n\t *\n\t * @param bounds - The bounding box.\n\t * @param opts - The camera move options, target zoom, or custom inset amount.\n\t *\n\t * @public\n\t */\n\tzoomToBounds(\n\t\tbounds: BoxLike,\n\t\topts?: { targetZoom?: number; inset?: number } & TLCameraMoveOptions\n\t): this {\n\t\tconst cameraOptions = this._cameraOptions.__unsafe__getWithoutCapture()\n\t\tif (cameraOptions.isLocked && !opts?.force) return this\n\n\t\tconst viewportScreenBounds = this.getViewportScreenBounds()\n\n\t\tconst inset = opts?.inset ?? Math.min(ZOOM_TO_FIT_PADDING, viewportScreenBounds.width * 0.28)\n\n\t\tconst baseZoom = this.getBaseZoom()\n\t\tconst zoomMin = cameraOptions.zoomSteps[0]\n\t\tconst zoomMax = last(cameraOptions.zoomSteps)!\n\n\t\tlet zoom = clamp(\n\t\t\tMath.min(\n\t\t\t\t(viewportScreenBounds.width - inset) / bounds.w,\n\t\t\t\t(viewportScreenBounds.height - inset) / bounds.h\n\t\t\t),\n\t\t\tzoomMin * baseZoom,\n\t\t\tzoomMax * baseZoom\n\t\t)\n\n\t\tif (opts?.targetZoom !== undefined) {\n\t\t\tzoom = Math.min(opts.targetZoom, zoom)\n\t\t}\n\n\t\tthis.setCamera(\n\t\t\tnew Vec(\n\t\t\t\t-bounds.x + (viewportScreenBounds.width - bounds.w * zoom) / 2 / zoom,\n\t\t\t\t-bounds.y + (viewportScreenBounds.height - bounds.h * zoom) / 2 / zoom,\n\t\t\t\tzoom\n\t\t\t),\n\t\t\topts\n\t\t)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Stop the current camera animation, if any.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.stopCameraAnimation()\n\t * ```\n\t *\n\t * @public\n\t */\n\tstopCameraAnimation(): this {\n\t\tthis.emit('stop-camera-animation')\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _viewportAnimation = null as null | {\n\t\telapsed: number\n\t\tduration: number\n\t\teasing(t: number): number\n\t\tstart: Box\n\t\tend: Box\n\t}\n\n\t/** @internal */\n\tprivate _animateViewport(ms: number): void {\n\t\tif (!this._viewportAnimation) return\n\n\t\tthis._viewportAnimation.elapsed += ms\n\n\t\tconst { elapsed, easing, duration, start, end } = this._viewportAnimation\n\n\t\tif (elapsed > duration) {\n\t\t\tthis.off('tick', this._animateViewport)\n\t\t\tthis._viewportAnimation = null\n\t\t\tthis._setCamera(new Vec(-end.x, -end.y, this.getViewportScreenBounds().width / end.width))\n\t\t\treturn\n\t\t}\n\n\t\tconst remaining = duration - elapsed\n\t\tconst t = easing(1 - remaining / duration)\n\n\t\tconst left = start.minX + (end.minX - start.minX) * t\n\t\tconst top = start.minY + (end.minY - start.minY) * t\n\t\tconst right = start.maxX + (end.maxX - start.maxX) * t\n\n\t\tthis._setCamera(new Vec(-left, -top, this.getViewportScreenBounds().width / (right - left)), {\n\t\t\tforce: true,\n\t\t})\n\t}\n\n\t/** @internal */\n\tprivate _animateToViewport(\n\t\ttargetViewportPage: Box,\n\t\topts = { animation: DEFAULT_ANIMATION_OPTIONS } as TLCameraMoveOptions\n\t) {\n\t\tconst { animation, ...rest } = opts\n\t\tif (!animation) return\n\t\tconst { duration = 0, easing = EASINGS.easeInOutCubic } = animation\n\t\tconst animationSpeed = this.user.getAnimationSpeed()\n\t\tconst viewportPageBounds = this.getViewportPageBounds()\n\n\t\t// If we have an existing animation, then stop it\n\t\tthis.stopCameraAnimation()\n\n\t\t// also stop following any user\n\t\tif (this.getInstanceState().followingUserId) {\n\t\t\tthis.stopFollowingUser()\n\t\t}\n\n\t\tif (duration === 0 || animationSpeed === 0) {\n\t\t\t// If we have no animation, then skip the animation and just set the camera\n\t\t\treturn this._setCamera(\n\t\t\t\tnew Vec(\n\t\t\t\t\t-targetViewportPage.x,\n\t\t\t\t\t-targetViewportPage.y,\n\t\t\t\t\tthis.getViewportScreenBounds().width / targetViewportPage.width\n\t\t\t\t),\n\t\t\t\t{ ...rest }\n\t\t\t)\n\t\t}\n\n\t\t// Set our viewport animation\n\t\tthis._viewportAnimation = {\n\t\t\telapsed: 0,\n\t\t\tduration: duration / animationSpeed,\n\t\t\teasing,\n\t\t\tstart: viewportPageBounds.clone(),\n\t\t\tend: targetViewportPage.clone(),\n\t\t}\n\n\t\t// If we ever get a \"stop-camera-animation\" event, we stop\n\t\tthis.once('stop-camera-animation', () => {\n\t\t\tthis.off('tick', this._animateViewport)\n\t\t\tthis._viewportAnimation = null\n\t\t})\n\n\t\t// On each tick, animate the viewport\n\t\tthis.on('tick', this._animateViewport)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Slide the camera in a certain direction.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.slideCamera({ speed: 1, direction: { x: 1, y: 0 }, friction: 0.1 })\n\t * ```\n\t *\n\t * @param opts - Options for the slide\n\t * @public\n\t */\n\tslideCamera(\n\t\topts = {} as {\n\t\t\tspeed: number\n\t\t\tdirection: VecLike\n\t\t\tfriction?: number\n\t\t\tspeedThreshold?: number\n\t\t\tforce?: boolean\n\t\t}\n\t): this {\n\t\tconst { isLocked } = this.getCameraOptions()\n\t\tif (isLocked && !opts?.force) return this\n\n\t\tconst animationSpeed = this.user.getAnimationSpeed()\n\t\tif (animationSpeed === 0) return this\n\n\t\tthis.stopCameraAnimation()\n\n\t\tconst {\n\t\t\tspeed,\n\t\t\tfriction = this.options.cameraSlideFriction,\n\t\t\tdirection,\n\t\t\tspeedThreshold = 0.01,\n\t\t} = opts\n\t\tlet currentSpeed = Math.min(speed, 1)\n\n\t\tconst cancel = () => {\n\t\t\tthis.off('tick', moveCamera)\n\t\t\tthis.off('stop-camera-animation', cancel)\n\t\t}\n\n\t\tthis.once('stop-camera-animation', cancel)\n\n\t\tconst moveCamera = (elapsed: number) => {\n\t\t\tconst { x: cx, y: cy, z: cz } = this.getCamera()\n\t\t\tconst movementVec = Vec.Mul(direction, (currentSpeed * elapsed) / cz)\n\n\t\t\t// Apply friction\n\t\t\tcurrentSpeed *= 1 - friction\n\t\t\tif (currentSpeed < speedThreshold) {\n\t\t\t\tcancel()\n\t\t\t} else {\n\t\t\t\tthis._setCamera(new Vec(cx + movementVec.x, cy + movementVec.y, cz))\n\t\t\t}\n\t\t}\n\n\t\tthis.on('tick', moveCamera)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Animate the camera to a user's cursor position. This also briefly show the user's cursor if it's not currently visible.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.zoomToUser(myUserId)\n\t * editor.zoomToUser(myUserId, { animation: { duration: 200 } })\n\t * ```\n\t *\n\t * @param userId - The id of the user to animate to.\n\t * @param opts - The camera move options.\n\t * @public\n\t */\n\tzoomToUser(userId: string, opts: TLCameraMoveOptions = { animation: { duration: 500 } }): this {\n\t\tconst presence = this.getCollaborators().find((c) => c.userId === userId)\n\n\t\tif (!presence) return this\n\n\t\tconst cursor = presence.cursor\n\t\tif (!cursor) return this\n\n\t\tthis.run(() => {\n\t\t\t// If we're following someone, stop following them\n\t\t\tif (this.getInstanceState().followingUserId !== null) {\n\t\t\t\tthis.stopFollowingUser()\n\t\t\t}\n\n\t\t\t// If we're not on the same page, move to the page they're on\n\t\t\tconst isOnSamePage = presence.currentPageId === this.getCurrentPageId()\n\t\t\tif (!isOnSamePage) {\n\t\t\t\tthis.setCurrentPage(presence.currentPageId)\n\t\t\t}\n\n\t\t\t// Only animate the camera if the user is on the same page as us\n\t\t\tif (opts && opts.animation && !isOnSamePage) {\n\t\t\t\topts.animation = undefined\n\t\t\t}\n\n\t\t\tthis.centerOnPoint(cursor, opts)\n\n\t\t\t// Highlight the user's cursor\n\t\t\tconst { highlightedUserIds } = this.getInstanceState()\n\t\t\tthis.updateInstanceState({ highlightedUserIds: [...highlightedUserIds, userId] })\n\n\t\t\t// Unhighlight the user's cursor after a few seconds\n\t\t\tthis.timers.setTimeout(() => {\n\t\t\t\tconst highlightedUserIds = [...this.getInstanceState().highlightedUserIds]\n\t\t\t\tconst index = highlightedUserIds.indexOf(userId)\n\t\t\t\tif (index < 0) return\n\t\t\t\thighlightedUserIds.splice(index, 1)\n\t\t\t\tthis.updateInstanceState({ highlightedUserIds })\n\t\t\t}, this.options.collaboratorIdleTimeoutMs)\n\t\t})\n\n\t\treturn this\n\t}\n\n\t// Viewport\n\n\t/** @internal */\n\tprivate _willSetInitialBounds = true\n\n\t/**\n\t * Update the viewport. The viewport will measure the size and screen position of its container\n\t * element. This should be done whenever the container's position on the screen changes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.updateViewportScreenBounds(new Box(0, 0, 1280, 1024))\n\t * editor.updateViewportScreenBounds(new Box(0, 0, 1280, 1024), true)\n\t * ```\n\t *\n\t * @param screenBounds - The new screen bounds of the viewport.\n\t * @param center - Whether to preserve the viewport page center as the viewport changes.\n\t *\n\t * @public\n\t */\n\tupdateViewportScreenBounds(screenBounds: Box | HTMLElement, center = false): this {\n\t\tif (!(screenBounds instanceof Box)) {\n\t\t\tconst rect = screenBounds.getBoundingClientRect()\n\t\t\tscreenBounds = new Box(\n\t\t\t\trect.left || rect.x,\n\t\t\t\trect.top || rect.y,\n\t\t\t\tMath.max(rect.width, 1),\n\t\t\t\tMath.max(rect.height, 1)\n\t\t\t)\n\t\t} else {\n\t\t\tscreenBounds.width = Math.max(screenBounds.width, 1)\n\t\t\tscreenBounds.height = Math.max(screenBounds.height, 1)\n\t\t}\n\n\t\tconst insets = [\n\t\t\t// top\n\t\t\tscreenBounds.minY !== 0,\n\t\t\t// right\n\t\t\t!approximately(document.body.scrollWidth, screenBounds.maxX, 1),\n\t\t\t// bottom\n\t\t\t!approximately(document.body.scrollHeight, screenBounds.maxY, 1),\n\t\t\t// left\n\t\t\tscreenBounds.minX !== 0,\n\t\t]\n\n\t\tconst { _willSetInitialBounds } = this\n\n\t\tthis._willSetInitialBounds = false\n\n\t\tconst { screenBounds: prevScreenBounds, insets: prevInsets } = this.getInstanceState()\n\t\tif (screenBounds.equals(prevScreenBounds) && insets.every((v, i) => v === prevInsets[i])) {\n\t\t\t// nothing to do\n\t\t\treturn this\n\t\t}\n\n\t\tif (_willSetInitialBounds) {\n\t\t\t// If we have just received the initial bounds, don't center the camera.\n\t\t\tthis.updateInstanceState({ screenBounds: screenBounds.toJson(), insets })\n\t\t\tthis.setCamera(this.getCamera())\n\t\t} else {\n\t\t\tif (center && !this.getInstanceState().followingUserId) {\n\t\t\t\t// Get the page center before the change, make the change, and restore it\n\t\t\t\tconst before = this.getViewportPageBounds().center\n\t\t\t\tthis.updateInstanceState({ screenBounds: screenBounds.toJson(), insets })\n\t\t\t\tthis.centerOnPoint(before)\n\t\t\t} else {\n\t\t\t\t// Otherwise,\n\t\t\t\tthis.updateInstanceState({ screenBounds: screenBounds.toJson(), insets })\n\t\t\t\tthis._setCamera(Vec.From({ ...this.getCamera() }))\n\t\t\t}\n\t\t}\n\n\t\tthis._tickCameraState()\n\n\t\treturn this\n\t}\n\n\t/**\n\t * The bounds of the editor's viewport in screen space.\n\t *\n\t * @public\n\t */\n\t@computed getViewportScreenBounds() {\n\t\tconst { x, y, w, h } = this.getInstanceState().screenBounds\n\t\treturn new Box(x, y, w, h)\n\t}\n\n\t/**\n\t * The center of the editor's viewport in screen space.\n\t *\n\t * @public\n\t */\n\t@computed getViewportScreenCenter() {\n\t\tconst viewportScreenBounds = this.getViewportScreenBounds()\n\t\treturn new Vec(viewportScreenBounds.w / 2, viewportScreenBounds.h / 2)\n\t}\n\n\t/**\n\t * The current viewport in the current page space.\n\t *\n\t * @public\n\t */\n\t@computed getViewportPageBounds() {\n\t\tconst { w, h } = this.getViewportScreenBounds()\n\t\tconst { x: cx, y: cy, z: cz } = this.getCamera()\n\t\treturn new Box(-cx, -cy, w / cz, h / cz)\n\t}\n\n\t/**\n\t * Convert a point in screen space to a point in the current page space.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.screenToPage({ x: 100, y: 100 })\n\t * ```\n\t *\n\t * @param point - The point in screen space.\n\t *\n\t * @public\n\t */\n\tscreenToPage(point: VecLike) {\n\t\tconst { screenBounds } = this.store.unsafeGetWithoutCapture(TLINSTANCE_ID)!\n\t\tconst { x: cx, y: cy, z: cz = 1 } = this.getCamera()\n\t\treturn new Vec(\n\t\t\t(point.x - screenBounds.x) / cz - cx,\n\t\t\t(point.y - screenBounds.y) / cz - cy,\n\t\t\tpoint.z ?? 0.5\n\t\t)\n\t}\n\n\t/**\n\t * Convert a point in the current page space to a point in current screen space.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.pageToScreen({ x: 100, y: 100 })\n\t * ```\n\t *\n\t * @param point - The point in page space.\n\t *\n\t * @public\n\t */\n\tpageToScreen(point: VecLike) {\n\t\tconst { screenBounds } = this.store.unsafeGetWithoutCapture(TLINSTANCE_ID)!\n\t\tconst { x: cx, y: cy, z: cz = 1 } = this.getCamera()\n\t\treturn new Vec(\n\t\t\t(point.x + cx) * cz + screenBounds.x,\n\t\t\t(point.y + cy) * cz + screenBounds.y,\n\t\t\tpoint.z ?? 0.5\n\t\t)\n\t}\n\n\t/**\n\t * Convert a point in the current page space to a point in current viewport space.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.pageToViewport({ x: 100, y: 100 })\n\t * ```\n\t *\n\t * @param point - The point in page space.\n\t *\n\t * @public\n\t */\n\tpageToViewport(point: VecLike) {\n\t\tconst { x: cx, y: cy, z: cz = 1 } = this.getCamera()\n\t\treturn new Vec((point.x + cx) * cz, (point.y + cy) * cz, point.z ?? 0.5)\n\t}\n\t// Collaborators\n\n\t@computed\n\tprivate _getCollaboratorsQuery() {\n\t\treturn this.store.query.records('instance_presence', () => ({\n\t\t\tuserId: { neq: this.user.getId() },\n\t\t}))\n\t}\n\n\t/**\n\t * Returns a list of presence records for all peer collaborators.\n\t * This will return the latest presence record for each connected user.\n\t *\n\t * @public\n\t */\n\t@computed\n\tgetCollaborators() {\n\t\tconst allPresenceRecords = this._getCollaboratorsQuery().get()\n\t\tif (!allPresenceRecords.length) return EMPTY_ARRAY\n\t\tconst userIds = [...new Set(allPresenceRecords.map((c) => c.userId))].sort()\n\t\treturn userIds.map((id) => {\n\t\t\tconst latestPresence = maxBy(\n\t\t\t\tallPresenceRecords.filter((c) => c.userId === id),\n\t\t\t\t(p) => p.lastActivityTimestamp ?? 0\n\t\t\t)\n\t\t\treturn latestPresence!\n\t\t})\n\t}\n\n\t/**\n\t * Returns a list of presence records for all peer collaborators on the current page.\n\t * This will return the latest presence record for each connected user.\n\t *\n\t * @public\n\t */\n\t@computed\n\tgetCollaboratorsOnCurrentPage() {\n\t\tconst currentPageId = this.getCurrentPageId()\n\t\treturn this.getCollaborators().filter((c) => c.currentPageId === currentPageId)\n\t}\n\n\t// Following\n\n\t// When we are 'locked on' to a user, our camera is derived from their camera.\n\tprivate _isLockedOnFollowingUser = atom('isLockedOnFollowingUser', false)\n\n\t/**\n\t * Start viewport-following a user.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.startFollowingUser(myUserId)\n\t * ```\n\t *\n\t * @param userId - The id of the user to follow.\n\t *\n\t * @public\n\t */\n\tstartFollowingUser(userId: string): this {\n\t\t// if we were already following someone, stop following them\n\t\tthis.stopFollowingUser()\n\n\t\tconst thisUserId = this.user.getId()\n\n\t\tif (!thisUserId) {\n\t\t\tconsole.warn('You should set the userId for the current instance before following a user')\n\t\t\t// allow to continue since it's probably fine most of the time.\n\t\t}\n\n\t\tconst leaderPresence = this._getFollowingPresence(userId)\n\n\t\tif (!leaderPresence) {\n\t\t\treturn this\n\t\t}\n\n\t\tconst latestLeaderPresence = computed('latestLeaderPresence', () => {\n\t\t\treturn this._getFollowingPresence(userId)\n\t\t})\n\n\t\ttransact(() => {\n\t\t\tthis.updateInstanceState({ followingUserId: userId }, { history: 'ignore' })\n\n\t\t\t// we listen for page changes separately from the 'moveTowardsUser' tick\n\t\t\tconst dispose = react('update current page', () => {\n\t\t\t\tconst leaderPresence = latestLeaderPresence.get()\n\t\t\t\tif (!leaderPresence) {\n\t\t\t\t\tthis.stopFollowingUser()\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\tleaderPresence.currentPageId !== this.getCurrentPageId() &&\n\t\t\t\t\tthis.getPage(leaderPresence.currentPageId)\n\t\t\t\t) {\n\t\t\t\t\t// if the page changed, switch page\n\t\t\t\t\tthis.run(\n\t\t\t\t\t\t() => {\n\t\t\t\t\t\t\t// sneaky store.put here, we can't go through setCurrentPage because it calls stopFollowingUser\n\t\t\t\t\t\t\tthis.store.put([\n\t\t\t\t\t\t\t\t{ ...this.getInstanceState(), currentPageId: leaderPresence.currentPageId },\n\t\t\t\t\t\t\t])\n\t\t\t\t\t\t\tthis._isLockedOnFollowingUser.set(true)\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{ history: 'ignore' }\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tconst cancel = () => {\n\t\t\t\tdispose()\n\t\t\t\tthis._isLockedOnFollowingUser.set(false)\n\t\t\t\tthis.off('frame', moveTowardsUser)\n\t\t\t\tthis.off('stop-following', cancel)\n\t\t\t}\n\n\t\t\tconst moveTowardsUser = () => {\n\t\t\t\t// Stop following if we can't find the user\n\t\t\t\tconst leaderPresence = latestLeaderPresence.get()\n\t\t\t\tif (!leaderPresence) {\n\t\t\t\t\tthis.stopFollowingUser()\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif (this._isLockedOnFollowingUser.get()) return\n\n\t\t\t\tconst animationSpeed = this.user.getAnimationSpeed()\n\n\t\t\t\tif (animationSpeed === 0) {\n\t\t\t\t\tthis._isLockedOnFollowingUser.set(true)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tconst targetViewport = this.getViewportPageBoundsForFollowing()\n\t\t\t\tif (!targetViewport) {\n\t\t\t\t\tthis.stopFollowingUser()\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tconst currentViewport = this.getViewportPageBounds()\n\n\t\t\t\tconst diffX =\n\t\t\t\t\tMath.abs(targetViewport.minX - currentViewport.minX) +\n\t\t\t\t\tMath.abs(targetViewport.maxX - currentViewport.maxX)\n\t\t\t\tconst diffY =\n\t\t\t\t\tMath.abs(targetViewport.minY - currentViewport.minY) +\n\t\t\t\t\tMath.abs(targetViewport.maxY - currentViewport.maxY)\n\n\t\t\t\t// Stop chasing if we're close enough!\n\t\t\t\tif (\n\t\t\t\t\tdiffX < this.options.followChaseViewportSnap &&\n\t\t\t\t\tdiffY < this.options.followChaseViewportSnap\n\t\t\t\t) {\n\t\t\t\t\tthis._isLockedOnFollowingUser.set(true)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// Chase the user's viewport!\n\t\t\t\t// Interpolate between the current viewport and the target viewport based on animation speed.\n\t\t\t\t// This will produce an 'ease-out' effect.\n\t\t\t\tconst t = clamp(animationSpeed * 0.5, 0.1, 0.8)\n\n\t\t\t\tconst nextViewport = new Box(\n\t\t\t\t\tlerp(currentViewport.minX, targetViewport.minX, t),\n\t\t\t\t\tlerp(currentViewport.minY, targetViewport.minY, t),\n\t\t\t\t\tlerp(currentViewport.width, targetViewport.width, t),\n\t\t\t\t\tlerp(currentViewport.height, targetViewport.height, t)\n\t\t\t\t)\n\n\t\t\t\tconst nextCamera = new Vec(\n\t\t\t\t\t-nextViewport.x,\n\t\t\t\t\t-nextViewport.y,\n\t\t\t\t\tthis.getViewportScreenBounds().width / nextViewport.width\n\t\t\t\t)\n\n\t\t\t\t// Update the camera!\n\t\t\t\tthis.stopCameraAnimation()\n\t\t\t\tthis._setCamera(nextCamera)\n\t\t\t}\n\n\t\t\tthis.once('stop-following', cancel)\n\t\t\tthis.addListener('frame', moveTowardsUser)\n\n\t\t\t// call once to start synchronously\n\t\t\tmoveTowardsUser()\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Stop viewport-following a user.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.stopFollowingUser()\n\t * ```\n\t * @public\n\t */\n\tstopFollowingUser(): this {\n\t\tthis.run(\n\t\t\t() => {\n\t\t\t\t// commit the current camera to the store\n\t\t\t\tthis.store.put([this.getCamera()])\n\t\t\t\t// this must happen after the camera is committed\n\t\t\t\tthis._isLockedOnFollowingUser.set(false)\n\t\t\t\tthis.updateInstanceState({ followingUserId: null })\n\t\t\t\tthis.emit('stop-following')\n\t\t\t},\n\t\t\t{ history: 'ignore' }\n\t\t)\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tgetUnorderedRenderingShapes(\n\t\t// The rendering state. We use this method both for rendering, which\n\t\t// is based on other state, and for computing order for SVG export,\n\t\t// which should work even when things are for example off-screen.\n\t\tuseEditorState: boolean\n\t): TLRenderingShape[] {\n\t\t// Here we get the shape as well as any of its children, as well as their\n\t\t// opacities. If the shape is being erased, and none of its ancestors are\n\t\t// being erased, then we reduce the opacity of the shape and all of its\n\t\t// ancestors; but we don't apply this effect more than once among a set\n\t\t// of descendants so that it does not compound.\n\n\t\t// This is designed to keep all the shapes in a single list which\n\t\t// allows the DOM nodes to be reused even when they become children\n\t\t// of other nodes.\n\n\t\tconst renderingShapes: TLRenderingShape[] = []\n\n\t\tlet nextIndex = this.options.maxShapesPerPage * 2\n\t\tlet nextBackgroundIndex = this.options.maxShapesPerPage\n\n\t\tconst erasingShapeIds = this.getErasingShapeIds()\n\n\t\tconst addShapeById = (id: TLShapeId, opacity: number, isAncestorErasing: boolean) => {\n\t\t\tconst shape = this.getShape(id)\n\t\t\tif (!shape) return\n\n\t\t\tif (this.isShapeHidden(shape)) {\n\t\t\t\t// process children just in case they are overriding the hidden state\n\t\t\t\tconst isErasing = isAncestorErasing || erasingShapeIds.includes(id)\n\t\t\t\tfor (const childId of this.getSortedChildIdsForParent(id)) {\n\t\t\t\t\taddShapeById(childId, opacity, isErasing)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\topacity *= shape.opacity\n\t\t\tlet isShapeErasing = false\n\t\t\tconst util = this.getShapeUtil(shape)\n\n\t\t\tif (useEditorState) {\n\t\t\t\tisShapeErasing = !isAncestorErasing && erasingShapeIds.includes(id)\n\t\t\t\tif (isShapeErasing) {\n\t\t\t\t\topacity *= 0.32\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trenderingShapes.push({\n\t\t\t\tid,\n\t\t\t\tshape,\n\t\t\t\tutil,\n\t\t\t\tindex: nextIndex,\n\t\t\t\tbackgroundIndex: nextBackgroundIndex,\n\t\t\t\topacity,\n\t\t\t})\n\n\t\t\tnextIndex += 1\n\t\t\tnextBackgroundIndex += 1\n\n\t\t\tconst childIds = this.getSortedChildIdsForParent(id)\n\t\t\tif (!childIds.length) return\n\n\t\t\tlet backgroundIndexToRestore = null\n\t\t\tif (util.providesBackgroundForChildren(shape)) {\n\t\t\t\tbackgroundIndexToRestore = nextBackgroundIndex\n\t\t\t\tnextBackgroundIndex = nextIndex\n\t\t\t\tnextIndex += this.options.maxShapesPerPage\n\t\t\t}\n\n\t\t\tfor (const childId of childIds) {\n\t\t\t\taddShapeById(childId, opacity, isAncestorErasing || isShapeErasing)\n\t\t\t}\n\n\t\t\tif (backgroundIndexToRestore !== null) {\n\t\t\t\tnextBackgroundIndex = backgroundIndexToRestore\n\t\t\t}\n\t\t}\n\n\t\t// If we're using editor state, then we're only interested in on-screen shapes.\n\t\t// If we're not using the editor state, then we're interested in ALL shapes, even those from other pages.\n\t\tconst pages = useEditorState ? [this.getCurrentPage()] : this.getPages()\n\t\tfor (const page of pages) {\n\t\t\tfor (const childId of this.getSortedChildIdsForParent(page.id)) {\n\t\t\t\taddShapeById(childId, 1, false)\n\t\t\t}\n\t\t}\n\n\t\treturn renderingShapes\n\t}\n\n\t// Camera state\n\t// Camera state does two things: first, it allows us to subscribe to whether\n\t// the camera is moving or not; and second, it allows us to update the rendering\n\t// shapes on the canvas. Changing the rendering shapes may cause shapes to\n\t// unmount / remount in the DOM, which is expensive; and computing visibility is\n\t// also expensive in large projects. For this reason, we use a second bounding\n\t// box just for rendering, and we only update after the camera stops moving.\n\tprivate _cameraState = atom('camera state', 'idle' as 'idle' | 'moving')\n\tprivate _cameraStateTimeoutRemaining = 0\n\t_decayCameraStateTimeout(elapsed: number) {\n\t\tthis._cameraStateTimeoutRemaining -= elapsed\n\t\tif (this._cameraStateTimeoutRemaining > 0) return\n\t\tthis.off('tick', this._decayCameraStateTimeout)\n\t\tthis._cameraState.set('idle')\n\t}\n\t_tickCameraState() {\n\t\t// always reset the timeout\n\t\tthis._cameraStateTimeoutRemaining = this.options.cameraMovingTimeoutMs\n\t\t// If the state is idle, then start the tick\n\t\tif (this._cameraState.__unsafe__getWithoutCapture() !== 'idle') return\n\t\tthis._cameraState.set('moving')\n\t\tthis.on('tick', this._decayCameraStateTimeout)\n\t}\n\n\t/**\n\t * Whether the camera is moving or idle.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getCameraState()\n\t * ```\n\t *\n\t * @public\n\t */\n\tgetCameraState() {\n\t\treturn this._cameraState.get()\n\t}\n\n\t/**\n\t * Get the shapes that should be displayed in the current viewport.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getRenderingShapes()\n\t * ```\n\t *\n\t * @public\n\t */\n\t@computed getRenderingShapes() {\n\t\tconst renderingShapes = this.getUnorderedRenderingShapes(true)\n\n\t\t// Its IMPORTANT that the result be sorted by id AND include the index\n\t\t// that the shape should be displayed at. Steve, this is the past you\n\t\t// telling the present you not to change this.\n\n\t\t// We want to sort by id because moving elements about in the DOM will\n\t\t// cause the element to get removed by react as it moves the DOM node. This\n\t\t// causes <iframes/> to re-render which is hella annoying and a perf\n\t\t// drain. By always sorting by 'id' we keep the shapes always in the\n\t\t// same order; but we later use index to set the element's 'z-index'\n\t\t// to change the \"rendered\" position in z-space.\n\t\treturn renderingShapes.sort(sortById)\n\t}\n\n\t/* --------------------- Pages ---------------------- */\n\n\t@computed private _getAllPagesQuery() {\n\t\treturn this.store.query.records('page')\n\t}\n\n\t/**\n\t * Info about the project's current pages.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getPages()\n\t * ```\n\t *\n\t * @public\n\t */\n\t@computed getPages(): TLPage[] {\n\t\treturn Array.from(this._getAllPagesQuery().get()).sort(sortByIndex)\n\t}\n\n\t/**\n\t * The current page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getCurrentPage()\n\t * ```\n\t *\n\t * @public\n\t */\n\tgetCurrentPage(): TLPage {\n\t\treturn this.getPage(this.getCurrentPageId())!\n\t}\n\n\t/**\n\t * The current page id.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getCurrentPageId()\n\t * ```\n\t *\n\t * @public\n\t */\n\t@computed getCurrentPageId(): TLPageId {\n\t\treturn this.getInstanceState().currentPageId\n\t}\n\n\t/**\n\t * Get a page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getPage(myPage.id)\n\t * editor.getPage(myPage)\n\t * ```\n\t *\n\t * @param page - The page (or the page id) to get.\n\t *\n\t * @public\n\t */\n\tgetPage(page: TLPageId | TLPage): TLPage | undefined {\n\t\treturn this.store.get(typeof page === 'string' ? page : page.id)\n\t}\n\n\t/* @internal */\n\tprivate readonly _currentPageShapeIds: ReturnType<typeof deriveShapeIdsInCurrentPage>\n\n\t/**\n\t * An array of all of the shapes on the current page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getCurrentPageIds()\n\t * ```\n\t *\n\t * @public\n\t */\n\tgetCurrentPageShapeIds() {\n\t\treturn this._currentPageShapeIds.get()\n\t}\n\n\t/**\n\t * @internal\n\t */\n\t@computed\n\tgetCurrentPageShapeIdsSorted() {\n\t\treturn Array.from(this.getCurrentPageShapeIds()).sort()\n\t}\n\n\t/**\n\t * Get the ids of shapes on a page.\n\t *\n\t * @example\n\t * ```ts\n\t * const idsOnPage1 = editor.getPageShapeIds('page1')\n\t * const idsOnPage2 = editor.getPageShapeIds(myPage2)\n\t * ```\n\t *\n\t * @param page - The page (or the page id) to get the shape ids for.\n\t *\n\t * @public\n\t **/\n\tgetPageShapeIds(page: TLPageId | TLPage): Set<TLShapeId> {\n\t\tconst pageId = typeof page === 'string' ? page : page.id\n\t\tconst result = this.store.query.exec('shape', { parentId: { eq: pageId } })\n\t\treturn this.getShapeAndDescendantIds(result.map((s) => s.id))\n\t}\n\n\t/**\n\t * Set the current page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setCurrentPage('page1')\n\t * editor.setCurrentPage(myPage1)\n\t * ```\n\t *\n\t * @param page - The page (or the page id) to set as the current page.\n\t *\n\t * @public\n\t */\n\tsetCurrentPage(page: TLPageId | TLPage): this {\n\t\tconst pageId = typeof page === 'string' ? page : page.id\n\t\tif (!this.store.has(pageId)) {\n\t\t\tconsole.error(\"Tried to set the current page id to a page that doesn't exist.\")\n\t\t\treturn this\n\t\t}\n\n\t\tthis.stopFollowingUser()\n\t\t// finish off any in-progress interactions\n\t\tthis.complete()\n\n\t\treturn this.run(\n\t\t\t() => {\n\t\t\t\tthis.store.put([{ ...this.getInstanceState(), currentPageId: pageId }])\n\t\t\t\t// ensure camera constraints are applied\n\t\t\t\tthis.setCamera(this.getCamera())\n\t\t\t},\n\t\t\t{ history: 'record-preserveRedoStack' }\n\t\t)\n\t}\n\n\t/**\n\t * Update a page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.updatePage({ id: 'page2', name: 'Page 2' })\n\t * ```\n\t *\n\t * @param partial - The partial of the shape to update.\n\t *\n\t * @public\n\t */\n\tupdatePage(partial: RequiredKeys<Partial<TLPage>, 'id'>): this {\n\t\tif (this.getIsReadonly()) return this\n\n\t\tconst prev = this.getPage(partial.id)\n\t\tif (!prev) return this\n\n\t\treturn this.run(() => this.store.update(partial.id, (page) => ({ ...page, ...partial })))\n\t}\n\n\t/**\n\t * Create a page whilst ensuring that the page name is unique.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.createPage(myPage)\n\t * editor.createPage({ name: 'Page 2' })\n\t * ```\n\t *\n\t * @param page - The page (or page partial) to create.\n\t *\n\t * @public\n\t */\n\tcreatePage(page: Partial<TLPage>): this {\n\t\tthis.run(() => {\n\t\t\tif (this.getIsReadonly()) return\n\t\t\tif (this.getPages().length >= this.options.maxPages) return\n\t\t\tconst pages = this.getPages()\n\n\t\t\tconst name = getIncrementedName(\n\t\t\t\tpage.name ?? 'Page 1',\n\t\t\t\tpages.map((p) => p.name)\n\t\t\t)\n\n\t\t\tlet index = page.index\n\n\t\t\tif (!index || pages.some((p) => p.index === index)) {\n\t\t\t\tindex = getIndexAbove(pages[pages.length - 1].index)\n\t\t\t}\n\n\t\t\tconst newPage = PageRecordType.create({\n\t\t\t\tmeta: {},\n\t\t\t\t...page,\n\t\t\t\tname,\n\t\t\t\tindex,\n\t\t\t})\n\n\t\t\tthis.store.put([newPage])\n\t\t})\n\t\treturn this\n\t}\n\n\t/**\n\t * Delete a page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.deletePage('page1')\n\t * ```\n\t *\n\t * @param page - The page (or the page id) to delete.\n\t *\n\t * @public\n\t */\n\tdeletePage(page: TLPageId | TLPage): this {\n\t\tconst id = typeof page === 'string' ? page : page.id\n\t\tthis.run(() => {\n\t\t\tif (this.getIsReadonly()) return\n\t\t\tconst pages = this.getPages()\n\t\t\tif (pages.length === 1) return\n\n\t\t\tconst deletedPage = this.getPage(id)\n\t\t\tif (!deletedPage) return\n\n\t\t\tif (id === this.getCurrentPageId()) {\n\t\t\t\tconst index = pages.findIndex((page) => page.id === id)\n\t\t\t\tconst next = pages[index - 1] ?? pages[index + 1]\n\t\t\t\tthis.setCurrentPage(next.id)\n\t\t\t}\n\t\t\tthis.store.remove([deletedPage.id])\n\t\t})\n\t\treturn this\n\t}\n\n\t/**\n\t * Duplicate a page.\n\t *\n\t * @param page - The page (or the page id) to duplicate. Defaults to the current page.\n\t * @param createId - The id of the new page. Defaults to a new id.\n\t *\n\t * @public\n\t */\n\tduplicatePage(page: TLPageId | TLPage, createId: TLPageId = PageRecordType.createId()): this {\n\t\tif (this.getPages().length >= this.options.maxPages) return this\n\t\tconst id = typeof page === 'string' ? page : page.id\n\t\tconst freshPage = this.getPage(id) // get the most recent version of the page anyway\n\t\tif (!freshPage) return this\n\n\t\tconst prevCamera = { ...this.getCamera() }\n\t\tconst content = this.getContentFromCurrentPage(this.getSortedChildIdsForParent(freshPage.id))\n\n\t\tthis.run(() => {\n\t\t\tconst pages = this.getPages()\n\t\t\tconst index = getIndexBetween(freshPage.index, pages[pages.indexOf(freshPage) + 1]?.index)\n\n\t\t\t// create the page (also creates the pagestate and camera for the new page)\n\t\t\tthis.createPage({ name: freshPage.name + ' Copy', id: createId, index })\n\t\t\t// set the new page as the current page\n\t\t\tthis.setCurrentPage(createId)\n\t\t\t// update the new page's camera to the previous page's camera\n\t\t\tthis.setCamera(prevCamera)\n\n\t\t\tif (content) {\n\t\t\t\t// If we had content on the previous page, put it on the new page\n\t\t\t\treturn this.putContentOntoCurrentPage(content)\n\t\t\t}\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Rename a page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.renamePage('page1', 'My Page')\n\t * ```\n\t *\n\t * @param page - The page (or the page id) to rename.\n\t * @param name - The new name.\n\t *\n\t * @public\n\t */\n\trenamePage(page: TLPageId | TLPage, name: string) {\n\t\tconst id = typeof page === 'string' ? page : page.id\n\t\tif (this.getIsReadonly()) return this\n\t\tthis.updatePage({ id, name })\n\t\treturn this\n\t}\n\n\t/* --------------------- Assets --------------------- */\n\n\t/** @internal */\n\t@computed private _getAllAssetsQuery() {\n\t\treturn this.store.query.records('asset')\n\t}\n\n\t/**\n\t * Get all assets in the editor.\n\t *\n\t * @public\n\t */\n\tgetAssets() {\n\t\treturn this._getAllAssetsQuery().get()\n\t}\n\n\t/**\n\t * Create one or more assets.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.createAssets([...myAssets])\n\t * ```\n\t *\n\t * @param assets - The assets to create.\n\t *\n\t * @public\n\t */\n\tcreateAssets(assets: TLAsset[]): this {\n\t\tif (this.getIsReadonly()) return this\n\t\tif (assets.length <= 0) return this\n\t\tthis.run(() => this.store.put(assets), { history: 'ignore' })\n\t\treturn this\n\t}\n\n\t/**\n\t * Update one or more assets.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.updateAssets([{ id: 'asset1', name: 'New name' }])\n\t * ```\n\t *\n\t * @param assets - The assets to update.\n\t *\n\t * @public\n\t */\n\tupdateAssets(assets: TLAssetPartial[]): this {\n\t\tif (this.getIsReadonly()) return this\n\t\tif (assets.length <= 0) return this\n\t\tthis.run(\n\t\t\t() => {\n\t\t\t\tthis.store.put(\n\t\t\t\t\tassets.map((partial) => ({\n\t\t\t\t\t\t...this.store.get(partial.id)!,\n\t\t\t\t\t\t...partial,\n\t\t\t\t\t}))\n\t\t\t\t)\n\t\t\t},\n\t\t\t{ history: 'ignore' }\n\t\t)\n\t\treturn this\n\t}\n\n\t/**\n\t * Delete one or more assets.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.deleteAssets(['asset1', 'asset2'])\n\t * ```\n\t *\n\t * @param assets - The assets (or asset ids) to delete.\n\t *\n\t * @public\n\t */\n\tdeleteAssets(assets: TLAssetId[] | TLAsset[]): this {\n\t\tif (this.getIsReadonly()) return this\n\n\t\tconst ids =\n\t\t\ttypeof assets[0] === 'string'\n\t\t\t\t? (assets as TLAssetId[])\n\t\t\t\t: (assets as TLAsset[]).map((a) => a.id)\n\t\tif (ids.length <= 0) return this\n\n\t\tthis.run(\n\t\t\t() => {\n\t\t\t\tthis.store.props.assets.remove?.(ids)\n\t\t\t\tthis.store.remove(ids)\n\t\t\t},\n\t\t\t{ history: 'ignore' }\n\t\t)\n\t\treturn this\n\t}\n\n\t/**\n\t * Get an asset by its id.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getAsset('asset1')\n\t * ```\n\t *\n\t * @param asset - The asset (or asset id) to get.\n\t *\n\t * @public\n\t */\n\tgetAsset<T extends TLAsset>(asset: T | T['id']): T | undefined {\n\t\treturn this.store.get(typeof asset === 'string' ? asset : asset.id) as T | undefined\n\t}\n\n\tasync resolveAssetUrl(\n\t\tassetId: TLAssetId | null,\n\t\tcontext: {\n\t\t\tscreenScale?: number\n\t\t\tshouldResolveToOriginal?: boolean\n\t\t\tdpr?: number\n\t\t}\n\t): Promise<string | null> {\n\t\tif (!assetId) return null\n\t\tconst asset = this.getAsset(assetId)\n\t\tif (!asset) return null\n\n\t\tconst {\n\t\t\tscreenScale = 1,\n\t\t\tshouldResolveToOriginal = false,\n\t\t\tdpr = this.getInstanceState().devicePixelRatio,\n\t\t} = context\n\n\t\t// We only look at the zoom level at powers of 2.\n\t\tconst zoomStepFunction = (zoom: number) => Math.pow(2, Math.ceil(Math.log2(zoom)))\n\t\tconst steppedScreenScale = zoomStepFunction(screenScale)\n\t\tconst networkEffectiveType: string | null =\n\t\t\t'connection' in navigator ? (navigator as any).connection.effectiveType : null\n\n\t\treturn await this.store.props.assets.resolve(asset, {\n\t\t\tscreenScale: screenScale || 1,\n\t\t\tsteppedScreenScale,\n\t\t\tdpr,\n\t\t\tnetworkEffectiveType,\n\t\t\tshouldResolveToOriginal,\n\t\t})\n\t}\n\t/**\n\t * Upload an asset to the store's asset service, returning a URL that can be used to resolve the\n\t * asset.\n\t */\n\tasync uploadAsset(\n\t\tasset: TLAsset,\n\t\tfile: File,\n\t\tabortSignal?: AbortSignal\n\t): Promise<{ src: string; meta?: JsonObject }> {\n\t\treturn await this.store.props.assets.upload(asset, file, abortSignal)\n\t}\n\n\t/* --------------------- Shapes --------------------- */\n\n\tprivate _shapeGeometryCaches: Record<string, ComputedCache<Geometry2d, TLShape>> = {}\n\n\t/**\n\t * Get the geometry of a shape in shape-space.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getShapeGeometry(myShape)\n\t * editor.getShapeGeometry(myShapeId)\n\t * editor.getShapeGeometry(myShapeId, { context: \"arrow\" })\n\t * ```\n\t *\n\t * @param shape - The shape (or shape id) to get the geometry for.\n\t * @param opts - Additional options about the request for geometry. Passed to {@link ShapeUtil.getGeometry}.\n\t *\n\t * @public\n\t */\n\tgetShapeGeometry<T extends Geometry2d>(shape: TLShape | TLShapeId, opts?: TLGeometryOpts): T {\n\t\tconst context = opts?.context ?? 'none'\n\t\tif (!this._shapeGeometryCaches[context]) {\n\t\t\tthis._shapeGeometryCaches[context] = this.store.createComputedCache(\n\t\t\t\t'bounds',\n\t\t\t\t(shape) => {\n\t\t\t\t\tthis.fonts.trackFontsForShape(shape)\n\t\t\t\t\treturn this.getShapeUtil(shape).getGeometry(shape, opts)\n\t\t\t\t},\n\t\t\t\t{ areRecordsEqual: areShapesContentEqual }\n\t\t\t)\n\t\t}\n\t\treturn this._shapeGeometryCaches[context].get(\n\t\t\ttypeof shape === 'string' ? shape : shape.id\n\t\t)! as T\n\t}\n\n\t/** @internal */\n\t@computed private _getShapeHandlesCache(): ComputedCache<TLHandle[] | undefined, TLShape> {\n\t\treturn this.store.createComputedCache(\n\t\t\t'handles',\n\t\t\t(shape) => {\n\t\t\t\treturn this.getShapeUtil(shape).getHandles?.(shape)\n\t\t\t},\n\t\t\t{\n\t\t\t\tareRecordsEqual: areShapesContentEqual,\n\t\t\t}\n\t\t)\n\t}\n\n\t/**\n\t * Get the handles (if any) for a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getShapeHandles(myShape)\n\t * editor.getShapeHandles(myShapeId)\n\t * ```\n\t *\n\t * @param shape - The shape (or shape id) to get the handles for.\n\t * @public\n\t */\n\tgetShapeHandles<T extends TLShape>(shape: T | T['id']): TLHandle[] | undefined {\n\t\treturn this._getShapeHandlesCache().get(typeof shape === 'string' ? shape : shape.id)\n\t}\n\n\t/**\n\t * Get the local transform for a shape as a matrix model. This transform reflects both its\n\t * translation (x, y) from from either its parent's top left corner, if the shape's parent is\n\t * another shape, or else from the 0,0 of the page, if the shape's parent is the page; and the\n\t * shape's rotation.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getShapeLocalTransform(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to get the local transform for.\n\t *\n\t * @public\n\t */\n\tgetShapeLocalTransform(shape: TLShape | TLShapeId): Mat {\n\t\tconst id = typeof shape === 'string' ? shape : shape.id\n\t\tconst freshShape = this.getShape(id)\n\t\tif (!freshShape) throw Error('Editor.getTransform: shape not found')\n\t\treturn Mat.Identity().translate(freshShape.x, freshShape.y).rotate(freshShape.rotation)\n\t}\n\n\t/**\n\t * A cache of page transforms.\n\t *\n\t * @internal\n\t */\n\t@computed private _getShapePageTransformCache(): ComputedCache<Mat, TLShape> {\n\t\treturn this.store.createComputedCache<Mat, TLShape>('pageTransformCache', (shape) => {\n\t\t\tif (isPageId(shape.parentId)) {\n\t\t\t\treturn this.getShapeLocalTransform(shape)\n\t\t\t}\n\n\t\t\t// If the shape's parent doesn't exist yet (e.g. when merging in changes from remote in the wrong order)\n\t\t\t// then we can't compute the transform yet, so just return the identity matrix.\n\t\t\t// In the future we should look at creating a store update mechanism that understands and preserves\n\t\t\t// ordering.\n\t\t\tconst parentTransform =\n\t\t\t\tthis._getShapePageTransformCache().get(shape.parentId) ?? Mat.Identity()\n\t\t\treturn Mat.Compose(parentTransform, this.getShapeLocalTransform(shape)!)\n\t\t})\n\t}\n\n\t/**\n\t * Get the local transform of a shape's parent as a matrix model.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getShapeParentTransform(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape (or shape id) to get the parent transform for.\n\t *\n\t * @public\n\t */\n\tgetShapeParentTransform(shape: TLShape | TLShapeId): Mat {\n\t\tconst id = typeof shape === 'string' ? shape : shape.id\n\t\tconst freshShape = this.getShape(id)\n\t\tif (!freshShape || isPageId(freshShape.parentId)) return Mat.Identity()\n\t\treturn this._getShapePageTransformCache().get(freshShape.parentId) ?? Mat.Identity()\n\t}\n\n\t/**\n\t * Get the transform of a shape in the current page space.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getShapePageTransform(myShape)\n\t * editor.getShapePageTransform(myShapeId)\n\t * ```\n\t *\n\t * @param shape - The shape (or shape id) to get the page transform for.\n\t *\n\t * @public\n\t */\n\tgetShapePageTransform(shape: TLShape | TLShapeId): Mat {\n\t\tconst id = typeof shape === 'string' ? shape : shape.id\n\t\treturn this._getShapePageTransformCache().get(id) ?? Mat.Identity()\n\t}\n\n\t/** @internal */\n\t@computed private _getShapePageBoundsCache(): ComputedCache<Box, TLShape> {\n\t\treturn this.store.createComputedCache<Box, TLShape>('pageBoundsCache', (shape) => {\n\t\t\tconst pageTransform = this.getShapePageTransform(shape)\n\t\t\tif (!pageTransform) return undefined\n\t\t\tconst geometry = this.getShapeGeometry(shape)\n\t\t\treturn Box.FromPoints(pageTransform.applyToPoints(geometry.vertices))\n\t\t})\n\t}\n\n\t/**\n\t * Get the bounds of a shape in the current page space.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getShapePageBounds(myShape)\n\t * editor.getShapePageBounds(myShapeId)\n\t * ```\n\t *\n\t * @param shape - The shape (or shape id) to get the bounds for.\n\t *\n\t * @public\n\t */\n\tgetShapePageBounds(shape: TLShape | TLShapeId): Box | undefined {\n\t\treturn this._getShapePageBoundsCache().get(typeof shape === 'string' ? shape : shape.id)\n\t}\n\n\t/**\n\t * A cache of clip paths used for clipping.\n\t *\n\t * @internal\n\t */\n\t@computed private _getShapeClipPathCache(): ComputedCache<string, TLShape> {\n\t\treturn this.store.createComputedCache<string, TLShape>('clipPathCache', (shape) => {\n\t\t\tconst pageMask = this._getShapeMaskCache().get(shape.id)\n\t\t\tif (!pageMask) return undefined\n\t\t\tif (pageMask.length === 0) {\n\t\t\t\treturn `polygon(0px 0px, 0px 0px, 0px 0px)`\n\t\t\t}\n\n\t\t\tconst pageTransform = this._getShapePageTransformCache().get(shape.id)\n\t\t\tif (!pageTransform) return undefined\n\n\t\t\tconst localMask = Mat.applyToPoints(Mat.Inverse(pageTransform), pageMask)\n\n\t\t\treturn `polygon(${localMask.map((p) => `${p.x}px ${p.y}px`).join(',')})`\n\t\t})\n\t}\n\n\t/**\n\t * Get the clip path for a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * const clipPath = editor.getShapeClipPath(shape)\n\t * const clipPath = editor.getShapeClipPath(shape.id)\n\t * ```\n\t *\n\t * @param shape - The shape (or shape id) to get the clip path for.\n\t *\n\t * @returns The clip path or undefined.\n\t *\n\t * @public\n\t */\n\tgetShapeClipPath(shape: TLShape | TLShapeId): string | undefined {\n\t\treturn this._getShapeClipPathCache().get(typeof shape === 'string' ? shape : shape.id)\n\t}\n\n\t/** @internal */\n\t@computed private _getShapeMaskCache(): ComputedCache<Vec[], TLShape> {\n\t\treturn this.store.createComputedCache('pageMaskCache', (shape) => {\n\t\t\tif (isPageId(shape.parentId)) return undefined\n\n\t\t\tconst frameAncestors = this.getShapeAncestors(shape.id).filter((shape) =>\n\t\t\t\tthis.isShapeOfType<TLFrameShape>(shape, 'frame')\n\t\t\t)\n\n\t\t\tif (frameAncestors.length === 0) return undefined\n\n\t\t\tconst pageMask = frameAncestors\n\t\t\t\t.map<Vec[] | undefined>((s) => {\n\t\t\t\t\t// Apply the frame transform to the frame outline to get the frame outline in the current page space\n\t\t\t\t\tconst geometry = this.getShapeGeometry(s.id)\n\t\t\t\t\tconst pageTransform = this.getShapePageTransform(s.id)\n\t\t\t\t\treturn pageTransform.applyToPoints(geometry.vertices)\n\t\t\t\t})\n\t\t\t\t.reduce((acc, b) => {\n\t\t\t\t\tif (!(b && acc)) return undefined\n\t\t\t\t\tconst intersection = intersectPolygonPolygon(acc, b)\n\t\t\t\t\tif (intersection) {\n\t\t\t\t\t\treturn intersection.map(Vec.Cast)\n\t\t\t\t\t}\n\t\t\t\t\treturn []\n\t\t\t\t})\n\n\t\t\treturn pageMask\n\t\t})\n\t}\n\n\t/**\n\t * Get the mask (in the current page space) for a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * const pageMask = editor.getShapeMask(shape.id)\n\t * ```\n\t *\n\t * @param shape - The shape (or the shape id) of the shape to get the mask for.\n\t *\n\t * @returns The mask for the shape.\n\t *\n\t * @public\n\t */\n\tgetShapeMask(shape: TLShapeId | TLShape): VecLike[] | undefined {\n\t\treturn this._getShapeMaskCache().get(typeof shape === 'string' ? shape : shape.id)\n\t}\n\n\t/**\n\t * Get the bounds of a shape in the current page space, incorporating any masks. For example, if the\n\t * shape were the child of a frame and was half way out of the frame, the bounds would be the half\n\t * of the shape that was in the frame.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getShapeMaskedPageBounds(myShape)\n\t * editor.getShapeMaskedPageBounds(myShapeId)\n\t * ```\n\t *\n\t * @param shape - The shape to get the masked bounds for.\n\t *\n\t * @public\n\t */\n\tgetShapeMaskedPageBounds(shape: TLShapeId | TLShape): Box | undefined {\n\t\tif (typeof shape !== 'string') shape = shape.id\n\t\treturn this._getShapeMaskedPageBoundsCache().get(shape)\n\t}\n\n\t/** @internal */\n\t@computed private _getShapeMaskedPageBoundsCache(): ComputedCache<Box, TLShape> {\n\t\treturn this.store.createComputedCache('shapeMaskedPageBoundsCache', (shape) => {\n\t\t\tconst pageBounds = this._getShapePageBoundsCache().get(shape.id)\n\t\t\tif (!pageBounds) return\n\t\t\tconst pageMask = this._getShapeMaskCache().get(shape.id)\n\t\t\tif (pageMask) {\n\t\t\t\tif (pageMask.length === 0) return undefined\n\t\t\t\tconst { corners } = pageBounds\n\t\t\t\tif (corners.every((p, i) => p && Vec.Equals(p, pageMask[i]))) return pageBounds.clone()\n\t\t\t\tconst intersection = intersectPolygonPolygon(pageMask, corners)\n\t\t\t\tif (!intersection) return\n\t\t\t\treturn Box.FromPoints(intersection)\n\t\t\t}\n\t\t\treturn pageBounds\n\t\t})\n\t}\n\n\t/**\n\t * Get the ancestors of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * const ancestors = editor.getShapeAncestors(myShape)\n\t * const ancestors = editor.getShapeAncestors(myShapeId)\n\t * ```\n\t *\n\t * @param shape - The shape (or shape id) to get the ancestors for.\n\t * @param acc - The accumulator.\n\t *\n\t * @public\n\t */\n\tgetShapeAncestors(shape: TLShapeId | TLShape, acc: TLShape[] = []): TLShape[] {\n\t\tconst id = typeof shape === 'string' ? shape : shape.id\n\t\tconst freshShape = this.getShape(id)\n\t\tif (!freshShape) return acc\n\t\tconst parentId = freshShape.parentId\n\t\tif (isPageId(parentId)) {\n\t\t\tacc.reverse()\n\t\t\treturn acc\n\t\t}\n\n\t\tconst parent = this.store.get(parentId)\n\t\tif (!parent) return acc\n\t\tacc.push(parent)\n\t\treturn this.getShapeAncestors(parent, acc)\n\t}\n\n\t/**\n\t * Find the first ancestor matching the given predicate\n\t *\n\t * @example\n\t * ```ts\n\t * const ancestor = editor.findShapeAncestor(myShape)\n\t * const ancestor = editor.findShapeAncestor(myShape.id)\n\t * const ancestor = editor.findShapeAncestor(myShape.id, (shape) => shape.type === 'frame')\n\t * ```\n\t *\n\t * @param shape - The shape to check the ancestors for.\n\t * @param predicate - The predicate to match.\n\t *\n\t * @public\n\t */\n\tfindShapeAncestor(\n\t\tshape: TLShape | TLShapeId,\n\t\tpredicate: (parent: TLShape) => boolean\n\t): TLShape | undefined {\n\t\tconst id = typeof shape === 'string' ? shape : shape.id\n\t\tconst freshShape = this.getShape(id)\n\t\tif (!freshShape) return\n\n\t\tconst parentId = freshShape.parentId\n\t\tif (isPageId(parentId)) return\n\n\t\tconst parent = this.getShape(parentId)\n\t\tif (!parent) return\n\t\treturn predicate(parent) ? parent : this.findShapeAncestor(parent, predicate)\n\t}\n\n\t/**\n\t * Returns true if the the given shape has the given ancestor.\n\t *\n\t * @param shape - The shape.\n\t * @param ancestorId - The id of the ancestor.\n\t *\n\t * @public\n\t */\n\thasAncestor(shape: TLShape | TLShapeId | undefined, ancestorId: TLShapeId): boolean {\n\t\tconst id = typeof shape === 'string' ? shape : shape?.id\n\t\tconst freshShape = id && this.getShape(id)\n\t\tif (!freshShape) return false\n\t\tif (freshShape.parentId === ancestorId) return true\n\t\treturn this.hasAncestor(this.getShapeParent(freshShape), ancestorId)\n\t}\n\n\t/**\n\t * Get the common ancestor of two or more shapes that matches a predicate.\n\t *\n\t * @param shapes - The shapes (or shape ids) to check.\n\t * @param predicate - The predicate to match.\n\t */\n\tfindCommonAncestor(\n\t\tshapes: TLShape[] | TLShapeId[],\n\t\tpredicate?: (shape: TLShape) => boolean\n\t): TLShapeId | undefined {\n\t\tif (shapes.length === 0) {\n\t\t\treturn\n\t\t}\n\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((s) => s.id)\n\t\tconst freshShapes = compact(ids.map((id) => this.getShape(id)))\n\n\t\tif (freshShapes.length === 1) {\n\t\t\tconst parentId = freshShapes[0].parentId\n\t\t\tif (isPageId(parentId)) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn predicate ? this.findShapeAncestor(freshShapes[0], predicate)?.id : parentId\n\t\t}\n\n\t\tconst [nodeA, ...others] = freshShapes\n\t\tlet ancestor = this.getShapeParent(nodeA)\n\t\twhile (ancestor) {\n\t\t\t// TODO: this is not ideal, optimize\n\t\t\tif (predicate && !predicate(ancestor)) {\n\t\t\t\tancestor = this.getShapeParent(ancestor)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif (others.every((shape) => this.hasAncestor(shape, ancestor!.id))) {\n\t\t\t\treturn ancestor!.id\n\t\t\t}\n\t\t\tancestor = this.getShapeParent(ancestor)\n\t\t}\n\t\treturn undefined\n\t}\n\n\t/**\n\t * Check whether a shape or its parent is locked.\n\t *\n\t * @param shape - The shape (or shape id) to check.\n\t *\n\t * @public\n\t */\n\tisShapeOrAncestorLocked(shape?: TLShape | TLShapeId): boolean {\n\t\tconst _shape = shape && this.getShape(shape)\n\t\tif (_shape === undefined) return false\n\t\tif (_shape.isLocked) return true\n\t\treturn this.isShapeOrAncestorLocked(this.getShapeParent(_shape))\n\t}\n\n\t/**\n\t * Get shapes that are outside of the viewport.\n\t *\n\t * @public\n\t */\n\t@computed\n\tgetNotVisibleShapes() {\n\t\treturn this._notVisibleShapes.get()\n\t}\n\n\tprivate _notVisibleShapes = notVisibleShapes(this)\n\n\t/**\n\t * Get culled shapes (those that should not render), taking into account which shapes are selected or editing.\n\t *\n\t * @public\n\t */\n\t@computed\n\tgetCulledShapes() {\n\t\tconst notVisibleShapes = this.getNotVisibleShapes()\n\t\tconst selectedShapeIds = this.getSelectedShapeIds()\n\t\tconst editingId = this.getEditingShapeId()\n\t\tconst culledShapes = new Set<TLShapeId>(notVisibleShapes)\n\t\t// we don't cull the shape we are editing\n\t\tif (editingId) {\n\t\t\tculledShapes.delete(editingId)\n\t\t}\n\t\t// we also don't cull selected shapes\n\t\tselectedShapeIds.forEach((id) => {\n\t\t\tculledShapes.delete(id)\n\t\t})\n\t\treturn culledShapes\n\t}\n\n\t/**\n\t * The bounds of the current page (the common bounds of all of the shapes on the page).\n\t *\n\t * @public\n\t */\n\t@computed getCurrentPageBounds(): Box | undefined {\n\t\tlet commonBounds: Box | undefined\n\n\t\tthis.getCurrentPageShapeIdsSorted().forEach((shapeId) => {\n\t\t\tconst bounds = this.getShapeMaskedPageBounds(shapeId)\n\t\t\tif (!bounds) return\n\t\t\tif (!commonBounds) {\n\t\t\t\tcommonBounds = bounds.clone()\n\t\t\t} else {\n\t\t\t\tcommonBounds = commonBounds.expand(bounds)\n\t\t\t}\n\t\t})\n\n\t\treturn commonBounds\n\t}\n\n\t/**\n\t * Get the top-most selected shape at the given point, ignoring groups.\n\t *\n\t * @param point - The point to check.\n\t *\n\t * @returns The top-most selected shape at the given point, or undefined if there is no shape at the point.\n\t */\n\tgetSelectedShapeAtPoint(point: VecLike): TLShape | undefined {\n\t\tconst selectedShapeIds = this.getSelectedShapeIds()\n\t\treturn this.getCurrentPageShapesSorted()\n\t\t\t.filter((shape) => shape.type !== 'group' && selectedShapeIds.includes(shape.id))\n\t\t\t.reverse() // find last\n\t\t\t.find((shape) => this.isPointInShape(shape, point, { hitInside: true, margin: 0 }))\n\t}\n\n\t/**\n\t * Get the shape at the current point.\n\t *\n\t * @param point - The point to check.\n\t * @param opts - Options for the check: `hitInside` to check if the point is inside the shape, `margin` to check if the point is within a margin of the shape, `hitFrameInside` to check if the point is inside the frame, and `filter` to filter the shapes to check.\n\t *\n\t * @returns The shape at the given point, or undefined if there is no shape at the point.\n\t */\n\tgetShapeAtPoint(\n\t\tpoint: VecLike,\n\t\topts = {} as {\n\t\t\trenderingOnly?: boolean\n\t\t\tmargin?: number\n\t\t\thitInside?: boolean\n\t\t\thitLocked?: boolean\n\t\t\t// TODO: we probably need to rename this, we don't quite _always_\n\t\t\t// respect this esp. in the part below that does \"Check labels first\"\n\t\t\thitLabels?: boolean\n\t\t\thitFrameInside?: boolean\n\t\t\tfilter?(shape: TLShape): boolean\n\t\t}\n\t): TLShape | undefined {\n\t\tconst zoomLevel = this.getZoomLevel()\n\t\tconst viewportPageBounds = this.getViewportPageBounds()\n\t\tconst {\n\t\t\tfilter,\n\t\t\tmargin = 0,\n\t\t\thitLocked = false,\n\t\t\thitLabels = false,\n\t\t\thitInside = false,\n\t\t\thitFrameInside = false,\n\t\t} = opts\n\n\t\tlet inHollowSmallestArea = Infinity\n\t\tlet inHollowSmallestAreaHit: TLShape | null = null\n\n\t\tlet inMarginClosestToEdgeDistance = Infinity\n\t\tlet inMarginClosestToEdgeHit: TLShape | null = null\n\n\t\tconst shapesToCheck = (\n\t\t\topts.renderingOnly\n\t\t\t\t? this.getCurrentPageRenderingShapesSorted()\n\t\t\t\t: this.getCurrentPageShapesSorted()\n\t\t).filter((shape) => {\n\t\t\tif (\n\t\t\t\t(shape.isLocked && !hitLocked) ||\n\t\t\t\tthis.isShapeHidden(shape) ||\n\t\t\t\tthis.isShapeOfType(shape, 'group')\n\t\t\t)\n\t\t\t\treturn false\n\t\t\tconst pageMask = this.getShapeMask(shape)\n\t\t\tif (pageMask && !pointInPolygon(point, pageMask)) return false\n\t\t\tif (filter) return filter(shape)\n\t\t\treturn true\n\t\t})\n\n\t\tfor (let i = shapesToCheck.length - 1; i >= 0; i--) {\n\t\t\tconst shape = shapesToCheck[i]\n\t\t\tconst geometry = this.getShapeGeometry(shape)\n\t\t\tconst isGroup = geometry instanceof Group2d\n\n\t\t\tconst pointInShapeSpace = this.getPointInShapeSpace(shape, point)\n\n\t\t\t// Check labels first\n\t\t\tif (\n\t\t\t\tthis.isShapeOfType<TLFrameShape>(shape, 'frame') ||\n\t\t\t\t(this.isShapeOfType<TLArrowShape>(shape, 'arrow') && shape.props.text.trim()) ||\n\t\t\t\t((this.isShapeOfType<TLNoteShape>(shape, 'note') ||\n\t\t\t\t\t(this.isShapeOfType<TLGeoShape>(shape, 'geo') && shape.props.fill === 'none')) &&\n\t\t\t\t\tthis.getShapeUtil(shape).getText(shape)?.trim())\n\t\t\t) {\n\t\t\t\tfor (const childGeometry of (geometry as Group2d).children) {\n\t\t\t\t\tif (childGeometry.isLabel && childGeometry.isPointInBounds(pointInShapeSpace)) {\n\t\t\t\t\t\treturn shape\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.isShapeOfType(shape, 'frame')) {\n\t\t\t\t// On the rare case that we've hit a frame (not its label), test again hitInside to be forced true;\n\t\t\t\t// this prevents clicks from passing through the body of a frame to shapes behind it.\n\n\t\t\t\t// If the hit is within the frame's outer margin, then select the frame\n\t\t\t\tconst distance = geometry.distanceToPoint(pointInShapeSpace, hitInside)\n\t\t\t\tif (Math.abs(distance) <= margin) {\n\t\t\t\t\treturn inMarginClosestToEdgeHit || shape\n\t\t\t\t}\n\n\t\t\t\tif (geometry.hitTestPoint(pointInShapeSpace, 0, true)) {\n\t\t\t\t\t// Once we've hit a frame, we want to end the search. If we have hit a shape\n\t\t\t\t\t// already, then this would either be above the frame or a child of the frame,\n\t\t\t\t\t// so we want to return that. Otherwise, the point is in the empty space of the\n\t\t\t\t\t// frame. If `hitFrameInside` is true (e.g. used drawing an arrow into the\n\t\t\t\t\t// frame) we the frame itself; other wise, (e.g. when hovering or pointing)\n\t\t\t\t\t// we would want to return null.\n\t\t\t\t\treturn (\n\t\t\t\t\t\tinMarginClosestToEdgeHit ||\n\t\t\t\t\t\tinHollowSmallestAreaHit ||\n\t\t\t\t\t\t(hitFrameInside ? shape : undefined)\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tlet distance: number\n\n\t\t\tif (isGroup) {\n\t\t\t\tlet minDistance = Infinity\n\t\t\t\tfor (const childGeometry of geometry.children) {\n\t\t\t\t\tif (childGeometry.isLabel && !hitLabels) continue\n\n\t\t\t\t\t// hit test the all of the child geometries that aren't labels\n\t\t\t\t\tconst tDistance = childGeometry.distanceToPoint(pointInShapeSpace, hitInside)\n\t\t\t\t\tif (tDistance < minDistance) {\n\t\t\t\t\t\tminDistance = tDistance\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdistance = minDistance\n\t\t\t} else {\n\t\t\t\t// If the margin is zero and the geometry has a very small width or height,\n\t\t\t\t// then check the actual distance. This is to prevent a bug where straight\n\t\t\t\t// lines would never pass the broad phase (point-in-bounds) check.\n\t\t\t\tif (margin === 0 && (geometry.bounds.w < 1 || geometry.bounds.h < 1)) {\n\t\t\t\t\tdistance = geometry.distanceToPoint(pointInShapeSpace, hitInside)\n\t\t\t\t} else {\n\t\t\t\t\t// Broad phase\n\t\t\t\t\tif (geometry.bounds.containsPoint(pointInShapeSpace, margin)) {\n\t\t\t\t\t\t// Narrow phase (actual distance)\n\t\t\t\t\t\tdistance = geometry.distanceToPoint(pointInShapeSpace, hitInside)\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Failed the broad phase, geddafugaotta'ere!\n\t\t\t\t\t\tdistance = Infinity\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (geometry.isClosed) {\n\t\t\t\t// For closed shapes, the distance will be positive if outside of\n\t\t\t\t// the shape or negative if inside of the shape. If the distance\n\t\t\t\t// is greater than the margin, then it's a miss. Otherwise...\n\n\t\t\t\tif (distance <= margin) {\n\t\t\t\t\tif (geometry.isFilled || (isGroup && geometry.children[0].isFilled)) {\n\t\t\t\t\t\t// If the shape is filled, then it's a hit. Remember, we're\n\t\t\t\t\t\t// starting from the TOP-MOST shape in z-index order, so any\n\t\t\t\t\t\t// other hits would be occluded by the shape.\n\t\t\t\t\t\treturn inMarginClosestToEdgeHit || shape\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If the shape is bigger than the viewport, then skip it.\n\t\t\t\t\t\tif (this.getShapePageBounds(shape)!.contains(viewportPageBounds)) continue\n\n\t\t\t\t\t\t// For hollow shapes...\n\t\t\t\t\t\tif (Math.abs(distance) < margin) {\n\t\t\t\t\t\t\t// We want to preference shapes where we're inside of the\n\t\t\t\t\t\t\t// shape margin; and we would want to hit the shape with the\n\t\t\t\t\t\t\t// edge closest to the point.\n\t\t\t\t\t\t\tif (Math.abs(distance) < inMarginClosestToEdgeDistance) {\n\t\t\t\t\t\t\t\tinMarginClosestToEdgeDistance = Math.abs(distance)\n\t\t\t\t\t\t\t\tinMarginClosestToEdgeHit = shape\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (!inMarginClosestToEdgeHit) {\n\t\t\t\t\t\t\t// If we're not within margin distance to any edge, and if the\n\t\t\t\t\t\t\t// shape is hollow, then we want to hit the shape with the\n\t\t\t\t\t\t\t// smallest area. (There's a bug here with self-intersecting\n\t\t\t\t\t\t\t// shapes, like a closed drawing of an \"8\", but that's a bigger\n\t\t\t\t\t\t\t// problem to solve.)\n\t\t\t\t\t\t\tconst { area } = geometry\n\t\t\t\t\t\t\tif (area < inHollowSmallestArea) {\n\t\t\t\t\t\t\t\tinHollowSmallestArea = area\n\t\t\t\t\t\t\t\tinHollowSmallestAreaHit = shape\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// For open shapes (e.g. lines or draw shapes) always use the margin.\n\t\t\t\t// If the distance is less than the margin, return the shape as the hit.\n\t\t\t\tif (distance < this.options.hitTestMargin / zoomLevel) {\n\t\t\t\t\treturn shape\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If we haven't hit any filled shapes or frames, then return either\n\t\t// the shape who we hit within the margin (and of those, the one that\n\t\t// had the shortest distance between the point and the shape edge),\n\t\t// or else the hollow shape with the smallest areaor if we didn't hit\n\t\t// any margins or any hollow shapes, then null.\n\t\treturn inMarginClosestToEdgeHit || inHollowSmallestAreaHit || undefined\n\t}\n\n\t/**\n\t * Get the shapes, if any, at a given page point.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getShapesAtPoint({ x: 100, y: 100 })\n\t * editor.getShapesAtPoint({ x: 100, y: 100 }, { hitInside: true, margin: 8 })\n\t * ```\n\t *\n\t * @param point - The page point to test.\n\t * @param opts - The options for the hit point testing.\n\t *\n\t * @returns An array of shapes at the given point, sorted in reverse order of their absolute z-index (top-most shape first).\n\t *\n\t * @public\n\t */\n\tgetShapesAtPoint(\n\t\tpoint: VecLike,\n\t\topts = {} as { margin?: number; hitInside?: boolean }\n\t): TLShape[] {\n\t\treturn this.getCurrentPageShapesSorted()\n\t\t\t.filter((shape) => !this.isShapeHidden(shape) && this.isPointInShape(shape, point, opts))\n\t\t\t.reverse()\n\t}\n\n\t/**\n\t * Test whether a point (in the current page space) will will a shape. This method takes into account masks,\n\t * such as when a shape is the child of a frame and is partially clipped by the frame.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.isPointInShape({ x: 100, y: 100 }, myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to test against.\n\t * @param point - The page point to test (in the current page space).\n\t * @param opts - The options for the hit point testing.\n\t *\n\t * @public\n\t */\n\tisPointInShape(\n\t\tshape: TLShape | TLShapeId,\n\t\tpoint: VecLike,\n\t\topts = {} as {\n\t\t\tmargin?: number\n\t\t\thitInside?: boolean\n\t\t}\n\t): boolean {\n\t\tconst { hitInside = false, margin = 0 } = opts\n\t\tconst id = typeof shape === 'string' ? shape : shape.id\n\t\t// If the shape is masked, and if the point falls outside of that\n\t\t// mask, then it's definitely a misswe don't need to test further.\n\t\tconst pageMask = this.getShapeMask(id)\n\t\tif (pageMask && !pointInPolygon(point, pageMask)) return false\n\n\t\treturn this.getShapeGeometry(id).hitTestPoint(\n\t\t\tthis.getPointInShapeSpace(shape, point),\n\t\t\tmargin,\n\t\t\thitInside\n\t\t)\n\t}\n\n\t/**\n\t * Convert a point in the current page space to a point in the local space of a shape. For example, if a\n\t * shape's page point were `{ x: 100, y: 100 }`, a page point at `{ x: 110, y: 110 }` would be at\n\t * `{ x: 10, y: 10 }` in the shape's local space.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getPointInShapeSpace(myShape, { x: 100, y: 100 })\n\t * ```\n\t *\n\t * @param shape - The shape to get the point in the local space of.\n\t * @param point - The page point to get in the local space of the shape.\n\t *\n\t * @public\n\t */\n\tgetPointInShapeSpace(shape: TLShape | TLShapeId, point: VecLike): Vec {\n\t\tconst id = typeof shape === 'string' ? shape : shape.id\n\t\treturn this._getShapePageTransformCache().get(id)!.clone().invert().applyToPoint(point)\n\t}\n\n\t/**\n\t * Convert a delta in the current page space to a point in the local space of a shape's parent.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getPointInParentSpace(myShape.id, { x: 100, y: 100 })\n\t * ```\n\t *\n\t * @param shape - The shape to get the point in the local space of.\n\t * @param point - The page point to get in the local space of the shape.\n\t *\n\t * @public\n\t */\n\tgetPointInParentSpace(shape: TLShapeId | TLShape, point: VecLike): Vec {\n\t\tconst id = typeof shape === 'string' ? shape : shape.id\n\t\tconst freshShape = this.getShape(id)\n\t\tif (!freshShape) return new Vec(0, 0)\n\t\tif (isPageId(freshShape.parentId)) return Vec.From(point)\n\n\t\tconst parentTransform = this.getShapePageTransform(freshShape.parentId)\n\t\tif (!parentTransform) return Vec.From(point)\n\t\treturn parentTransform.clone().invert().applyToPoint(point)\n\t}\n\n\t/**\n\t * An array containing all of the shapes in the current page.\n\t *\n\t * @public\n\t */\n\t@computed getCurrentPageShapes(): TLShape[] {\n\t\treturn Array.from(this.getCurrentPageShapeIds(), (id) => this.store.get(id)! as TLShape)\n\t}\n\n\t/**\n\t * An array containing all of the shapes in the current page, sorted in z-index order (accounting\n\t * for nested shapes): e.g. A, B, BA, BB, C.\n\t *\n\t * @public\n\t */\n\t@computed getCurrentPageShapesSorted(): TLShape[] {\n\t\tconst result: TLShape[] = []\n\t\tconst topLevelShapes = this.getSortedChildIdsForParent(this.getCurrentPageId())\n\n\t\tfor (let i = 0, n = topLevelShapes.length; i < n; i++) {\n\t\t\tpushShapeWithDescendants(this, topLevelShapes[i], result)\n\t\t}\n\n\t\treturn result\n\t}\n\n\t/**\n\t * An array containing all of the rendering shapes in the current page, sorted in z-index order (accounting\n\t * for nested shapes): e.g. A, B, BA, BB, C.\n\t *\n\t * @public\n\t */\n\t@computed getCurrentPageRenderingShapesSorted(): TLShape[] {\n\t\tconst culledShapes = this.getCulledShapes()\n\t\treturn this.getCurrentPageShapesSorted().filter(\n\t\t\t({ id }) => !culledShapes.has(id) && !this.isShapeHidden(id)\n\t\t)\n\t}\n\n\t/**\n\t * Get whether a shape matches the type of a TLShapeUtil.\n\t *\n\t * @example\n\t * ```ts\n\t * const isArrowShape = isShapeOfType<TLArrowShape>(someShape, 'arrow')\n\t * ```\n\t *\n\t * @param util - the TLShapeUtil constructor to test against\n\t * @param shape - the shape to test\n\t *\n\t * @public\n\t */\n\tisShapeOfType<T extends TLUnknownShape>(shape: TLUnknownShape, type: T['type']): shape is T\n\tisShapeOfType<T extends TLUnknownShape>(\n\t\tshapeId: TLUnknownShape['id'],\n\t\ttype: T['type']\n\t): shapeId is T['id']\n\tisShapeOfType<T extends TLUnknownShape>(\n\t\targ: TLUnknownShape | TLUnknownShape['id'],\n\t\ttype: T['type']\n\t) {\n\t\tconst shape = typeof arg === 'string' ? this.getShape(arg) : arg\n\t\tif (!shape) return false\n\t\treturn shape.type === type\n\t}\n\n\t/**\n\t * Get a shape by its id.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getShape('box1')\n\t * ```\n\t *\n\t * @param shape - The shape (or the id of the shape) to get.\n\t *\n\t * @public\n\t */\n\tgetShape<T extends TLShape = TLShape>(shape: TLShape | TLParentId): T | undefined {\n\t\tconst id = typeof shape === 'string' ? shape : shape.id\n\t\tif (!isShapeId(id)) return undefined\n\t\treturn this.store.get(id) as T\n\t}\n\n\t/**\n\t * Get the parent shape for a given shape. Returns undefined if the shape is the direct child of\n\t * the page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getShapeParent(myShape)\n\t * ```\n\t *\n\t * @public\n\t */\n\tgetShapeParent(shape?: TLShape | TLShapeId): TLShape | undefined {\n\t\tconst id = typeof shape === 'string' ? shape : shape?.id\n\t\tif (!id) return undefined\n\t\tconst freshShape = this.getShape(id)\n\t\tif (freshShape === undefined || !isShapeId(freshShape.parentId)) return undefined\n\t\treturn this.getShape(freshShape.parentId)\n\t}\n\n\t/**\n\t * If siblingShape and targetShape are siblings, this returns targetShape. If targetShape has an\n\t * ancestor who is a sibling of siblingShape, this returns that ancestor. Otherwise, this returns\n\t * undefined.\n\t *\n\t * @internal\n\t */\n\tgetShapeNearestSibling(\n\t\tsiblingShape: TLShape,\n\t\ttargetShape: TLShape | undefined\n\t): TLShape | undefined {\n\t\tif (!targetShape) {\n\t\t\treturn undefined\n\t\t}\n\t\tif (targetShape.parentId === siblingShape.parentId) {\n\t\t\treturn targetShape\n\t\t}\n\n\t\tconst ancestor = this.findShapeAncestor(\n\t\t\ttargetShape,\n\t\t\t(ancestor) => ancestor.parentId === siblingShape.parentId\n\t\t)\n\n\t\treturn ancestor\n\t}\n\n\t/**\n\t * Get whether the given shape is the descendant of the given page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.isShapeInPage(myShape)\n\t * editor.isShapeInPage(myShape, 'page1')\n\t * ```\n\t *\n\t * @param shape - The shape to check.\n\t * @param pageId - The id of the page to check against. Defaults to the current page.\n\t *\n\t * @public\n\t */\n\tisShapeInPage(shape: TLShape | TLShapeId, pageId = this.getCurrentPageId()): boolean {\n\t\tconst id = typeof shape === 'string' ? shape : shape.id\n\t\tconst shapeToCheck = this.getShape(id)\n\t\tif (!shapeToCheck) return false\n\n\t\tlet shapeIsInPage = false\n\n\t\tif (shapeToCheck.parentId === pageId) {\n\t\t\tshapeIsInPage = true\n\t\t} else {\n\t\t\tlet parent = this.getShape(shapeToCheck.parentId)\n\t\t\tisInPageSearch: while (parent) {\n\t\t\t\tif (parent.parentId === pageId) {\n\t\t\t\t\tshapeIsInPage = true\n\t\t\t\t\tbreak isInPageSearch\n\t\t\t\t}\n\t\t\t\tparent = this.getShape(parent.parentId)\n\t\t\t}\n\t\t}\n\n\t\treturn shapeIsInPage\n\t}\n\n\t/**\n\t * Get the id of the containing page for a given shape.\n\t *\n\t * @param shape - The shape to get the page id for.\n\t *\n\t * @returns The id of the page that contains the shape, or undefined if the shape is undefined.\n\t *\n\t * @public\n\t */\n\tgetAncestorPageId(shape?: TLShape | TLShapeId): TLPageId | undefined {\n\t\tconst id = typeof shape === 'string' ? shape : shape?.id\n\t\tconst _shape = id && this.getShape(id)\n\t\tif (!_shape) return undefined\n\t\tif (isPageId(_shape.parentId)) {\n\t\t\treturn _shape.parentId\n\t\t} else {\n\t\t\treturn this.getAncestorPageId(this.getShape(_shape.parentId))\n\t\t}\n\t}\n\n\t// Parents and children\n\n\t/**\n\t * A cache of parents to children.\n\t *\n\t * @internal\n\t */\n\tprivate readonly _parentIdsToChildIds: ReturnType<typeof parentsToChildren>\n\n\t/**\n\t * Reparent shapes to a new parent. This operation preserves the shape's current page positions /\n\t * rotations.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.reparentShapes([box1, box2], 'frame1')\n\t * editor.reparentShapes([box1.id, box2.id], 'frame1')\n\t * editor.reparentShapes([box1.id, box2.id], 'frame1', 4)\n\t * ```\n\t *\n\t * @param shapes - The shapes (or shape ids) of the shapes to reparent.\n\t * @param parentId - The id of the new parent shape.\n\t * @param insertIndex - The index to insert the children.\n\t *\n\t * @public\n\t */\n\treparentShapes(shapes: TLShapeId[] | TLShape[], parentId: TLParentId, insertIndex?: IndexKey) {\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string' ? (shapes as TLShapeId[]) : shapes.map((s) => (s as TLShape).id)\n\t\tif (ids.length === 0) return this\n\n\t\tconst changes: TLShapePartial[] = []\n\n\t\tconst parentTransform = isPageId(parentId)\n\t\t\t? Mat.Identity()\n\t\t\t: this.getShapePageTransform(parentId)!\n\n\t\tconst parentPageRotation = parentTransform.rotation()\n\n\t\tlet indices: IndexKey[] = []\n\n\t\tconst sibs = compact(this.getSortedChildIdsForParent(parentId).map((id) => this.getShape(id)))\n\n\t\tif (insertIndex) {\n\t\t\tconst sibWithInsertIndex = sibs.find((s) => s.index === insertIndex)\n\t\t\tif (sibWithInsertIndex) {\n\t\t\t\t// If there's a sibling with the same index as the insert index...\n\t\t\t\tconst sibAbove = sibs[sibs.indexOf(sibWithInsertIndex) + 1]\n\t\t\t\tif (sibAbove) {\n\t\t\t\t\t// If the sibling has a sibling above it, insert the shapes\n\t\t\t\t\t// between the sibling and its sibling above it.\n\t\t\t\t\tindices = getIndicesBetween(insertIndex, sibAbove.index, ids.length)\n\t\t\t\t} else {\n\t\t\t\t\t// Or if the sibling is the top sibling, insert the shapes\n\t\t\t\t\t// above the sibling\n\t\t\t\t\tindices = getIndicesAbove(insertIndex, ids.length)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If there's no collision, then we can start at the insert index\n\t\t\t\tconst sibAbove = sibs.sort(sortByIndex).find((s) => s.index > insertIndex)\n\n\t\t\t\tif (sibAbove) {\n\t\t\t\t\t// If the siblings include a sibling with a higher index, insert the shapes\n\t\t\t\t\t// between the insert index and the sibling with the higher index.\n\t\t\t\t\tindices = getIndicesBetween(insertIndex, sibAbove.index, ids.length)\n\t\t\t\t} else {\n\t\t\t\t\t// Otherwise, we're at the top of the order, so insert the shapes above\n\t\t\t\t\t// the insert index.\n\t\t\t\t\tindices = getIndicesAbove(insertIndex, ids.length)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// If insert index is not specified, start the index at the top.\n\t\t\tconst sib = sibs.length && sibs[sibs.length - 1]\n\t\t\tindices = sib ? getIndicesAbove(sib.index, ids.length) : getIndices(ids.length)\n\t\t}\n\n\t\tconst invertedParentTransform = parentTransform.clone().invert()\n\n\t\tconst shapesToReparent = compact(ids.map((id) => this.getShape(id))).sort(sortByIndex)\n\n\t\t// Ignore locked shapes so that we can reparent locked shapes, for example\n\t\t// when a locked shape's parent is deleted.\n\t\tthis.run(\n\t\t\t() => {\n\t\t\t\tfor (let i = 0; i < shapesToReparent.length; i++) {\n\t\t\t\t\tconst shape = shapesToReparent[i]\n\n\t\t\t\t\tconst pageTransform = this.getShapePageTransform(shape)!\n\t\t\t\t\tif (!pageTransform) continue\n\n\t\t\t\t\tconst pagePoint = pageTransform.point()\n\t\t\t\t\tif (!pagePoint) continue\n\n\t\t\t\t\tconst newPoint = invertedParentTransform.applyToPoint(pagePoint)\n\t\t\t\t\tconst newRotation = pageTransform.rotation() - parentPageRotation\n\n\t\t\t\t\tif (shape.id === parentId) {\n\t\t\t\t\t\tthrow Error('Attempted to reparent a shape to itself!')\n\t\t\t\t\t}\n\n\t\t\t\t\tchanges.push({\n\t\t\t\t\t\tid: shape.id,\n\t\t\t\t\t\ttype: shape.type,\n\t\t\t\t\t\tparentId: parentId,\n\t\t\t\t\t\tx: newPoint.x,\n\t\t\t\t\t\ty: newPoint.y,\n\t\t\t\t\t\trotation: newRotation,\n\t\t\t\t\t\tindex: indices[i],\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\tthis.updateShapes(changes)\n\t\t\t},\n\t\t\t{ ignoreShapeLock: true }\n\t\t)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Get the index above the highest child of a given parent.\n\t *\n\t * @param parent - The parent (or the id) of the parent.\n\t *\n\t * @returns The index.\n\t *\n\t * @public\n\t */\n\tgetHighestIndexForParent(parent: TLParentId | TLPage | TLShape): IndexKey {\n\t\tconst parentId = typeof parent === 'string' ? parent : parent.id\n\t\tconst children = this._parentIdsToChildIds.get()[parentId]\n\n\t\tif (!children || children.length === 0) {\n\t\t\treturn 'a1' as IndexKey\n\t\t}\n\t\tconst shape = this.getShape(children[children.length - 1])!\n\t\treturn getIndexAbove(shape.index)\n\t}\n\n\t/**\n\t * Get an array of all the children of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getSortedChildIdsForParent('frame1')\n\t * ```\n\t *\n\t * @param parent - The parent (or the id) of the parent shape.\n\t *\n\t * @public\n\t */\n\tgetSortedChildIdsForParent(parent: TLParentId | TLPage | TLShape): TLShapeId[] {\n\t\tconst parentId = typeof parent === 'string' ? parent : parent.id\n\t\tconst ids = this._parentIdsToChildIds.get()[parentId]\n\t\tif (!ids) return EMPTY_ARRAY\n\t\treturn ids\n\t}\n\n\t/**\n\t * Run a visitor function for all descendants of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.visitDescendants('frame1', myCallback)\n\t * ```\n\t *\n\t * @param parent - The parent (or the id) of the parent shape.\n\t * @param visitor - The visitor function.\n\t *\n\t * @public\n\t */\n\tvisitDescendants(\n\t\tparent: TLParentId | TLPage | TLShape,\n\t\tvisitor: (id: TLShapeId) => void | false\n\t): this {\n\t\tconst children = this.getSortedChildIdsForParent(parent)\n\t\tfor (const id of children) {\n\t\t\tif (visitor(id) === false) continue\n\t\t\tthis.visitDescendants(id, visitor)\n\t\t}\n\t\treturn this\n\t}\n\n\t/**\n\t * Get the shape ids of all descendants of the given shapes (including the shapes themselves). IDs are returned in z-index order.\n\t *\n\t * @param ids - The ids of the shapes to get descendants of.\n\t *\n\t * @returns The descendant ids.\n\t *\n\t * @public\n\t */\n\tgetShapeAndDescendantIds(ids: TLShapeId[]): Set<TLShapeId> {\n\t\tconst shapeIds = new Set<TLShapeId>()\n\t\tfor (const shape of ids.map((id) => this.getShape(id)!).sort(sortByIndex)) {\n\t\t\tshapeIds.add(shape.id)\n\t\t\tthis.visitDescendants(shape, (descendantId) => {\n\t\t\t\tshapeIds.add(descendantId)\n\t\t\t})\n\t\t}\n\t\treturn shapeIds\n\t}\n\n\t/** @deprecated Use {@link Editor.getDraggingOverShape} instead */\n\tgetDroppingOverShape(point: Vec, droppingShapes: TLShape[]): TLShape | undefined {\n\t\treturn this.getDraggingOverShape(point, droppingShapes)\n\t}\n\n\t/**\n\t * Get the shape that some shapes should be dropped on at a given point.\n\t *\n\t * @param point - The point to find the parent for.\n\t * @param droppingShapes - The shapes that are being dropped.\n\t *\n\t * @returns The shape to drop on.\n\t *\n\t * @public\n\t */\n\tgetDraggingOverShape(point: Vec, droppingShapes: TLShape[]): TLShape | undefined {\n\t\t// get fresh moving shapes\n\t\tconst draggingShapes = compact(droppingShapes.map((s) => this.getShape(s))).filter(\n\t\t\t(s) => !s.isLocked && !this.isShapeHidden(s)\n\t\t)\n\n\t\tconst maybeDraggingOverShapes = this.getShapesAtPoint(point, {\n\t\t\thitInside: true,\n\t\t\tmargin: 0,\n\t\t}).filter(\n\t\t\t(s) =>\n\t\t\t\t!droppingShapes.includes(s) &&\n\t\t\t\t!s.isLocked &&\n\t\t\t\t!this.isShapeHidden(s) &&\n\t\t\t\t!draggingShapes.includes(s)\n\t\t)\n\n\t\tfor (const maybeDraggingOverShape of maybeDraggingOverShapes) {\n\t\t\tconst shapeUtil = this.getShapeUtil(maybeDraggingOverShape)\n\t\t\t// Any shape that can handle any dragging interactions is a valid target\n\t\t\tif (\n\t\t\t\tshapeUtil.onDragShapesOver ||\n\t\t\t\tshapeUtil.onDragShapesIn ||\n\t\t\t\tshapeUtil.onDragShapesOut ||\n\t\t\t\tshapeUtil.onDropShapesOver\n\t\t\t) {\n\t\t\t\treturn maybeDraggingOverShape\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the shape that should be selected when you click on a given shape, assuming there is\n\t * nothing already selected. It will not return anything higher than or including the current\n\t * focus layer.\n\t *\n\t * @param shape - The shape to get the outermost selectable shape for.\n\t * @param filter - A function to filter the selectable shapes.\n\t *\n\t * @returns The outermost selectable shape.\n\t *\n\t * @public\n\t */\n\tgetOutermostSelectableShape(\n\t\tshape: TLShape | TLShapeId,\n\t\tfilter?: (shape: TLShape) => boolean\n\t): TLShape {\n\t\tconst id = typeof shape === 'string' ? shape : shape.id\n\t\tconst freshShape = this.getShape(id)!\n\t\tlet match = freshShape\n\t\tlet node = freshShape as TLShape | undefined\n\n\t\tconst focusedGroup = this.getFocusedGroup()\n\n\t\twhile (node) {\n\t\t\tif (\n\t\t\t\tthis.isShapeOfType<TLGroupShape>(node, 'group') &&\n\t\t\t\tfocusedGroup?.id !== node.id &&\n\t\t\t\t!this.hasAncestor(focusedGroup, node.id) &&\n\t\t\t\t(filter?.(node) ?? true)\n\t\t\t) {\n\t\t\t\tmatch = node\n\t\t\t} else if (focusedGroup?.id === node.id) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tnode = this.getShapeParent(node)\n\t\t}\n\n\t\treturn match\n\t}\n\n\t/* -------------------- Bindings -------------------- */\n\n\t@computed\n\tprivate _getBindingsIndexCache() {\n\t\tconst index = bindingsIndex(this)\n\t\treturn this.store.createComputedCache<TLBinding[], TLShape>(\n\t\t\t'bindingsIndex',\n\t\t\t(shape) => {\n\t\t\t\treturn index.get().get(shape.id)\n\t\t\t},\n\t\t\t// we can ignore the shape equality check here because the index is\n\t\t\t// computed incrementally based on what bindings are in the store\n\t\t\t{ areRecordsEqual: () => true }\n\t\t)\n\t}\n\n\t/**\n\t * Get a binding from the store by its ID if it exists.\n\t */\n\tgetBinding(id: TLBindingId): TLBinding | undefined {\n\t\treturn this.store.get(id) as TLBinding | undefined\n\t}\n\n\t/**\n\t * Get all bindings of a certain type _from_ a particular shape. These are the bindings whose\n\t * `fromId` matched the shape's ID.\n\t */\n\tgetBindingsFromShape<Binding extends TLUnknownBinding = TLBinding>(\n\t\tshape: TLShape | TLShapeId,\n\t\ttype: Binding['type']\n\t): Binding[] {\n\t\tconst id = typeof shape === 'string' ? shape : shape.id\n\t\treturn this.getBindingsInvolvingShape(id).filter(\n\t\t\t(b) => b.fromId === id && b.type === type\n\t\t) as Binding[]\n\t}\n\n\t/**\n\t * Get all bindings of a certain type _to_ a particular shape. These are the bindings whose\n\t * `toId` matches the shape's ID.\n\t */\n\tgetBindingsToShape<Binding extends TLUnknownBinding = TLBinding>(\n\t\tshape: TLShape | TLShapeId,\n\t\ttype: Binding['type']\n\t): Binding[] {\n\t\tconst id = typeof shape === 'string' ? shape : shape.id\n\t\treturn this.getBindingsInvolvingShape(id).filter(\n\t\t\t(b) => b.toId === id && b.type === type\n\t\t) as Binding[]\n\t}\n\n\t/**\n\t * Get all bindings involving a particular shape. This includes bindings where the shape is the\n\t * `fromId` or `toId`. If a type is provided, only bindings of that type are returned.\n\t */\n\tgetBindingsInvolvingShape<Binding extends TLUnknownBinding = TLBinding>(\n\t\tshape: TLShape | TLShapeId,\n\t\ttype?: Binding['type']\n\t): Binding[] {\n\t\tconst id = typeof shape === 'string' ? shape : shape.id\n\t\tconst result = this._getBindingsIndexCache().get(id) ?? EMPTY_ARRAY\n\t\tif (!type) return result as Binding[]\n\t\treturn result.filter((b) => b.type === type) as Binding[]\n\t}\n\n\t/**\n\t * Create bindings from a list of partial bindings. You can omit the ID and most props of a\n\t * binding, but the `type`, `toId`, and `fromId` must all be provided.\n\t */\n\tcreateBindings<B extends TLBinding = TLBinding>(partials: TLBindingCreate<B>[]) {\n\t\tconst bindings: TLBinding[] = []\n\t\tfor (const partial of partials) {\n\t\t\tconst fromShape = this.getShape(partial.fromId)\n\t\t\tconst toShape = this.getShape(partial.toId)\n\t\t\tif (!fromShape || !toShape) continue\n\t\t\tif (!this.canBindShapes({ fromShape, toShape, binding: partial })) continue\n\n\t\t\tconst util = this.getBindingUtil<TLUnknownBinding>(partial.type)\n\t\t\tconst defaultProps = util.getDefaultProps()\n\t\t\tconst binding = this.store.schema.types.binding.create({\n\t\t\t\t...partial,\n\t\t\t\tid: partial.id ?? createBindingId(),\n\t\t\t\tprops: {\n\t\t\t\t\t...defaultProps,\n\t\t\t\t\t...partial.props,\n\t\t\t\t},\n\t\t\t}) as TLBinding\n\n\t\t\tbindings.push(binding)\n\t\t}\n\n\t\tthis.store.put(bindings)\n\t\treturn this\n\t}\n\n\t/**\n\t * Create a single binding from a partial. You can omit the ID and most props of a binding, but\n\t * the `type`, `toId`, and `fromId` must all be provided.\n\t */\n\tcreateBinding<B extends TLBinding = TLBinding>(partial: TLBindingCreate<B>) {\n\t\treturn this.createBindings([partial])\n\t}\n\n\t/**\n\t * Update bindings from a list of partial bindings. Each partial must include an ID, which will\n\t * be used to match the binding to it's existing record. If there is no existing record, that\n\t * binding is skipped. The changes from the partial are merged into the existing record.\n\t */\n\tupdateBindings(partials: (TLBindingUpdate | null | undefined)[]) {\n\t\tconst updated: TLBinding[] = []\n\n\t\tfor (const partial of partials) {\n\t\t\tif (!partial) continue\n\n\t\t\tconst current = this.getBinding(partial.id)\n\t\t\tif (!current) continue\n\n\t\t\tconst updatedBinding = applyPartialToRecordWithProps(current, partial)\n\t\t\tif (updatedBinding === current) continue\n\n\t\t\tconst fromShape = this.getShape(updatedBinding.fromId)\n\t\t\tconst toShape = this.getShape(updatedBinding.toId)\n\t\t\tif (!fromShape || !toShape) continue\n\t\t\tif (!this.canBindShapes({ fromShape, toShape, binding: updatedBinding })) continue\n\n\t\t\tupdated.push(updatedBinding)\n\t\t}\n\n\t\tthis.store.put(updated)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Update a binding from a partial binding. Each partial must include an ID, which will be used\n\t * to match the binding to it's existing record. If there is no existing record, that binding is\n\t * skipped. The changes from the partial are merged into the existing record.\n\t */\n\tupdateBinding<B extends TLBinding = TLBinding>(partial: TLBindingUpdate<B>) {\n\t\treturn this.updateBindings([partial])\n\t}\n\n\t/**\n\t * Delete several bindings by their IDs. If a binding ID doesn't exist, it's ignored.\n\t */\n\tdeleteBindings(bindings: (TLBinding | TLBindingId)[], { isolateShapes = false } = {}) {\n\t\tconst ids = bindings.map((binding) => (typeof binding === 'string' ? binding : binding.id))\n\t\tif (isolateShapes) {\n\t\t\tthis.store.atomic(() => {\n\t\t\t\tfor (const id of ids) {\n\t\t\t\t\tconst binding = this.getBinding(id)\n\t\t\t\t\tif (!binding) continue\n\t\t\t\t\tconst util = this.getBindingUtil(binding)\n\t\t\t\t\tutil.onBeforeIsolateFromShape?.({ binding, removedShape: this.getShape(binding.toId)! })\n\t\t\t\t\tutil.onBeforeIsolateToShape?.({ binding, removedShape: this.getShape(binding.fromId)! })\n\t\t\t\t\tthis.store.remove([id])\n\t\t\t\t}\n\t\t\t})\n\t\t} else {\n\t\t\tthis.store.remove(ids)\n\t\t}\n\t\treturn this\n\t}\n\t/**\n\t * Delete a binding by its ID. If the binding doesn't exist, it's ignored.\n\t */\n\tdeleteBinding(binding: TLBinding | TLBindingId, opts?: Parameters<this['deleteBindings']>[1]) {\n\t\treturn this.deleteBindings([binding], opts)\n\t}\n\tcanBindShapes({\n\t\tfromShape,\n\t\ttoShape,\n\t\tbinding,\n\t}: {\n\t\tfromShape: TLShape | { type: TLShape['type'] } | TLShape['type']\n\t\ttoShape: TLShape | { type: TLShape['type'] } | TLShape['type']\n\t\tbinding: TLBinding | { type: TLBinding['type'] } | TLBinding['type']\n\t}): boolean {\n\t\tconst fromShapeType = typeof fromShape === 'string' ? fromShape : fromShape.type\n\t\tconst toShapeType = typeof toShape === 'string' ? toShape : toShape.type\n\t\tconst bindingType = typeof binding === 'string' ? binding : binding.type\n\n\t\tconst canBindOpts = { fromShapeType, toShapeType, bindingType }\n\n\t\tif (fromShapeType === toShapeType) {\n\t\t\treturn this.getShapeUtil(fromShapeType).canBind(canBindOpts)\n\t\t}\n\n\t\treturn (\n\t\t\tthis.getShapeUtil(fromShapeType).canBind(canBindOpts) &&\n\t\t\tthis.getShapeUtil(toShapeType).canBind(canBindOpts)\n\t\t)\n\t}\n\n\t/* -------------------- Commands -------------------- */\n\n\t/**\n\t * Rotate shapes by a delta in radians.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.rotateShapesBy(editor.getSelectedShapeIds(), Math.PI)\n\t * editor.rotateShapesBy(editor.getSelectedShapeIds(), Math.PI / 2)\n\t * ```\n\t *\n\t * @param shapes - The shapes (or shape ids) of the shapes to move.\n\t * @param delta - The delta in radians to apply to the selection rotation.\n\t * @param opts - The options for the rotation.\n\t */\n\trotateShapesBy(\n\t\tshapes: TLShapeId[] | TLShape[],\n\t\tdelta: number,\n\t\topts?: { center?: VecLike }\n\t): this {\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((s) => s.id)\n\n\t\tif (ids.length <= 0) return this\n\n\t\tconst snapshot = getRotationSnapshot({ editor: this, ids })\n\t\tif (!snapshot) return this\n\t\tapplyRotationToSnapshotShapes({\n\t\t\tdelta,\n\t\t\tsnapshot,\n\t\t\teditor: this,\n\t\t\tstage: 'one-off',\n\t\t\tcenterOverride: opts?.center,\n\t\t})\n\n\t\treturn this\n\t}\n\n\t// Gets a shape partial that includes life cycle changes: on translate start, on translate, on translate end\n\tprivate getChangesToTranslateShape(initialShape: TLShape, newShapeCoords: VecLike): TLShape {\n\t\tlet workingShape = initialShape\n\t\tconst util = this.getShapeUtil(initialShape)\n\n\t\tconst afterTranslateStart = util.onTranslateStart?.(workingShape)\n\t\tif (afterTranslateStart) {\n\t\t\tworkingShape = applyPartialToRecordWithProps(workingShape, afterTranslateStart)\n\t\t}\n\n\t\tworkingShape = applyPartialToRecordWithProps(workingShape, {\n\t\t\tid: initialShape.id,\n\t\t\ttype: initialShape.type,\n\t\t\tx: newShapeCoords.x,\n\t\t\ty: newShapeCoords.y,\n\t\t})\n\n\t\tconst afterTranslate = util.onTranslate?.(initialShape, workingShape)\n\t\tif (afterTranslate) {\n\t\t\tworkingShape = applyPartialToRecordWithProps(workingShape, afterTranslate)\n\t\t}\n\n\t\tconst afterTranslateEnd = util.onTranslateEnd?.(initialShape, workingShape)\n\t\tif (afterTranslateEnd) {\n\t\t\tworkingShape = applyPartialToRecordWithProps(workingShape, afterTranslateEnd)\n\t\t}\n\n\t\treturn workingShape\n\t}\n\n\t/**\n\t * Move shapes by a delta.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.nudgeShapes(['box1', 'box2'], { x: 8, y: 8 })\n\t * ```\n\t *\n\t * @param shapes - The shapes (or shape ids) to move.\n\t * @param offset - The offset to apply to the shapes.\n\t */\n\tnudgeShapes(shapes: TLShapeId[] | TLShape[], offset: VecLike): this {\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((s) => s.id)\n\n\t\tif (ids.length <= 0) return this\n\t\tconst changes: TLShapePartial[] = []\n\n\t\tfor (const id of ids) {\n\t\t\tconst shape = this.getShape(id)!\n\t\t\tconst localDelta = Vec.From(offset)\n\t\t\tconst parentTransform = this.getShapeParentTransform(shape)\n\t\t\tif (parentTransform) localDelta.rot(-parentTransform.rotation())\n\n\t\t\tchanges.push(this.getChangesToTranslateShape(shape, localDelta.add(shape)))\n\t\t}\n\n\t\tthis.updateShapes(changes)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Duplicate shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.duplicateShapes(['box1', 'box2'], { x: 8, y: 8 })\n\t * editor.duplicateShapes(editor.getSelectedShapes(), { x: 8, y: 8 })\n\t * ```\n\t *\n\t * @param shapes - The shapes (or shape ids) to duplicate.\n\t * @param offset - The offset (in pixels) to apply to the duplicated shapes.\n\t *\n\t * @public\n\t */\n\tduplicateShapes(shapes: TLShapeId[] | TLShape[], offset?: VecLike): this {\n\t\tthis.run(() => {\n\t\t\tconst _ids =\n\t\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t\t: (shapes as TLShape[]).map((s) => s.id)\n\n\t\t\tconst ids = this._shouldIgnoreShapeLock ? _ids : this._getUnlockedShapeIds(_ids)\n\t\t\tif (ids.length <= 0) return this\n\n\t\t\tconst initialIds = new Set(ids)\n\t\t\tconst shapeIdSet = this.getShapeAndDescendantIds(ids)\n\n\t\t\tconst orderedShapeIds = [...shapeIdSet].reverse()\n\t\t\tconst shapeIds = new Map<TLShapeId, TLShapeId>()\n\t\t\tfor (const shapeId of shapeIdSet) {\n\t\t\t\tshapeIds.set(shapeId, createShapeId())\n\t\t\t}\n\n\t\t\tconst { shapesToCreateWithOriginals, bindingsToCreate } = withIsolatedShapes(\n\t\t\t\tthis,\n\t\t\t\tshapeIdSet,\n\t\t\t\t(bindingIdsToMaintain) => {\n\t\t\t\t\tconst bindingsToCreate: TLBinding[] = []\n\t\t\t\t\tfor (const originalId of bindingIdsToMaintain) {\n\t\t\t\t\t\tconst originalBinding = this.getBinding(originalId)\n\t\t\t\t\t\tif (!originalBinding) continue\n\n\t\t\t\t\t\tconst duplicatedId = createBindingId()\n\t\t\t\t\t\tbindingsToCreate.push({\n\t\t\t\t\t\t\t...originalBinding,\n\t\t\t\t\t\t\tid: duplicatedId,\n\t\t\t\t\t\t\tfromId: assertExists(shapeIds.get(originalBinding.fromId)),\n\t\t\t\t\t\t\ttoId: assertExists(shapeIds.get(originalBinding.toId)),\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\n\t\t\t\t\tconst shapesToCreateWithOriginals: { shape: TLShape; originalShape: TLShape }[] = []\n\t\t\t\t\tfor (const originalId of orderedShapeIds) {\n\t\t\t\t\t\tconst duplicatedId = assertExists(shapeIds.get(originalId))\n\t\t\t\t\t\tconst originalShape = this.getShape(originalId)\n\t\t\t\t\t\tif (!originalShape) continue\n\n\t\t\t\t\t\tlet ox = 0\n\t\t\t\t\t\tlet oy = 0\n\n\t\t\t\t\t\tif (offset && initialIds.has(originalId)) {\n\t\t\t\t\t\t\tconst parentTransform = this.getShapeParentTransform(originalShape)\n\t\t\t\t\t\t\tconst vec = new Vec(offset.x, offset.y).rot(-parentTransform!.rotation())\n\t\t\t\t\t\t\tox = vec.x\n\t\t\t\t\t\t\toy = vec.y\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tshapesToCreateWithOriginals.push({\n\t\t\t\t\t\t\tshape: {\n\t\t\t\t\t\t\t\t...originalShape,\n\t\t\t\t\t\t\t\tid: duplicatedId,\n\t\t\t\t\t\t\t\tx: originalShape.x + ox,\n\t\t\t\t\t\t\t\ty: originalShape.y + oy,\n\t\t\t\t\t\t\t\t// Use a dummy index for now, it will get updated outside of the `withIsolatedShapes`\n\t\t\t\t\t\t\t\tindex: 'a1' as IndexKey,\n\t\t\t\t\t\t\t\tparentId:\n\t\t\t\t\t\t\t\t\tshapeIds.get(originalShape.parentId as TLShapeId) ?? originalShape.parentId,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toriginalShape,\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\n\t\t\t\t\treturn { shapesToCreateWithOriginals, bindingsToCreate }\n\t\t\t\t}\n\t\t\t)\n\n\t\t\t// We will update the indexes after the `withIsolatedShapes`, since we cannot rely on the indexes\n\t\t\t// to be correct inside of it.\n\t\t\tshapesToCreateWithOriginals.forEach(({ shape, originalShape }) => {\n\t\t\t\tconst parentId = originalShape.parentId\n\t\t\t\tconst siblings = this.getSortedChildIdsForParent(parentId)\n\t\t\t\tconst currentIndex = siblings.indexOf(originalShape.id)\n\t\t\t\tconst siblingAboveId = siblings[currentIndex + 1]\n\t\t\t\tconst siblingAbove = siblingAboveId ? this.getShape(siblingAboveId) : undefined\n\n\t\t\t\tconst index = getIndexBetween(originalShape.index, siblingAbove?.index)\n\n\t\t\t\tshape.index = index\n\t\t\t})\n\t\t\tconst shapesToCreate = shapesToCreateWithOriginals.map(({ shape }) => shape)\n\n\t\t\tif (!this.canCreateShapes(shapesToCreate)) {\n\t\t\t\talertMaxShapes(this)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tthis.createShapes(shapesToCreate)\n\t\t\tthis.createBindings(bindingsToCreate)\n\t\t\tthis.setSelectedShapes(compact(ids.map((id) => shapeIds.get(id))))\n\n\t\t\tif (offset !== undefined) {\n\t\t\t\t// If we've offset the duplicated shapes, check to see whether their new bounds is entirely\n\t\t\t\t// contained in the current viewport. If not, then animate the camera to be centered on the\n\t\t\t\t// new shapes.\n\t\t\t\tconst selectionPageBounds = this.getSelectionPageBounds()\n\t\t\t\tconst viewportPageBounds = this.getViewportPageBounds()\n\t\t\t\tif (selectionPageBounds && !viewportPageBounds.contains(selectionPageBounds)) {\n\t\t\t\t\tthis.centerOnPoint(selectionPageBounds.center, {\n\t\t\t\t\t\tanimation: { duration: this.options.animationMediumMs },\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Move shapes to page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.moveShapesToPage(['box1', 'box2'], 'page1')\n\t * ```\n\t *\n\t * @param shapes - The shapes (or shape ids) of the shapes to move.\n\t * @param pageId - The id of the page where the shapes will be moved.\n\t *\n\t * @public\n\t */\n\tmoveShapesToPage(shapes: TLShapeId[] | TLShape[], pageId: TLPageId): this {\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((s) => s.id)\n\n\t\tif (ids.length === 0) return this\n\t\tif (this.getIsReadonly()) return this\n\n\t\tconst currentPageId = this.getCurrentPageId()\n\n\t\tif (pageId === currentPageId) return this\n\t\tif (!this.store.has(pageId)) return this\n\n\t\t// Basically copy the shapes\n\t\tconst content = this.getContentFromCurrentPage(ids)\n\n\t\t// Just to be sure\n\t\tif (!content) return this\n\n\t\t// If there is no space on pageId, or if the selected shapes\n\t\t// would take the new page above the limit, don't move the shapes\n\t\tif (this.getPageShapeIds(pageId).size + content.shapes.length > this.options.maxShapesPerPage) {\n\t\t\talertMaxShapes(this, pageId)\n\t\t\treturn this\n\t\t}\n\n\t\tconst fromPageZ = this.getCamera().z\n\n\t\tthis.run(() => {\n\t\t\t// Delete the shapes on the current page\n\t\t\tthis.deleteShapes(ids)\n\n\t\t\t// Move to the next page\n\t\t\tthis.setCurrentPage(pageId)\n\n\t\t\t// Put the shape content onto the new page; parents and indices will\n\t\t\t// be taken care of by the putContent method; make sure to pop any focus\n\t\t\t// layers so that the content will be put onto the page.\n\t\t\tthis.setFocusedGroup(null)\n\t\t\tthis.selectNone()\n\t\t\tthis.putContentOntoCurrentPage(content, {\n\t\t\t\tselect: true,\n\t\t\t\tpreserveIds: true,\n\t\t\t\tpreservePosition: true,\n\t\t\t})\n\n\t\t\t// Force the new page's camera to be at the same zoom level as the\n\t\t\t// \"from\" page's camera, then center the \"to\" page's camera on the\n\t\t\t// pasted shapes\n\t\t\tthis.setCamera({ ...this.getCamera(), z: fromPageZ })\n\t\t\tthis.centerOnPoint(this.getSelectionRotatedPageBounds()!.center)\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Toggle the lock state of one or more shapes. If there is a mix of locked and unlocked shapes, all shapes will be locked.\n\t *\n\t * @param shapes - The shapes (or shape ids) to toggle.\n\t *\n\t * @public\n\t */\n\ttoggleLock(shapes: TLShapeId[] | TLShape[]): this {\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((s) => s.id)\n\n\t\tif (this.getIsReadonly() || ids.length === 0) return this\n\n\t\tlet allLocked = true,\n\t\t\tallUnlocked = true\n\t\tconst shapesToToggle: TLShape[] = []\n\t\tfor (const id of ids) {\n\t\t\tconst shape = this.getShape(id)\n\t\t\tif (shape) {\n\t\t\t\tshapesToToggle.push(shape)\n\t\t\t\tif (shape.isLocked) {\n\t\t\t\t\tallUnlocked = false\n\t\t\t\t} else {\n\t\t\t\t\tallLocked = false\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.run(() => {\n\t\t\tif (allUnlocked) {\n\t\t\t\tthis.updateShapes(\n\t\t\t\t\tshapesToToggle.map((shape) => ({ id: shape.id, type: shape.type, isLocked: true }))\n\t\t\t\t)\n\t\t\t\tthis.setSelectedShapes([])\n\t\t\t} else if (allLocked) {\n\t\t\t\tthis.updateShapes(\n\t\t\t\t\tshapesToToggle.map((shape) => ({ id: shape.id, type: shape.type, isLocked: false }))\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tthis.updateShapes(\n\t\t\t\t\tshapesToToggle.map((shape) => ({ id: shape.id, type: shape.type, isLocked: true }))\n\t\t\t\t)\n\t\t\t}\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Send shapes to the back of the page's object list.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.sendToBack(['id1', 'id2'])\n\t * editor.sendToBack(box1, box2)\n\t * ```\n\t *\n\t * @param shapes - The shapes (or shape ids) to move.\n\t *\n\t * @public\n\t */\n\tsendToBack(shapes: TLShapeId[] | TLShape[]): this {\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((s) => s.id)\n\t\tconst changes = getReorderingShapesChanges(this, 'toBack', ids as TLShapeId[], {\n\t\t\tconsiderAllShapes: true,\n\t\t})\n\t\tif (changes) this.updateShapes(changes)\n\t\treturn this\n\t}\n\n\t/**\n\t * Send shapes backward in the page's object list.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.sendBackward(['id1', 'id2'])\n\t * editor.sendBackward([box1, box2])\n\t * ```\n\t *\n\t * By default, the operation will only consider overlapping shapes.\n\t * To consider all shapes, pass `{ considerAllShapes: true }` in the options.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.sendBackward(['id1', 'id2'], { considerAllShapes: true })\n\t * ```\n\t *\n\t * @param shapes - The shapes (or shape ids) to move.\n\t * @param opts - The options for the backward operation.\n\t *\n\t * @public\n\t */\n\tsendBackward(shapes: TLShapeId[] | TLShape[], opts: { considerAllShapes?: boolean } = {}): this {\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((s) => s.id)\n\t\tconst changes = getReorderingShapesChanges(this, 'backward', ids as TLShapeId[], opts)\n\t\tif (changes) this.updateShapes(changes)\n\t\treturn this\n\t}\n\n\t/**\n\t * Bring shapes forward in the page's object list.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.bringForward(['id1', 'id2'])\n\t * editor.bringForward(box1,  box2)\n\t * ```\n\t *\n\t * By default, the operation will only consider overlapping shapes.\n\t * To consider all shapes, pass `{ considerAllShapes: true }` in the options.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.bringForward(['id1', 'id2'], { considerAllShapes: true })\n\t * ```\n\t *\n\t * @param shapes - The shapes (or shape ids) to move.\n\t * @param opts - The options for the forward operation.\n\t *\n\t * @public\n\t */\n\tbringForward(shapes: TLShapeId[] | TLShape[], opts: { considerAllShapes?: boolean } = {}): this {\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((s) => s.id)\n\t\tconst changes = getReorderingShapesChanges(this, 'forward', ids as TLShapeId[], opts)\n\t\tif (changes) this.updateShapes(changes)\n\t\treturn this\n\t}\n\n\t/**\n\t * Bring shapes to the front of the page's object list.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.bringToFront(['id1', 'id2'])\n\t * editor.bringToFront([box1, box2])\n\t * ```\n\t *\n\t * @param shapes - The shapes (or shape ids) to move.\n\t *\n\t * @public\n\t */\n\tbringToFront(shapes: TLShapeId[] | TLShape[]): this {\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((s) => s.id)\n\t\tconst changes = getReorderingShapesChanges(this, 'toFront', ids as TLShapeId[])\n\t\tif (changes) this.updateShapes(changes)\n\t\treturn this\n\t}\n\n\t/**\n\t * @internal\n\t */\n\tprivate collectShapesViaArrowBindings(info: {\n\t\tinitialShapes: TLShape[]\n\t\tresultShapes: TLShape[]\n\t\tresultBounds: Box[]\n\t\tbindings: TLBinding[]\n\t\tvisited: Set<TLShapeId>\n\t}) {\n\t\tconst { initialShapes, resultShapes, resultBounds, bindings, visited } = info\n\t\tfor (const binding of bindings) {\n\t\t\tfor (const id of [binding.fromId, binding.toId]) {\n\t\t\t\tif (!visited.has(id)) {\n\t\t\t\t\tconst aligningShape = initialShapes.find((s) => s.id === id)\n\t\t\t\t\tif (aligningShape && !visited.has(aligningShape.id)) {\n\t\t\t\t\t\tvisited.add(aligningShape.id)\n\t\t\t\t\t\tconst shapePageBounds = this.getShapePageBounds(aligningShape)\n\t\t\t\t\t\tif (!shapePageBounds) continue\n\t\t\t\t\t\tresultShapes.push(aligningShape)\n\t\t\t\t\t\tresultBounds.push(shapePageBounds)\n\t\t\t\t\t\tthis.collectShapesViaArrowBindings({\n\t\t\t\t\t\t\t...info,\n\t\t\t\t\t\t\tbindings: this.getBindingsInvolvingShape(aligningShape, 'arrow'),\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Flip shape positions.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.flipShapes([box1, box2], 'horizontal', 32)\n\t * editor.flipShapes(editor.getSelectedShapeIds(), 'horizontal', 32)\n\t * ```\n\t *\n\t * @param shapes - The ids of the shapes to flip.\n\t * @param operation - Whether to flip horizontally or vertically.\n\t *\n\t * @public\n\t */\n\tflipShapes(shapes: TLShapeId[] | TLShape[], operation: 'horizontal' | 'vertical'): this {\n\t\tif (this.getIsReadonly()) return this\n\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((s) => s.id)\n\n\t\t// Collect a greedy list of shapes to flip\n\t\tconst shapesToFlipFirstPass = compact(ids.map((id) => this.getShape(id)))\n\n\t\tfor (const shape of shapesToFlipFirstPass) {\n\t\t\tif (this.isShapeOfType<TLGroupShape>(shape, 'group')) {\n\t\t\t\tconst childrenOfGroups = compact(\n\t\t\t\t\tthis.getSortedChildIdsForParent(shape.id).map((id) => this.getShape(id))\n\t\t\t\t)\n\t\t\t\tshapesToFlipFirstPass.push(...childrenOfGroups)\n\t\t\t}\n\t\t}\n\n\t\t// exclude shapes that can't be flipped\n\t\tconst shapesToFlip: {\n\t\t\tshape: TLShape\n\t\t\tlocalBounds: Box\n\t\t\tpageTransform: Mat\n\t\t\tisAspectRatioLocked: boolean\n\t\t}[] = []\n\n\t\tconst allBounds: Box[] = []\n\n\t\tfor (const shape of shapesToFlipFirstPass) {\n\t\t\tconst util = this.getShapeUtil(shape)\n\t\t\tif (\n\t\t\t\t!util.canBeLaidOut(shape, {\n\t\t\t\t\ttype: 'flip',\n\t\t\t\t\tshapes: shapesToFlipFirstPass,\n\t\t\t\t})\n\t\t\t) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tconst pageBounds = this.getShapePageBounds(shape)\n\t\t\tconst localBounds = this.getShapeGeometry(shape).bounds\n\t\t\tconst pageTransform = this.getShapePageTransform(shape.id)\n\t\t\tif (!(pageBounds && localBounds && pageTransform)) continue\n\t\t\tshapesToFlip.push({\n\t\t\t\tshape,\n\t\t\t\tlocalBounds,\n\t\t\t\tpageTransform,\n\t\t\t\tisAspectRatioLocked: util.isAspectRatioLocked(shape),\n\t\t\t})\n\t\t\tallBounds.push(pageBounds)\n\t\t}\n\n\t\tif (!shapesToFlip.length) return this\n\n\t\tconst scaleOriginPage = Box.Common(allBounds).center\n\n\t\tthis.run(() => {\n\t\t\tfor (const { shape, localBounds, pageTransform, isAspectRatioLocked } of shapesToFlip) {\n\t\t\t\tthis.resizeShape(\n\t\t\t\t\tshape.id,\n\t\t\t\t\t{ x: operation === 'horizontal' ? -1 : 1, y: operation === 'vertical' ? -1 : 1 },\n\t\t\t\t\t{\n\t\t\t\t\t\tinitialBounds: localBounds,\n\t\t\t\t\t\tinitialPageTransform: pageTransform,\n\t\t\t\t\t\tinitialShape: shape,\n\t\t\t\t\t\tisAspectRatioLocked,\n\t\t\t\t\t\tmode: 'scale_shape',\n\t\t\t\t\t\tscaleOrigin: scaleOriginPage,\n\t\t\t\t\t\tscaleAxisRotation: 0,\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Stack shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.stackShapes([box1, box2], 'horizontal')\n\t * editor.stackShapes(editor.getSelectedShapeIds(), 'horizontal')\n\t * ```\n\t *\n\t * @param shapes - The shapes (or shape ids) to stack.\n\t * @param operation - Whether to stack horizontally or vertically.\n\t * @param gap - The gap to leave between shapes. By default, uses the editor's `adjacentShapeMargin` option.\n\t *\n\t * @public\n\t */\n\tstackShapes(\n\t\tshapes: TLShapeId[] | TLShape[],\n\t\toperation: 'horizontal' | 'vertical',\n\t\tgap?: number\n\t): this {\n\t\tconst _gap = gap ?? this.options.adjacentShapeMargin\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((s) => s.id)\n\t\tif (this.getIsReadonly()) return this\n\n\t\t// todo: this has a lot of extra code to handle stacking with custom gaps or auto gaps or other things like that. I don't think anyone has ever used this stuff.\n\n\t\t// always fresh shapes\n\t\tconst shapesToStackFirstPass = compact(ids.map((id) => this.getShape(id)))\n\n\t\tconst shapeClustersToStack: {\n\t\t\tshapes: TLShape[]\n\t\t\tpageBounds: Box\n\t\t}[] = []\n\t\tconst allBounds: Box[] = []\n\t\tconst visited = new Set<TLShapeId>()\n\n\t\tfor (const shape of shapesToStackFirstPass) {\n\t\t\tif (visited.has(shape.id)) continue\n\t\t\tvisited.add(shape.id)\n\n\t\t\tconst shapePageBounds = this.getShapePageBounds(shape)\n\t\t\tif (!shapePageBounds) continue\n\n\t\t\tif (\n\t\t\t\t!this.getShapeUtil(shape).canBeLaidOut?.(shape, {\n\t\t\t\t\ttype: 'stack',\n\t\t\t\t\tshapes: shapesToStackFirstPass,\n\t\t\t\t})\n\t\t\t) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tconst shapesMovingTogether = [shape]\n\t\t\tconst boundsOfShapesMovingTogether: Box[] = [shapePageBounds]\n\n\t\t\tthis.collectShapesViaArrowBindings({\n\t\t\t\tbindings: this.getBindingsToShape(shape.id, 'arrow'),\n\t\t\t\tinitialShapes: shapesToStackFirstPass,\n\t\t\t\tresultShapes: shapesMovingTogether,\n\t\t\t\tresultBounds: boundsOfShapesMovingTogether,\n\t\t\t\tvisited,\n\t\t\t})\n\n\t\t\tconst commonPageBounds = Box.Common(boundsOfShapesMovingTogether)\n\t\t\tif (!commonPageBounds) continue\n\n\t\t\tshapeClustersToStack.push({\n\t\t\t\tshapes: shapesMovingTogether,\n\t\t\t\tpageBounds: commonPageBounds,\n\t\t\t})\n\n\t\t\tallBounds.push(commonPageBounds)\n\t\t}\n\n\t\tconst len = shapeClustersToStack.length\n\t\tif ((_gap === 0 && len < 3) || len < 2) return this\n\n\t\tlet val: 'x' | 'y'\n\t\tlet min: 'minX' | 'minY'\n\t\tlet max: 'maxX' | 'maxY'\n\t\tlet dim: 'width' | 'height'\n\n\t\tif (operation === 'horizontal') {\n\t\t\tval = 'x'\n\t\t\tmin = 'minX'\n\t\t\tmax = 'maxX'\n\t\t\tdim = 'width'\n\t\t} else {\n\t\t\tval = 'y'\n\t\t\tmin = 'minY'\n\t\t\tmax = 'maxY'\n\t\t\tdim = 'height'\n\t\t}\n\n\t\tlet shapeGap: number = 0\n\n\t\tif (_gap === 0) {\n\t\t\t// note: this is not used in the current tldraw.com; there we use a specified stack\n\n\t\t\tconst gaps: Record<number, number> = {}\n\n\t\t\tshapeClustersToStack.sort((a, b) => a.pageBounds[min] - b.pageBounds[min])\n\n\t\t\t// Collect all of the gaps between shapes. We want to find\n\t\t\t// patterns (equal gaps between shapes) and use the most common\n\t\t\t// one as the gap for all of the shapes.\n\t\t\tfor (let i = 0; i < len - 1; i++) {\n\t\t\t\tconst currCluster = shapeClustersToStack[i]\n\t\t\t\tconst nextCluster = shapeClustersToStack[i + 1]\n\t\t\t\tconst gap = nextCluster.pageBounds[min] - currCluster.pageBounds[max]\n\t\t\t\tif (!gaps[gap]) {\n\t\t\t\t\tgaps[gap] = 0\n\t\t\t\t}\n\t\t\t\tgaps[gap]++\n\t\t\t}\n\n\t\t\t// Which gap is the most common?\n\t\t\tlet maxCount = 1\n\t\t\tfor (const [gap, count] of Object.entries(gaps)) {\n\t\t\t\tif (count > maxCount) {\n\t\t\t\t\tmaxCount = count\n\t\t\t\t\tshapeGap = parseFloat(gap)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there is no most-common gap, use the average gap.\n\t\t\tif (maxCount === 1) {\n\t\t\t\tlet totalCount = 0\n\t\t\t\tfor (const [gap, count] of Object.entries(gaps)) {\n\t\t\t\t\tshapeGap += parseFloat(gap) * count\n\t\t\t\t\ttotalCount += count\n\t\t\t\t}\n\t\t\t\tshapeGap /= totalCount\n\t\t\t}\n\t\t} else {\n\t\t\t// If a gap was provided, then use that instead.\n\t\t\tshapeGap = _gap\n\t\t}\n\n\t\tconst changes: TLShapePartial[] = []\n\n\t\tlet v = shapeClustersToStack[0].pageBounds[max]\n\n\t\tfor (let i = 1; i < shapeClustersToStack.length; i++) {\n\t\t\tconst { shapes, pageBounds } = shapeClustersToStack[i]\n\t\t\tconst delta = new Vec()\n\t\t\tdelta[val] = v + shapeGap - pageBounds[val]\n\n\t\t\tfor (const shape of shapes) {\n\t\t\t\tconst shapeDelta = delta.clone()\n\n\t\t\t\t// If the shape has another shape as its parent, and if the parent has a rotation, we need to rotate the counter-rotate delta\n\t\t\t\t// todo: ensure that the parent isn't being aligned together with its children\n\t\t\t\tconst parent = this.getShapeParent(shape)\n\t\t\t\tif (parent) {\n\t\t\t\t\tconst parentTransform = this.getShapePageTransform(parent)\n\t\t\t\t\tif (parentTransform) shapeDelta.rot(-parentTransform.rotation())\n\t\t\t\t}\n\n\t\t\t\tshapeDelta.add(shape) // add the shape's x and y to the delta\n\t\t\t\tchanges.push(this.getChangesToTranslateShape(shape, shapeDelta))\n\t\t\t}\n\n\t\t\tv += pageBounds[dim] + shapeGap\n\t\t}\n\n\t\tthis.updateShapes(changes)\n\t\treturn this\n\t}\n\n\t/**\n\t * Pack shapes into a grid centered on their current position. Based on potpack (https://github.com/mapbox/potpack).\n\t *\n\t * @example\n\t * ```ts\n\t * editor.packShapes([box1, box2])\n\t * editor.packShapes(editor.getSelectedShapeIds(), 32)\n\t * ```\n\t *\n\t *\n\t * @param shapes - The shapes (or shape ids) to pack.\n\t * @param gap - The padding to apply to the packed shapes. Defaults to the editor's `adjacentShapeMargin` option.\n\t */\n\tpackShapes(shapes: TLShapeId[] | TLShape[], _gap?: number): this {\n\t\tif (this.getIsReadonly()) return this\n\n\t\tconst gap = _gap ?? this.options.adjacentShapeMargin\n\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((s) => s.id)\n\n\t\t// Always fresh shapes\n\t\tconst shapesToPackFirstPass = compact(ids.map((id) => this.getShape(id)))\n\n\t\tconst shapeClustersToPack: {\n\t\t\tshapes: TLShape[]\n\t\t\tpageBounds: Box\n\t\t\tnextPageBounds: Box\n\t\t}[] = []\n\n\t\tconst allBounds: Box[] = []\n\t\tconst visited = new Set<TLShapeId>()\n\n\t\tfor (const shape of shapesToPackFirstPass) {\n\t\t\tif (visited.has(shape.id)) continue\n\t\t\tvisited.add(shape.id)\n\n\t\t\tconst shapePageBounds = this.getShapePageBounds(shape)\n\t\t\tif (!shapePageBounds) continue\n\n\t\t\tif (\n\t\t\t\t!this.getShapeUtil(shape).canBeLaidOut?.(shape, {\n\t\t\t\t\ttype: 'pack',\n\t\t\t\t\tshapes: shapesToPackFirstPass,\n\t\t\t\t})\n\t\t\t) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tconst shapesMovingTogether = [shape]\n\t\t\tconst boundsOfShapesMovingTogether: Box[] = [shapePageBounds]\n\n\t\t\tthis.collectShapesViaArrowBindings({\n\t\t\t\tbindings: this.getBindingsToShape(shape.id, 'arrow'),\n\t\t\t\tinitialShapes: shapesToPackFirstPass,\n\t\t\t\tresultShapes: shapesMovingTogether,\n\t\t\t\tresultBounds: boundsOfShapesMovingTogether,\n\t\t\t\tvisited,\n\t\t\t})\n\n\t\t\tconst commonPageBounds = Box.Common(boundsOfShapesMovingTogether)\n\t\t\tif (!commonPageBounds) continue\n\n\t\t\tshapeClustersToPack.push({\n\t\t\t\tshapes: shapesMovingTogether,\n\t\t\t\tpageBounds: commonPageBounds,\n\t\t\t\tnextPageBounds: commonPageBounds.clone(),\n\t\t\t})\n\n\t\t\tallBounds.push(commonPageBounds)\n\t\t}\n\n\t\tif (shapeClustersToPack.length < 2) return this\n\n\t\tlet area = 0\n\t\tfor (const { pageBounds } of shapeClustersToPack) {\n\t\t\tarea += pageBounds.width * pageBounds.height\n\t\t}\n\n\t\tconst commonBounds = Box.Common(allBounds)\n\n\t\tconst maxWidth = commonBounds.width\n\n\t\t// sort the shape clusters by width and then height, descending\n\t\tshapeClustersToPack\n\t\t\t.sort((a, b) => a.pageBounds.width - b.pageBounds.width)\n\t\t\t.sort((a, b) => a.pageBounds.height - b.pageBounds.height)\n\n\t\t// Start with is (sort of) the square of the area\n\t\tconst startWidth = Math.max(Math.ceil(Math.sqrt(area / 0.95)), maxWidth)\n\n\t\t// first shape fills the width and is infinitely tall\n\t\tconst spaces: Box[] = [new Box(commonBounds.x, commonBounds.y, startWidth, Infinity)]\n\n\t\tlet width = 0\n\t\tlet height = 0\n\t\tlet space: Box\n\t\tlet last: Box\n\n\t\tfor (const { nextPageBounds } of shapeClustersToPack) {\n\t\t\t// starting at the back (smaller shapes)\n\t\t\tfor (let i = spaces.length - 1; i >= 0; i--) {\n\t\t\t\tspace = spaces[i]\n\n\t\t\t\t// find a space that is big enough to contain the shape\n\t\t\t\tif (nextPageBounds.width > space.width || nextPageBounds.height > space.height) continue\n\n\t\t\t\t// add the shape to its top-left corner\n\t\t\t\tnextPageBounds.x = space.x\n\t\t\t\tnextPageBounds.y = space.y\n\n\t\t\t\theight = Math.max(height, nextPageBounds.maxY)\n\t\t\t\twidth = Math.max(width, nextPageBounds.maxX)\n\n\t\t\t\tif (nextPageBounds.width === space.width && nextPageBounds.height === space.height) {\n\t\t\t\t\t// remove the space on a perfect fit\n\t\t\t\t\tlast = spaces.pop()!\n\t\t\t\t\tif (i < spaces.length) spaces[i] = last\n\t\t\t\t} else if (nextPageBounds.height === space.height) {\n\t\t\t\t\t// fit the shape into the space (width)\n\t\t\t\t\tspace.x += nextPageBounds.width + gap\n\t\t\t\t\tspace.width -= nextPageBounds.width + gap\n\t\t\t\t} else if (nextPageBounds.width === space.width) {\n\t\t\t\t\t// fit the shape into the space (height)\n\t\t\t\t\tspace.y += nextPageBounds.height + gap\n\t\t\t\t\tspace.height -= nextPageBounds.height + gap\n\t\t\t\t} else {\n\t\t\t\t\t// split the space into two spaces\n\t\t\t\t\tspaces.push(\n\t\t\t\t\t\tnew Box(\n\t\t\t\t\t\t\tspace.x + (nextPageBounds.width + gap),\n\t\t\t\t\t\t\tspace.y,\n\t\t\t\t\t\t\tspace.width - (nextPageBounds.width + gap),\n\t\t\t\t\t\t\tnextPageBounds.height\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t\tspace.y += nextPageBounds.height + gap\n\t\t\t\t\tspace.height -= nextPageBounds.height + gap\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tconst commonAfter = Box.Common(shapeClustersToPack.map((s) => s.nextPageBounds))\n\t\tconst centerDelta = Vec.Sub(commonBounds.center, commonAfter.center)\n\n\t\tconst changes: TLShapePartial<any>[] = []\n\n\t\tfor (const { shapes, pageBounds, nextPageBounds } of shapeClustersToPack) {\n\t\t\tconst delta = Vec.Sub(nextPageBounds.point, pageBounds.point).add(centerDelta)\n\n\t\t\tfor (const shape of shapes) {\n\t\t\t\tconst shapeDelta = delta.clone()\n\n\t\t\t\tconst parent = this.getShapeParent(shape)\n\t\t\t\tif (parent) {\n\t\t\t\t\tconst parentTransform = this.getShapeParentTransform(shape)\n\t\t\t\t\tif (parentTransform) shapeDelta.rot(-parentTransform.rotation())\n\t\t\t\t}\n\n\t\t\t\tshapeDelta.add(shape)\n\t\t\t\tchanges.push(this.getChangesToTranslateShape(shape, shapeDelta))\n\t\t\t}\n\t\t}\n\n\t\tif (changes.length) {\n\t\t\tthis.updateShapes(changes)\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Align shape positions.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.alignShapes([box1, box2], 'left')\n\t * editor.alignShapes(editor.getSelectedShapeIds(), 'left')\n\t * ```\n\t *\n\t * @param shapes - The shapes (or shape ids) to align.\n\t * @param operation - The align operation to apply.\n\t *\n\t * @public\n\t */\n\talignShapes(\n\t\tshapes: TLShapeId[] | TLShape[],\n\t\toperation: 'left' | 'center-horizontal' | 'right' | 'top' | 'center-vertical' | 'bottom'\n\t): this {\n\t\tif (this.getIsReadonly()) return this\n\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((s) => s.id)\n\n\t\t// Always get fresh shapes\n\t\tconst shapesToAlignFirstPass = compact(ids.map((id) => this.getShape(id)))\n\n\t\tconst shapeClustersToAlign: {\n\t\t\tshapes: TLShape[]\n\t\t\tpageBounds: Box\n\t\t}[] = []\n\t\tconst allBounds: Box[] = []\n\t\tconst visited = new Set<TLShapeId>()\n\n\t\tfor (const shape of shapesToAlignFirstPass) {\n\t\t\tif (visited.has(shape.id)) continue\n\t\t\tvisited.add(shape.id)\n\n\t\t\tconst shapePageBounds = this.getShapePageBounds(shape)\n\t\t\tif (!shapePageBounds) continue\n\n\t\t\tif (\n\t\t\t\t!this.getShapeUtil(shape).canBeLaidOut?.(shape, {\n\t\t\t\t\ttype: 'align',\n\t\t\t\t\tshapes: shapesToAlignFirstPass,\n\t\t\t\t})\n\t\t\t) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// In this implementation, we want to create psuedo-groups out of shapes that\n\t\t\t// are moving together. At the moment shapes only move together if they're connected\n\t\t\t// by arrows. So let's say A -> B -> C -> D and A, B, and C are selected. If we're\n\t\t\t// aligning A, B, and C, then we want these to move together as one unit.\n\n\t\t\tconst shapesMovingTogether = [shape]\n\t\t\tconst boundsOfShapesMovingTogether: Box[] = [shapePageBounds]\n\n\t\t\tthis.collectShapesViaArrowBindings({\n\t\t\t\tbindings: this.getBindingsToShape(shape.id, 'arrow'),\n\t\t\t\tinitialShapes: shapesToAlignFirstPass,\n\t\t\t\tresultShapes: shapesMovingTogether,\n\t\t\t\tresultBounds: boundsOfShapesMovingTogether,\n\t\t\t\tvisited,\n\t\t\t})\n\n\t\t\tconst commonPageBounds = Box.Common(boundsOfShapesMovingTogether)\n\t\t\tif (!commonPageBounds) continue\n\n\t\t\tshapeClustersToAlign.push({\n\t\t\t\tshapes: shapesMovingTogether,\n\t\t\t\tpageBounds: commonPageBounds,\n\t\t\t})\n\n\t\t\tallBounds.push(commonPageBounds)\n\t\t}\n\n\t\tif (shapeClustersToAlign.length < 2) return this\n\n\t\tconst commonBounds = Box.Common(allBounds)\n\n\t\tconst changes: TLShapePartial[] = []\n\n\t\tshapeClustersToAlign.forEach(({ shapes, pageBounds }) => {\n\t\t\tconst delta = new Vec()\n\n\t\t\tswitch (operation) {\n\t\t\t\tcase 'top': {\n\t\t\t\t\tdelta.y = commonBounds.minY - pageBounds.minY\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'center-vertical': {\n\t\t\t\t\tdelta.y = commonBounds.midY - pageBounds.minY - pageBounds.height / 2\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'bottom': {\n\t\t\t\t\tdelta.y = commonBounds.maxY - pageBounds.minY - pageBounds.height\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'left': {\n\t\t\t\t\tdelta.x = commonBounds.minX - pageBounds.minX\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'center-horizontal': {\n\t\t\t\t\tdelta.x = commonBounds.midX - pageBounds.minX - pageBounds.width / 2\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'right': {\n\t\t\t\t\tdelta.x = commonBounds.maxX - pageBounds.minX - pageBounds.width\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const shape of shapes) {\n\t\t\t\tconst shapeDelta = delta.clone()\n\n\t\t\t\t// If the shape has another shape as its parent, and if the parent has a rotation, we need to rotate the counter-rotate delta\n\t\t\t\t// todo: ensure that the parent isn't being aligned together with its children\n\t\t\t\tconst parent = this.getShapeParent(shape)\n\t\t\t\tif (parent) {\n\t\t\t\t\tconst parentTransform = this.getShapePageTransform(parent)\n\t\t\t\t\tif (parentTransform) shapeDelta.rot(-parentTransform.rotation())\n\t\t\t\t}\n\n\t\t\t\tshapeDelta.add(shape) // add the shape's x and y to the delta\n\t\t\t\tchanges.push(this.getChangesToTranslateShape(shape, shapeDelta))\n\t\t\t}\n\t\t})\n\n\t\tthis.updateShapes(changes)\n\t\treturn this\n\t}\n\n\t/**\n\t * Distribute shape positions.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.distributeShapes([box1, box2], 'horizontal')\n\t * editor.distributeShapes(editor.getSelectedShapeIds(), 'horizontal')\n\t * ```\n\t *\n\t * @param shapes - The shapes (or shape ids) to distribute.\n\t * @param operation - Whether to distribute shapes horizontally or vertically.\n\t *\n\t * @public\n\t */\n\tdistributeShapes(shapes: TLShapeId[] | TLShape[], operation: 'horizontal' | 'vertical'): this {\n\t\tif (this.getIsReadonly()) return this\n\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((s) => s.id)\n\n\t\t// always fresh shapes\n\t\tconst shapesToDistributeFirstPass = compact(ids.map((id) => this.getShape(id)))\n\n\t\tconst shapeClustersToDistribute: {\n\t\t\tshapes: TLShape[]\n\t\t\tpageBounds: Box\n\t\t}[] = []\n\n\t\tconst allBounds: Box[] = []\n\t\tconst visited = new Set<TLShapeId>()\n\n\t\tfor (const shape of shapesToDistributeFirstPass) {\n\t\t\tif (visited.has(shape.id)) continue\n\t\t\tvisited.add(shape.id)\n\n\t\t\tconst shapePageBounds = this.getShapePageBounds(shape)\n\t\t\tif (!shapePageBounds) continue\n\n\t\t\tif (\n\t\t\t\t!this.getShapeUtil(shape).canBeLaidOut?.(shape, {\n\t\t\t\t\ttype: 'distribute',\n\t\t\t\t\tshapes: shapesToDistributeFirstPass,\n\t\t\t\t})\n\t\t\t) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tconst shapesMovingTogether = [shape]\n\t\t\tconst boundsOfShapesMovingTogether: Box[] = [shapePageBounds]\n\n\t\t\tthis.collectShapesViaArrowBindings({\n\t\t\t\tbindings: this.getBindingsToShape(shape.id, 'arrow'),\n\t\t\t\tinitialShapes: shapesToDistributeFirstPass,\n\t\t\t\tresultShapes: shapesMovingTogether,\n\t\t\t\tresultBounds: boundsOfShapesMovingTogether,\n\t\t\t\tvisited,\n\t\t\t})\n\n\t\t\tconst commonPageBounds = Box.Common(boundsOfShapesMovingTogether)\n\t\t\tif (!commonPageBounds) continue\n\n\t\t\tshapeClustersToDistribute.push({\n\t\t\t\tshapes: shapesMovingTogether,\n\t\t\t\tpageBounds: commonPageBounds,\n\t\t\t})\n\n\t\t\tallBounds.push(commonPageBounds)\n\t\t}\n\n\t\tif (shapeClustersToDistribute.length < 3) return this\n\n\t\tlet val: 'x' | 'y'\n\t\tlet min: 'minX' | 'minY'\n\t\tlet max: 'maxX' | 'maxY'\n\t\tlet dim: 'width' | 'height'\n\n\t\tif (operation === 'horizontal') {\n\t\t\tval = 'x'\n\t\t\tmin = 'minX'\n\t\t\tmax = 'maxX'\n\t\t\tdim = 'width'\n\t\t} else {\n\t\t\tval = 'y'\n\t\t\tmin = 'minY'\n\t\t\tmax = 'maxY'\n\t\t\tdim = 'height'\n\t\t}\n\t\tconst changes: TLShapePartial[] = []\n\n\t\tconst first = shapeClustersToDistribute.sort((a, b) => a.pageBounds[min] - b.pageBounds[min])[0]\n\t\tconst last = shapeClustersToDistribute.sort((a, b) => b.pageBounds[max] - a.pageBounds[max])[0]\n\n\t\t// If the first shape group is also the last shape group, distribute without it\n\t\tif (first === last) {\n\t\t\tconst excludedShapeIds = new Set(first.shapes.map((s) => s.id))\n\t\t\treturn this.distributeShapes(\n\t\t\t\tids.filter((id) => !excludedShapeIds.has(id)),\n\t\t\t\toperation\n\t\t\t)\n\t\t}\n\n\t\tconst shapeClustersToMove = shapeClustersToDistribute\n\t\t\t.filter((shape) => shape !== first && shape !== last)\n\t\t\t.sort((a, b) => {\n\t\t\t\tif (a.pageBounds[min] === b.pageBounds[min]) {\n\t\t\t\t\treturn a.shapes[0].id < b.shapes[0].id ? -1 : 1\n\t\t\t\t}\n\t\t\t\treturn a.pageBounds[min] - b.pageBounds[min]\n\t\t\t})\n\n\t\t// The gap is the amount of space \"left over\" between the first and last shape. This can be a negative number if the shapes are overlapping.\n\t\tconst maxFirst = first.pageBounds[max]\n\t\tconst range = last.pageBounds[min] - maxFirst\n\t\tconst summedShapeDimensions = shapeClustersToMove.reduce((acc, s) => acc + s.pageBounds[dim], 0)\n\t\tconst gap = (range - summedShapeDimensions) / (shapeClustersToMove.length + 1)\n\n\t\tfor (let v = maxFirst + gap, i = 0; i < shapeClustersToMove.length; i++) {\n\t\t\tconst { shapes, pageBounds } = shapeClustersToMove[i]\n\t\t\tconst delta = new Vec()\n\t\t\tdelta[val] = v - pageBounds[val]\n\n\t\t\t// If for some reason the new position would be more than the maximum, we need to adjust the delta\n\t\t\t// This will likely throw off some of the other placements but hey, it's better than changing the common bounds\n\t\t\tif (v + pageBounds[dim] > last.pageBounds[max] - 1) {\n\t\t\t\tdelta[val] = last.pageBounds[max] - pageBounds[max] - 1\n\t\t\t}\n\n\t\t\tfor (const shape of shapes) {\n\t\t\t\tconst shapeDelta = delta.clone()\n\n\t\t\t\t// If the shape has another shape as its parent, and if the parent has a rotation, we need to rotate the counter-rotate delta\n\t\t\t\t// todo: ensure that the parent isn't being aligned together with its children\n\t\t\t\tconst parent = this.getShapeParent(shape)\n\t\t\t\tif (parent) {\n\t\t\t\t\tconst parentTransform = this.getShapePageTransform(parent)\n\t\t\t\t\tif (parentTransform) shapeDelta.rot(-parentTransform.rotation())\n\t\t\t\t}\n\n\t\t\t\tshapeDelta.add(shape) // add the shape's x and y to the delta\n\t\t\t\tchanges.push(this.getChangesToTranslateShape(shape, shapeDelta))\n\t\t\t}\n\n\t\t\tv += pageBounds[dim] + gap\n\t\t}\n\n\t\tthis.updateShapes(changes)\n\t\treturn this\n\t}\n\n\t/**\n\t * Stretch shape sizes and positions to fill their common bounding box.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.stretchShapes([box1, box2], 'horizontal')\n\t * editor.stretchShapes(editor.getSelectedShapeIds(), 'horizontal')\n\t * ```\n\t *\n\t * @param shapes - The shapes (or shape ids) to stretch.\n\t * @param operation - Whether to stretch shapes horizontally or vertically.\n\t *\n\t * @public\n\t */\n\tstretchShapes(shapes: TLShapeId[] | TLShape[], operation: 'horizontal' | 'vertical'): this {\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((s) => s.id)\n\n\t\tif (this.getIsReadonly()) return this\n\n\t\t// always fresh shapes, skip anything that isn't rotated 90 deg\n\t\tconst shapesToStretchFirstPass = compact(ids.map((id) => this.getShape(id))).filter(\n\t\t\t(s) => this.getShapePageTransform(s)?.rotation() % (PI / 2) === 0\n\t\t)\n\n\t\tconst shapeClustersToStretch: {\n\t\t\tshapes: TLShape[]\n\t\t\tpageBounds: Box\n\t\t}[] = []\n\n\t\tconst allBounds: Box[] = []\n\t\tconst visited = new Set<TLShapeId>()\n\n\t\tfor (const shape of shapesToStretchFirstPass) {\n\t\t\tif (visited.has(shape.id)) continue\n\t\t\tvisited.add(shape.id)\n\n\t\t\tconst shapePageBounds = this.getShapePageBounds(shape)\n\t\t\tif (!shapePageBounds) continue\n\n\t\t\tconst shapesMovingTogether = [shape]\n\t\t\tconst boundsOfShapesMovingTogether: Box[] = [shapePageBounds]\n\n\t\t\tif (\n\t\t\t\t!this.getShapeUtil(shape).canBeLaidOut?.(shape, {\n\t\t\t\t\ttype: 'stretch',\n\t\t\t\t\tshapes: shapesToStretchFirstPass,\n\t\t\t\t})\n\t\t\t) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tthis.collectShapesViaArrowBindings({\n\t\t\t\tbindings: this.getBindingsToShape(shape.id, 'arrow'),\n\t\t\t\tinitialShapes: shapesToStretchFirstPass,\n\t\t\t\tresultShapes: shapesMovingTogether,\n\t\t\t\tresultBounds: boundsOfShapesMovingTogether,\n\t\t\t\tvisited,\n\t\t\t})\n\n\t\t\tconst commonPageBounds = Box.Common(boundsOfShapesMovingTogether)\n\t\t\tif (!commonPageBounds) continue\n\n\t\t\tshapeClustersToStretch.push({\n\t\t\t\tshapes: shapesMovingTogether,\n\t\t\t\tpageBounds: commonPageBounds,\n\t\t\t})\n\n\t\t\tallBounds.push(commonPageBounds)\n\t\t}\n\n\t\tif (shapeClustersToStretch.length < 2) return this\n\n\t\tconst commonBounds = Box.Common(allBounds)\n\t\tlet val: 'x' | 'y'\n\t\tlet min: 'minX' | 'minY'\n\t\tlet dim: 'width' | 'height'\n\n\t\tif (operation === 'horizontal') {\n\t\t\tval = 'x'\n\t\t\tmin = 'minX'\n\t\t\tdim = 'width'\n\t\t} else {\n\t\t\tval = 'y'\n\t\t\tmin = 'minY'\n\t\t\tdim = 'height'\n\t\t}\n\n\t\tthis.run(() => {\n\t\t\tshapeClustersToStretch.forEach(({ shapes, pageBounds }) => {\n\t\t\t\tconst localOffset = new Vec()\n\t\t\t\tlocalOffset[val] = commonBounds[min] - pageBounds[min]\n\n\t\t\t\tconst scaleOrigin = pageBounds.center.clone()\n\t\t\t\tscaleOrigin[val] = commonBounds[min]\n\n\t\t\t\tconst scale = new Vec(1, 1)\n\t\t\t\tscale[val] = commonBounds[dim] / pageBounds[dim]\n\n\t\t\t\tfor (const shape of shapes) {\n\t\t\t\t\t// First translate\n\t\t\t\t\tconst shapeLocalOffset = localOffset.clone()\n\t\t\t\t\tconst parentTransform = this.getShapeParentTransform(shape)\n\t\t\t\t\tif (parentTransform) localOffset.rot(-parentTransform.rotation())\n\t\t\t\t\tshapeLocalOffset.add(shape)\n\t\t\t\t\tconst changes = this.getChangesToTranslateShape(shape, shapeLocalOffset)\n\t\t\t\t\tthis.updateShape(changes)\n\n\t\t\t\t\t// Then resize\n\t\t\t\t\tthis.resizeShape(shape.id, scale, {\n\t\t\t\t\t\tinitialBounds: this.getShapeGeometry(shape).bounds,\n\t\t\t\t\t\tscaleOrigin,\n\t\t\t\t\t\tisAspectRatioLocked: this.getShapeUtil(shape).isAspectRatioLocked(shape),\n\t\t\t\t\t\tscaleAxisRotation: 0,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Resize a shape.\n\t *\n\t * @param shape - The shape (or the shape id of the shape) to resize.\n\t * @param scale - The scale factor to apply to the shape.\n\t * @param opts - Additional options.\n\t *\n\t * @public\n\t */\n\tresizeShape(shape: TLShapeId | TLShape, scale: VecLike, opts: TLResizeShapeOptions = {}): this {\n\t\tconst id = typeof shape === 'string' ? shape : shape.id\n\t\tif (this.getIsReadonly()) return this\n\n\t\tif (!Number.isFinite(scale.x)) scale = new Vec(1, scale.y)\n\t\tif (!Number.isFinite(scale.y)) scale = new Vec(scale.x, 1)\n\n\t\tconst initialShape = opts.initialShape ?? this.getShape(id)\n\t\tif (!initialShape) return this\n\n\t\tconst scaleOrigin = opts.scaleOrigin ?? this.getShapePageBounds(id)?.center\n\t\tif (!scaleOrigin) return this\n\n\t\tconst pageTransform = opts.initialPageTransform\n\t\t\t? Mat.Cast(opts.initialPageTransform)\n\t\t\t: this.getShapePageTransform(id)\n\t\tif (!pageTransform) return this\n\n\t\tconst pageRotation = pageTransform.rotation()\n\n\t\tif (pageRotation == null) return this\n\n\t\tconst scaleAxisRotation = opts.scaleAxisRotation ?? pageRotation\n\n\t\tconst initialBounds = opts.initialBounds ?? this.getShapeGeometry(id).bounds\n\n\t\tif (!initialBounds) return this\n\n\t\tconst isAspectRatioLocked =\n\t\t\topts.isAspectRatioLocked ?? this.getShapeUtil(initialShape).isAspectRatioLocked(initialShape)\n\n\t\tif (!areAnglesCompatible(pageRotation, scaleAxisRotation)) {\n\t\t\t// shape is awkwardly rotated, keep the aspect ratio locked and adopt the scale factor\n\t\t\t// from whichever axis is being scaled the least, to avoid the shape getting bigger\n\t\t\t// than the bounds of the selection\n\t\t\t// const minScale = Math.min(Math.abs(scale.x), Math.abs(scale.y))\n\t\t\treturn this._resizeUnalignedShape(id, scale, {\n\t\t\t\t...opts,\n\t\t\t\tinitialBounds,\n\t\t\t\tscaleOrigin,\n\t\t\t\tscaleAxisRotation,\n\t\t\t\tinitialPageTransform: pageTransform,\n\t\t\t\tisAspectRatioLocked,\n\t\t\t\tinitialShape,\n\t\t\t})\n\t\t}\n\n\t\tconst util = this.getShapeUtil(initialShape)\n\n\t\tif (isAspectRatioLocked) {\n\t\t\tif (Math.abs(scale.x) > Math.abs(scale.y)) {\n\t\t\t\tscale = new Vec(scale.x, Math.sign(scale.y) * Math.abs(scale.x))\n\t\t\t} else {\n\t\t\t\tscale = new Vec(Math.sign(scale.x) * Math.abs(scale.y), scale.y)\n\t\t\t}\n\t\t}\n\n\t\tlet didResize = false\n\n\t\tif (util.onResize && util.canResize(initialShape)) {\n\t\t\t// get the model changes from the shape util\n\t\t\tconst newPagePoint = this._scalePagePoint(\n\t\t\t\tMat.applyToPoint(pageTransform, new Vec(0, 0)),\n\t\t\t\tscaleOrigin,\n\t\t\t\tscale,\n\t\t\t\tscaleAxisRotation\n\t\t\t)\n\n\t\t\tconst newLocalPoint = this.getPointInParentSpace(initialShape.id, newPagePoint)\n\n\t\t\t// resize the shape's local bounding box\n\t\t\tconst myScale = new Vec(scale.x, scale.y)\n\t\t\t// the shape is aligned with the rest of the shapes in the selection, but may be\n\t\t\t// 90deg offset from the main rotation of the selection, in which case\n\t\t\t// we need to flip the width and height scale factors\n\t\t\tconst areWidthAndHeightAlignedWithCorrectAxis = approximately(\n\t\t\t\t(pageRotation - scaleAxisRotation) % Math.PI,\n\t\t\t\t0\n\t\t\t)\n\t\t\tmyScale.x = areWidthAndHeightAlignedWithCorrectAxis ? scale.x : scale.y\n\t\t\tmyScale.y = areWidthAndHeightAlignedWithCorrectAxis ? scale.y : scale.x\n\n\t\t\t// adjust initial model for situations where the parent has moved during the resize\n\t\t\t// e.g. groups\n\t\t\tconst initialPagePoint = Mat.applyToPoint(pageTransform, new Vec())\n\n\t\t\t// need to adjust the shape's x and y points in case the parent has moved since start of resizing\n\t\t\tconst { x, y } = this.getPointInParentSpace(initialShape.id, initialPagePoint)\n\n\t\t\tlet workingShape = initialShape\n\t\t\tif (!opts.skipStartAndEndCallbacks) {\n\t\t\t\tworkingShape = applyPartialToRecordWithProps(\n\t\t\t\t\tinitialShape,\n\t\t\t\t\tutil.onResizeStart?.(initialShape) ?? undefined\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tconst resizedShape = util.onResize(\n\t\t\t\t{ ...initialShape, x, y },\n\t\t\t\t{\n\t\t\t\t\tnewPoint: newLocalPoint,\n\t\t\t\t\thandle: opts.dragHandle ?? 'bottom_right',\n\t\t\t\t\t// don't set isSingle to true for children\n\t\t\t\t\tmode: opts.mode ?? 'scale_shape',\n\t\t\t\t\tscaleX: myScale.x,\n\t\t\t\t\tscaleY: myScale.y,\n\t\t\t\t\tinitialBounds,\n\t\t\t\t\tinitialShape,\n\t\t\t\t}\n\t\t\t)\n\n\t\t\tif (resizedShape) {\n\t\t\t\tdidResize = true\n\t\t\t}\n\n\t\t\tworkingShape = applyPartialToRecordWithProps(workingShape, {\n\t\t\t\tid,\n\t\t\t\ttype: initialShape.type as any,\n\t\t\t\tx: newLocalPoint.x,\n\t\t\t\ty: newLocalPoint.y,\n\t\t\t\t...resizedShape,\n\t\t\t})\n\n\t\t\tif (!opts.skipStartAndEndCallbacks) {\n\t\t\t\tworkingShape = applyPartialToRecordWithProps(\n\t\t\t\t\tworkingShape,\n\t\t\t\t\tutil.onResizeEnd?.(initialShape, workingShape) ?? undefined\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tthis.updateShapes([workingShape])\n\t\t}\n\n\t\tif (!didResize) {\n\t\t\t// reposition shape (rather than resizing it) based on where its resized center would be\n\n\t\t\tconst initialPageCenter = Mat.applyToPoint(pageTransform, initialBounds.center)\n\t\t\t// get the model changes from the shape util\n\t\t\tconst newPageCenter = this._scalePagePoint(\n\t\t\t\tinitialPageCenter,\n\t\t\t\tscaleOrigin,\n\t\t\t\tscale,\n\t\t\t\tscaleAxisRotation\n\t\t\t)\n\n\t\t\tconst initialPageCenterInParentSpace = this.getPointInParentSpace(\n\t\t\t\tinitialShape.id,\n\t\t\t\tinitialPageCenter\n\t\t\t)\n\t\t\tconst newPageCenterInParentSpace = this.getPointInParentSpace(initialShape.id, newPageCenter)\n\n\t\t\tconst delta = Vec.Sub(newPageCenterInParentSpace, initialPageCenterInParentSpace)\n\t\t\t// apply the changes to the model\n\t\t\tthis.updateShapes([\n\t\t\t\t{\n\t\t\t\t\tid,\n\t\t\t\t\ttype: initialShape.type as any,\n\t\t\t\t\tx: initialShape.x + delta.x,\n\t\t\t\t\ty: initialShape.y + delta.y,\n\t\t\t\t},\n\t\t\t])\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _scalePagePoint(\n\t\tpoint: VecLike,\n\t\tscaleOrigin: VecLike,\n\t\tscale: VecLike,\n\t\tscaleAxisRotation: number\n\t) {\n\t\tconst relativePoint = Vec.RotWith(point, scaleOrigin, -scaleAxisRotation).sub(scaleOrigin)\n\n\t\t// calculate the new point position relative to the scale origin\n\t\tconst newRelativePagePoint = Vec.MulV(relativePoint, scale)\n\n\t\t// and rotate it back to page coords to get the new page point of the resized shape\n\t\tconst destination = Vec.Add(newRelativePagePoint, scaleOrigin).rotWith(\n\t\t\tscaleOrigin,\n\t\t\tscaleAxisRotation\n\t\t)\n\n\t\treturn destination\n\t}\n\n\t/** @internal */\n\tprivate _resizeUnalignedShape(\n\t\tid: TLShapeId,\n\t\tscale: VecLike,\n\t\toptions: {\n\t\t\tinitialBounds: Box\n\t\t\tscaleOrigin: VecLike\n\t\t\tscaleAxisRotation: number\n\t\t\tinitialShape: TLShape\n\t\t\tisAspectRatioLocked: boolean\n\t\t\tinitialPageTransform: MatLike\n\t\t}\n\t) {\n\t\tconst { type } = options.initialShape\n\t\t// If a shape is not aligned with the scale axis we need to treat it differently to avoid skewing.\n\t\t// Instead of skewing we normalize the scale aspect ratio (i.e. keep the same scale magnitude in both axes)\n\t\t// and then after applying the scale to the shape we also rotate it if required and translate it so that it's center\n\t\t// point ends up in the right place.\n\n\t\tconst shapeScale = new Vec(scale.x, scale.y)\n\n\t\t// // make sure we are constraining aspect ratio, and using the smallest scale axis to avoid shapes getting bigger\n\t\t// // than the selection bounding box\n\t\tif (Math.abs(scale.x) > Math.abs(scale.y)) {\n\t\t\tshapeScale.x = Math.sign(scale.x) * Math.abs(scale.y)\n\t\t} else {\n\t\t\tshapeScale.y = Math.sign(scale.y) * Math.abs(scale.x)\n\t\t}\n\n\t\t// first we can scale the shape about its center point\n\t\tthis.resizeShape(id, shapeScale, {\n\t\t\tinitialShape: options.initialShape,\n\t\t\tinitialBounds: options.initialBounds,\n\t\t\tisAspectRatioLocked: options.isAspectRatioLocked,\n\t\t})\n\n\t\t// then if the shape is flipped in one axis only, we need to apply an extra rotation\n\t\t// to make sure the shape is mirrored correctly\n\t\tif (Math.sign(scale.x) * Math.sign(scale.y) < 0) {\n\t\t\tlet { rotation } = Mat.Decompose(options.initialPageTransform)\n\t\t\trotation -= 2 * rotation\n\t\t\tthis.updateShapes([{ id, type, rotation }])\n\t\t}\n\n\t\t// Next we need to translate the shape so that it's center point ends up in the right place.\n\t\t// To do that we first need to calculate the center point of the shape in the current page space before the scale was applied.\n\t\tconst preScaleShapePageCenter = Mat.applyToPoint(\n\t\t\toptions.initialPageTransform,\n\t\t\toptions.initialBounds.center\n\t\t)\n\n\t\t// And now we scale the center point by the original scale factor\n\t\tconst postScaleShapePageCenter = this._scalePagePoint(\n\t\t\tpreScaleShapePageCenter,\n\t\t\toptions.scaleOrigin,\n\t\t\tscale,\n\t\t\toptions.scaleAxisRotation\n\t\t)\n\n\t\t// now calculate how far away the shape is from where it needs to be\n\t\tconst pageBounds = this.getShapePageBounds(id)!\n\t\tconst pageTransform = this.getShapePageTransform(id)!\n\t\tconst currentPageCenter = pageBounds.center\n\t\tconst shapePageTransformOrigin = pageTransform.point()\n\t\tif (!currentPageCenter || !shapePageTransformOrigin) return this\n\t\tconst pageDelta = Vec.Sub(postScaleShapePageCenter, currentPageCenter)\n\n\t\t// and finally figure out what the shape's new position should be\n\t\tconst postScaleShapePagePoint = Vec.Add(shapePageTransformOrigin, pageDelta)\n\t\tconst { x, y } = this.getPointInParentSpace(id, postScaleShapePagePoint)\n\n\t\tthis.updateShapes([{ id, type, x, y }])\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Get the initial meta value for a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getInitialMetaForShape = (shape) => {\n\t *   if (shape.type === 'note') {\n\t *     return { createdBy: myCurrentUser.id }\n\t *   }\n\t * }\n\t * ```\n\t *\n\t * @param shape - The shape to get the initial meta for.\n\t *\n\t * @public\n\t */\n\tgetInitialMetaForShape(_shape: TLShape): JsonObject {\n\t\treturn {}\n\t}\n\n\t/**\n\t * Get whether the provided shape can be created.\n\t *\n\t * @param shape - The shape or shape IDs to check.\n\t *\n\t * @public\n\t */\n\tcanCreateShape<T extends TLUnknownShape>(\n\t\tshape: OptionalKeys<TLShapePartial<T>, 'id'> | T['id']\n\t): boolean {\n\t\treturn this.canCreateShapes([shape])\n\t}\n\n\t/**\n\t * Get whether the provided shapes can be created.\n\t *\n\t * @param shapes - The shapes or shape IDs to create.\n\t *\n\t * @public\n\t */\n\tcanCreateShapes<T extends TLUnknownShape>(\n\t\tshapes: (T['id'] | OptionalKeys<TLShapePartial<T>, 'id'>)[]\n\t): boolean {\n\t\treturn shapes.length + this.getCurrentPageShapeIds().size <= this.options.maxShapesPerPage\n\t}\n\n\t/**\n\t * Create a single shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.createShape(myShape)\n\t * editor.createShape({ id: 'box1', type: 'text', props: { richText: toRichText(\"ok\") } })\n\t * ```\n\t *\n\t * @param shape - The shape (or shape partial) to create.\n\t *\n\t * @public\n\t */\n\tcreateShape<T extends TLUnknownShape>(shape: OptionalKeys<TLShapePartial<T>, 'id'>): this {\n\t\tthis.createShapes([shape])\n\t\treturn this\n\t}\n\n\t/**\n\t * Create shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.createShapes([myShape])\n\t * editor.createShapes([{ id: 'box1', type: 'text', props: { richText: toRichText(\"ok\") } }])\n\t * ```\n\t *\n\t * @param shapes - The shapes (or shape partials) to create.\n\t *\n\t * @public\n\t */\n\tcreateShapes<T extends TLUnknownShape>(shapes: OptionalKeys<TLShapePartial<T>, 'id'>[]): this {\n\t\tif (!Array.isArray(shapes)) {\n\t\t\tthrow Error('Editor.createShapes: must provide an array of shapes or shape partials')\n\t\t}\n\t\tif (this.getIsReadonly()) return this\n\t\tif (shapes.length <= 0) return this\n\n\t\tconst currentPageShapeIds = this.getCurrentPageShapeIds()\n\n\t\tconst maxShapesReached =\n\t\t\tshapes.length + currentPageShapeIds.size > this.options.maxShapesPerPage\n\n\t\tif (maxShapesReached) {\n\t\t\t// can't create more shapes than fit on the page\n\t\t\talertMaxShapes(this)\n\t\t\t// todo: throw an error here? Otherwise we'll need to check every time whether the shapes were actually created\n\t\t\treturn this\n\t\t}\n\n\t\tconst focusedGroupId = this.getFocusedGroupId()\n\n\t\tthis.run(() => {\n\t\t\t// 1. Parents\n\n\t\t\t// Make sure that each partial will become the child of either the\n\t\t\t// page or another shape that exists (or that will exist) in this page.\n\n\t\t\t// find last parent id\n\t\t\tconst currentPageShapesSorted = this.getCurrentPageShapesSorted()\n\n\t\t\tconst partials = shapes.map((partial) => {\n\t\t\t\tif (!partial.id) {\n\t\t\t\t\tpartial = { id: createShapeId(), ...partial }\n\t\t\t\t}\n\n\t\t\t\t// If the partial does not provide the parentId OR if the provided\n\t\t\t\t// parentId is NOT in the store AND NOT among the other shapes being\n\t\t\t\t// created, then we need to find a parent for the shape. This can be\n\t\t\t\t// another shape that exists under that point and which can receive\n\t\t\t\t// children of the creating shape's type, or else the page itself.\n\t\t\t\tif (\n\t\t\t\t\t!partial.parentId ||\n\t\t\t\t\t!(this.store.has(partial.parentId) || shapes.some((p) => p.id === partial.parentId))\n\t\t\t\t) {\n\t\t\t\t\tlet parentId: TLParentId = this.getFocusedGroupId()\n\n\t\t\t\t\tfor (let i = currentPageShapesSorted.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tconst parent = currentPageShapesSorted[i]\n\t\t\t\t\t\tconst util = this.getShapeUtil(parent)\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tutil.canReceiveNewChildrenOfType(parent, partial.type) &&\n\t\t\t\t\t\t\t!this.isShapeHidden(parent) &&\n\t\t\t\t\t\t\tthis.isPointInShape(\n\t\t\t\t\t\t\t\tparent,\n\t\t\t\t\t\t\t\t// If no parent is provided, then we can treat the\n\t\t\t\t\t\t\t\t// shape's provided x/y as being in the page's space.\n\t\t\t\t\t\t\t\t{ x: partial.x ?? 0, y: partial.y ?? 0 },\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmargin: 0,\n\t\t\t\t\t\t\t\t\thitInside: true,\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tparentId = parent.id\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst prevParentId = partial.parentId\n\n\t\t\t\t\t// a shape cannot be its own parent. This was a rare issue with frames/groups in the syncFuzz tests.\n\t\t\t\t\tif (parentId === partial.id) {\n\t\t\t\t\t\tparentId = focusedGroupId\n\t\t\t\t\t}\n\n\t\t\t\t\t// If the parentid has changed...\n\t\t\t\t\tif (parentId !== prevParentId) {\n\t\t\t\t\t\tpartial = { ...partial }\n\n\t\t\t\t\t\tpartial.parentId = parentId\n\n\t\t\t\t\t\t// If the parent is a shape (rather than a page) then insert the\n\t\t\t\t\t\t// shapes into the shape's children. Adjust the point and page rotation to be\n\t\t\t\t\t\t// preserved relative to the parent.\n\t\t\t\t\t\tif (isShapeId(parentId)) {\n\t\t\t\t\t\t\tconst point = this.getPointInShapeSpace(this.getShape(parentId)!, {\n\t\t\t\t\t\t\t\tx: partial.x ?? 0,\n\t\t\t\t\t\t\t\ty: partial.y ?? 0,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\tpartial.x = point.x\n\t\t\t\t\t\t\tpartial.y = point.y\n\t\t\t\t\t\t\tpartial.rotation =\n\t\t\t\t\t\t\t\t-this.getShapePageTransform(parentId)!.rotation() + (partial.rotation ?? 0)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn partial\n\t\t\t})\n\n\t\t\t// 2. Indices\n\n\t\t\t// Get the highest index among the parents of each of the\n\t\t\t// the shapes being created; we'll increment from there.\n\n\t\t\tconst parentIndices = new Map<TLParentId, IndexKey>()\n\n\t\t\tconst shapeRecordsToCreate: TLShape[] = []\n\n\t\t\tconst { opacityForNextShape } = this.getInstanceState()\n\n\t\t\tfor (const partial of partials) {\n\t\t\t\tconst util = this.getShapeUtil(partial as TLShapePartial)\n\n\t\t\t\t// If an index is not explicitly provided, then add the\n\t\t\t\t// shapes to the top of their parents' children; using the\n\t\t\t\t// value in parentsMappedToIndex, get the index above, use it,\n\t\t\t\t// and set it back to parentsMappedToIndex for next time.\n\t\t\t\tlet index = partial.index\n\n\t\t\t\tif (!index) {\n\t\t\t\t\t// Hello bug-seeker: have you just created a frame and then a shape\n\t\t\t\t\t// and found that the shape is automatically the child of the frame?\n\t\t\t\t\t// this is the reason why! It would be harder to have each shape specify\n\t\t\t\t\t// the frame as the parent when creating a shape inside of a frame, so\n\t\t\t\t\t// we do it here.\n\t\t\t\t\tconst parentId = partial.parentId ?? focusedGroupId\n\n\t\t\t\t\tif (!parentIndices.has(parentId)) {\n\t\t\t\t\t\tparentIndices.set(parentId, this.getHighestIndexForParent(parentId))\n\t\t\t\t\t}\n\t\t\t\t\tindex = parentIndices.get(parentId)!\n\t\t\t\t\tparentIndices.set(parentId, getIndexAbove(index))\n\t\t\t\t}\n\n\t\t\t\t// The initial props starts as the shape utility's default props\n\t\t\t\tconst initialProps = util.getDefaultProps()\n\n\t\t\t\t// We then look up each key in the tab state's styles; and if it's there,\n\t\t\t\t// we use the value from the tab state's styles instead of the default.\n\t\t\t\tfor (const [style, propKey] of this.styleProps[partial.type]) {\n\t\t\t\t\t;(initialProps as any)[propKey] = this.getStyleForNextShape(style)\n\t\t\t\t}\n\n\t\t\t\t// When we create the shape, take in the partial (the props coming into the\n\t\t\t\t// function) and merge it with the default props.\n\t\t\t\tlet shapeRecordToCreate = (\n\t\t\t\t\tthis.store.schema.types.shape as RecordType<\n\t\t\t\t\t\tTLShape,\n\t\t\t\t\t\t'type' | 'props' | 'index' | 'parentId'\n\t\t\t\t\t>\n\t\t\t\t).create({\n\t\t\t\t\t...partial,\n\t\t\t\t\tindex,\n\t\t\t\t\topacity: partial.opacity ?? opacityForNextShape,\n\t\t\t\t\tparentId: partial.parentId ?? focusedGroupId,\n\t\t\t\t\tprops: 'props' in partial ? { ...initialProps, ...partial.props } : initialProps,\n\t\t\t\t})\n\n\t\t\t\tif (shapeRecordToCreate.index === undefined) {\n\t\t\t\t\tthrow Error('no index!')\n\t\t\t\t}\n\n\t\t\t\tconst next = this.getShapeUtil(shapeRecordToCreate).onBeforeCreate?.(shapeRecordToCreate)\n\n\t\t\t\tif (next) {\n\t\t\t\t\tshapeRecordToCreate = next\n\t\t\t\t}\n\n\t\t\t\tshapeRecordsToCreate.push(shapeRecordToCreate)\n\t\t\t}\n\n\t\t\t// Add meta properties, if any, to the shapes\n\t\t\tshapeRecordsToCreate.forEach((shape) => {\n\t\t\t\tshape.meta = {\n\t\t\t\t\t...this.getInitialMetaForShape(shape),\n\t\t\t\t\t...shape.meta,\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tthis.emit('created-shapes', shapeRecordsToCreate)\n\t\t\tthis.emit('edit')\n\t\t\tthis.store.put(shapeRecordsToCreate)\n\t\t})\n\n\t\treturn this\n\t}\n\n\tprivate animatingShapes = new Map<TLShapeId, string>()\n\n\t/**\n\t * Animate a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.animateShape({ id: 'box1', type: 'box', x: 100, y: 100 })\n\t * editor.animateShape({ id: 'box1', type: 'box', x: 100, y: 100 }, { animation: { duration: 100, ease: t => t*t } })\n\t * ```\n\t *\n\t * @param partial - The shape partial to update.\n\t * @param opts - The animation's options.\n\t *\n\t * @public\n\t */\n\tanimateShape(\n\t\tpartial: TLShapePartial | null | undefined,\n\t\topts = { animation: DEFAULT_ANIMATION_OPTIONS } as TLCameraMoveOptions\n\t): this {\n\t\treturn this.animateShapes([partial], opts)\n\t}\n\n\t/**\n\t * Animate shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.animateShapes([{ id: 'box1', type: 'box', x: 100, y: 100 }])\n\t * editor.animateShapes([{ id: 'box1', type: 'box', x: 100, y: 100 }], { animation: { duration: 100, ease: t => t*t } })\n\t * ```\n\t *\n\t * @param partials - The shape partials to update.\n\t * @param opts - The animation's options.\n\t *\n\t * @public\n\t */\n\tanimateShapes(\n\t\tpartials: (TLShapePartial | null | undefined)[],\n\t\topts = { animation: DEFAULT_ANIMATION_OPTIONS } as TLCameraMoveOptions\n\t): this {\n\t\tif (!opts.animation) return this\n\t\tconst { duration = 500, easing = EASINGS.linear } = opts.animation\n\n\t\tconst animationId = uniqueId()\n\n\t\tlet remaining = duration\n\t\tlet t: number\n\n\t\tinterface ShapeAnimation {\n\t\t\tstart: TLShape\n\t\t\tend: TLShape\n\t\t}\n\n\t\tconst animations: ShapeAnimation[] = []\n\n\t\tlet partial: TLShapePartial | null | undefined, result: ShapeAnimation\n\t\tfor (let i = 0, n = partials.length; i < n; i++) {\n\t\t\tpartial = partials[i]\n\t\t\tif (!partial) continue\n\n\t\t\tconst shape = this.getShape(partial.id)!\n\t\t\tif (!shape) continue\n\n\t\t\tresult = {\n\t\t\t\tstart: structuredClone(shape),\n\t\t\t\tend: applyPartialToRecordWithProps(structuredClone(shape), partial),\n\t\t\t}\n\n\t\t\tanimations.push(result)\n\t\t\tthis.animatingShapes.set(shape.id, animationId)\n\t\t}\n\n\t\tconst handleTick = (elapsed: number) => {\n\t\t\tremaining -= elapsed\n\n\t\t\tif (remaining < 0) {\n\t\t\t\tconst { animatingShapes } = this\n\t\t\t\tconst partialsToUpdate = partials.filter(\n\t\t\t\t\t(p) => p && animatingShapes.get(p.id) === animationId\n\t\t\t\t)\n\t\t\t\tif (partialsToUpdate.length) {\n\t\t\t\t\t// the regular update shapes also removes the shape from\n\t\t\t\t\t// the animating shapes set\n\t\t\t\t\tthis.updateShapes(partialsToUpdate)\n\t\t\t\t}\n\n\t\t\t\tthis.off('tick', handleTick)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tt = easing(1 - remaining / duration)\n\n\t\t\tconst { animatingShapes } = this\n\n\t\t\tconst updates: TLShapePartial[] = []\n\n\t\t\tlet animationIdForShape: string | undefined\n\t\t\tfor (let i = 0, n = animations.length; i < n; i++) {\n\t\t\t\tconst { start, end } = animations[i]\n\t\t\t\t// Is the animation for this shape still active?\n\t\t\t\tanimationIdForShape = animatingShapes.get(start.id)\n\t\t\t\tif (animationIdForShape !== animationId) continue\n\n\t\t\t\tupdates.push({\n\t\t\t\t\t...end,\n\t\t\t\t\tx: start.x + (end.x - start.x) * t,\n\t\t\t\t\ty: start.y + (end.y - start.y) * t,\n\t\t\t\t\topacity: start.opacity + (end.opacity - start.opacity) * t,\n\t\t\t\t\trotation: start.rotation + (end.rotation - start.rotation) * t,\n\t\t\t\t\tprops: this.getShapeUtil(end).getInterpolatedProps?.(start, end, t) ?? end.props,\n\t\t\t\t})\n\t\t\t}\n\n\t\t\t// The _updateShapes method does NOT remove the\n\t\t\t// shapes from the animated shapes set\n\t\t\tthis._updateShapes(updates)\n\t\t}\n\n\t\tthis.on('tick', handleTick)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Create a group containing the provided shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.groupShapes([myShape, myOtherShape])\n\t * editor.groupShapes([myShape, myOtherShape], { groupId: myGroupId, select: false })\n\t * ```\n\t *\n\t * @param shapes - The shapes (or shape ids) to group. Defaults to the selected shapes.\n\t * @param opts - An options object.\n\t *\n\t * @public\n\t */\n\tgroupShapes(shapes: TLShape[], opts?: Partial<{ groupId: TLShapeId; select: boolean }>): this\n\tgroupShapes(ids: TLShapeId[], opts?: Partial<{ groupId: TLShapeId; select: boolean }>): this\n\tgroupShapes(\n\t\tshapes: TLShapeId[] | TLShape[],\n\t\topts = {} as Partial<{ groupId: TLShapeId; select: boolean }>\n\t): this {\n\t\tconst { groupId = createShapeId(), select = true } = opts\n\n\t\tif (!Array.isArray(shapes)) {\n\t\t\tthrow Error('Editor.groupShapes: must provide an array of shapes or shape ids')\n\t\t}\n\t\tif (this.getIsReadonly()) return this\n\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes.map((s) => (s as TLShape).id) as TLShapeId[])\n\n\t\tif (ids.length <= 1) return this\n\n\t\tconst shapesToGroup = compact(\n\t\t\t(this._shouldIgnoreShapeLock ? ids : this._getUnlockedShapeIds(ids)).map((id) =>\n\t\t\t\tthis.getShape(id)\n\t\t\t)\n\t\t)\n\t\tconst sortedShapeIds = shapesToGroup.sort(sortByIndex).map((s) => s.id)\n\t\tconst pageBounds = Box.Common(compact(shapesToGroup.map((id) => this.getShapePageBounds(id))))\n\n\t\tconst { x, y } = pageBounds.point\n\n\t\tconst parentId = this.findCommonAncestor(shapesToGroup) ?? this.getCurrentPageId()\n\n\t\t// Only group when the select tool is active\n\t\tif (this.getCurrentToolId() !== 'select') return this\n\n\t\t// If not already in idle, cancel the current interaction (get back to idle)\n\t\tif (!this.isIn('select.idle')) {\n\t\t\tthis.cancel()\n\t\t}\n\n\t\t// Find all the shapes that have the same parentId, and use the highest index.\n\t\tconst shapesWithRootParent = shapesToGroup\n\t\t\t.filter((shape) => shape.parentId === parentId)\n\t\t\t.sort(sortByIndex)\n\n\t\tconst highestIndex = shapesWithRootParent[shapesWithRootParent.length - 1]?.index\n\n\t\tthis.run(() => {\n\t\t\tthis.createShapes<TLGroupShape>([\n\t\t\t\t{\n\t\t\t\t\tid: groupId,\n\t\t\t\t\ttype: 'group',\n\t\t\t\t\tparentId,\n\t\t\t\t\tindex: highestIndex,\n\t\t\t\t\tx,\n\t\t\t\t\ty,\n\t\t\t\t\topacity: 1,\n\t\t\t\t\tprops: {},\n\t\t\t\t},\n\t\t\t])\n\t\t\tthis.reparentShapes(sortedShapeIds, groupId)\n\t\t\tif (select) {\n\t\t\t\t// the select option determines whether the grouped shapes' children are selected\n\t\t\t\tthis.select(groupId)\n\t\t\t}\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Ungroup some shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.ungroupShapes([myGroup, myOtherGroup])\n\t * editor.ungroupShapes([myGroup], { select: false })\n\t * ```\n\t *\n\t * @param shapes - The group shapes (or shape ids) to ungroup.\n\t * @param opts - An options object.\n\t *\n\t * @public\n\t */\n\tungroupShapes(ids: TLShapeId[], opts?: Partial<{ select: boolean }>): this\n\tungroupShapes(shapes: TLShape[], opts?: Partial<{ select: boolean }>): this\n\tungroupShapes(shapes: TLShapeId[] | TLShape[], opts = {} as Partial<{ select: boolean }>) {\n\t\tif (this.getIsReadonly()) return this\n\n\t\tconst { select = true } = opts\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((s) => s.id)\n\n\t\tconst shapesToUngroup = compact(\n\t\t\t(this._shouldIgnoreShapeLock ? ids : this._getUnlockedShapeIds(ids)).map((id) =>\n\t\t\t\tthis.getShape(id)\n\t\t\t)\n\t\t)\n\n\t\tif (shapesToUngroup.length === 0) return this\n\n\t\t// todo: the editor shouldn't know about the select tool, move to group / ungroup actions\n\t\tif (this.getCurrentToolId() !== 'select') return this\n\t\tif (!this.isIn('select.idle')) {\n\t\t\tthis.cancel()\n\t\t}\n\n\t\t// The ids of the selected shapes after ungrouping;\n\t\t// these include all of the grouped shapes children,\n\t\t// plus any shapes that were selected apart from the groups.\n\t\tconst idsToSelect = new Set<TLShapeId>()\n\n\t\t// Get all groups in the selection\n\t\tconst groups: TLGroupShape[] = []\n\n\t\tshapesToUngroup.forEach((shape) => {\n\t\t\tif (this.isShapeOfType<TLGroupShape>(shape, 'group')) {\n\t\t\t\tgroups.push(shape)\n\t\t\t} else {\n\t\t\t\tidsToSelect.add(shape.id)\n\t\t\t}\n\t\t})\n\n\t\tif (groups.length === 0) return this\n\n\t\tthis.run(() => {\n\t\t\tlet group: TLGroupShape\n\n\t\t\tfor (let i = 0, n = groups.length; i < n; i++) {\n\t\t\t\tgroup = groups[i]\n\t\t\t\tconst childIds = this.getSortedChildIdsForParent(group.id)\n\n\t\t\t\tfor (let j = 0, n = childIds.length; j < n; j++) {\n\t\t\t\t\tidsToSelect.add(childIds[j])\n\t\t\t\t}\n\n\t\t\t\tthis.reparentShapes(childIds, group.parentId, group.index)\n\t\t\t}\n\n\t\t\tthis.deleteShapes(groups.map((group) => group.id))\n\n\t\t\tif (select) {\n\t\t\t\t// the select option determines whether the ungrouped shapes' children are selected\n\t\t\t\tthis.select(...idsToSelect)\n\t\t\t}\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Update a shape using a partial of the shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.updateShape({ id: 'box1', type: 'geo', props: { w: 100, h: 100 } })\n\t * ```\n\t *\n\t * @param partial - The shape partial to update.\n\t *\n\t * @public\n\t */\n\tupdateShape<T extends TLUnknownShape>(partial: TLShapePartial<T> | null | undefined) {\n\t\tthis.updateShapes([partial])\n\t\treturn this\n\t}\n\n\t/**\n\t * Update shapes using partials of each shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.updateShapes([{ id: 'box1', type: 'geo', props: { w: 100, h: 100 } }])\n\t * ```\n\t *\n\t * @param partials - The shape partials to update.\n\t *\n\t * @public\n\t */\n\tupdateShapes<T extends TLUnknownShape>(partials: (TLShapePartial<T> | null | undefined)[]) {\n\t\tconst compactedPartials: TLShapePartial<T>[] = Array(partials.length)\n\n\t\tfor (let i = 0, n = partials.length; i < n; i++) {\n\t\t\tconst partial = partials[i]\n\t\t\tif (!partial) continue\n\t\t\t// Get the current shape referenced by the partial\n\t\t\tconst shape = this.getShape(partial.id)\n\t\t\tif (!shape) continue\n\n\t\t\t// If we're \"forcing\" the update, then we'll update the shape\n\t\t\t// regardless of whether it / its ancestor is locked\n\t\t\tif (!this._shouldIgnoreShapeLock) {\n\t\t\t\tif (shape.isLocked) {\n\t\t\t\t\t// If the shape itself is locked (even if one of its ancestors is\n\t\t\t\t\t// also locked) then only allow an update that unlocks the shape.\n\t\t\t\t\tif (!(Object.hasOwn(partial, 'isLocked') && !partial.isLocked)) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t} else if (this.isShapeOrAncestorLocked(shape)) {\n\t\t\t\t\t// If the shape itself is unlocked, and any of the shape's\n\t\t\t\t\t// ancestors are locked then we'll skip the update\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove any animating shapes from the list of partials\n\t\t\tthis.animatingShapes.delete(partial.id)\n\n\t\t\tcompactedPartials.push(partial)\n\t\t}\n\n\t\tthis._updateShapes(compactedPartials)\n\t\treturn this\n\t}\n\n\t/** @internal */\n\t_updateShapes(_partials: (TLShapePartial | null | undefined)[]) {\n\t\tif (this.getIsReadonly()) return\n\n\t\tthis.run(() => {\n\t\t\tconst updates = []\n\n\t\t\tlet shape: TLShape | undefined\n\t\t\tlet updated: TLShape\n\n\t\t\tfor (let i = 0, n = _partials.length; i < n; i++) {\n\t\t\t\tconst partial = _partials[i]\n\t\t\t\t// Skip nullish partials (sometimes created by map fns returning undefined)\n\t\t\t\tif (!partial) continue\n\n\t\t\t\t// Get the current shape referenced by the partial\n\t\t\t\t// If there is no current shape, we'll skip this update\n\t\t\t\tshape = this.getShape(partial.id)\n\t\t\t\tif (!shape) continue\n\n\t\t\t\t// Get the updated version of the shape\n\t\t\t\t// If the update had no effect, we'll skip this update\n\t\t\t\tupdated = applyPartialToRecordWithProps(shape, partial)\n\t\t\t\tif (updated === shape) continue\n\n\t\t\t\t//if any shape has an onBeforeUpdate handler, call it and, if the handler returns a\n\t\t\t\t// new shape, replace the old shape with the new one. This is used for example when\n\t\t\t\t// repositioning a text shape based on its new text content.\n\t\t\t\tupdated = this.getShapeUtil(shape).onBeforeUpdate?.(shape, updated) ?? updated\n\n\t\t\t\tupdates.push(updated)\n\t\t\t}\n\n\t\t\tthis.emit('edited-shapes', updates)\n\t\t\tthis.emit('edit')\n\t\t\tthis.store.put(updates)\n\t\t})\n\t}\n\n\t/** @internal */\n\tprivate _getUnlockedShapeIds(ids: TLShapeId[]): TLShapeId[] {\n\t\treturn ids.filter((id) => !this.getShape(id)?.isLocked)\n\t}\n\n\t/**\n\t * Delete shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.deleteShapes(['box1', 'box2'])\n\t * ```\n\t *\n\t * @param ids - The ids of the shapes to delete.\n\t *\n\t * @public\n\t */\n\tdeleteShapes(ids: TLShapeId[]): this\n\tdeleteShapes(shapes: TLShape[]): this\n\tdeleteShapes(_ids: TLShapeId[] | TLShape[]): this {\n\t\tif (this.getIsReadonly()) return this\n\n\t\tif (!Array.isArray(_ids)) {\n\t\t\tthrow Error('Editor.deleteShapes: must provide an array of shapes or shapeIds')\n\t\t}\n\n\t\tconst shapeIds =\n\t\t\ttypeof _ids[0] === 'string' ? (_ids as TLShapeId[]) : (_ids as TLShape[]).map((s) => s.id)\n\n\t\t// Normally we don't want to delete locked shapes, but if the force option is set, we'll delete them anyway\n\t\tconst shapeIdsToDelete = this._shouldIgnoreShapeLock\n\t\t\t? shapeIds\n\t\t\t: this._getUnlockedShapeIds(shapeIds)\n\n\t\tif (shapeIdsToDelete.length === 0) return this\n\n\t\t// We also need to delete these shapes' descendants\n\t\tconst allShapeIdsToDelete = new Set<TLShapeId>(shapeIdsToDelete)\n\n\t\tfor (const id of shapeIdsToDelete) {\n\t\t\tthis.visitDescendants(id, (childId) => {\n\t\t\t\tallShapeIdsToDelete.add(childId)\n\t\t\t})\n\t\t}\n\n\t\tthis.emit('deleted-shapes', [...allShapeIdsToDelete])\n\t\tthis.emit('edit')\n\t\treturn this.run(() => this.store.remove([...allShapeIdsToDelete]))\n\t}\n\n\t/**\n\t * Delete a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.deleteShape(shape.id)\n\t * ```\n\t *\n\t * @param id - The id of the shape to delete.\n\t *\n\t * @public\n\t */\n\tdeleteShape(id: TLShapeId): this\n\tdeleteShape(shape: TLShape): this\n\tdeleteShape(_id: TLShapeId | TLShape) {\n\t\tthis.deleteShapes([typeof _id === 'string' ? _id : _id.id])\n\t\treturn this\n\t}\n\n\t/* --------------------- Styles --------------------- */\n\n\t/**\n\t * Get all the current styles among the users selected shapes\n\t *\n\t * @internal\n\t */\n\tprivate _extractSharedStyles(shape: TLShape, sharedStyleMap: SharedStyleMap) {\n\t\tif (this.isShapeOfType<TLGroupShape>(shape, 'group')) {\n\t\t\t// For groups, ignore the styles of the group shape and instead include the styles of the\n\t\t\t// group's children. These are the shapes that would have their styles changed if the\n\t\t\t// user called `setStyle` on the current selection.\n\t\t\tconst childIds = this._parentIdsToChildIds.get()[shape.id]\n\t\t\tif (!childIds) return\n\n\t\t\tfor (let i = 0, n = childIds.length; i < n; i++) {\n\t\t\t\tthis._extractSharedStyles(this.getShape(childIds[i])!, sharedStyleMap)\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const [style, propKey] of this.styleProps[shape.type]) {\n\t\t\t\tsharedStyleMap.applyValue(style, getOwnProperty(shape.props, propKey))\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * A derived map containing all current styles among the user's selected shapes.\n\t *\n\t * @internal\n\t */\n\t@computed\n\tprivate _getSelectionSharedStyles(): ReadonlySharedStyleMap {\n\t\tconst selectedShapes = this.getSelectedShapes()\n\n\t\tconst sharedStyles = new SharedStyleMap()\n\t\tfor (const selectedShape of selectedShapes) {\n\t\t\tthis._extractSharedStyles(selectedShape, sharedStyles)\n\t\t}\n\n\t\treturn sharedStyles\n\t}\n\n\t/**\n\t * Get the style for the next shape.\n\t *\n\t * @example\n\t * ```ts\n\t * const color = editor.getStyleForNextShape(DefaultColorStyle)\n\t * ```\n\t *\n\t * @param style - The style to get.\n\t *\n\t * @public */\n\tgetStyleForNextShape<T>(style: StyleProp<T>): T {\n\t\tconst value = this.getInstanceState().stylesForNextShape[style.id]\n\t\treturn value === undefined ? style.defaultValue : (value as T)\n\t}\n\n\tgetShapeStyleIfExists<T>(shape: TLShape, style: StyleProp<T>): T | undefined {\n\t\tconst styleKey = this.styleProps[shape.type].get(style)\n\t\tif (styleKey === undefined) return undefined\n\t\treturn getOwnProperty(shape.props, styleKey) as T | undefined\n\t}\n\n\t/**\n\t * A map of all the current styles either in the current selection, or that are relevant to the\n\t * current tool.\n\t *\n\t * @example\n\t * ```ts\n\t * const color = editor.getSharedStyles().get(DefaultColorStyle)\n\t * if (color && color.type === 'shared') {\n\t *   print('All selected shapes have the same color:', color.value)\n\t * }\n\t * ```\n\t *\n\t * @public\n\t */\n\t@computed<ReadonlySharedStyleMap>({ isEqual: (a, b) => a.equals(b) })\n\tgetSharedStyles(): ReadonlySharedStyleMap {\n\t\t// If we're in selecting and if we have a selection, return the shared styles from the\n\t\t// current selection\n\t\tif (this.isIn('select') && this.getSelectedShapeIds().length > 0) {\n\t\t\treturn this._getSelectionSharedStyles()\n\t\t}\n\n\t\t// If the current tool is associated with a shape, return the styles for that shape.\n\t\t// Otherwise, just return an empty map.\n\t\tconst currentTool = this.root.getCurrent()!\n\t\tconst styles = new SharedStyleMap()\n\n\t\tif (!currentTool) return styles\n\n\t\tif (currentTool.shapeType) {\n\t\t\tif (\n\t\t\t\tcurrentTool.shapeType === 'frame' &&\n\t\t\t\t!(this.getShapeUtil('frame')!.options as any).showColors\n\t\t\t) {\n\t\t\t\tfor (const style of this.styleProps[currentTool.shapeType].keys()) {\n\t\t\t\t\tif (style.id === 'tldraw:color') continue\n\t\t\t\t\tstyles.applyValue(style, this.getStyleForNextShape(style))\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (const style of this.styleProps[currentTool.shapeType].keys()) {\n\t\t\t\t\tstyles.applyValue(style, this.getStyleForNextShape(style))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn styles\n\t}\n\n\t/**\n\t * Get the currently selected shared opacity.\n\t * If any shapes are selected, this returns the shared opacity of the selected shapes.\n\t * Otherwise, this returns the chosen opacity for the next shape.\n\t *\n\t * @public\n\t */\n\t@computed getSharedOpacity(): SharedStyle<number> {\n\t\tif (this.isIn('select') && this.getSelectedShapeIds().length > 0) {\n\t\t\tconst shapesToCheck: TLShape[] = []\n\t\t\tconst addShape = (shapeId: TLShapeId) => {\n\t\t\t\tconst shape = this.getShape(shapeId)\n\t\t\t\tif (!shape) return\n\t\t\t\t// For groups, ignore the opacity of the group shape and instead include\n\t\t\t\t// the opacity of the group's children. These are the shapes that would have\n\t\t\t\t// their opacity changed if the user called `setOpacity` on the current selection.\n\t\t\t\tif (this.isShapeOfType<TLGroupShape>(shape, 'group')) {\n\t\t\t\t\tfor (const childId of this.getSortedChildIdsForParent(shape.id)) {\n\t\t\t\t\t\taddShape(childId)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tshapesToCheck.push(shape)\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const shapeId of this.getSelectedShapeIds()) {\n\t\t\t\taddShape(shapeId)\n\t\t\t}\n\n\t\t\tlet opacity: number | null = null\n\t\t\tfor (const shape of shapesToCheck) {\n\t\t\t\tif (opacity === null) {\n\t\t\t\t\topacity = shape.opacity\n\t\t\t\t} else if (opacity !== shape.opacity) {\n\t\t\t\t\treturn { type: 'mixed' }\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (opacity !== null) return { type: 'shared', value: opacity }\n\t\t}\n\t\treturn { type: 'shared', value: this.getInstanceState().opacityForNextShape }\n\t}\n\n\t/**\n\t * Set the opacity for the next shapes. This will effect subsequently created shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setOpacityForNextShapes(0.5)\n\t * ```\n\t *\n\t * @param opacity - The opacity to set. Must be a number between 0 and 1 inclusive.\n\t * @param historyOptions - The history options for the change.\n\t */\n\tsetOpacityForNextShapes(opacity: number, historyOptions?: TLHistoryBatchOptions): this {\n\t\tthis.updateInstanceState({ opacityForNextShape: opacity }, historyOptions)\n\t\treturn this\n\t}\n\n\t/**\n\t * Set the current opacity. This will effect any selected shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setOpacityForSelectedShapes(0.5)\n\t * ```\n\t *\n\t * @param opacity - The opacity to set. Must be a number between 0 and 1 inclusive.\n\t */\n\tsetOpacityForSelectedShapes(opacity: number): this {\n\t\tconst selectedShapes = this.getSelectedShapes()\n\n\t\tif (selectedShapes.length > 0) {\n\t\t\tconst shapesToUpdate: TLShape[] = []\n\n\t\t\t// We can have many deep levels of grouped shape\n\t\t\t// Making a recursive function to look through all the levels\n\t\t\tconst addShapeById = (shape: TLShape) => {\n\t\t\t\tif (this.isShapeOfType<TLGroupShape>(shape, 'group')) {\n\t\t\t\t\tconst childIds = this.getSortedChildIdsForParent(shape)\n\t\t\t\t\tfor (const childId of childIds) {\n\t\t\t\t\t\taddShapeById(this.getShape(childId)!)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tshapesToUpdate.push(shape)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const id of selectedShapes) {\n\t\t\t\taddShapeById(id)\n\t\t\t}\n\n\t\t\tthis.updateShapes(\n\t\t\t\tshapesToUpdate.map((shape) => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tid: shape.id,\n\t\t\t\t\t\ttype: shape.type,\n\t\t\t\t\t\topacity,\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t)\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Set the value of a {@link @tldraw/tlschema#StyleProp} for the next shapes. This change will be applied to subsequently created shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setStyleForNextShapes(DefaultColorStyle, 'red')\n\t * editor.setStyleForNextShapes(DefaultColorStyle, 'red', { ephemeral: true })\n\t * ```\n\t *\n\t * @param style - The style to set.\n\t * @param value - The value to set.\n\t * @param historyOptions - The history options for the change.\n\t *\n\t * @public\n\t */\n\tsetStyleForNextShapes<T>(\n\t\tstyle: StyleProp<T>,\n\t\tvalue: T,\n\t\thistoryOptions?: TLHistoryBatchOptions\n\t): this {\n\t\tconst stylesForNextShape = this.getInstanceState().stylesForNextShape\n\n\t\tthis.updateInstanceState(\n\t\t\t{ stylesForNextShape: { ...stylesForNextShape, [style.id]: value } },\n\t\t\thistoryOptions\n\t\t)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Set the value of a {@link @tldraw/tlschema#StyleProp}. This change will be applied to the currently selected shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setStyleForSelectedShapes(DefaultColorStyle, 'red')\n\t * ```\n\t *\n\t * @param style - The style to set.\n\t * @param value - The value to set.\n\t *\n\t * @public\n\t */\n\tsetStyleForSelectedShapes<S extends StyleProp<any>>(style: S, value: StylePropValue<S>): this {\n\t\tconst selectedShapes = this.getSelectedShapes()\n\n\t\tif (selectedShapes.length > 0) {\n\t\t\tconst updates: {\n\t\t\t\tutil: ShapeUtil\n\t\t\t\toriginalShape: TLShape\n\t\t\t\tupdatePartial: TLShapePartial\n\t\t\t}[] = []\n\n\t\t\t// We can have many deep levels of grouped shape\n\t\t\t// Making a recursive function to look through all the levels\n\t\t\tconst addShapeById = (shape: TLShape) => {\n\t\t\t\tif (this.isShapeOfType<TLGroupShape>(shape, 'group')) {\n\t\t\t\t\tconst childIds = this.getSortedChildIdsForParent(shape.id)\n\t\t\t\t\tfor (const childId of childIds) {\n\t\t\t\t\t\taddShapeById(this.getShape(childId)!)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst util = this.getShapeUtil(shape)\n\t\t\t\t\tconst stylePropKey = this.styleProps[shape.type].get(style)\n\t\t\t\t\tif (stylePropKey) {\n\t\t\t\t\t\tconst shapePartial: TLShapePartial = {\n\t\t\t\t\t\t\tid: shape.id,\n\t\t\t\t\t\t\ttype: shape.type,\n\t\t\t\t\t\t\tprops: { [stylePropKey]: value },\n\t\t\t\t\t\t}\n\t\t\t\t\t\tupdates.push({\n\t\t\t\t\t\t\tutil,\n\t\t\t\t\t\t\toriginalShape: shape,\n\t\t\t\t\t\t\tupdatePartial: shapePartial,\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const shape of selectedShapes) {\n\t\t\t\taddShapeById(shape)\n\t\t\t}\n\n\t\t\tthis.updateShapes(updates.map(({ updatePartial }) => updatePartial))\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/* --------------------- Content -------------------- */\n\n\t/** @internal */\n\texternalAssetContentHandlers: {\n\t\t[K in TLExternalAsset['type']]: {\n\t\t\t[Key in K]: null | ((info: TLExternalAsset & { type: Key }) => Promise<TLAsset | undefined>)\n\t\t}[K]\n\t} = {\n\t\tfile: null,\n\t\turl: null,\n\t}\n\n\t/** @internal */\n\tprivate readonly temporaryAssetPreview = new Map<TLAssetId, string>()\n\n\t/**\n\t * Register an external asset handler. This handler will be called when the editor needs to\n\t * create an asset for some external content, like an image/video file or a bookmark URL. For\n\t * example, the 'file' type handler will be called when a user drops an image onto the canvas.\n\t *\n\t * The handler should extract any relevant metadata for the asset, upload it to blob storage\n\t * using {@link Editor.uploadAsset} if needed, and return the asset with the metadata & uploaded\n\t * URL.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.registerExternalAssetHandler('file', myHandler)\n\t * ```\n\t *\n\t * @param type - The type of external content.\n\t * @param handler - The handler to use for this content type.\n\t *\n\t * @public\n\t */\n\tregisterExternalAssetHandler<T extends TLExternalAsset['type']>(\n\t\ttype: T,\n\t\thandler: null | ((info: TLExternalAsset & { type: T }) => Promise<TLAsset>)\n\t): this {\n\t\tthis.externalAssetContentHandlers[type] = handler as any\n\t\treturn this\n\t}\n\n\t/**\n\t * Register a temporary preview of an asset. This is useful for showing a ghost image of\n\t * something that is being uploaded. Retrieve the placeholder with\n\t * {@link Editor.getTemporaryAssetPreview}. Placeholders last for 3 minutes by default, but this\n\t * can be configured using\n\t *\n\t * @example\n\t * ```ts\n\t * editor.createTemporaryAssetPreview(assetId, file)\n\t * ```\n\t *\n\t * @param assetId - The asset's id.\n\t * @param file - The raw file.\n\t *\n\t * @public\n\t */\n\tcreateTemporaryAssetPreview(assetId: TLAssetId, file: File) {\n\t\tif (this.temporaryAssetPreview.has(assetId)) {\n\t\t\treturn this.temporaryAssetPreview.get(assetId)\n\t\t}\n\n\t\tconst objectUrl = URL.createObjectURL(file)\n\t\tthis.temporaryAssetPreview.set(assetId, objectUrl)\n\n\t\t// eslint-disable-next-line no-restricted-globals -- we always want to revoke the asset and object URL\n\t\tsetTimeout(() => {\n\t\t\tthis.temporaryAssetPreview.delete(assetId)\n\t\t\tURL.revokeObjectURL(objectUrl)\n\t\t}, this.options.temporaryAssetPreviewLifetimeMs)\n\n\t\treturn objectUrl\n\t}\n\n\t/**\n\t * Get temporary preview of an asset. This is useful for showing a ghost\n\t * image of something that is being uploaded.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getTemporaryAssetPreview('someId')\n\t * ```\n\t *\n\t * @param assetId - The asset's id.\n\t *\n\t * @public\n\t */\n\tgetTemporaryAssetPreview(assetId: TLAssetId) {\n\t\treturn this.temporaryAssetPreview.get(assetId)\n\t}\n\n\t/**\n\t * Get an asset for an external asset content type.\n\t *\n\t * @example\n\t * ```ts\n\t * const asset = await editor.getAssetForExternalContent({ type: 'file', file: myFile })\n\t * const asset = await editor.getAssetForExternalContent({ type: 'url', url: myUrl })\n\t * ```\n\t *\n\t * @param info - Info about the external content.\n\t * @returns The asset.\n\t */\n\tasync getAssetForExternalContent(info: TLExternalAsset): Promise<TLAsset | undefined> {\n\t\treturn await this.externalAssetContentHandlers[info.type]?.(info as any)\n\t}\n\n\thasExternalAssetHandler(type: TLExternalAsset['type']): boolean {\n\t\treturn !!this.externalAssetContentHandlers[type]\n\t}\n\n\t/** @internal */\n\texternalContentHandlers: {\n\t\t[K in TLExternalContent<any>['type']]: {\n\t\t\t[Key in K]: null | ((info: Extract<TLExternalContent<any>, { type: Key }>) => void)\n\t\t}[K]\n\t} = {\n\t\ttext: null,\n\t\tfiles: null,\n\t\t'file-replace': null,\n\t\tembed: null,\n\t\t'svg-text': null,\n\t\turl: null,\n\t\ttldraw: null,\n\t\texcalidraw: null,\n\t}\n\n\t/**\n\t * Register an external content handler. This handler will be called when the editor receives\n\t * external content of the provided type. For example, the 'image' type handler will be called\n\t * when a user drops an image onto the canvas.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.registerExternalContentHandler('text', myHandler)\n\t * ```\n\t * @example\n\t * ```ts\n\t * editor.registerExternalContentHandler<'embed', MyEmbedType>('embed', myHandler)\n\t * ```\n\t *\n\t * @param type - The type of external content.\n\t * @param handler - The handler to use for this content type.\n\t *\n\t * @public\n\t */\n\tregisterExternalContentHandler<T extends TLExternalContent<E>['type'], E>(\n\t\ttype: T,\n\t\thandler:\n\t\t\t| null\n\t\t\t| ((\n\t\t\t\t\tinfo: T extends TLExternalContent<E>['type']\n\t\t\t\t\t\t? Extract<TLExternalContent<E>, { type: T }>\n\t\t\t\t\t\t: TLExternalContent<E>\n\t\t\t  ) => void)\n\t): this {\n\t\tthis.externalContentHandlers[type] = handler as any\n\t\treturn this\n\t}\n\n\t/**\n\t * Handle external content, such as files, urls, embeds, or plain text which has been put into the app, for example by pasting external text or dropping external images onto canvas.\n\t *\n\t * @param info - Info about the external content.\n\t */\n\tasync putExternalContent<E>(info: TLExternalContent<E>): Promise<void> {\n\t\treturn this.externalContentHandlers[info.type]?.(info as any)\n\t}\n\n\t/**\n\t * Handle replacing external content.\n\t *\n\t * @param info - Info about the external content.\n\t */\n\tasync replaceExternalContent<E>(info: TLExternalContent<E>): Promise<void> {\n\t\treturn this.externalContentHandlers[info.type]?.(info as any)\n\t}\n\n\t/**\n\t * Get content that can be exported for the given shape ids.\n\t *\n\t * @param shapes - The shapes (or shape ids) to get content for.\n\t *\n\t * @returns The exported content.\n\t *\n\t * @public\n\t */\n\tgetContentFromCurrentPage(shapes: TLShapeId[] | TLShape[]): TLContent | undefined {\n\t\t// todo: make this work with any page, not just the current page\n\t\tconst ids =\n\t\t\ttypeof shapes[0] === 'string'\n\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t: (shapes as TLShape[]).map((s) => s.id)\n\n\t\tif (!ids) return\n\t\tif (ids.length === 0) return\n\n\t\tconst shapeIds = this.getShapeAndDescendantIds(ids)\n\n\t\treturn withIsolatedShapes(this, shapeIds, (bindingIdsToKeep) => {\n\t\t\tconst bindings: TLBinding[] = []\n\t\t\tfor (const id of bindingIdsToKeep) {\n\t\t\t\tconst binding = this.getBinding(id)\n\t\t\t\tif (!binding) continue\n\t\t\t\tbindings.push(binding)\n\t\t\t}\n\n\t\t\tconst rootShapeIds: TLShapeId[] = []\n\t\t\tconst shapes: TLShape[] = []\n\t\t\tfor (const shapeId of shapeIds) {\n\t\t\t\tconst shape = this.getShape(shapeId)\n\t\t\t\tif (!shape) continue\n\n\t\t\t\tconst isRootShape = !shapeIds.has(shape.parentId as TLShapeId)\n\t\t\t\tif (isRootShape) {\n\t\t\t\t\t// Need to get page point and rotation of the shape because shapes in\n\t\t\t\t\t// groups use local position/rotation\n\t\t\t\t\tconst pageTransform = this.getShapePageTransform(shape.id)!\n\t\t\t\t\tconst pagePoint = pageTransform.point()\n\t\t\t\t\tshapes.push({\n\t\t\t\t\t\t...shape,\n\t\t\t\t\t\tx: pagePoint.x,\n\t\t\t\t\t\ty: pagePoint.y,\n\t\t\t\t\t\trotation: pageTransform.rotation(),\n\t\t\t\t\t\tparentId: this.getCurrentPageId(),\n\t\t\t\t\t})\n\t\t\t\t\trootShapeIds.push(shape.id)\n\t\t\t\t} else {\n\t\t\t\t\tshapes.push(shape)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst assets: TLAsset[] = []\n\t\t\tconst seenAssetIds = new Set<TLAssetId>()\n\t\t\tfor (const shape of shapes) {\n\t\t\t\tif (!('assetId' in shape.props)) continue\n\n\t\t\t\tconst assetId = shape.props.assetId\n\t\t\t\tif (!assetId || seenAssetIds.has(assetId)) continue\n\n\t\t\t\tseenAssetIds.add(assetId)\n\t\t\t\tconst asset = this.getAsset(assetId)\n\t\t\t\tif (!asset) continue\n\t\t\t\tassets.push(asset)\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tschema: this.store.schema.serialize(),\n\t\t\t\tshapes,\n\t\t\t\trootShapeIds,\n\t\t\t\tbindings,\n\t\t\t\tassets,\n\t\t\t}\n\t\t})\n\t}\n\n\tasync resolveAssetsInContent(content: TLContent | undefined): Promise<TLContent | undefined> {\n\t\tif (!content) return undefined\n\n\t\tconst assets: TLAsset[] = []\n\t\tawait Promise.allSettled(\n\t\t\tcontent.assets.map(async (asset) => {\n\t\t\t\tif (\n\t\t\t\t\t(asset.type === 'image' || asset.type === 'video') &&\n\t\t\t\t\t!asset.props.src?.startsWith('data:image') &&\n\t\t\t\t\t!asset.props.src?.startsWith('data:video') &&\n\t\t\t\t\t!asset.props.src?.startsWith('http')\n\t\t\t\t) {\n\t\t\t\t\tconst assetWithDataUrl = structuredClone(asset as TLImageAsset | TLVideoAsset)\n\t\t\t\t\tconst objectUrl = await this.store.props.assets.resolve(asset, {\n\t\t\t\t\t\tscreenScale: 1,\n\t\t\t\t\t\tsteppedScreenScale: 1,\n\t\t\t\t\t\tdpr: 1,\n\t\t\t\t\t\tnetworkEffectiveType: null,\n\t\t\t\t\t\tshouldResolveToOriginal: true,\n\t\t\t\t\t})\n\t\t\t\t\tassetWithDataUrl.props.src = await FileHelpers.blobToDataUrl(\n\t\t\t\t\t\tawait fetch(objectUrl!).then((r) => r.blob())\n\t\t\t\t\t)\n\t\t\t\t\tassets.push(assetWithDataUrl)\n\t\t\t\t} else {\n\t\t\t\t\tassets.push(asset)\n\t\t\t\t}\n\t\t\t})\n\t\t)\n\t\tcontent.assets = assets\n\n\t\treturn content\n\t}\n\n\t/**\n\t * Place content into the editor.\n\t *\n\t * @param content - The content.\n\t * @param opts - Options for placing the content.\n\t *\n\t * @public\n\t */\n\tputContentOntoCurrentPage(\n\t\tcontent: TLContent,\n\t\topts: {\n\t\t\tpoint?: VecLike\n\t\t\tselect?: boolean\n\t\t\tpreservePosition?: boolean\n\t\t\tpreserveIds?: boolean\n\t\t} = {}\n\t): this {\n\t\tif (this.getIsReadonly()) return this\n\n\t\t// todo: make this able to support putting content onto any page, not just the current page\n\n\t\tif (!content.schema) {\n\t\t\tthrow Error('Could not put content:\\ncontent is missing a schema.')\n\t\t}\n\n\t\tconst { select = false, preserveIds = false, preservePosition = false } = opts\n\t\tlet { point = undefined } = opts\n\n\t\t// decide on a parent for the put shapes; if the parent is among the put shapes(?) then use its parent\n\n\t\tconst currentPageId = this.getCurrentPageId()\n\t\tconst { rootShapeIds } = content\n\n\t\t// We need to collect the migrated records\n\t\tconst assets: TLAsset[] = []\n\t\tconst shapes: TLShape[] = []\n\t\tconst bindings: TLBinding[] = []\n\n\t\t// Let's treat the content as a store, and then migrate that store.\n\t\tconst store: StoreSnapshot<TLRecord> = {\n\t\t\tstore: {\n\t\t\t\t...Object.fromEntries(content.assets.map((asset) => [asset.id, asset] as const)),\n\t\t\t\t...Object.fromEntries(content.shapes.map((shape) => [shape.id, shape] as const)),\n\t\t\t\t...Object.fromEntries(\n\t\t\t\t\tcontent.bindings?.map((bindings) => [bindings.id, bindings] as const) ?? []\n\t\t\t\t),\n\t\t\t},\n\t\t\tschema: content.schema,\n\t\t}\n\t\tconst result = this.store.schema.migrateStoreSnapshot(store)\n\t\tif (result.type === 'error') {\n\t\t\tthrow Error('Could not put content: could not migrate content')\n\t\t}\n\t\tfor (const record of Object.values(result.value)) {\n\t\t\tswitch (record.typeName) {\n\t\t\t\tcase 'asset': {\n\t\t\t\t\tassets.push(record)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'shape': {\n\t\t\t\t\tshapes.push(record)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'binding': {\n\t\t\t\t\tbindings.push(record)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Ok, we've got our migrated records, now we can continue!\n\t\tconst shapeIdMap = new Map<string, TLShapeId>(\n\t\t\tpreserveIds\n\t\t\t\t? shapes.map((shape) => [shape.id, shape.id])\n\t\t\t\t: shapes.map((shape) => [shape.id, createShapeId()])\n\t\t)\n\t\tconst bindingIdMap = new Map<string, TLBindingId>(\n\t\t\tpreserveIds\n\t\t\t\t? bindings.map((binding) => [binding.id, binding.id])\n\t\t\t\t: bindings.map((binding) => [binding.id, createBindingId()])\n\t\t)\n\n\t\t// By default, the paste parent will be the current page.\n\t\tlet pasteParentId = this.getCurrentPageId() as TLPageId | TLShapeId\n\t\tlet lowestDepth = Infinity\n\t\tlet lowestAncestors: TLShape[] = []\n\n\t\t// Among the selected shapes, find the shape with the fewest ancestors and use its first ancestor.\n\t\tfor (const shape of this.getSelectedShapes()) {\n\t\t\tif (lowestDepth === 0) break\n\n\t\t\tconst isFrame = this.isShapeOfType<TLFrameShape>(shape, 'frame')\n\t\t\tconst ancestors = this.getShapeAncestors(shape)\n\t\t\tif (isFrame) ancestors.push(shape)\n\n\t\t\tconst depth = isFrame ? ancestors.length + 1 : ancestors.length\n\n\t\t\tif (depth < lowestDepth) {\n\t\t\t\tlowestDepth = depth\n\t\t\t\tlowestAncestors = ancestors\n\t\t\t\tpasteParentId = isFrame ? shape.id : shape.parentId\n\t\t\t} else if (depth === lowestDepth) {\n\t\t\t\tif (lowestAncestors.length !== ancestors.length) {\n\t\t\t\t\tthrow Error(`Ancestors: ${lowestAncestors.length} !== ${ancestors.length}`)\n\t\t\t\t}\n\n\t\t\t\tif (lowestAncestors.length === 0) {\n\t\t\t\t\tpasteParentId = currentPageId\n\t\t\t\t\tbreak\n\t\t\t\t} else {\n\t\t\t\t\tpasteParentId = currentPageId\n\t\t\t\t\tfor (let i = 0; i < lowestAncestors.length; i++) {\n\t\t\t\t\t\tif (ancestors[i] !== lowestAncestors[i]) break\n\t\t\t\t\t\tpasteParentId = ancestors[i].id\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet isDuplicating = false\n\n\t\tif (!isPageId(pasteParentId)) {\n\t\t\tconst parent = this.getShape(pasteParentId)\n\t\t\tif (parent) {\n\t\t\t\tif (!this.getViewportPageBounds().includes(this.getShapePageBounds(parent)!)) {\n\t\t\t\t\tpasteParentId = currentPageId\n\t\t\t\t} else {\n\t\t\t\t\tif (rootShapeIds.length === 1) {\n\t\t\t\t\t\tconst rootShape = shapes.find((s) => s.id === rootShapeIds[0])!\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tthis.isShapeOfType<TLFrameShape>(parent, 'frame') &&\n\t\t\t\t\t\t\tthis.isShapeOfType<TLFrameShape>(rootShape, 'frame') &&\n\t\t\t\t\t\t\trootShape.props.w === parent?.props.w &&\n\t\t\t\t\t\t\trootShape.props.h === parent?.props.h\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tisDuplicating = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpasteParentId = currentPageId\n\t\t\t}\n\t\t}\n\n\t\tif (!isDuplicating) {\n\t\t\tisDuplicating = shapeIdMap.has(pasteParentId)\n\t\t}\n\n\t\tif (isDuplicating) {\n\t\t\tpasteParentId = this.getShape(pasteParentId)!.parentId\n\t\t}\n\n\t\tlet index = this.getHighestIndexForParent(pasteParentId) // todo: requires that the putting page is the current page\n\n\t\tconst rootShapes: TLShape[] = []\n\n\t\tconst newShapes: TLShape[] = shapes.map((oldShape): TLShape => {\n\t\t\tconst newId = shapeIdMap.get(oldShape.id)!\n\n\t\t\t// Create the new shape (new except for the id)\n\t\t\tconst newShape = { ...oldShape, id: newId }\n\n\t\t\tif (rootShapeIds.includes(oldShape.id)) {\n\t\t\t\tnewShape.parentId = currentPageId\n\t\t\t\trootShapes.push(newShape)\n\t\t\t}\n\n\t\t\t// Assign the child to its new parent.\n\n\t\t\t// If the child's parent is among the putting shapes, then assign\n\t\t\t// it to the new parent's id.\n\t\t\tif (shapeIdMap.has(newShape.parentId)) {\n\t\t\t\tnewShape.parentId = shapeIdMap.get(oldShape.parentId)!\n\t\t\t} else {\n\t\t\t\trootShapeIds.push(newShape.id)\n\t\t\t\t// newShape.parentId = pasteParentId\n\t\t\t\tnewShape.index = index\n\t\t\t\tindex = getIndexAbove(index)\n\t\t\t}\n\n\t\t\treturn newShape\n\t\t})\n\n\t\tif (newShapes.length + this.getCurrentPageShapeIds().size > this.options.maxShapesPerPage) {\n\t\t\t// There's some complexity here involving children\n\t\t\t// that might be created without their parents, so\n\t\t\t// if we're going over the limit then just don't paste.\n\t\t\talertMaxShapes(this)\n\t\t\treturn this\n\t\t}\n\n\t\tconst newBindings = bindings.map(\n\t\t\t(oldBinding): TLBinding => ({\n\t\t\t\t...oldBinding,\n\t\t\t\tid: assertExists(bindingIdMap.get(oldBinding.id)),\n\t\t\t\tfromId: assertExists(shapeIdMap.get(oldBinding.fromId)),\n\t\t\t\ttoId: assertExists(shapeIdMap.get(oldBinding.toId)),\n\t\t\t})\n\t\t)\n\n\t\t// These are all the assets we need to create\n\t\tconst assetsToCreate: TLAsset[] = []\n\n\t\t// These assets have base64 data that may need to be hosted\n\t\tconst assetsToUpdate: (TLImageAsset | TLVideoAsset)[] = []\n\n\t\tfor (const asset of assets) {\n\t\t\tif (this.store.has(asset.id)) {\n\t\t\t\t// We already have this asset\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t(asset.type === 'image' && asset.props.src?.startsWith('data:image')) ||\n\t\t\t\t(asset.type === 'video' && asset.props.src?.startsWith('data:video'))\n\t\t\t) {\n\t\t\t\t// it's src is a base64 image or video; we need to create a new asset without the src,\n\t\t\t\t// then create a new asset from the original src. So we save a copy of the original asset,\n\t\t\t\t// then delete the src from the original asset.\n\t\t\t\tassetsToUpdate.push(structuredClone(asset as TLImageAsset | TLVideoAsset))\n\t\t\t\tasset.props.src = null\n\t\t\t}\n\n\t\t\t// Add the asset to the list of assets to create\n\t\t\tassetsToCreate.push(asset)\n\t\t}\n\n\t\t// Start loading the new assets, order does not matter\n\t\tPromise.allSettled(\n\t\t\t(assetsToUpdate as (TLImageAsset | TLVideoAsset)[]).map(async (asset) => {\n\t\t\t\t// Turn the data url into a file\n\t\t\t\tconst file = await dataUrlToFile(\n\t\t\t\t\tasset.props.src!,\n\t\t\t\t\tasset.props.name,\n\t\t\t\t\tasset.props.mimeType ?? 'image/png'\n\t\t\t\t)\n\n\t\t\t\t// Get a new asset for the file\n\t\t\t\tconst newAsset = await this.getAssetForExternalContent({\n\t\t\t\t\ttype: 'file',\n\t\t\t\t\tfile,\n\t\t\t\t\tassetId: asset.id,\n\t\t\t\t})\n\n\t\t\t\tif (!newAsset) {\n\t\t\t\t\t// If we don't have a new asset, delete the old asset.\n\t\t\t\t\t// The shapes that reference this asset should break.\n\t\t\t\t\tthis.deleteAssets([asset.id])\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// Save the new asset under the old asset's id\n\t\t\t\tthis.updateAssets([{ ...newAsset, id: asset.id }])\n\t\t\t})\n\t\t)\n\n\t\tthis.run(() => {\n\t\t\t// Create any assets that need to be created\n\t\t\tif (assetsToCreate.length > 0) {\n\t\t\t\tthis.createAssets(assetsToCreate)\n\t\t\t}\n\n\t\t\t// Create the shapes with root shapes as children of the page\n\t\t\tthis.createShapes(newShapes)\n\t\t\tthis.createBindings(newBindings)\n\n\t\t\tif (select) {\n\t\t\t\tthis.select(...rootShapes.map((s) => s.id))\n\t\t\t}\n\n\t\t\t// And then, if needed, reparent the root shapes to the paste parent\n\t\t\tif (pasteParentId !== currentPageId) {\n\t\t\t\tthis.reparentShapes(\n\t\t\t\t\trootShapes.map((s) => s.id),\n\t\t\t\t\tpasteParentId\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tconst newCreatedShapes = newShapes.map((s) => this.getShape(s.id)!)\n\t\t\tconst bounds = Box.Common(newCreatedShapes.map((s) => this.getShapePageBounds(s)!))\n\n\t\t\tif (point === undefined) {\n\t\t\t\tif (!isPageId(pasteParentId)) {\n\t\t\t\t\t// Put the shapes in the middle of the (on screen) parent\n\t\t\t\t\tconst shape = this.getShape(pasteParentId)!\n\t\t\t\t\tpoint = Mat.applyToPoint(\n\t\t\t\t\t\tthis.getShapePageTransform(shape),\n\t\t\t\t\t\tthis.getShapeGeometry(shape).bounds.center\n\t\t\t\t\t)\n\t\t\t\t} else {\n\t\t\t\t\tconst viewportPageBounds = this.getViewportPageBounds()\n\t\t\t\t\tif (preservePosition || viewportPageBounds.includes(Box.From(bounds))) {\n\t\t\t\t\t\t// Otherwise, put shapes where they used to be\n\t\t\t\t\t\tpoint = bounds.center\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If the old bounds are outside of the viewport...\n\t\t\t\t\t\t// put the shapes in the middle of the viewport\n\t\t\t\t\t\tpoint = viewportPageBounds.center\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rootShapes.length === 1) {\n\t\t\t\tconst onlyRoot = rootShapes[0] as TLFrameShape\n\t\t\t\t// If the old bounds are in the viewport...\n\t\t\t\t// todo: replace frame references with shapes that can accept children\n\t\t\t\tif (this.isShapeOfType<TLFrameShape>(onlyRoot, 'frame')) {\n\t\t\t\t\twhile (\n\t\t\t\t\t\tthis.getShapesAtPoint(point).some(\n\t\t\t\t\t\t\t(shape) =>\n\t\t\t\t\t\t\t\tthis.isShapeOfType<TLFrameShape>(shape, 'frame') &&\n\t\t\t\t\t\t\t\tshape.props.w === onlyRoot.props.w &&\n\t\t\t\t\t\t\t\tshape.props.h === onlyRoot.props.h\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tpoint.x += bounds.w + 16\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst pageCenter = Box.Common(\n\t\t\t\tcompact(rootShapes.map(({ id }) => this.getShapePageBounds(id)))\n\t\t\t).center\n\n\t\t\tconst offset = Vec.Sub(point, pageCenter)\n\n\t\t\tthis.updateShapes(\n\t\t\t\trootShapes.map(({ id }) => {\n\t\t\t\t\tconst s = this.getShape(id)!\n\t\t\t\t\tconst localRotation = this.getShapeParentTransform(id).decompose().rotation\n\t\t\t\t\tconst localDelta = Vec.Rot(offset, -localRotation)\n\n\t\t\t\t\treturn { id: s.id, type: s.type, x: s.x + localDelta.x, y: s.y + localDelta.y }\n\t\t\t\t})\n\t\t\t)\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Get an exported SVG element of the given shapes.\n\t *\n\t * @param shapes - The shapes (or shape ids) to export.\n\t * @param opts - Options for the export.\n\t *\n\t * @returns The SVG element.\n\t *\n\t * @public\n\t */\n\tasync getSvgElement(shapes: TLShapeId[] | TLShape[], opts: TLSvgExportOptions = {}) {\n\t\tconst ids =\n\t\t\tshapes.length === 0\n\t\t\t\t? this.getCurrentPageShapeIdsSorted()\n\t\t\t\t: typeof shapes[0] === 'string'\n\t\t\t\t\t? (shapes as TLShapeId[])\n\t\t\t\t\t: (shapes as TLShape[]).map((s) => s.id)\n\n\t\tif (ids.length === 0) return undefined\n\n\t\treturn exportToSvg(this, ids, opts)\n\t}\n\n\t/**\n\t * Get an exported SVG string of the given shapes.\n\t *\n\t * @param shapes - The shapes (or shape ids) to export.\n\t * @param opts - Options for the export.\n\t *\n\t * @returns The SVG element.\n\t *\n\t * @public\n\t */\n\tasync getSvgString(shapes: TLShapeId[] | TLShape[], opts: TLSvgExportOptions = {}) {\n\t\tconst result = await this.getSvgElement(shapes, opts)\n\t\tif (!result) return undefined\n\n\t\tconst serializer = new XMLSerializer()\n\t\treturn {\n\t\t\tsvg: serializer.serializeToString(result.svg),\n\t\t\twidth: result.width,\n\t\t\theight: result.height,\n\t\t}\n\t}\n\n\t/** @deprecated Use {@link Editor.getSvgString} or {@link Editor.getSvgElement} instead. */\n\tasync getSvg(shapes: TLShapeId[] | TLShape[], opts: TLSvgExportOptions = {}) {\n\t\tconst result = await this.getSvgElement(shapes, opts)\n\t\tif (!result) return undefined\n\t\treturn result.svg\n\t}\n\n\t/**\n\t * Get an exported image of the given shapes.\n\t *\n\t * @param shapes - The shapes (or shape ids) to export.\n\t * @param opts - Options for the export.\n\t *\n\t * @returns A blob of the image.\n\t * @public\n\t */\n\tasync toImage(shapes: TLShapeId[] | TLShape[], opts: TLImageExportOptions = {}) {\n\t\tconst withDefaults = {\n\t\t\tformat: 'png',\n\t\t\tscale: 1,\n\t\t\tpixelRatio: opts.format === 'svg' ? undefined : 2,\n\t\t\t...opts,\n\t\t} satisfies TLImageExportOptions\n\t\tconst result = await this.getSvgString(shapes, withDefaults)\n\t\tif (!result) throw new Error('Could not create SVG')\n\n\t\tswitch (withDefaults.format) {\n\t\t\tcase 'svg':\n\t\t\t\treturn {\n\t\t\t\t\tblob: new Blob([result.svg], { type: 'image/svg+xml' }),\n\t\t\t\t\twidth: result.width,\n\t\t\t\t\theight: result.height,\n\t\t\t\t}\n\t\t\tcase 'jpeg':\n\t\t\tcase 'png':\n\t\t\tcase 'webp': {\n\t\t\t\tconst blob = await getSvgAsImage(result.svg, {\n\t\t\t\t\ttype: withDefaults.format,\n\t\t\t\t\tquality: withDefaults.quality,\n\t\t\t\t\tpixelRatio: withDefaults.pixelRatio,\n\t\t\t\t\twidth: result.width,\n\t\t\t\t\theight: result.height,\n\t\t\t\t})\n\t\t\t\tif (!blob) {\n\t\t\t\t\tthrow new Error('Could not construct image.')\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tblob,\n\t\t\t\t\twidth: result.width,\n\t\t\t\t\theight: result.height,\n\t\t\t\t}\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\texhaustiveSwitchError(withDefaults.format)\n\t\t\t}\n\t\t}\n\t}\n\n\t/* --------------------- Events --------------------- */\n\n\t/**\n\t * The app's current input state.\n\t *\n\t * @public\n\t */\n\tinputs = {\n\t\t/** The most recent pointer down's position in the current page space. */\n\t\toriginPagePoint: new Vec(),\n\t\t/** The most recent pointer down's position in screen space. */\n\t\toriginScreenPoint: new Vec(),\n\t\t/** The previous pointer position in the current page space. */\n\t\tpreviousPagePoint: new Vec(),\n\t\t/** The previous pointer position in screen space. */\n\t\tpreviousScreenPoint: new Vec(),\n\t\t/** The most recent pointer position in the current page space. */\n\t\tcurrentPagePoint: new Vec(),\n\t\t/** The most recent pointer position in screen space. */\n\t\tcurrentScreenPoint: new Vec(),\n\t\t/** A set containing the currently pressed keys. */\n\t\tkeys: new Set<string>(),\n\t\t/** A set containing the currently pressed buttons. */\n\t\tbuttons: new Set<number>(),\n\t\t/** Whether the input is from a pe. */\n\t\tisPen: false,\n\t\t/** Whether the shift key is currently pressed. */\n\t\tshiftKey: false,\n\t\t/** Whether the meta key is currently pressed. */\n\t\tmetaKey: false,\n\t\t/** Whether the control or command key is currently pressed. */\n\t\tctrlKey: false,\n\t\t/** Whether the alt or option key is currently pressed. */\n\t\taltKey: false,\n\t\t/** Whether the user is dragging. */\n\t\tisDragging: false,\n\t\t/** Whether the user is pointing. */\n\t\tisPointing: false,\n\t\t/** Whether the user is pinching. */\n\t\tisPinching: false,\n\t\t/** Whether the user is editing. */\n\t\tisEditing: false,\n\t\t/** Whether the user is panning. */\n\t\tisPanning: false,\n\t\t/** Whether the user is spacebar panning. */\n\t\tisSpacebarPanning: false,\n\t\t/** Velocity of mouse pointer, in pixels per millisecond */\n\t\tpointerVelocity: new Vec(),\n\t}\n\n\t/**\n\t * Update the input points from a pointer, pinch, or wheel event.\n\t *\n\t * @param info - The event info.\n\t */\n\tprivate _updateInputsFromEvent(\n\t\tinfo: TLPointerEventInfo | TLPinchEventInfo | TLWheelEventInfo\n\t): void {\n\t\tconst {\n\t\t\tpointerVelocity,\n\t\t\tpreviousScreenPoint,\n\t\t\tpreviousPagePoint,\n\t\t\tcurrentScreenPoint,\n\t\t\tcurrentPagePoint,\n\t\t\toriginScreenPoint,\n\t\t\toriginPagePoint,\n\t\t} = this.inputs\n\n\t\tconst { screenBounds } = this.store.unsafeGetWithoutCapture(TLINSTANCE_ID)!\n\t\tconst { x: cx, y: cy, z: cz } = unsafe__withoutCapture(() => this.getCamera())\n\n\t\tconst sx = info.point.x - screenBounds.x\n\t\tconst sy = info.point.y - screenBounds.y\n\t\tconst sz = info.point.z ?? 0.5\n\n\t\tpreviousScreenPoint.setTo(currentScreenPoint)\n\t\tpreviousPagePoint.setTo(currentPagePoint)\n\n\t\t// The \"screen bounds\" is relative to the user's actual screen.\n\t\t// The \"screen point\" is relative to the \"screen bounds\";\n\t\t// it will be 0,0 when its actual screen position is equal\n\t\t// to screenBounds.point. This is confusing!\n\t\tcurrentScreenPoint.set(sx, sy)\n\t\tconst nx = sx / cz - cx\n\t\tconst ny = sy / cz - cy\n\t\tif (isFinite(nx) && isFinite(ny)) {\n\t\t\tcurrentPagePoint.set(nx, ny, sz)\n\t\t}\n\n\t\tthis.inputs.isPen = info.type === 'pointer' && info.isPen\n\n\t\t// Reset velocity on pointer down, or when a pinch starts or ends\n\t\tif (info.name === 'pointer_down' || this.inputs.isPinching) {\n\t\t\tpointerVelocity.set(0, 0)\n\t\t\toriginScreenPoint.setTo(currentScreenPoint)\n\t\t\toriginPagePoint.setTo(currentPagePoint)\n\t\t}\n\n\t\t// todo: We only have to do this if there are multiple users in the document\n\t\tthis.run(\n\t\t\t() => {\n\t\t\t\tthis.store.put([\n\t\t\t\t\t{\n\t\t\t\t\t\tid: TLPOINTER_ID,\n\t\t\t\t\t\ttypeName: 'pointer',\n\t\t\t\t\t\tx: currentPagePoint.x,\n\t\t\t\t\t\ty: currentPagePoint.y,\n\t\t\t\t\t\tlastActivityTimestamp:\n\t\t\t\t\t\t\t// If our pointer moved only because we're following some other user, then don't\n\t\t\t\t\t\t\t// update our last activity timestamp; otherwise, update it to the current timestamp.\n\t\t\t\t\t\t\tinfo.type === 'pointer' && info.pointerId === INTERNAL_POINTER_IDS.CAMERA_MOVE\n\t\t\t\t\t\t\t\t? (this.store.unsafeGetWithoutCapture(TLPOINTER_ID)?.lastActivityTimestamp ??\n\t\t\t\t\t\t\t\t\tthis._tickManager.now)\n\t\t\t\t\t\t\t\t: this._tickManager.now,\n\t\t\t\t\t\tmeta: {},\n\t\t\t\t\t},\n\t\t\t\t])\n\t\t\t},\n\t\t\t{ history: 'ignore' }\n\t\t)\n\t}\n\n\t/**\n\t * Dispatch a cancel event.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.cancel()\n\t * ```\n\t *\n\t * @public\n\t */\n\tcancel(): this {\n\t\tthis.dispatch({ type: 'misc', name: 'cancel' })\n\t\treturn this\n\t}\n\n\t/**\n\t * Dispatch an interrupt event.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.interrupt()\n\t * ```\n\t *\n\t * @public\n\t */\n\tinterrupt(): this {\n\t\tthis.dispatch({ type: 'misc', name: 'interrupt' })\n\t\treturn this\n\t}\n\n\t/**\n\t * Dispatch a complete event.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.complete()\n\t * ```\n\t *\n\t * @public\n\t */\n\tcomplete(): this {\n\t\tthis.dispatch({ type: 'misc', name: 'complete' })\n\t\treturn this\n\t}\n\n\t/**\n\t * Puts the editor into focused mode.\n\t *\n\t * This makes the editor eligible to receive keyboard events and some pointer events (move, wheel).\n\t *\n\t * @example\n\t * ```ts\n\t * editor.focus()\n\t * ```\n\t *\n\t * By default this also dispatches a 'focus' event to the container element. To prevent this, pass `focusContainer: false`.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.focus({ focusContainer: false })\n\t * ```\n\t *\n\t * @public\n\t */\n\tfocus({ focusContainer = true } = {}): this {\n\t\tif (this.getIsFocused()) return this\n\t\tif (focusContainer) this.focusManager.focus()\n\t\tthis.updateInstanceState({ isFocused: true })\n\t\treturn this\n\t}\n\n\t/**\n\t * Switches off the editor's focused mode.\n\t *\n\t * This makes the editor ignore keyboard events and some pointer events (move, wheel).\n\t *\n\t * @example\n\t * ```ts\n\t * editor.blur()\n\t * ```\n\t * By default this also dispatches a 'blur' event to the container element. To prevent this, pass `blurContainer: false`.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.blur({ blurContainer: false })\n\t * ```\n\t *\n\t * @public\n\t */\n\tblur({ blurContainer = true } = {}): this {\n\t\tif (!this.getIsFocused()) return this\n\t\tif (blurContainer) {\n\t\t\tthis.focusManager.blur()\n\t\t} else {\n\t\t\tthis.complete() // stop any interaction\n\t\t}\n\t\tthis.updateInstanceState({ isFocused: false })\n\t\treturn this\n\t}\n\n\t/**\n\t * @public\n\t * @returns true if the editor is focused\n\t */\n\t@computed getIsFocused() {\n\t\treturn this.getInstanceState().isFocused\n\t}\n\n\t/**\n\t * @public\n\t * @returns true if the editor is in readonly mode\n\t */\n\t@computed getIsReadonly() {\n\t\treturn this.getInstanceState().isReadonly\n\t}\n\n\t/**\n\t * @public\n\t * @returns a snapshot of the store's UI and document state\n\t */\n\tgetSnapshot() {\n\t\treturn getSnapshot(this.store)\n\t}\n\n\t/**\n\t * Loads a snapshot into the editor.\n\t * @param snapshot - The snapshot to load.\n\t * @param opts - The options for loading the snapshot.\n\t * @returns\n\t */\n\tloadSnapshot(\n\t\tsnapshot: Partial<TLEditorSnapshot> | TLStoreSnapshot,\n\t\topts?: TLLoadSnapshotOptions\n\t) {\n\t\tloadSnapshot(this.store, snapshot, opts)\n\t\treturn this\n\t}\n\n\tprivate _zoomToFitPageContentAt100Percent() {\n\t\tconst bounds = this.getCurrentPageBounds()\n\t\tif (bounds) {\n\t\t\tthis.zoomToBounds(bounds, { immediate: true, targetZoom: this.getBaseZoom() })\n\t\t}\n\t}\n\tprivate _navigateToDeepLink(deepLink: TLDeepLink) {\n\t\tthis.run(() => {\n\t\t\tswitch (deepLink.type) {\n\t\t\t\tcase 'page': {\n\t\t\t\t\tconst page = this.getPage(deepLink.pageId)\n\t\t\t\t\tif (page) {\n\t\t\t\t\t\tthis.setCurrentPage(page)\n\t\t\t\t\t}\n\t\t\t\t\tthis._zoomToFitPageContentAt100Percent()\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tcase 'shapes': {\n\t\t\t\t\tconst allShapes = compact(deepLink.shapeIds.map((id) => this.getShape(id)))\n\t\t\t\t\tconst byPage: { [pageId: string]: TLShape[] } = {}\n\t\t\t\t\tfor (const shape of allShapes) {\n\t\t\t\t\t\tconst pageId = this.getAncestorPageId(shape)\n\t\t\t\t\t\tif (!pageId) continue\n\t\t\t\t\t\tbyPage[pageId] ??= []\n\t\t\t\t\t\tbyPage[pageId].push(shape)\n\t\t\t\t\t}\n\t\t\t\t\tconst [pageId, shapes] = Object.entries(byPage).sort(\n\t\t\t\t\t\t([_, a], [__, b]) => b.length - a.length\n\t\t\t\t\t)[0] ?? ['', []]\n\n\t\t\t\t\tif (!pageId || !shapes.length) {\n\t\t\t\t\t\tthis._zoomToFitPageContentAt100Percent()\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.setCurrentPage(pageId as TLPageId)\n\t\t\t\t\t\tconst bounds = Box.Common(shapes.map((s) => this.getShapePageBounds(s)!))\n\t\t\t\t\t\tthis.zoomToBounds(bounds, { immediate: true, targetZoom: this.getBaseZoom() })\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tcase 'viewport': {\n\t\t\t\t\tif (deepLink.pageId) {\n\t\t\t\t\t\tif (!this.getPage(deepLink.pageId)) {\n\t\t\t\t\t\t\tthis._zoomToFitPageContentAt100Percent()\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.setCurrentPage(deepLink.pageId)\n\t\t\t\t\t}\n\t\t\t\t\tthis.zoomToBounds(deepLink.bounds, { immediate: true, inset: 0 })\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\texhaustiveSwitchError(deepLink)\n\t\t\t}\n\t\t})\n\t}\n\n\t/**\n\t * Handles navigating to the content specified by the query param in the given URL.\n\t *\n\t * Use {@link Editor#createDeepLink} to create a URL with a deep link query param.\n\t *\n\t * If no URL is provided, it will look for the param in the current `window.location.href`.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.navigateToDeepLink()\n\t * ```\n\t *\n\t * The default parameter name is 'd'. You can override this by providing the `param` option.\n\t *\n\t * @example\n\t * ```ts\n\t * // disable page parameter and change viewport parameter to 'c'\n\t * editor.navigateToDeepLink({\n\t *   param: 'x',\n\t *   url: 'https://my-app.com/my-document?x=200.12.454.23.xyz123',\n\t * })\n\t * ```\n\t *\n\t * @param opts - Options for loading the state from the URL.\n\t */\n\tnavigateToDeepLink(opts?: TLDeepLink | { url?: string | URL; param?: string }): Editor {\n\t\tif (opts && 'type' in opts) {\n\t\t\tthis._navigateToDeepLink(opts)\n\t\t\treturn this\n\t\t}\n\n\t\tconst url = new URL(opts?.url ?? window.location.href)\n\t\tconst deepLinkString = url.searchParams.get(opts?.param ?? 'd')\n\n\t\tif (!deepLinkString) {\n\t\t\tthis._zoomToFitPageContentAt100Percent()\n\t\t\treturn this\n\t\t}\n\n\t\ttry {\n\t\t\tthis._navigateToDeepLink(parseDeepLinkString(deepLinkString))\n\t\t} catch (e) {\n\t\t\tconsole.warn(e)\n\t\t\tthis._zoomToFitPageContentAt100Percent()\n\t\t}\n\t\treturn this\n\t}\n\n\t/**\n\t * Turns the given URL into a deep link by adding a query parameter.\n\t *\n\t * e.g. `https://my-app.com/my-document?d=100.100.200.200.xyz123`\n\t *\n\t * If no URL is provided, it will use the current `window.location.href`.\n\t *\n\t * @example\n\t * ```ts\n\t * // create a deep link to the current page + viewport\n\t * navigator.clipboard.writeText(editor.createDeepLink())\n\t * ```\n\t *\n\t * You can link to a particular set of shapes by providing a `to` parameter.\n\t *\n\t * @example\n\t * ```ts\n\t * // create a deep link to the set of currently selected shapes\n\t * navigator.clipboard.writeText(editor.createDeepLink({\n\t *   to: { type: 'selection', shapeIds: editor.getSelectedShapeIds() }\n\t * }))\n\t * ```\n\t *\n\t * The default query param is 'd'. You can override this by providing a `param` parameter.\n\t *\n\t * @example\n\t * ```ts\n\t * // Use `x` as the param name instead\n\t * editor.createDeepLink({ param: 'x' })\n\t * ```\n\t *\n\t * @param opts - Options for adding the state to the URL.\n\t * @returns the updated URL\n\t */\n\tcreateDeepLink(opts?: { url?: string | URL; param?: string; to?: TLDeepLink }): URL {\n\t\tconst url = new URL(opts?.url ?? window.location.href)\n\n\t\turl.searchParams.set(\n\t\t\topts?.param ?? 'd',\n\t\t\tcreateDeepLinkString(\n\t\t\t\topts?.to ?? {\n\t\t\t\t\ttype: 'viewport',\n\t\t\t\t\tpageId: this.options.maxPages === 1 ? undefined : this.getCurrentPageId(),\n\t\t\t\t\tbounds: this.getViewportPageBounds(),\n\t\t\t\t}\n\t\t\t)\n\t\t)\n\n\t\treturn url\n\t}\n\n\t/**\n\t * Register a listener for changes to a deep link for the current document.\n\t *\n\t * You'll typically want to use this indirectly via the {@link TldrawEditorBaseProps.deepLinks} prop on the `<Tldraw />` component.\n\t *\n\t * By default this will update `window.location` in place, but you can provide a custom callback\n\t * to handle state changes on your own.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.registerDeepLinkListener({\n\t *   onChange(url) {\n\t *     window.history.replaceState({}, document.title, url.toString())\n\t *   }\n\t * })\n\t * ```\n\t *\n\t * You can also provide a custom URL to update, in which case you must also provide `onChange`.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.registerDeepLinkListener({\n\t *   getUrl: () => `https://my-app.com/my-document`,\n\t *   onChange(url) {\n\t *     setShareUrl(url.toString())\n\t *   }\n\t * })\n\t * ```\n\t *\n\t * By default this will update with a debounce interval of 500ms, but you can provide a custom interval.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.registerDeepLinkListener({ debounceMs: 1000 })\n\t * ```\n\t * The default parameter name is `d`. You can override this by providing a `param` option.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.registerDeepLinkListener({ param: 'x' })\n\t * ```\n\t * @param opts - Options for setting up the listener.\n\t * @returns a function that will stop the listener.\n\t */\n\tregisterDeepLinkListener(opts?: TLDeepLinkOptions): () => void {\n\t\tif (opts?.getUrl && !opts?.onChange) {\n\t\t\tthrow Error(\n\t\t\t\t'[tldraw:urlStateSync] If you specify getUrl, you must also specify the onChange callback.'\n\t\t\t)\n\t\t}\n\n\t\tconst url$ = computed('url with state', () => {\n\t\t\tconst url = opts?.getUrl?.(this) ?? window.location.href\n\t\t\tconst urlWithState = this.createDeepLink({\n\t\t\t\tparam: opts?.param,\n\t\t\t\turl,\n\t\t\t\tto: opts?.getTarget?.(this),\n\t\t\t})\n\t\t\treturn urlWithState.toString()\n\t\t})\n\n\t\tconst announceChange =\n\t\t\topts?.onChange ??\n\t\t\t(() => {\n\t\t\t\tconst url = this.createDeepLink({\n\t\t\t\t\tparam: opts?.param,\n\t\t\t\t\tto: opts?.getTarget?.(this),\n\t\t\t\t})\n\n\t\t\t\twindow.history.replaceState({}, document.title, url.toString())\n\t\t\t})\n\n\t\tconst scheduleEffect = debounce((execute: () => void) => execute(), opts?.debounceMs ?? 500)\n\n\t\tconst unlisten = react(\n\t\t\t'update url on state change',\n\t\t\t() => announceChange(new URL(url$.get()), this),\n\t\t\t{ scheduleEffect }\n\t\t)\n\n\t\treturn () => {\n\t\t\tunlisten()\n\t\t\tscheduleEffect.cancel()\n\t\t}\n\t}\n\n\t/**\n\t * A manager for recording multiple click events.\n\t *\n\t * @internal\n\t */\n\tprotected _clickManager = new ClickManager(this)\n\n\t/**\n\t * Prevent a double click event from firing the next time the user clicks\n\t *\n\t * @public\n\t */\n\tcancelDoubleClick() {\n\t\tthis._clickManager.cancelDoubleClickTimeout()\n\t}\n\n\t/**\n\t * The previous cursor. Used for restoring the cursor after pan events.\n\t *\n\t * @internal\n\t */\n\tprivate _prevCursor: TLCursorType = 'default'\n\n\t/** @internal */\n\tprivate _shiftKeyTimeout = -1 as any\n\n\t/** @internal */\n\t@bind\n\t_setShiftKeyTimeout() {\n\t\tthis.inputs.shiftKey = false\n\t\tthis.dispatch({\n\t\t\ttype: 'keyboard',\n\t\t\tname: 'key_up',\n\t\t\tkey: 'Shift',\n\t\t\tshiftKey: this.inputs.shiftKey,\n\t\t\tctrlKey: this.inputs.ctrlKey,\n\t\t\taltKey: this.inputs.altKey,\n\t\t\tmetaKey: this.inputs.metaKey,\n\t\t\taccelKey: isAccelKey(this.inputs),\n\t\t\tcode: 'ShiftLeft',\n\t\t})\n\t}\n\n\t/** @internal */\n\tprivate _altKeyTimeout = -1 as any\n\n\t/** @internal */\n\t@bind\n\t_setAltKeyTimeout() {\n\t\tthis.inputs.altKey = false\n\t\tthis.dispatch({\n\t\t\ttype: 'keyboard',\n\t\t\tname: 'key_up',\n\t\t\tkey: 'Alt',\n\t\t\tshiftKey: this.inputs.shiftKey,\n\t\t\tctrlKey: this.inputs.ctrlKey,\n\t\t\taltKey: this.inputs.altKey,\n\t\t\tmetaKey: this.inputs.metaKey,\n\t\t\taccelKey: isAccelKey(this.inputs),\n\t\t\tcode: 'AltLeft',\n\t\t})\n\t}\n\n\t/** @internal */\n\tprivate _ctrlKeyTimeout = -1 as any\n\n\t/** @internal */\n\t@bind\n\t_setCtrlKeyTimeout() {\n\t\tthis.inputs.ctrlKey = false\n\t\tthis.dispatch({\n\t\t\ttype: 'keyboard',\n\t\t\tname: 'key_up',\n\t\t\tkey: 'Ctrl',\n\t\t\tshiftKey: this.inputs.shiftKey,\n\t\t\tctrlKey: this.inputs.ctrlKey,\n\t\t\taltKey: this.inputs.altKey,\n\t\t\tmetaKey: this.inputs.metaKey,\n\t\t\taccelKey: isAccelKey(this.inputs),\n\t\t\tcode: 'ControlLeft',\n\t\t})\n\t}\n\n\t/** @internal */\n\tprivate _metaKeyTimeout = -1 as any\n\n\t/** @internal */\n\t@bind\n\t_setMetaKeyTimeout() {\n\t\tthis.inputs.metaKey = false\n\t\tthis.dispatch({\n\t\t\ttype: 'keyboard',\n\t\t\tname: 'key_up',\n\t\t\tkey: 'Meta',\n\t\t\tshiftKey: this.inputs.shiftKey,\n\t\t\tctrlKey: this.inputs.ctrlKey,\n\t\t\taltKey: this.inputs.altKey,\n\t\t\tmetaKey: this.inputs.metaKey,\n\t\t\taccelKey: isAccelKey(this.inputs),\n\t\t\tcode: 'MetaLeft',\n\t\t})\n\t}\n\n\t/** @internal */\n\tprivate _restoreToolId = 'select'\n\n\t/** @internal */\n\tprivate _pinchStart = 1\n\n\t/** @internal */\n\tprivate _didPinch = false\n\n\t/** @internal */\n\tprivate _selectedShapeIdsAtPointerDown: TLShapeId[] = []\n\n\t/** @internal */\n\tprivate _longPressTimeout = -1 as any\n\n\t/** @internal */\n\tcapturedPointerId: number | null = null\n\n\t/** @internal */\n\tprivate readonly performanceTracker: PerformanceTracker\n\n\t/** @internal */\n\tprivate performanceTrackerTimeout = -1 as any\n\n\t/**\n\t * Dispatch an event to the editor.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.dispatch(myPointerEvent)\n\t * ```\n\t *\n\t * @param info - The event info.\n\t *\n\t * @public\n\t */\n\tdispatch(info: TLEventInfo) {\n\t\tthis._pendingEventsForNextTick.push(info)\n\t\tif (\n\t\t\t!(\n\t\t\t\t(info.type === 'pointer' && info.name === 'pointer_move') ||\n\t\t\t\tinfo.type === 'wheel' ||\n\t\t\t\tinfo.type === 'pinch'\n\t\t\t)\n\t\t) {\n\t\t\tthis._flushEventsForTick(0)\n\t\t}\n\t\treturn this\n\t}\n\n\tprivate _pendingEventsForNextTick: TLEventInfo[] = []\n\n\tprivate _flushEventsForTick(elapsed: number) {\n\t\tthis.run(() => {\n\t\t\tif (this._pendingEventsForNextTick.length > 0) {\n\t\t\t\tconst events = [...this._pendingEventsForNextTick]\n\t\t\t\tthis._pendingEventsForNextTick.length = 0\n\t\t\t\tfor (const info of events) {\n\t\t\t\t\tthis._flushEventForTick(info)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (elapsed > 0) {\n\t\t\t\tthis.root.handleEvent({ type: 'misc', name: 'tick', elapsed })\n\t\t\t}\n\t\t\tthis.scribbles.tick(elapsed)\n\t\t})\n\t}\n\n\t_flushEventForTick(info: TLEventInfo) {\n\t\t// prevent us from spamming similar event errors if we're crashed.\n\t\t// todo: replace with new readonly mode?\n\t\tif (this.getCrashingError()) return this\n\n\t\tthis.emit('before-event', info)\n\n\t\tconst { inputs } = this\n\t\tconst { type } = info\n\n\t\tif (info.type === 'misc') {\n\t\t\t// stop panning if the interaction is cancelled or completed\n\t\t\tif (info.name === 'cancel' || info.name === 'complete') {\n\t\t\t\tthis.inputs.isDragging = false\n\n\t\t\t\tif (this.inputs.isPanning) {\n\t\t\t\t\tthis.inputs.isPanning = false\n\t\t\t\t\tthis.inputs.isSpacebarPanning = false\n\t\t\t\t\tthis.setCursor({ type: this._prevCursor, rotation: 0 })\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.root.handleEvent(info)\n\t\t\treturn\n\t\t}\n\n\t\tif (info.shiftKey) {\n\t\t\tclearTimeout(this._shiftKeyTimeout)\n\t\t\tthis._shiftKeyTimeout = -1\n\t\t\tinputs.shiftKey = true\n\t\t} else if (!info.shiftKey && inputs.shiftKey && this._shiftKeyTimeout === -1) {\n\t\t\tthis._shiftKeyTimeout = this.timers.setTimeout(this._setShiftKeyTimeout, 150)\n\t\t}\n\n\t\tif (info.altKey) {\n\t\t\tclearTimeout(this._altKeyTimeout)\n\t\t\tthis._altKeyTimeout = -1\n\t\t\tinputs.altKey = true\n\t\t} else if (!info.altKey && inputs.altKey && this._altKeyTimeout === -1) {\n\t\t\tthis._altKeyTimeout = this.timers.setTimeout(this._setAltKeyTimeout, 150)\n\t\t}\n\n\t\tif (info.ctrlKey) {\n\t\t\tclearTimeout(this._ctrlKeyTimeout)\n\t\t\tthis._ctrlKeyTimeout = -1\n\t\t\tinputs.ctrlKey = true\n\t\t} else if (!info.ctrlKey && inputs.ctrlKey && this._ctrlKeyTimeout === -1) {\n\t\t\tthis._ctrlKeyTimeout = this.timers.setTimeout(this._setCtrlKeyTimeout, 150)\n\t\t}\n\n\t\tif (info.metaKey) {\n\t\t\tclearTimeout(this._metaKeyTimeout)\n\t\t\tthis._metaKeyTimeout = -1\n\t\t\tinputs.metaKey = true\n\t\t} else if (!info.metaKey && inputs.metaKey && this._metaKeyTimeout === -1) {\n\t\t\tthis._metaKeyTimeout = this.timers.setTimeout(this._setMetaKeyTimeout, 150)\n\t\t}\n\n\t\tconst { originPagePoint, currentPagePoint } = inputs\n\n\t\tif (!inputs.isPointing) {\n\t\t\tinputs.isDragging = false\n\t\t}\n\n\t\tconst instanceState = this.store.unsafeGetWithoutCapture(TLINSTANCE_ID)!\n\t\tconst pageState = this.store.get(this._getCurrentPageStateId())!\n\t\tconst cameraOptions = this._cameraOptions.__unsafe__getWithoutCapture()!\n\n\t\tswitch (type) {\n\t\t\tcase 'pinch': {\n\t\t\t\tif (cameraOptions.isLocked) return\n\t\t\t\tclearTimeout(this._longPressTimeout)\n\t\t\t\tthis._updateInputsFromEvent(info)\n\n\t\t\t\tswitch (info.name) {\n\t\t\t\t\tcase 'pinch_start': {\n\t\t\t\t\t\tif (inputs.isPinching) return\n\n\t\t\t\t\t\tif (!inputs.isEditing) {\n\t\t\t\t\t\t\tthis._pinchStart = this.getCamera().z\n\t\t\t\t\t\t\tif (!this._selectedShapeIdsAtPointerDown.length) {\n\t\t\t\t\t\t\t\tthis._selectedShapeIdsAtPointerDown = [...pageState.selectedShapeIds]\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis._didPinch = true\n\n\t\t\t\t\t\t\tinputs.isPinching = true\n\n\t\t\t\t\t\t\tthis.interrupt()\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn // Stop here!\n\t\t\t\t\t}\n\t\t\t\t\tcase 'pinch': {\n\t\t\t\t\t\tif (!inputs.isPinching) return\n\n\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\tpoint: { z = 1 },\n\t\t\t\t\t\t\tdelta: { x: dx, y: dy },\n\t\t\t\t\t\t} = info\n\n\t\t\t\t\t\t// The center of the pinch in screen space\n\t\t\t\t\t\tconst { x, y } = Vec.SubXY(\n\t\t\t\t\t\t\tinfo.point,\n\t\t\t\t\t\t\tinstanceState.screenBounds.x,\n\t\t\t\t\t\t\tinstanceState.screenBounds.y\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\tthis.stopCameraAnimation()\n\t\t\t\t\t\tif (instanceState.followingUserId) {\n\t\t\t\t\t\t\tthis.stopFollowingUser()\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst { x: cx, y: cy, z: cz } = unsafe__withoutCapture(() => this.getCamera())\n\n\t\t\t\t\t\tconst { panSpeed } = cameraOptions\n\t\t\t\t\t\tthis._setCamera(\n\t\t\t\t\t\t\tnew Vec(\n\t\t\t\t\t\t\t\tcx + (dx * panSpeed) / cz - x / cz + x / z,\n\t\t\t\t\t\t\t\tcy + (dy * panSpeed) / cz - y / cz + y / z,\n\t\t\t\t\t\t\t\tz\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t{ immediate: true }\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\treturn // Stop here!\n\t\t\t\t\t}\n\t\t\t\t\tcase 'pinch_end': {\n\t\t\t\t\t\tif (!inputs.isPinching) return this\n\n\t\t\t\t\t\t// Stop pinching\n\t\t\t\t\t\tinputs.isPinching = false\n\n\t\t\t\t\t\t// Stash and clear the shapes that were selected when the pinch started\n\t\t\t\t\t\tconst { _selectedShapeIdsAtPointerDown: shapesToReselect } = this\n\t\t\t\t\t\tthis.setSelectedShapes(this._selectedShapeIdsAtPointerDown)\n\t\t\t\t\t\tthis._selectedShapeIdsAtPointerDown = []\n\n\t\t\t\t\t\tif (this._didPinch) {\n\t\t\t\t\t\t\tthis._didPinch = false\n\t\t\t\t\t\t\tif (shapesToReselect.length > 0) {\n\t\t\t\t\t\t\t\tthis.once('tick', () => {\n\t\t\t\t\t\t\t\t\tif (!this._didPinch) {\n\t\t\t\t\t\t\t\t\t\t// Unless we've started pinching again...\n\t\t\t\t\t\t\t\t\t\t// Reselect the shapes that were selected when the pinch started\n\t\t\t\t\t\t\t\t\t\tthis.setSelectedShapes(shapesToReselect)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn // Stop here!\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase 'wheel': {\n\t\t\t\tif (cameraOptions.isLocked) return\n\n\t\t\t\tthis._updateInputsFromEvent(info)\n\n\t\t\t\tconst { panSpeed, zoomSpeed, wheelBehavior } = cameraOptions\n\n\t\t\t\tif (wheelBehavior !== 'none') {\n\t\t\t\t\t// Stop any camera animation\n\t\t\t\t\tthis.stopCameraAnimation()\n\t\t\t\t\t// Stop following any following user\n\t\t\t\t\tif (instanceState.followingUserId) {\n\t\t\t\t\t\tthis.stopFollowingUser()\n\t\t\t\t\t}\n\n\t\t\t\t\tconst { x: cx, y: cy, z: cz } = unsafe__withoutCapture(() => this.getCamera())\n\t\t\t\t\tconst { x: dx, y: dy, z: dz = 0 } = info.delta\n\n\t\t\t\t\tlet behavior = wheelBehavior\n\n\t\t\t\t\t// If the camera behavior is \"zoom\" and the ctrl key is pressed, then pan;\n\t\t\t\t\t// If the camera behavior is \"pan\" and the ctrl key is not pressed, then zoom\n\t\t\t\t\tif (info.ctrlKey) behavior = wheelBehavior === 'pan' ? 'zoom' : 'pan'\n\n\t\t\t\t\tswitch (behavior) {\n\t\t\t\t\t\tcase 'zoom': {\n\t\t\t\t\t\t\t// Zoom in on current screen point using the wheel delta\n\t\t\t\t\t\t\tconst { x, y } = this.inputs.currentScreenPoint\n\t\t\t\t\t\t\tlet delta = dz\n\n\t\t\t\t\t\t\t// If we're forcing zoom, then we need to do the wheel normalization math here\n\t\t\t\t\t\t\tif (wheelBehavior === 'zoom') {\n\t\t\t\t\t\t\t\tif (Math.abs(dy) > 10) {\n\t\t\t\t\t\t\t\t\tdelta = (10 * Math.sign(dy)) / 100\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tdelta = dy / 100\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst zoom = cz + (delta ?? 0) * zoomSpeed * cz\n\t\t\t\t\t\t\tthis._setCamera(new Vec(cx + x / zoom - x / cz, cy + y / zoom - y / cz, zoom), {\n\t\t\t\t\t\t\t\timmediate: true,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\tthis.maybeTrackPerformance('Zooming')\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'pan': {\n\t\t\t\t\t\t\t// Pan the camera based on the wheel delta\n\t\t\t\t\t\t\tthis._setCamera(new Vec(cx + (dx * panSpeed) / cz, cy + (dy * panSpeed) / cz, cz), {\n\t\t\t\t\t\t\t\timmediate: true,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\tthis.maybeTrackPerformance('Panning')\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'pointer': {\n\t\t\t\t// Ignore pointer events while we're pinching\n\t\t\t\tif (inputs.isPinching) return\n\n\t\t\t\tthis._updateInputsFromEvent(info)\n\t\t\t\tconst { isPen } = info\n\t\t\t\tconst { isPenMode } = instanceState\n\n\t\t\t\tswitch (info.name) {\n\t\t\t\t\tcase 'pointer_down': {\n\t\t\t\t\t\t// If we're in pen mode and the input is not a pen type, then stop here\n\t\t\t\t\t\tif (isPenMode && !isPen) return\n\n\t\t\t\t\t\tif (!this.inputs.isPanning) {\n\t\t\t\t\t\t\t// Start a long press timeout\n\t\t\t\t\t\t\tthis._longPressTimeout = this.timers.setTimeout(() => {\n\t\t\t\t\t\t\t\tconst vsb = this.getViewportScreenBounds()\n\t\t\t\t\t\t\t\tthis.dispatch({\n\t\t\t\t\t\t\t\t\t...info,\n\t\t\t\t\t\t\t\t\t// important! non-obvious!! the screenpoint was adjusted using the\n\t\t\t\t\t\t\t\t\t// viewport bounds, and will be again when this event is handled...\n\t\t\t\t\t\t\t\t\t// so we need to counter-adjust from the stored value so that the\n\t\t\t\t\t\t\t\t\t// new value is set correctly.\n\t\t\t\t\t\t\t\t\tpoint: this.inputs.originScreenPoint.clone().addXY(vsb.x, vsb.y),\n\t\t\t\t\t\t\t\t\tname: 'long_press',\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t}, this.options.longPressDurationMs)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Save the selected ids at pointer down\n\t\t\t\t\t\tthis._selectedShapeIdsAtPointerDown = this.getSelectedShapeIds()\n\n\t\t\t\t\t\t// Firefox bug fix...\n\t\t\t\t\t\t// If it's a left-mouse-click, we store the pointer id for later user\n\t\t\t\t\t\tif (info.button === LEFT_MOUSE_BUTTON) this.capturedPointerId = info.pointerId\n\n\t\t\t\t\t\t// Add the button from the buttons set\n\t\t\t\t\t\tinputs.buttons.add(info.button)\n\n\t\t\t\t\t\t// Start pointing and stop dragging\n\t\t\t\t\t\tinputs.isPointing = true\n\t\t\t\t\t\tinputs.isDragging = false\n\n\t\t\t\t\t\t// If pen mode is off but we're not already in pen mode, turn that on\n\t\t\t\t\t\tif (!isPenMode && isPen) this.updateInstanceState({ isPenMode: true })\n\n\t\t\t\t\t\t// On devices with erasers (like the Surface Pen or Wacom Pen), button 5 is the eraser\n\t\t\t\t\t\tif (info.button === STYLUS_ERASER_BUTTON) {\n\t\t\t\t\t\t\tthis._restoreToolId = this.getCurrentToolId()\n\t\t\t\t\t\t\tthis.complete()\n\t\t\t\t\t\t\tthis.setCurrentTool('eraser')\n\t\t\t\t\t\t} else if (info.button === MIDDLE_MOUSE_BUTTON) {\n\t\t\t\t\t\t\t// Middle mouse pan activates panning unless we're already panning (with spacebar)\n\t\t\t\t\t\t\tif (!this.inputs.isPanning) {\n\t\t\t\t\t\t\t\tthis._prevCursor = this.getInstanceState().cursor.type\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.inputs.isPanning = true\n\t\t\t\t\t\t\tclearTimeout(this._longPressTimeout)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// We might be panning because we did a middle mouse click, or because we're holding spacebar and started a regular click\n\t\t\t\t\t\t// Also stop here, we don't want the state chart to receive the event\n\t\t\t\t\t\tif (this.inputs.isPanning) {\n\t\t\t\t\t\t\tthis.stopCameraAnimation()\n\t\t\t\t\t\t\tthis.setCursor({ type: 'grabbing', rotation: 0 })\n\t\t\t\t\t\t\treturn this\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tcase 'pointer_move': {\n\t\t\t\t\t\t// If the user is in pen mode, but the pointer is not a pen, stop here.\n\t\t\t\t\t\tif (!isPen && isPenMode) return\n\n\t\t\t\t\t\tconst { x: cx, y: cy, z: cz } = unsafe__withoutCapture(() => this.getCamera())\n\n\t\t\t\t\t\t// If we've started panning, then clear any long press timeout\n\t\t\t\t\t\tif (this.inputs.isPanning && this.inputs.isPointing) {\n\t\t\t\t\t\t\t// Handle spacebar / middle mouse button panning\n\t\t\t\t\t\t\tconst { currentScreenPoint, previousScreenPoint } = this.inputs\n\t\t\t\t\t\t\tconst offset = Vec.Sub(currentScreenPoint, previousScreenPoint)\n\t\t\t\t\t\t\tthis.setCamera(new Vec(cx + offset.x / cz, cy + offset.y / cz, cz), {\n\t\t\t\t\t\t\t\timmediate: true,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\tthis.maybeTrackPerformance('Panning')\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tinputs.isPointing &&\n\t\t\t\t\t\t\t!inputs.isDragging &&\n\t\t\t\t\t\t\tVec.Dist2(originPagePoint, currentPagePoint) * this.getZoomLevel() >\n\t\t\t\t\t\t\t\t(instanceState.isCoarsePointer\n\t\t\t\t\t\t\t\t\t? this.options.coarseDragDistanceSquared\n\t\t\t\t\t\t\t\t\t: this.options.dragDistanceSquared) /\n\t\t\t\t\t\t\t\t\tcz\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t// Start dragging\n\t\t\t\t\t\t\tinputs.isDragging = true\n\t\t\t\t\t\t\tclearTimeout(this._longPressTimeout)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tcase 'pointer_up': {\n\t\t\t\t\t\t// Stop dragging / pointing\n\t\t\t\t\t\tinputs.isDragging = false\n\t\t\t\t\t\tinputs.isPointing = false\n\t\t\t\t\t\tclearTimeout(this._longPressTimeout)\n\n\t\t\t\t\t\t// Remove the button from the buttons set\n\t\t\t\t\t\tinputs.buttons.delete(info.button)\n\n\t\t\t\t\t\t// If we're in pen mode and we're not using a pen, stop here\n\t\t\t\t\t\tif (instanceState.isPenMode && !isPen) return\n\n\t\t\t\t\t\t// Firefox bug fix...\n\t\t\t\t\t\t// If it's the same pointer that we stored earlier...\n\t\t\t\t\t\t// ... then it's probably still a left-mouse-click!\n\t\t\t\t\t\tif (this.capturedPointerId === info.pointerId) {\n\t\t\t\t\t\t\tthis.capturedPointerId = null\n\t\t\t\t\t\t\tinfo.button = 0\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (inputs.isPanning) {\n\t\t\t\t\t\t\tif (!inputs.keys.has('Space')) {\n\t\t\t\t\t\t\t\tinputs.isPanning = false\n\t\t\t\t\t\t\t\tinputs.isSpacebarPanning = false\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst slideDirection = this.inputs.pointerVelocity\n\t\t\t\t\t\t\tconst slideSpeed = Math.min(2, slideDirection.len())\n\n\t\t\t\t\t\t\tswitch (info.button) {\n\t\t\t\t\t\t\t\tcase LEFT_MOUSE_BUTTON: {\n\t\t\t\t\t\t\t\t\tthis.setCursor({ type: 'grab', rotation: 0 })\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcase MIDDLE_MOUSE_BUTTON: {\n\t\t\t\t\t\t\t\t\tif (this.inputs.keys.has(' ')) {\n\t\t\t\t\t\t\t\t\t\tthis.setCursor({ type: 'grab', rotation: 0 })\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tthis.setCursor({ type: this._prevCursor, rotation: 0 })\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (slideSpeed > 0) {\n\t\t\t\t\t\t\t\tthis.slideCamera({ speed: slideSpeed, direction: slideDirection })\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (info.button === STYLUS_ERASER_BUTTON) {\n\t\t\t\t\t\t\t\t// If we were erasing with a stylus button, restore the tool we were using before we started erasing\n\t\t\t\t\t\t\t\tthis.complete()\n\t\t\t\t\t\t\t\tthis.setCurrentTool(this._restoreToolId)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'keyboard': {\n\t\t\t\t// please, please\n\t\t\t\tif (info.key === 'ShiftRight') info.key = 'ShiftLeft'\n\t\t\t\tif (info.key === 'AltRight') info.key = 'AltLeft'\n\t\t\t\tif (info.code === 'ControlRight') info.code = 'ControlLeft'\n\t\t\t\tif (info.code === 'MetaRight') info.code = 'MetaLeft'\n\n\t\t\t\tswitch (info.name) {\n\t\t\t\t\tcase 'key_down': {\n\t\t\t\t\t\t// Add the key from the keys set\n\t\t\t\t\t\tinputs.keys.add(info.code)\n\n\t\t\t\t\t\t// If the space key is pressed (but meta / control isn't!) activate panning\n\t\t\t\t\t\tif (info.code === 'Space' && !info.ctrlKey) {\n\t\t\t\t\t\t\tif (!this.inputs.isPanning) {\n\t\t\t\t\t\t\t\tthis._prevCursor = instanceState.cursor.type\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.inputs.isPanning = true\n\t\t\t\t\t\t\tthis.inputs.isSpacebarPanning = true\n\t\t\t\t\t\t\tclearTimeout(this._longPressTimeout)\n\t\t\t\t\t\t\tthis.setCursor({ type: this.inputs.isPointing ? 'grabbing' : 'grab', rotation: 0 })\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (this.inputs.isSpacebarPanning) {\n\t\t\t\t\t\t\tlet offset: Vec | undefined\n\t\t\t\t\t\t\tswitch (info.code) {\n\t\t\t\t\t\t\t\tcase 'ArrowUp': {\n\t\t\t\t\t\t\t\t\toffset = new Vec(0, -1)\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcase 'ArrowRight': {\n\t\t\t\t\t\t\t\t\toffset = new Vec(1, 0)\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcase 'ArrowDown': {\n\t\t\t\t\t\t\t\t\toffset = new Vec(0, 1)\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcase 'ArrowLeft': {\n\t\t\t\t\t\t\t\t\toffset = new Vec(-1, 0)\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (offset) {\n\t\t\t\t\t\t\t\tconst bounds = this.getViewportPageBounds()\n\t\t\t\t\t\t\t\tconst next = bounds.clone().translate(offset.mulV({ x: bounds.w, y: bounds.h }))\n\t\t\t\t\t\t\t\tthis._animateToViewport(next, { animation: { duration: 320 } })\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tcase 'key_up': {\n\t\t\t\t\t\t// Remove the key from the keys set\n\t\t\t\t\t\tinputs.keys.delete(info.code)\n\n\t\t\t\t\t\t// If we've lifted the space key,\n\t\t\t\t\t\tif (info.code === 'Space') {\n\t\t\t\t\t\t\tif (this.inputs.buttons.has(MIDDLE_MOUSE_BUTTON)) {\n\t\t\t\t\t\t\t\t// If we're still middle dragging, continue panning\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// otherwise, stop panning\n\t\t\t\t\t\t\t\tthis.inputs.isPanning = false\n\t\t\t\t\t\t\t\tthis.inputs.isSpacebarPanning = false\n\t\t\t\t\t\t\t\tthis.setCursor({ type: this._prevCursor, rotation: 0 })\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tcase 'key_repeat': {\n\t\t\t\t\t\t// noop\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// Correct the info name for right / middle clicks\n\t\tif (info.type === 'pointer') {\n\t\t\tif (info.button === MIDDLE_MOUSE_BUTTON) {\n\t\t\t\tinfo.name = 'middle_click'\n\t\t\t} else if (info.button === RIGHT_MOUSE_BUTTON) {\n\t\t\t\tinfo.name = 'right_click'\n\t\t\t}\n\n\t\t\t// If a left click pointer event, send the event to the click manager.\n\t\t\tconst { isPenMode } = this.store.unsafeGetWithoutCapture(TLINSTANCE_ID)!\n\t\t\tif (info.isPen === isPenMode) {\n\t\t\t\t// The click manager may return a new event, i.e. a double click event\n\t\t\t\t// depending on the event coming in and its own state. If the event has\n\t\t\t\t// changed then hand both events to the statechart\n\t\t\t\tconst clickInfo = this._clickManager.handlePointerEvent(info)\n\t\t\t\tif (info.name !== clickInfo.name) {\n\t\t\t\t\tthis.root.handleEvent(info)\n\t\t\t\t\tthis.emit('event', info)\n\t\t\t\t\tthis.root.handleEvent(clickInfo)\n\t\t\t\t\tthis.emit('event', clickInfo)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Send the event to the statechart. It will be handled by all\n\t\t// active states, starting at the root.\n\t\tthis.root.handleEvent(info)\n\t\tthis.emit('event', info)\n\n\t\t// close open menus at the very end on pointer down! after everything else!   !!\n\t\tif (info.type === 'pointer' && info.name === 'pointer_down') {\n\t\t\tthis.menus.clearOpenMenus()\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate maybeTrackPerformance(name: string) {\n\t\tif (debugFlags.measurePerformance.get()) {\n\t\t\tif (this.performanceTracker.isStarted()) {\n\t\t\t\tclearTimeout(this.performanceTrackerTimeout)\n\t\t\t} else {\n\t\t\t\tthis.performanceTracker.start(name)\n\t\t\t}\n\t\t\tthis.performanceTrackerTimeout = this.timers.setTimeout(() => {\n\t\t\t\tthis.performanceTracker.stop()\n\t\t\t}, 50)\n\t\t}\n\t}\n}\n\nfunction alertMaxShapes(editor: Editor, pageId = editor.getCurrentPageId()) {\n\tconst name = editor.getPage(pageId)!.name\n\teditor.emit('max-shapes', { name, pageId, count: editor.options.maxShapesPerPage })\n}\n\nfunction applyPartialToRecordWithProps<\n\tT extends UnknownRecord & { type: string; props: object; meta: object },\n>(prev: T, partial?: Partial<T> & { props?: Partial<T['props']> }): T {\n\tif (!partial) return prev\n\tlet next = null as null | T\n\tconst entries = Object.entries(partial)\n\tfor (let i = 0, n = entries.length; i < n; i++) {\n\t\tconst [k, v] = entries[i]\n\t\tif (v === undefined) continue\n\n\t\t// Is the key a special key? We don't update those\n\t\tif (k === 'id' || k === 'type' || k === 'typeName') continue\n\n\t\t// Is the value the same as it was before?\n\t\tif (v === (prev as any)[k]) continue\n\n\t\t// There's a new value, so create the new shape if we haven't already (should we be cloning this?)\n\t\tif (!next) next = { ...prev }\n\n\t\t// for props / meta properties, we support updates with partials of this object\n\t\tif (k === 'props' || k === 'meta') {\n\t\t\tnext[k] = { ...prev[k] } as JsonObject\n\t\t\tfor (const [nextKey, nextValue] of Object.entries(v as object)) {\n\t\t\t\t;(next[k] as JsonObject)[nextKey] = nextValue\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\t// base property\n\t\t;(next as any)[k] = v\n\t}\n\tif (!next) return prev\n\treturn next\n}\n\nfunction pushShapeWithDescendants(editor: Editor, id: TLShapeId, result: TLShape[]): void {\n\tconst shape = editor.getShape(id)\n\tif (!shape) return\n\tresult.push(shape)\n\tconst childIds = editor.getSortedChildIdsForParent(id)\n\tfor (let i = 0, n = childIds.length; i < n; i++) {\n\t\tpushShapeWithDescendants(editor, childIds[i], result)\n\t}\n}\n\n/**\n * Run `callback` in a world where all bindings from the shapes in `shapeIds` to shapes not in\n * `shapeIds` are removed. This is useful when you want to duplicate/copy shapes without worrying\n * about bindings that might be pointing to shapes that are not being duplicated.\n *\n * The callback is given the set of bindings that should be maintained.\n */\nfunction withIsolatedShapes<T>(\n\teditor: Editor,\n\tshapeIds: Set<TLShapeId>,\n\tcallback: (bindingsWithBoth: Set<TLBindingId>) => T\n): T {\n\tlet result!: Result<T, unknown>\n\n\teditor.run(\n\t\t() => {\n\t\t\tconst changes = editor.store.extractingChanges(() => {\n\t\t\t\tconst bindingsWithBoth = new Set<TLBindingId>()\n\t\t\t\tconst bindingsToRemove = new Set<TLBindingId>()\n\n\t\t\t\tfor (const shapeId of shapeIds) {\n\t\t\t\t\tconst shape = editor.getShape(shapeId)\n\t\t\t\t\tif (!shape) continue\n\n\t\t\t\t\tfor (const binding of editor.getBindingsInvolvingShape(shapeId)) {\n\t\t\t\t\t\tconst hasFrom = shapeIds.has(binding.fromId)\n\t\t\t\t\t\tconst hasTo = shapeIds.has(binding.toId)\n\t\t\t\t\t\tif (hasFrom && hasTo) {\n\t\t\t\t\t\t\tbindingsWithBoth.add(binding.id)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!hasFrom || !hasTo) {\n\t\t\t\t\t\t\tbindingsToRemove.add(binding.id)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\teditor.deleteBindings([...bindingsToRemove], { isolateShapes: true })\n\n\t\t\t\ttry {\n\t\t\t\t\tresult = Result.ok(callback(bindingsWithBoth))\n\t\t\t\t} catch (error) {\n\t\t\t\t\tresult = Result.err(error)\n\t\t\t\t}\n\t\t\t})\n\n\t\t\teditor.store.applyDiff(reverseRecordsDiff(changes), { runCallbacks: false })\n\t\t},\n\t\t{ history: 'ignore' }\n\t)\n\n\tif (result.ok) {\n\t\treturn result.value\n\t} else {\n\t\tthrow result.error\n\t}\n}\n\nfunction getCameraFitXFitY(editor: Editor, cameraOptions: TLCameraOptions) {\n\tif (!cameraOptions.constraints) throw Error('Should have constraints here')\n\tconst {\n\t\tpadding: { x: px, y: py },\n\t} = cameraOptions.constraints\n\tconst vsb = editor.getViewportScreenBounds()\n\tconst bounds = Box.From(cameraOptions.constraints.bounds)\n\tconst zx = (vsb.w - px * 2) / bounds.w\n\tconst zy = (vsb.h - py * 2) / bounds.h\n\treturn { zx, zy }\n}\n"],"names":["shape","highlightedUserIds","leaderPresence","page","notVisibleShapes","distance","ancestor","bindingsToCreate","shapesToCreateWithOriginals","gap","shapes","last","animatingShapes","n","group","bindings","pageId"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 12326, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/%40tldraw/editor/src/lib/editor/bindings/BindingUtil.ts"],"sourcesContent":["import { RecordProps, TLPropsMigrations, TLShape, TLUnknownBinding } from '@tldraw/tlschema'\nimport { Editor } from '../Editor'\n\n/** @public */\nexport interface TLBindingUtilConstructor<\n\tT extends TLUnknownBinding,\n\tU extends BindingUtil<T> = BindingUtil<T>,\n> {\n\tnew (editor: Editor): U\n\ttype: T['type']\n\t/** Validations for this binding's props. */\n\tprops?: RecordProps<T>\n\t/** Migrations for this binding's props. */\n\tmigrations?: TLPropsMigrations\n}\n\n/**\n * Options passed to {@link BindingUtil.onBeforeCreate} and {@link BindingUtil.onAfterCreate},\n * describing a the creating a binding.\n *\n * @public\n */\nexport interface BindingOnCreateOptions<Binding extends TLUnknownBinding> {\n\t/** The binding being created. */\n\tbinding: Binding\n}\n\n/**\n * Options passed to {@link BindingUtil.onBeforeChange} and {@link BindingUtil.onAfterChange},\n * describing the data associated with a binding being changed.\n *\n * @public\n */\nexport interface BindingOnChangeOptions<Binding extends TLUnknownBinding> {\n\t/** The binding record before the change is made. */\n\tbindingBefore: Binding\n\t/** The binding record after the change is made. */\n\tbindingAfter: Binding\n}\n\n/**\n * Options passed to {@link BindingUtil.onBeforeDelete} and {@link BindingUtil.onAfterDelete},\n * describing a binding being deleted.\n *\n * @public\n */\nexport interface BindingOnDeleteOptions<Binding extends TLUnknownBinding> {\n\t/** The binding being deleted. */\n\tbinding: Binding\n}\n\n/**\n * Options passed to {@link BindingUtil.onAfterChangeFromShape} and\n * {@link BindingUtil.onAfterChangeToShape}, describing a bound shape being changed.\n *\n * @public\n */\nexport interface BindingOnShapeChangeOptions<Binding extends TLUnknownBinding> {\n\t/** The binding record linking these two shapes. */\n\tbinding: Binding\n\t/** The shape record before the change is made. */\n\tshapeBefore: TLShape\n\t/** The shape record after the change is made. */\n\tshapeAfter: TLShape\n\t/**\n\t * Why did this shape change?\n\t * - 'self': the shape itself changed\n\t * - 'ancestry': the ancestry of the shape changed, but the shape itself may not have done\n\t */\n\treason: 'self' | 'ancestry'\n}\n\n/**\n * Options passed to {@link BindingUtil.onBeforeIsolateFromShape} and\n * {@link BindingUtil.onBeforeIsolateToShape}, describing a shape that is about to be isolated from\n * the one that it's bound to.\n *\n * Isolation happens whenever two bound shapes are separated. For example\n * 1. One is deleted, but the other is not.\n * 1. One is copied, but the other is not.\n * 1. One is duplicated, but the other is not.\n *\n * In each of these cases, if the remaining shape depends on the binding for its rendering, it may\n * now be in an inconsistent state. For example, tldraw's arrow shape depends on the binding to know\n * where the end of the arrow is. If we removed the binding without doing anything else, the arrow\n * would suddenly be pointing to the wrong location. Instead, when the shape the arrow is pointing\n * to is deleted, or the arrow is copied/duplicated, we use an isolation callback. The callback\n * updates the arrow based on the binding that's about to be removed, so it doesn't end up pointing\n * to the wrong place.\n *\n * For this style of consistency update, use isolation callbacks. For actions specific to deletion\n * (like deleting a sticker when the shape it's bound to is removed), use the delete callbacks\n * ({@link BindingUtil.onBeforeDeleteFromShape} and {@link BindingUtil.onBeforeDeleteToShape})\n * instead.\n *\n * @public\n */\nexport interface BindingOnShapeIsolateOptions<Binding extends TLUnknownBinding> {\n\t/** The binding record that refers to the shape in question. */\n\tbinding: Binding\n\t/**\n\t * The shape being removed. For deletion, this is the deleted shape. For copy/duplicate, this is\n\t * the shape that _isn't_ being copied/duplicated and is getting left behind.\n\t */\n\tremovedShape: TLShape\n}\n\n/**\n * Options passed to {@link BindingUtil.onBeforeDeleteFromShape} and\n * {@link BindingUtil.onBeforeDeleteToShape}, describing a bound shape that is about to be deleted.\n *\n * See {@link BindingOnShapeIsolateOptions} for discussion on when to use the delete vs. the isolate\n * callbacks.\n *\n * @public\n */\nexport interface BindingOnShapeDeleteOptions<Binding extends TLUnknownBinding> {\n\t/** The binding record that refers to the shape in question. */\n\tbinding: Binding\n\t/** The shape that is about to be deleted. */\n\tshape: TLShape\n}\n\n/** @public */\nexport abstract class BindingUtil<Binding extends TLUnknownBinding = TLUnknownBinding> {\n\tconstructor(public editor: Editor) {}\n\tstatic props?: RecordProps<TLUnknownBinding>\n\tstatic migrations?: TLPropsMigrations\n\n\t/**\n\t * The type of the binding util, which should match the binding's type.\n\t *\n\t * @public\n\t */\n\tstatic type: string\n\n\t/**\n\t * Get the default props for a binding.\n\t *\n\t * @public\n\t */\n\tabstract getDefaultProps(): Partial<Binding['props']>\n\n\t/**\n\t * Called whenever a store operation involving this binding type has completed. This is useful\n\t * for working with networks of related bindings that may need to update together.\n\t *\n\t * @example\n\t * ```ts\n\t * class MyBindingUtil extends BindingUtil<MyBinding> {\n\t *   changedBindingIds = new Set<TLBindingId>()\n\t *\n\t *   onOperationComplete() {\n\t *     doSomethingWithChangedBindings(this.changedBindingIds)\n\t *     this.changedBindingIds.clear()\n\t *   }\n\t *\n\t *   onAfterChange({ bindingAfter }: BindingOnChangeOptions<MyBinding>) {\n\t *     this.changedBindingIds.add(bindingAfter.id)\n\t *   }\n\t * }\n\t * ```\n\t *\n\t * @public\n\t */\n\tonOperationComplete?(): void\n\n\t/**\n\t * Called when a binding is about to be created. See {@link BindingOnCreateOptions} for details.\n\t *\n\t * You can optionally return a new binding to replace the one being created - for example, to\n\t * set different initial props.\n\t *\n\t * @public\n\t */\n\tonBeforeCreate?(options: BindingOnCreateOptions<Binding>): Binding | void\n\n\t/**\n\t * Called after a binding has been created. See {@link BindingOnCreateOptions} for details.\n\t *\n\t * @public\n\t */\n\tonAfterCreate?(options: BindingOnCreateOptions<Binding>): void\n\n\t/**\n\t * Called when a binding is about to be changed. See {@link BindingOnChangeOptions} for details.\n\t *\n\t * Note that this only fires when the binding record is changing, not when the shapes\n\t * associated change. Use {@link BindingUtil.onAfterChangeFromShape} and\n\t * {@link BindingUtil.onAfterChangeToShape} for that.\n\t *\n\t * You can optionally return a new binding to replace the one being changed - for example, to\n\t * enforce constraints on the binding's props.\n\t *\n\t * @public\n\t */\n\tonBeforeChange?(options: BindingOnChangeOptions<Binding>): Binding | void\n\n\t/**\n\t * Called after a binding has been changed. See {@link BindingOnChangeOptions} for details.\n\t *\n\t * Note that this only fires when the binding record is changing, not when the shapes\n\t * associated change. Use {@link BindingUtil.onAfterChangeFromShape} and\n\t * {@link BindingUtil.onAfterChangeToShape} for that.\n\t *\n\t * @public\n\t */\n\tonAfterChange?(options: BindingOnChangeOptions<Binding>): void\n\n\t/**\n\t * Called when a binding is about to be deleted. See {@link BindingOnDeleteOptions} for details.\n\t *\n\t * @public\n\t */\n\tonBeforeDelete?(options: BindingOnDeleteOptions<Binding>): void\n\n\t/**\n\t * Called after a binding has been deleted. See {@link BindingOnDeleteOptions} for details.\n\t *\n\t * @public\n\t */\n\tonAfterDelete?(options: BindingOnDeleteOptions<Binding>): void\n\n\t/**\n\t * Called after the shape referenced in a binding's `fromId` is changed. Use this to propagate\n\t * any changes to the binding itself or the other shape as needed. See\n\t * {@link BindingOnShapeChangeOptions} for details.\n\t *\n\t * @public\n\t */\n\tonAfterChangeFromShape?(options: BindingOnShapeChangeOptions<Binding>): void\n\n\t/**\n\t * Called after the shape referenced in a binding's `toId` is changed. Use this to propagate any\n\t * changes to the binding itself or the other shape as needed. See\n\t * {@link BindingOnShapeChangeOptions} for details.\n\t *\n\t * @public\n\t */\n\tonAfterChangeToShape?(options: BindingOnShapeChangeOptions<Binding>): void\n\n\t/**\n\t * Called before the shape referenced in a binding's `fromId` is about to be deleted. Use this\n\t * with care - you may want to use {@link BindingUtil.onBeforeIsolateToShape} instead. See\n\t * {@link BindingOnShapeDeleteOptions} for details.\n\t *\n\t * @public\n\t */\n\tonBeforeDeleteFromShape?(options: BindingOnShapeDeleteOptions<Binding>): void\n\t/**\n\t * Called before the shape referenced in a binding's `toId` is about to be deleted. Use this\n\t * with care - you may want to use {@link BindingUtil.onBeforeIsolateFromShape} instead. See\n\t * {@link BindingOnShapeDeleteOptions} for details.\n\t *\n\t * @public\n\t */\n\tonBeforeDeleteToShape?(options: BindingOnShapeDeleteOptions<Binding>): void\n\n\t/**\n\t * Called before the shape referenced in a binding's `fromId` is about to be isolated from the\n\t * shape referenced in `toId`. See {@link BindingOnShapeIsolateOptions} for discussion on what\n\t * isolation means, and when/how to use this callback.\n\t */\n\tonBeforeIsolateFromShape?(options: BindingOnShapeIsolateOptions<Binding>): void\n\n\t/**\n\t * Called before the shape referenced in a binding's `toId` is about to be isolated from the\n\t * shape referenced in `fromId`. See {@link BindingOnShapeIsolateOptions} for discussion on what\n\t * isolation means, and when/how to use this callback.\n\t */\n\tonBeforeIsolateToShape?(options: BindingOnShapeIsolateOptions<Binding>): void\n}\n"],"names":[],"mappings":";;;AA4HO,MAAe,YAAiE;IACtF,YAAmB,MAAA,CAAgB;QAAhB,IAAA,CAAA,MAAA,GAAA;IAAiB;IACpC,OAAO,MAAA;IACP,OAAO,WAAA;IAAA;;;;GAAA,GAOP,OAAO,KAAA;AAyIR","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 12349, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/%40tldraw/editor/src/lib/editor/shapes/shared/resizeBox.ts"],"sourcesContent":["import { VecModel } from '@tldraw/tlschema'\nimport { Box } from '../../../primitives/Box'\nimport { Vec } from '../../../primitives/Vec'\nimport { TLResizeHandle } from '../../types/selection-types'\nimport { TLBaseBoxShape } from '../BaseBoxShapeUtil'\nimport { TLResizeMode } from '../ShapeUtil'\n\n/** @public */\nexport interface ResizeBoxOptions {\n\tminWidth?: number\n\tmaxWidth?: number\n\tminHeight?: number\n\tmaxHeight?: number\n}\n\n/** @public */\nexport function resizeBox<T extends TLBaseBoxShape>(\n\tshape: T,\n\tinfo: {\n\t\tnewPoint: VecModel\n\t\thandle: TLResizeHandle\n\t\tmode: TLResizeMode\n\t\tscaleX: number\n\t\tscaleY: number\n\t\tinitialBounds: Box\n\t\tinitialShape: T\n\t},\n\topts = {} as ResizeBoxOptions\n): T {\n\tconst { newPoint, handle, scaleX, scaleY } = info\n\tconst { minWidth = 1, maxWidth = Infinity, minHeight = 1, maxHeight = Infinity } = opts\n\n\tlet w = shape.props.w * scaleX\n\tlet h = shape.props.h * scaleY\n\n\tconst offset = new Vec(0, 0)\n\n\tif (w > 0) {\n\t\tif (w < minWidth) {\n\t\t\tswitch (handle) {\n\t\t\t\tcase 'top_left':\n\t\t\t\tcase 'left':\n\t\t\t\tcase 'bottom_left': {\n\t\t\t\t\toffset.x = w - minWidth\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'top':\n\t\t\t\tcase 'bottom': {\n\t\t\t\t\toffset.x = (w - minWidth) / 2\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tdefault: {\n\t\t\t\t\toffset.x = 0\n\t\t\t\t}\n\t\t\t}\n\t\t\tw = minWidth\n\t\t}\n\t} else {\n\t\toffset.x = w\n\t\tw = -w\n\t\tif (w < minWidth) {\n\t\t\tswitch (handle) {\n\t\t\t\tcase 'top_left':\n\t\t\t\tcase 'left':\n\t\t\t\tcase 'bottom_left': {\n\t\t\t\t\toffset.x = -w\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tdefault: {\n\t\t\t\t\toffset.x = -minWidth\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tw = minWidth\n\t\t}\n\t}\n\n\tif (h > 0) {\n\t\tif (h < minHeight) {\n\t\t\tswitch (handle) {\n\t\t\t\tcase 'top_left':\n\t\t\t\tcase 'top':\n\t\t\t\tcase 'top_right': {\n\t\t\t\t\toffset.y = h - minHeight\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'right':\n\t\t\t\tcase 'left': {\n\t\t\t\t\toffset.y = (h - minHeight) / 2\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tdefault: {\n\t\t\t\t\toffset.y = 0\n\t\t\t\t}\n\t\t\t}\n\n\t\t\th = minHeight\n\t\t}\n\t} else {\n\t\toffset.y = h\n\t\th = -h\n\t\tif (h < minHeight) {\n\t\t\tswitch (handle) {\n\t\t\t\tcase 'top_left':\n\t\t\t\tcase 'top':\n\t\t\t\tcase 'top_right': {\n\t\t\t\t\toffset.y = -h\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tdefault: {\n\t\t\t\t\toffset.y = -minHeight\n\t\t\t\t}\n\t\t\t}\n\t\t\th = minHeight\n\t\t}\n\t}\n\n\tconst { x, y } = offset.rot(shape.rotation).add(newPoint)\n\n\treturn {\n\t\t...shape,\n\t\tx,\n\t\ty,\n\t\tprops: {\n\t\t\tw: Math.min(maxWidth, w),\n\t\t\th: Math.min(maxHeight, h),\n\t\t},\n\t}\n}\n"],"names":[],"mappings":";;;AAEA,SAAS,WAAW;;AAcb,SAAS,UACf,KAAA,EACA,IAAA,EASA,OAAO,CAAC,CAAA,EACJ;IACJ,MAAM,EAAE,QAAA,EAAU,MAAA,EAAQ,MAAA,EAAQ,MAAA,CAAO,CAAA,GAAI;IAC7C,MAAM,EAAE,WAAW,CAAA,EAAG,WAAW,QAAA,EAAU,YAAY,CAAA,EAAG,YAAY,QAAA,CAAS,CAAA,GAAI;IAEnF,IAAI,IAAI,MAAM,KAAA,CAAM,CAAA,GAAI;IACxB,IAAI,IAAI,MAAM,KAAA,CAAM,CAAA,GAAI;IAExB,MAAM,SAAS,sLAAI,MAAA,CAAI,GAAG,CAAC;IAE3B,IAAI,IAAI,GAAG;QACV,IAAI,IAAI,UAAU;YACjB,OAAQ,QAAQ;gBACf,KAAK;gBACL,KAAK;gBACL,KAAK;oBAAe;wBACnB,OAAO,CAAA,GAAI,IAAI;wBACf;oBACD;gBACA,KAAK;gBACL,KAAK;oBAAU;wBACd,OAAO,CAAA,GAAA,CAAK,IAAI,QAAA,IAAY;wBAC5B;oBACD;gBACA;oBAAS;wBACR,OAAO,CAAA,GAAI;oBACZ;YACD;YACA,IAAI;QACL;IACD,OAAO;QACN,OAAO,CAAA,GAAI;QACX,IAAI,CAAC;QACL,IAAI,IAAI,UAAU;YACjB,OAAQ,QAAQ;gBACf,KAAK;gBACL,KAAK;gBACL,KAAK;oBAAe;wBACnB,OAAO,CAAA,GAAI,CAAC;wBACZ;oBACD;gBACA;oBAAS;wBACR,OAAO,CAAA,GAAI,CAAC;oBACb;YACD;YAEA,IAAI;QACL;IACD;IAEA,IAAI,IAAI,GAAG;QACV,IAAI,IAAI,WAAW;YAClB,OAAQ,QAAQ;gBACf,KAAK;gBACL,KAAK;gBACL,KAAK;oBAAa;wBACjB,OAAO,CAAA,GAAI,IAAI;wBACf;oBACD;gBACA,KAAK;gBACL,KAAK;oBAAQ;wBACZ,OAAO,CAAA,GAAA,CAAK,IAAI,SAAA,IAAa;wBAC7B;oBACD;gBACA;oBAAS;wBACR,OAAO,CAAA,GAAI;oBACZ;YACD;YAEA,IAAI;QACL;IACD,OAAO;QACN,OAAO,CAAA,GAAI;QACX,IAAI,CAAC;QACL,IAAI,IAAI,WAAW;YAClB,OAAQ,QAAQ;gBACf,KAAK;gBACL,KAAK;gBACL,KAAK;oBAAa;wBACjB,OAAO,CAAA,GAAI,CAAC;wBACZ;oBACD;gBACA;oBAAS;wBACR,OAAO,CAAA,GAAI,CAAC;oBACb;YACD;YACA,IAAI;QACL;IACD;IAEA,MAAM,EAAE,CAAA,EAAG,CAAA,CAAE,CAAA,GAAI,OAAO,GAAA,CAAI,MAAM,QAAQ,EAAE,GAAA,CAAI,QAAQ;IAExD,OAAO;QACN,GAAG,KAAA;QACH;QACA;QACA,OAAO;YACN,GAAG,KAAK,GAAA,CAAI,UAAU,CAAC;YACvB,GAAG,KAAK,GAAA,CAAI,WAAW,CAAC;QACzB;IACD;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 12465, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/%40tldraw/editor/src/lib/editor/shapes/BaseBoxShapeUtil.tsx"],"sourcesContent":["import { TLBaseShape } from '@tldraw/tlschema'\nimport { lerp } from '@tldraw/utils'\nimport { Geometry2d } from '../../primitives/geometry/Geometry2d'\nimport { Rectangle2d } from '../../primitives/geometry/Rectangle2d'\nimport { HandleSnapGeometry } from '../managers/SnapManager/HandleSnaps'\nimport { ShapeUtil, TLResizeInfo } from './ShapeUtil'\nimport { resizeBox } from './shared/resizeBox'\n\n/** @public */\nexport type TLBaseBoxShape = TLBaseShape<string, { w: number; h: number }>\n\n/** @public */\nexport abstract class BaseBoxShapeUtil<Shape extends TLBaseBoxShape> extends ShapeUtil<Shape> {\n\tgetGeometry(shape: Shape): Geometry2d {\n\t\treturn new Rectangle2d({\n\t\t\twidth: shape.props.w,\n\t\t\theight: shape.props.h,\n\t\t\tisFilled: true,\n\t\t})\n\t}\n\n\toverride onResize(shape: any, info: TLResizeInfo<any>) {\n\t\treturn resizeBox(shape, info)\n\t}\n\n\toverride getHandleSnapGeometry(shape: Shape): HandleSnapGeometry {\n\t\treturn {\n\t\t\tpoints: this.getGeometry(shape).bounds.cornersAndCenter,\n\t\t}\n\t}\n\n\toverride getInterpolatedProps(startShape: Shape, endShape: Shape, t: number): Shape['props'] {\n\t\treturn {\n\t\t\t...endShape.props,\n\t\t\tw: lerp(startShape.props.w, endShape.props.w, t),\n\t\t\th: lerp(startShape.props.h, endShape.props.h, t),\n\t\t}\n\t}\n}\n"],"names":[],"mappings":";;;AACA,SAAS,YAAY;;AAErB,SAAS,mBAAmB;AAE5B,SAAS,iBAA+B;AACxC,SAAS,iBAAiB;;;;;AAMnB,MAAe,uNAAuD,YAAA,CAAiB;IAC7F,YAAY,KAAA,EAA0B;QACrC,OAAO,0MAAI,cAAA,CAAY;YACtB,OAAO,MAAM,KAAA,CAAM,CAAA;YACnB,QAAQ,MAAM,KAAA,CAAM,CAAA;YACpB,UAAU;QACX,CAAC;IACF;IAES,SAAS,KAAA,EAAY,IAAA,EAAyB;QACtD,mNAAO,YAAA,EAAU,OAAO,IAAI;IAC7B;IAES,sBAAsB,KAAA,EAAkC;QAChE,OAAO;YACN,QAAQ,IAAA,CAAK,WAAA,CAAY,KAAK,EAAE,MAAA,CAAO,gBAAA;QACxC;IACD;IAES,qBAAqB,UAAA,EAAmB,QAAA,EAAiB,CAAA,EAA2B;QAC5F,OAAO;YACN,GAAG,SAAS,KAAA;YACZ,6KAAG,OAAA,EAAK,WAAW,KAAA,CAAM,CAAA,EAAG,SAAS,KAAA,CAAM,CAAA,EAAG,CAAC;YAC/C,6KAAG,OAAA,EAAK,WAAW,KAAA,CAAM,CAAA,EAAG,SAAS,KAAA,CAAM,CAAA,EAAG,CAAC;QAChD;IACD;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 12509, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/%40tldraw/editor/src/lib/editor/shapes/shared/resizeScaled.ts"],"sourcesContent":["import { TLBaseShape } from '@tldraw/tlschema'\nimport { exhaustiveSwitchError } from '@tldraw/utils'\nimport { Vec } from '../../../primitives/Vec'\nimport { TLResizeInfo } from '../ShapeUtil'\n\n/**\n * Resize a shape that has a scale prop.\n *\n * @param shape - The shape to resize\n * @param info - The resize info\n *\n * @public */\nexport function resizeScaled(\n\tshape: TLBaseShape<any, { scale: number }>,\n\t{ initialBounds, scaleX, scaleY, newPoint, handle }: TLResizeInfo<any>\n) {\n\tlet scaleDelta: number\n\tswitch (handle) {\n\t\tcase 'bottom_left':\n\t\tcase 'bottom_right':\n\t\tcase 'top_left':\n\t\tcase 'top_right': {\n\t\t\tscaleDelta = Math.max(0.01, Math.max(Math.abs(scaleX), Math.abs(scaleY)))\n\t\t\tbreak\n\t\t}\n\t\tcase 'left':\n\t\tcase 'right': {\n\t\t\tscaleDelta = Math.max(0.01, Math.abs(scaleX))\n\t\t\tbreak\n\t\t}\n\t\tcase 'bottom':\n\t\tcase 'top': {\n\t\t\tscaleDelta = Math.max(0.01, Math.abs(scaleY))\n\t\t\tbreak\n\t\t}\n\t\tdefault: {\n\t\t\tthrow exhaustiveSwitchError(handle)\n\t\t}\n\t}\n\n\t// Compute the offset (if flipped X or flipped Y)\n\tconst offset = new Vec(0, 0)\n\n\tif (scaleX < 0) {\n\t\toffset.x = -(initialBounds.width * scaleDelta)\n\t}\n\tif (scaleY < 0) {\n\t\toffset.y = -(initialBounds.height * scaleDelta)\n\t}\n\n\t// Apply the offset to the new point\n\tconst { x, y } = Vec.Add(newPoint, offset.rot(shape.rotation))\n\n\treturn {\n\t\tx,\n\t\ty,\n\t\tprops: {\n\t\t\tscale: scaleDelta * shape.props.scale,\n\t\t},\n\t}\n}\n"],"names":[],"mappings":";;;AACA,SAAS,6BAA6B;;AACtC,SAAS,WAAW;;;AAUb,SAAS,aACf,KAAA,EACA,EAAE,aAAA,EAAe,MAAA,EAAQ,MAAA,EAAQ,QAAA,EAAU,MAAA,CAAO,CAAA,EACjD;IACD,IAAI;IACJ,OAAQ,QAAQ;QACf,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;YAAa;gBACjB,aAAa,KAAK,GAAA,CAAI,MAAM,KAAK,GAAA,CAAI,KAAK,GAAA,CAAI,MAAM,GAAG,KAAK,GAAA,CAAI,MAAM,CAAC,CAAC;gBACxE;YACD;QACA,KAAK;QACL,KAAK;YAAS;gBACb,aAAa,KAAK,GAAA,CAAI,MAAM,KAAK,GAAA,CAAI,MAAM,CAAC;gBAC5C;YACD;QACA,KAAK;QACL,KAAK;YAAO;gBACX,aAAa,KAAK,GAAA,CAAI,MAAM,KAAK,GAAA,CAAI,MAAM,CAAC;gBAC5C;YACD;QACA;YAAS;gBACR,iLAAM,wBAAA,EAAsB,MAAM;YACnC;IACD;IAGA,MAAM,SAAS,sLAAI,MAAA,CAAI,GAAG,CAAC;IAE3B,IAAI,SAAS,GAAG;QACf,OAAO,CAAA,GAAI,CAAA,CAAE,cAAc,KAAA,GAAQ,UAAA;IACpC;IACA,IAAI,SAAS,GAAG;QACf,OAAO,CAAA,GAAI,CAAA,CAAE,cAAc,MAAA,GAAS,UAAA;IACrC;IAGA,MAAM,EAAE,CAAA,EAAG,CAAA,CAAE,CAAA,qLAAI,MAAA,CAAI,GAAA,CAAI,UAAU,OAAO,GAAA,CAAI,MAAM,QAAQ,CAAC;IAE7D,OAAO;QACN;QACA;QACA,OAAO;YACN,OAAO,aAAa,MAAM,KAAA,CAAM,KAAA;QACjC;IACD;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 12569, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/%40tldraw/editor/src/lib/editor/tools/BaseBoxShapeTool/children/Idle.ts"],"sourcesContent":["import { TLPointerEventInfo } from '../../../types/event-types'\nimport { StateNode } from '../../StateNode'\n\nexport class Idle extends StateNode {\n\tstatic override id = 'idle'\n\n\toverride onPointerDown(info: TLPointerEventInfo) {\n\t\tthis.parent.transition('pointing', info)\n\t}\n\n\toverride onEnter() {\n\t\tthis.editor.setCursor({ type: 'cross', rotation: 0 })\n\t}\n\n\toverride onCancel() {\n\t\tthis.editor.setCurrentTool('select')\n\t}\n}\n"],"names":[],"mappings":";;;AACA,SAAS,iBAAiB;;AAEnB,MAAM,0MAAa,YAAA,CAAU;IACnC,OAAgB,KAAK,OAAA;IAEZ,cAAc,IAAA,EAA0B;QAChD,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,YAAY,IAAI;IACxC;IAES,UAAU;QAClB,IAAA,CAAK,MAAA,CAAO,SAAA,CAAU;YAAE,MAAM;YAAS,UAAU;QAAE,CAAC;IACrD;IAES,WAAW;QACnB,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,QAAQ;IACpC;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 12597, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/%40tldraw/editor/src/lib/editor/tools/BaseBoxShapeTool/children/Pointing.ts"],"sourcesContent":["import { TLShape, createShapeId } from '@tldraw/tlschema'\nimport { structuredClone } from '@tldraw/utils'\nimport { Vec } from '../../../../primitives/Vec'\nimport { Editor } from '../../../Editor'\nimport { TLBaseBoxShape } from '../../../shapes/BaseBoxShapeUtil'\nimport { TLPointerEventInfo } from '../../../types/event-types'\nimport { StateNode } from '../../StateNode'\nimport { BaseBoxShapeTool } from '../BaseBoxShapeTool'\n\nexport class Pointing extends StateNode {\n\tstatic override id = 'pointing'\n\n\toverride onPointerMove(info: TLPointerEventInfo) {\n\t\tconst { editor } = this\n\t\tif (editor.inputs.isDragging) {\n\t\t\tconst { originPagePoint } = editor.inputs\n\n\t\t\tconst shapeType = (this.parent as BaseBoxShapeTool)!.shapeType\n\n\t\t\tconst id = createShapeId()\n\n\t\t\tconst creatingMarkId = editor.markHistoryStoppingPoint(`creating_box:${id}`)\n\t\t\tconst newPoint = maybeSnapToGrid(originPagePoint, editor)\n\n\t\t\t// Allow this to trigger the max shapes reached alert\n\t\t\tthis.editor.createShapes<TLBaseBoxShape>([\n\t\t\t\t{\n\t\t\t\t\tid,\n\t\t\t\t\ttype: shapeType,\n\t\t\t\t\tx: newPoint.x,\n\t\t\t\t\ty: newPoint.y,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\tw: 1,\n\t\t\t\t\t\th: 1,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t])\n\t\t\tconst shape = editor.getShape(id)\n\t\t\tif (!shape) {\n\t\t\t\tthis.cancel()\n\t\t\t\treturn\n\t\t\t}\n\t\t\teditor.select(id)\n\n\t\t\tconst parent = this.parent as BaseBoxShapeTool\n\t\t\tthis.editor.setCurrentTool(\n\t\t\t\t'select.resizing',\n\t\t\t\t{\n\t\t\t\t\t...info,\n\t\t\t\t\ttarget: 'selection',\n\t\t\t\t\thandle: 'bottom_right',\n\t\t\t\t\tisCreating: true,\n\t\t\t\t\tcreatingMarkId,\n\t\t\t\t\tcreationCursorOffset: { x: 1, y: 1 },\n\t\t\t\t\tonInteractionEnd: this.parent.id,\n\t\t\t\t\tonCreate: parent.onCreate\n\t\t\t\t\t\t? (shape: TLShape | null) => parent.onCreate?.(shape)\n\t\t\t\t\t\t: undefined,\n\t\t\t\t} /** satisfies ResizingInfo, defined in main tldraw package  */\n\t\t\t)\n\t\t}\n\t}\n\n\toverride onPointerUp() {\n\t\tthis.complete()\n\t}\n\n\toverride onCancel() {\n\t\tthis.cancel()\n\t}\n\n\toverride onComplete() {\n\t\tthis.complete()\n\t}\n\n\toverride onInterrupt() {\n\t\tthis.cancel()\n\t}\n\n\tcomplete() {\n\t\tconst { originPagePoint } = this.editor.inputs\n\n\t\tconst shapeType = (this.parent as BaseBoxShapeTool)!.shapeType as TLBaseBoxShape['type']\n\n\t\tconst id = createShapeId()\n\n\t\tthis.editor.markHistoryStoppingPoint(`creating_box:${id}`)\n\n\t\t// Allow this to trigger the max shapes reached alert\n\t\t// todo: add scale here when dynamic size is enabled (is this still needed?)\n\t\tthis.editor.createShapes<TLBaseBoxShape>([\n\t\t\t{\n\t\t\t\tid,\n\t\t\t\ttype: shapeType,\n\t\t\t\tx: originPagePoint.x,\n\t\t\t\ty: originPagePoint.y,\n\t\t\t},\n\t\t])\n\n\t\tconst shape = this.editor.getShape<TLBaseBoxShape>(id)!\n\t\tif (!shape) {\n\t\t\tthis.cancel()\n\t\t\treturn\n\t\t}\n\n\t\tlet { w, h } = shape.props\n\t\tconst delta = new Vec(w / 2, h / 2)\n\t\tconst parentTransform = this.editor.getShapeParentTransform(shape)\n\t\tif (parentTransform) delta.rot(-parentTransform.rotation())\n\t\tlet scale = 1\n\n\t\tif (this.editor.user.getIsDynamicResizeMode()) {\n\t\t\tscale = 1 / this.editor.getZoomLevel()\n\t\t\tw *= scale\n\t\t\th *= scale\n\t\t\tdelta.mul(scale)\n\t\t}\n\n\t\tconst next = structuredClone(shape)\n\t\tconst newPoint = maybeSnapToGrid(new Vec(shape.x - delta.x, shape.y - delta.y), this.editor)\n\t\tnext.x = newPoint.x\n\t\tnext.y = newPoint.y\n\t\tnext.props.w = w\n\t\tnext.props.h = h\n\n\t\tif ('scale' in shape.props) {\n\t\t\t;(next as TLBaseBoxShape & { props: { scale: number } }).props.scale = scale\n\t\t}\n\n\t\tthis.editor.updateShape<TLBaseBoxShape>(next)\n\n\t\tthis.editor.setSelectedShapes([id])\n\n\t\tif (this.editor.getInstanceState().isToolLocked) {\n\t\t\tthis.parent.transition('idle')\n\t\t} else {\n\t\t\tthis.editor.setCurrentTool('select.idle')\n\t\t}\n\t}\n\n\tcancel() {\n\t\tthis.parent.transition('idle')\n\t}\n}\n\n/**\n * Checks if grid mode is enabled and snaps a point to the grid if so\n *\n * @public\n */\nexport function maybeSnapToGrid(point: Vec, editor: Editor): Vec {\n\tconst isGridMode = editor.getInstanceState().isGridMode\n\tconst gridSize = editor.getDocumentSettings().gridSize\n\tif (isGridMode) return point.clone().snapToGrid(gridSize)\n\treturn point.clone()\n}\n"],"names":["shape"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 12734, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/%40tldraw/editor/src/lib/editor/tools/BaseBoxShapeTool/BaseBoxShapeTool.ts"],"sourcesContent":["import { TLShape } from '@tldraw/tlschema'\nimport { StateNode, TLStateNodeConstructor } from '../StateNode'\nimport { Idle } from './children/Idle'\nimport { Pointing } from './children/Pointing'\n\n/** @public */\nexport abstract class BaseBoxShapeTool extends StateNode {\n\tstatic override id = 'box'\n\tstatic override initial = 'idle'\n\tstatic override children(): TLStateNodeConstructor[] {\n\t\treturn [Idle, Pointing]\n\t}\n\n\tabstract override shapeType: string\n\n\tonCreate?(_shape: TLShape | null): void | null\n}\n"],"names":[],"mappings":";;;AACA,SAAS,iBAAyC;AAClD,SAAS,YAAY;AACrB,SAAS,gBAAgB;;;;AAGlB,MAAe,sNAAyB,YAAA,CAAU;IACxD,OAAgB,KAAK,MAAA;IACrB,OAAgB,UAAU,OAAA;IAC1B,OAAgB,WAAqC;QACpD,OAAO;oOAAC,OAAA;wOAAM,WAAQ;SAAA;IACvB;AAKD","ignoreList":[0],"debugId":null}}]
}