{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/selection-logic/updateHoveredShapeId.ts"],"sourcesContent":["import { Editor, TLShape, throttle } from '@tldraw/editor'\n\nfunction _updateHoveredShapeId(editor: Editor) {\n\t// todo: consider replacing `get hoveredShapeId` with this; it would mean keeping hoveredShapeId in memory rather than in the store and possibly re-computing it more often than necessary\n\tconst hitShape = editor.getShapeAtPoint(editor.inputs.currentPagePoint, {\n\t\thitInside: false,\n\t\thitLabels: false,\n\t\tmargin: editor.options.hitTestMargin / editor.getZoomLevel(),\n\t\trenderingOnly: true,\n\t})\n\n\tif (!hitShape) return editor.setHoveredShape(null)\n\n\tlet shapeToHover: TLShape | undefined = undefined\n\n\tconst outermostShape = editor.getOutermostSelectableShape(hitShape)\n\n\tif (outermostShape === hitShape) {\n\t\tshapeToHover = hitShape\n\t} else {\n\t\tif (\n\t\t\toutermostShape.id === editor.getFocusedGroupId() ||\n\t\t\teditor.getSelectedShapeIds().includes(outermostShape.id)\n\t\t) {\n\t\t\tshapeToHover = hitShape\n\t\t} else {\n\t\t\tshapeToHover = outermostShape\n\t\t}\n\t}\n\n\treturn editor.setHoveredShape(shapeToHover.id)\n}\n\n/** @internal */\nexport const updateHoveredShapeId = throttle(\n\t_updateHoveredShapeId,\n\tprocess.env.NODE_ENV === 'test' ? 0 : 32\n)\n"],"names":[],"mappings":";;;;AAAA,SAA0B,gBAAgB;;;AAE1C,SAAS,sBAAsB,MAAA,EAAgB;IAE9C,MAAM,WAAW,OAAO,eAAA,CAAgB,OAAO,MAAA,CAAO,gBAAA,EAAkB;QACvE,WAAW;QACX,WAAW;QACX,QAAQ,OAAO,OAAA,CAAQ,aAAA,GAAgB,OAAO,YAAA,CAAa;QAC3D,eAAe;IAChB,CAAC;IAED,IAAI,CAAC,SAAU,CAAA,OAAO,OAAO,eAAA,CAAgB,IAAI;IAEjD,IAAI,eAAoC,KAAA;IAExC,MAAM,iBAAiB,OAAO,2BAAA,CAA4B,QAAQ;IAElE,IAAI,mBAAmB,UAAU;QAChC,eAAe;IAChB,OAAO;QACN,IACC,eAAe,EAAA,KAAO,OAAO,iBAAA,CAAkB,KAC/C,OAAO,mBAAA,CAAoB,EAAE,QAAA,CAAS,eAAe,EAAE,GACtD;YACD,eAAe;QAChB,OAAO;YACN,eAAe;QAChB;IACD;IAEA,OAAO,OAAO,eAAA,CAAgB,aAAa,EAAE;AAC9C;AAGO,MAAM,gNAAuB,YAAA,EACnC,uBACA,QAAQ,IAAI,aAAa,SAAS,2CAAI","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 44, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/SelectTool/selectHelpers.ts"],"sourcesContent":["import { Editor, TLShape } from '@tldraw/editor'\n\n/** @internal */\nexport function startEditingShapeWithLabel(editor: Editor, shape: TLShape, selectAll = false) {\n\t// Finish this shape and start editing the next one\n\teditor.select(shape)\n\teditor.setEditingShape(shape)\n\teditor.setCurrentTool('select.editing_shape', {\n\t\ttarget: 'shape',\n\t\tshape: shape,\n\t})\n\tif (selectAll) {\n\t\teditor.emit('select-all-text', { shapeId: shape.id })\n\t}\n}\n"],"names":[],"mappings":";;;AAGO,SAAS,2BAA2B,MAAA,EAAgB,KAAA,EAAgB,YAAY,KAAA,EAAO;IAE7F,OAAO,MAAA,CAAO,KAAK;IACnB,OAAO,eAAA,CAAgB,KAAK;IAC5B,OAAO,cAAA,CAAe,wBAAwB;QAC7C,QAAQ;QACR;IACD,CAAC;IACD,IAAI,WAAW;QACd,OAAO,IAAA,CAAK,mBAAmB;YAAE,SAAS,MAAM,EAAA;QAAG,CAAC;IACrD;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 68, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/EraserTool/childStates/Erasing.ts"],"sourcesContent":["import {\n\tStateNode,\n\tTLFrameShape,\n\tTLGroupShape,\n\tTLPointerEventInfo,\n\tTLShapeId,\n\tpointInPolygon,\n} from '@tldraw/editor'\n\nexport class Erasing extends StateNode {\n\tstatic override id = 'erasing'\n\n\tprivate info = {} as TLPointerEventInfo\n\tprivate scribbleId = 'id'\n\tprivate markId = ''\n\tprivate excludedShapeIds = new Set<TLShapeId>()\n\n\toverride onEnter(info: TLPointerEventInfo) {\n\t\tthis.markId = this.editor.markHistoryStoppingPoint('erase scribble begin')\n\t\tthis.info = info\n\n\t\tconst { originPagePoint } = this.editor.inputs\n\t\tthis.excludedShapeIds = new Set(\n\t\t\tthis.editor\n\t\t\t\t.getCurrentPageShapes()\n\t\t\t\t.filter((shape) => {\n\t\t\t\t\t//If the shape is locked, we shouldn't erase it\n\t\t\t\t\tif (this.editor.isShapeOrAncestorLocked(shape)) return true\n\t\t\t\t\t//If the shape is a group or frame, check we're inside it when we start erasing\n\t\t\t\t\tif (\n\t\t\t\t\t\tthis.editor.isShapeOfType<TLGroupShape>(shape, 'group') ||\n\t\t\t\t\t\tthis.editor.isShapeOfType<TLFrameShape>(shape, 'frame')\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst pointInShapeShape = this.editor.getPointInShapeSpace(shape, originPagePoint)\n\t\t\t\t\t\tconst geometry = this.editor.getShapeGeometry(shape)\n\t\t\t\t\t\treturn geometry.bounds.containsPoint(pointInShapeShape)\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false\n\t\t\t\t})\n\t\t\t\t.map((shape) => shape.id)\n\t\t)\n\n\t\tconst scribble = this.editor.scribbles.addScribble({\n\t\t\tcolor: 'muted-1',\n\t\t\tsize: 12,\n\t\t})\n\t\tthis.scribbleId = scribble.id\n\n\t\tthis.update()\n\t}\n\n\tprivate pushPointToScribble() {\n\t\tconst { x, y } = this.editor.inputs.currentPagePoint\n\t\tthis.editor.scribbles.addPoint(this.scribbleId, x, y)\n\t}\n\n\toverride onExit() {\n\t\tthis.editor.setErasingShapes([])\n\t\tthis.editor.scribbles.stop(this.scribbleId)\n\t}\n\n\toverride onPointerMove() {\n\t\tthis.update()\n\t}\n\n\toverride onPointerUp() {\n\t\tthis.complete()\n\t}\n\n\toverride onCancel() {\n\t\tthis.cancel()\n\t}\n\n\toverride onComplete() {\n\t\tthis.complete()\n\t}\n\n\tupdate() {\n\t\tconst { editor, excludedShapeIds } = this\n\t\tconst erasingShapeIds = editor.getErasingShapeIds()\n\t\tconst zoomLevel = editor.getZoomLevel()\n\t\tconst currentPageShapes = editor.getCurrentPageRenderingShapesSorted()\n\t\tconst {\n\t\t\tinputs: { currentPagePoint, previousPagePoint },\n\t\t} = editor\n\n\t\tthis.pushPointToScribble()\n\n\t\tconst erasing = new Set<TLShapeId>(erasingShapeIds)\n\t\tconst minDist = this.editor.options.hitTestMargin / zoomLevel\n\n\t\tfor (const shape of currentPageShapes) {\n\t\t\tif (editor.isShapeOfType<TLGroupShape>(shape, 'group')) continue\n\n\t\t\t// Avoid testing masked shapes, unless the pointer is inside the mask\n\t\t\tconst pageMask = editor.getShapeMask(shape.id)\n\t\t\tif (pageMask && !pointInPolygon(currentPagePoint, pageMask)) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Hit test the shape using a line segment\n\t\t\tconst geometry = editor.getShapeGeometry(shape)\n\t\t\tconst pageTransform = editor.getShapePageTransform(shape)\n\t\t\tif (!geometry || !pageTransform) continue\n\t\t\tconst pt = pageTransform.clone().invert()\n\t\t\tconst A = pt.applyToPoint(previousPagePoint)\n\t\t\tconst B = pt.applyToPoint(currentPagePoint)\n\n\t\t\t// If the line segment is entirely above / below / left / right of the shape's bounding box, skip the hit test\n\t\t\tconst { bounds } = geometry\n\t\t\tif (\n\t\t\t\tbounds.minX - minDist > Math.max(A.x, B.x) ||\n\t\t\t\tbounds.minY - minDist > Math.max(A.y, B.y) ||\n\t\t\t\tbounds.maxX + minDist < Math.min(A.x, B.x) ||\n\t\t\t\tbounds.maxY + minDist < Math.min(A.y, B.y)\n\t\t\t) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif (geometry.hitTestLineSegment(A, B, minDist)) {\n\t\t\t\terasing.add(editor.getOutermostSelectableShape(shape).id)\n\t\t\t}\n\t\t}\n\n\t\t// Remove the hit shapes, except if they're in the list of excluded shapes\n\t\t// (these excluded shapes will be any frames or groups the pointer was inside of\n\t\t// when the user started erasing)\n\t\tthis.editor.setErasingShapes([...erasing].filter((id) => !excludedShapeIds.has(id)))\n\t}\n\n\tcomplete() {\n\t\tconst { editor } = this\n\t\teditor.deleteShapes(editor.getCurrentPageState().erasingShapeIds)\n\t\tthis.parent.transition('idle')\n\t}\n\n\tcancel() {\n\t\tconst { editor } = this\n\t\teditor.bailToMark(this.markId)\n\t\tthis.parent.transition('idle', this.info)\n\t}\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 173, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/EraserTool/childStates/Idle.ts"],"sourcesContent":["import { StateNode, TLPointerEventInfo } from '@tldraw/editor'\n\nexport class Idle extends StateNode {\n\tstatic override id = 'idle'\n\n\toverride onPointerDown(info: TLPointerEventInfo) {\n\t\tthis.parent.transition('pointing', info)\n\t}\n\n\toverride onCancel() {\n\t\tthis.editor.setCurrentTool('select')\n\t}\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,iBAAqC;;AAEvC,MAAM,0MAAa,YAAA,CAAU;IACnC,OAAgB,KAAK,OAAA;IAEZ,cAAc,IAAA,EAA0B;QAChD,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,YAAY,IAAI;IACxC;IAES,WAAW;QACnB,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,QAAQ;IACpC;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 196, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/EraserTool/childStates/Pointing.ts"],"sourcesContent":["import {\n\tStateNode,\n\tTLFrameShape,\n\tTLGroupShape,\n\tTLPointerEventInfo,\n\tTLShapeId,\n} from '@tldraw/editor'\n\nexport class Pointing extends StateNode {\n\tstatic override id = 'pointing'\n\n\toverride onEnter() {\n\t\tconst zoomLevel = this.editor.getZoomLevel()\n\t\tconst currentPageShapesSorted = this.editor.getCurrentPageRenderingShapesSorted()\n\t\tconst {\n\t\t\tinputs: { currentPagePoint },\n\t\t} = this.editor\n\n\t\tconst erasing = new Set<TLShapeId>()\n\n\t\tconst initialSize = erasing.size\n\n\t\tfor (let n = currentPageShapesSorted.length, i = n - 1; i >= 0; i--) {\n\t\t\tconst shape = currentPageShapesSorted[i]\n\t\t\tif (\n\t\t\t\tthis.editor.isShapeOrAncestorLocked(shape) ||\n\t\t\t\tthis.editor.isShapeOfType<TLGroupShape>(shape, 'group')\n\t\t\t) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tthis.editor.isPointInShape(shape, currentPagePoint, {\n\t\t\t\t\thitInside: false,\n\t\t\t\t\tmargin: this.editor.options.hitTestMargin / zoomLevel,\n\t\t\t\t})\n\t\t\t) {\n\t\t\t\tconst hitShape = this.editor.getOutermostSelectableShape(shape)\n\t\t\t\t// If we've hit a frame after hitting any other shape, stop here\n\t\t\t\tif (\n\t\t\t\t\tthis.editor.isShapeOfType<TLFrameShape>(hitShape, 'frame') &&\n\t\t\t\t\terasing.size > initialSize\n\t\t\t\t) {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\terasing.add(hitShape.id)\n\t\t\t}\n\t\t}\n\n\t\tthis.editor.setErasingShapes([...erasing])\n\t}\n\n\toverride onLongPress(info: TLPointerEventInfo) {\n\t\tthis.startErasing(info)\n\t}\n\n\toverride onExit(_info: any, to: string) {\n\t\tif (to !== 'erasing') {\n\t\t\tthis.editor.setErasingShapes([])\n\t\t}\n\t}\n\n\toverride onPointerMove(info: TLPointerEventInfo) {\n\t\tif (this.editor.inputs.isDragging) {\n\t\t\tthis.startErasing(info)\n\t\t}\n\t}\n\n\toverride onPointerUp() {\n\t\tthis.complete()\n\t}\n\n\toverride onCancel() {\n\t\tthis.cancel()\n\t}\n\n\toverride onComplete() {\n\t\tthis.complete()\n\t}\n\n\toverride onInterrupt() {\n\t\tthis.cancel()\n\t}\n\n\tprivate startErasing(info: TLPointerEventInfo) {\n\t\tthis.parent.transition('erasing', info)\n\t}\n\n\tcomplete() {\n\t\tconst erasingShapeIds = this.editor.getErasingShapeIds()\n\n\t\tif (erasingShapeIds.length) {\n\t\t\tthis.editor.markHistoryStoppingPoint('erase end')\n\t\t\tthis.editor.deleteShapes(erasingShapeIds)\n\t\t}\n\n\t\tthis.parent.transition('idle')\n\t}\n\n\tcancel() {\n\t\tthis.parent.transition('idle')\n\t}\n}\n"],"names":[],"mappings":";;;;AAAA;;AAQO,MAAM,8MAAiB,YAAA,CAAU;IACvC,OAAgB,KAAK,WAAA;IAEZ,UAAU;QAClB,MAAM,YAAY,IAAA,CAAK,MAAA,CAAO,YAAA,CAAa;QAC3C,MAAM,0BAA0B,IAAA,CAAK,MAAA,CAAO,mCAAA,CAAoC;QAChF,MAAM,EACL,QAAQ,EAAE,gBAAA,CAAiB,CAAA,EAC5B,GAAI,IAAA,CAAK,MAAA;QAET,MAAM,UAAU,aAAA,GAAA,IAAI,IAAe;QAEnC,MAAM,cAAc,QAAQ,IAAA;QAE5B,IAAA,IAAS,IAAI,wBAAwB,MAAA,EAAQ,IAAI,IAAI,GAAG,KAAK,GAAG,IAAK;YACpE,MAAM,QAAQ,uBAAA,CAAwB,CAAC,CAAA;YACvC,IACC,IAAA,CAAK,MAAA,CAAO,uBAAA,CAAwB,KAAK,KACzC,IAAA,CAAK,MAAA,CAAO,aAAA,CAA4B,OAAO,OAAO,GACrD;gBACD;YACD;YAEA,IACC,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,OAAO,kBAAkB;gBACnD,WAAW;gBACX,QAAQ,IAAA,CAAK,MAAA,CAAO,OAAA,CAAQ,aAAA,GAAgB;YAC7C,CAAC,GACA;gBACD,MAAM,WAAW,IAAA,CAAK,MAAA,CAAO,2BAAA,CAA4B,KAAK;gBAE9D,IACC,IAAA,CAAK,MAAA,CAAO,aAAA,CAA4B,UAAU,OAAO,KACzD,QAAQ,IAAA,GAAO,aACd;oBACD;gBACD;gBAEA,QAAQ,GAAA,CAAI,SAAS,EAAE;YACxB;QACD;QAEA,IAAA,CAAK,MAAA,CAAO,gBAAA,CAAiB,CAAC;eAAG,OAAO;SAAC;IAC1C;IAES,YAAY,IAAA,EAA0B;QAC9C,IAAA,CAAK,YAAA,CAAa,IAAI;IACvB;IAES,OAAO,KAAA,EAAY,EAAA,EAAY;QACvC,IAAI,OAAO,WAAW;YACrB,IAAA,CAAK,MAAA,CAAO,gBAAA,CAAiB,CAAC,CAAC;QAChC;IACD;IAES,cAAc,IAAA,EAA0B;QAChD,IAAI,IAAA,CAAK,MAAA,CAAO,MAAA,CAAO,UAAA,EAAY;YAClC,IAAA,CAAK,YAAA,CAAa,IAAI;QACvB;IACD;IAES,cAAc;QACtB,IAAA,CAAK,QAAA,CAAS;IACf;IAES,WAAW;QACnB,IAAA,CAAK,MAAA,CAAO;IACb;IAES,aAAa;QACrB,IAAA,CAAK,QAAA,CAAS;IACf;IAES,cAAc;QACtB,IAAA,CAAK,MAAA,CAAO;IACb;IAEQ,aAAa,IAAA,EAA0B;QAC9C,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,WAAW,IAAI;IACvC;IAEA,WAAW;QACV,MAAM,kBAAkB,IAAA,CAAK,MAAA,CAAO,kBAAA,CAAmB;QAEvD,IAAI,gBAAgB,MAAA,EAAQ;YAC3B,IAAA,CAAK,MAAA,CAAO,wBAAA,CAAyB,WAAW;YAChD,IAAA,CAAK,MAAA,CAAO,YAAA,CAAa,eAAe;QACzC;QAEA,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,MAAM;IAC9B;IAEA,SAAS;QACR,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,MAAM;IAC9B;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 278, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/EraserTool/EraserTool.ts"],"sourcesContent":["import { StateNode, TLStateNodeConstructor } from '@tldraw/editor'\nimport { Erasing } from './childStates/Erasing'\nimport { Idle } from './childStates/Idle'\nimport { Pointing } from './childStates/Pointing'\n\n/** @public */\nexport class EraserTool extends StateNode {\n\tstatic override id = 'eraser'\n\tstatic override initial = 'idle'\n\tstatic override isLockable = false\n\tstatic override children(): TLStateNodeConstructor[] {\n\t\treturn [Idle, Pointing, Erasing]\n\t}\n\n\toverride onEnter() {\n\t\tthis.editor.setCursor({ type: 'cross', rotation: 0 })\n\t}\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,iBAAyC;AAClD,SAAS,eAAe;AACxB,SAAS,YAAY;AACrB,SAAS,gBAAgB;;;;;AAGlB,MAAM,gNAAmB,YAAA,CAAU;IACzC,OAAgB,KAAK,SAAA;IACrB,OAAgB,UAAU,OAAA;IAC1B,OAAgB,aAAa,MAAA;IAC7B,OAAgB,WAAqC;QACpD,OAAO;2MAAC,OAAA;+MAAM,WAAA;8MAAU,UAAO;SAAA;IAChC;IAES,UAAU;QAClB,IAAA,CAAK,MAAA,CAAO,SAAA,CAAU;YAAE,MAAM;YAAS,UAAU;QAAE,CAAC;IACrD;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 316, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/HandTool/childStates/Dragging.ts"],"sourcesContent":["import { StateNode, Vec } from '@tldraw/editor'\n\nexport class Dragging extends StateNode {\n\tstatic override id = 'dragging'\n\n\tinitialCamera = new Vec()\n\n\toverride onEnter() {\n\t\tthis.initialCamera = Vec.From(this.editor.getCamera())\n\t\tthis.update()\n\t}\n\n\toverride onPointerMove() {\n\t\tthis.update()\n\t}\n\n\toverride onPointerUp() {\n\t\tthis.complete()\n\t}\n\n\toverride onCancel() {\n\t\tthis.parent.transition('idle')\n\t}\n\n\toverride onComplete() {\n\t\tthis.complete()\n\t}\n\n\tprivate update() {\n\t\tconst { initialCamera, editor } = this\n\t\tconst { currentScreenPoint, originScreenPoint } = editor.inputs\n\n\t\tconst delta = Vec.Sub(currentScreenPoint, originScreenPoint).div(editor.getZoomLevel())\n\t\tif (delta.len2() === 0) return\n\t\teditor.setCamera(initialCamera.clone().add(delta))\n\t}\n\n\tprivate complete() {\n\t\tconst { editor } = this\n\t\tconst { pointerVelocity } = editor.inputs\n\n\t\tconst velocityAtPointerUp = Math.min(pointerVelocity.len(), 2)\n\n\t\tif (velocityAtPointerUp > 0.1) {\n\t\t\tthis.editor.slideCamera({ speed: velocityAtPointerUp, direction: pointerVelocity })\n\t\t}\n\n\t\tthis.parent.transition('idle')\n\t}\n}\n"],"names":[],"mappings":";;;;;AAAA,SAAS,WAAW,WAAW;;AAExB,MAAM,8MAAiB,YAAA,CAAU;IACvC,OAAgB,KAAK,WAAA;IAErB,gBAAgB,sLAAI,MAAA,CAAI,EAAA;IAEf,UAAU;QAClB,IAAA,CAAK,aAAA,qLAAgB,MAAA,CAAI,IAAA,CAAK,IAAA,CAAK,MAAA,CAAO,SAAA,CAAU,CAAC;QACrD,IAAA,CAAK,MAAA,CAAO;IACb;IAES,gBAAgB;QACxB,IAAA,CAAK,MAAA,CAAO;IACb;IAES,cAAc;QACtB,IAAA,CAAK,QAAA,CAAS;IACf;IAES,WAAW;QACnB,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,MAAM;IAC9B;IAES,aAAa;QACrB,IAAA,CAAK,QAAA,CAAS;IACf;IAEQ,SAAS;QAChB,MAAM,EAAE,aAAA,EAAe,MAAA,CAAO,CAAA,GAAI,IAAA;QAClC,MAAM,EAAE,kBAAA,EAAoB,iBAAA,CAAkB,CAAA,GAAI,OAAO,MAAA;QAEzD,MAAM,0LAAQ,MAAA,CAAI,GAAA,CAAI,oBAAoB,iBAAiB,EAAE,GAAA,CAAI,OAAO,YAAA,CAAa,CAAC;QACtF,IAAI,MAAM,IAAA,CAAK,MAAM,EAAG,CAAA;QACxB,OAAO,SAAA,CAAU,cAAc,KAAA,CAAM,EAAE,GAAA,CAAI,KAAK,CAAC;IAClD;IAEQ,WAAW;QAClB,MAAM,EAAE,MAAA,CAAO,CAAA,GAAI,IAAA;QACnB,MAAM,EAAE,eAAA,CAAgB,CAAA,GAAI,OAAO,MAAA;QAEnC,MAAM,sBAAsB,KAAK,GAAA,CAAI,gBAAgB,GAAA,CAAI,GAAG,CAAC;QAE7D,IAAI,sBAAsB,KAAK;YAC9B,IAAA,CAAK,MAAA,CAAO,WAAA,CAAY;gBAAE,OAAO;gBAAqB,WAAW;YAAgB,CAAC;QACnF;QAEA,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,MAAM;IAC9B;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 370, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/HandTool/childStates/Idle.ts"],"sourcesContent":["import { StateNode, TLPointerEventInfo } from '@tldraw/editor'\n\nexport class Idle extends StateNode {\n\tstatic override id = 'idle'\n\n\toverride onEnter() {\n\t\tthis.editor.setCursor({ type: 'grab', rotation: 0 })\n\t}\n\n\toverride onPointerDown(info: TLPointerEventInfo) {\n\t\tthis.parent.transition('pointing', info)\n\t}\n\n\toverride onCancel() {\n\t\tthis.editor.setCurrentTool('select')\n\t}\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,iBAAqC;;AAEvC,MAAM,0MAAa,YAAA,CAAU;IACnC,OAAgB,KAAK,OAAA;IAEZ,UAAU;QAClB,IAAA,CAAK,MAAA,CAAO,SAAA,CAAU;YAAE,MAAM;YAAQ,UAAU;QAAE,CAAC;IACpD;IAES,cAAc,IAAA,EAA0B;QAChD,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,YAAY,IAAI;IACxC;IAES,WAAW;QACnB,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,QAAQ;IACpC;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 399, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/HandTool/childStates/Pointing.ts"],"sourcesContent":["import { StateNode } from '@tldraw/editor'\n\nexport class Pointing extends StateNode {\n\tstatic override id = 'pointing'\n\n\toverride onEnter() {\n\t\tthis.editor.stopCameraAnimation()\n\t\tthis.editor.setCursor({ type: 'grabbing', rotation: 0 })\n\t}\n\n\toverride onLongPress() {\n\t\tthis.startDragging()\n\t}\n\n\toverride onPointerMove() {\n\t\tif (this.editor.inputs.isDragging) {\n\t\t\tthis.startDragging()\n\t\t}\n\t}\n\n\tprivate startDragging() {\n\t\tthis.parent.transition('dragging')\n\t}\n\n\toverride onPointerUp() {\n\t\tthis.complete()\n\t}\n\n\toverride onCancel() {\n\t\tthis.complete()\n\t}\n\n\toverride onComplete() {\n\t\tthis.complete()\n\t}\n\n\toverride onInterrupt() {\n\t\tthis.complete()\n\t}\n\n\tprivate complete() {\n\t\tthis.parent.transition('idle')\n\t}\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,iBAAiB;;AAEnB,MAAM,8MAAiB,YAAA,CAAU;IACvC,OAAgB,KAAK,WAAA;IAEZ,UAAU;QAClB,IAAA,CAAK,MAAA,CAAO,mBAAA,CAAoB;QAChC,IAAA,CAAK,MAAA,CAAO,SAAA,CAAU;YAAE,MAAM;YAAY,UAAU;QAAE,CAAC;IACxD;IAES,cAAc;QACtB,IAAA,CAAK,aAAA,CAAc;IACpB;IAES,gBAAgB;QACxB,IAAI,IAAA,CAAK,MAAA,CAAO,MAAA,CAAO,UAAA,EAAY;YAClC,IAAA,CAAK,aAAA,CAAc;QACpB;IACD;IAEQ,gBAAgB;QACvB,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,UAAU;IAClC;IAES,cAAc;QACtB,IAAA,CAAK,QAAA,CAAS;IACf;IAES,WAAW;QACnB,IAAA,CAAK,QAAA,CAAS;IACf;IAES,aAAa;QACrB,IAAA,CAAK,QAAA,CAAS;IACf;IAES,cAAc;QACtB,IAAA,CAAK,QAAA,CAAS;IACf;IAEQ,WAAW;QAClB,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,MAAM;IAC9B;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 449, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/HandTool/HandTool.ts"],"sourcesContent":["import { EASINGS, StateNode, TLClickEventInfo, TLStateNodeConstructor } from '@tldraw/editor'\nimport { Dragging } from './childStates/Dragging'\nimport { Idle } from './childStates/Idle'\nimport { Pointing } from './childStates/Pointing'\n\n/** @public */\nexport class HandTool extends StateNode {\n\tstatic override id = 'hand'\n\tstatic override initial = 'idle'\n\tstatic override isLockable = false\n\tstatic override children(): TLStateNodeConstructor[] {\n\t\treturn [Idle, Pointing, Dragging]\n\t}\n\n\toverride onDoubleClick(info: TLClickEventInfo) {\n\t\tif (info.phase === 'settle') {\n\t\t\tconst { currentScreenPoint } = this.editor.inputs\n\t\t\tthis.editor.zoomIn(currentScreenPoint, {\n\t\t\t\tanimation: { duration: 220, easing: EASINGS.easeOutQuint },\n\t\t\t})\n\t\t}\n\t}\n\n\toverride onTripleClick(info: TLClickEventInfo) {\n\t\tif (info.phase === 'settle') {\n\t\t\tconst { currentScreenPoint } = this.editor.inputs\n\t\t\tthis.editor.zoomOut(currentScreenPoint, {\n\t\t\t\tanimation: { duration: 320, easing: EASINGS.easeOutQuint },\n\t\t\t})\n\t\t}\n\t}\n\n\toverride onQuadrupleClick(info: TLClickEventInfo) {\n\t\tif (info.phase === 'settle') {\n\t\t\tconst zoomLevel = this.editor.getZoomLevel()\n\t\t\tconst {\n\t\t\t\tinputs: { currentScreenPoint },\n\t\t\t} = this.editor\n\n\t\t\tif (zoomLevel === 1) {\n\t\t\t\tthis.editor.zoomToFit({ animation: { duration: 400, easing: EASINGS.easeOutQuint } })\n\t\t\t} else {\n\t\t\t\tthis.editor.resetZoom(currentScreenPoint, {\n\t\t\t\t\tanimation: { duration: 320, easing: EASINGS.easeOutQuint },\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n}\n"],"names":[],"mappings":";;;;;AAAA,SAAS,SAAS,iBAA2D;AAC7E,SAAS,gBAAgB;AACzB,SAAS,YAAY;AACrB,SAAS,gBAAgB;;;;;AAGlB,MAAM,8MAAiB,YAAA,CAAU;IACvC,OAAgB,KAAK,OAAA;IACrB,OAAgB,UAAU,OAAA;IAC1B,OAAgB,aAAa,MAAA;IAC7B,OAAgB,WAAqC;QACpD,OAAO;yMAAC,OAAA;6MAAM,WAAA;6MAAU,WAAQ;SAAA;IACjC;IAES,cAAc,IAAA,EAAwB;QAC9C,IAAI,KAAK,KAAA,KAAU,UAAU;YAC5B,MAAM,EAAE,kBAAA,CAAmB,CAAA,GAAI,IAAA,CAAK,MAAA,CAAO,MAAA;YAC3C,IAAA,CAAK,MAAA,CAAO,MAAA,CAAO,oBAAoB;gBACtC,WAAW;oBAAE,UAAU;oBAAK,8LAAQ,UAAA,CAAQ,YAAA;gBAAa;YAC1D,CAAC;QACF;IACD;IAES,cAAc,IAAA,EAAwB;QAC9C,IAAI,KAAK,KAAA,KAAU,UAAU;YAC5B,MAAM,EAAE,kBAAA,CAAmB,CAAA,GAAI,IAAA,CAAK,MAAA,CAAO,MAAA;YAC3C,IAAA,CAAK,MAAA,CAAO,OAAA,CAAQ,oBAAoB;gBACvC,WAAW;oBAAE,UAAU;oBAAK,8LAAQ,UAAA,CAAQ,YAAA;gBAAa;YAC1D,CAAC;QACF;IACD;IAES,iBAAiB,IAAA,EAAwB;QACjD,IAAI,KAAK,KAAA,KAAU,UAAU;YAC5B,MAAM,YAAY,IAAA,CAAK,MAAA,CAAO,YAAA,CAAa;YAC3C,MAAM,EACL,QAAQ,EAAE,kBAAA,CAAmB,CAAA,EAC9B,GAAI,IAAA,CAAK,MAAA;YAET,IAAI,cAAc,GAAG;gBACpB,IAAA,CAAK,MAAA,CAAO,SAAA,CAAU;oBAAE,WAAW;wBAAE,UAAU;wBAAK,8LAAQ,UAAA,CAAQ,YAAA;oBAAa;gBAAE,CAAC;YACrF,OAAO;gBACN,IAAA,CAAK,MAAA,CAAO,SAAA,CAAU,oBAAoB;oBACzC,WAAW;wBAAE,UAAU;wBAAK,8LAAQ,UAAA,CAAQ,YAAA;oBAAa;gBAC1D,CAAC;YACF;QACD;IACD;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 525, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/LaserTool/childStates/Idle.ts"],"sourcesContent":["import { StateNode, TLPointerEventInfo } from '@tldraw/editor'\n\nexport class Idle extends StateNode {\n\tstatic override id = 'idle'\n\n\toverride onCancel() {\n\t\tthis.editor.setCurrentTool('select')\n\t}\n\n\toverride onPointerDown(info: TLPointerEventInfo) {\n\t\tthis.parent.transition('lasering', info)\n\t}\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,iBAAqC;;AAEvC,MAAM,0MAAa,YAAA,CAAU;IACnC,OAAgB,KAAK,OAAA;IAEZ,WAAW;QACnB,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,QAAQ;IACpC;IAES,cAAc,IAAA,EAA0B;QAChD,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,YAAY,IAAI;IACxC;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 548, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/LaserTool/childStates/Lasering.ts"],"sourcesContent":["import { StateNode } from '@tldraw/editor'\n\nexport class Lasering extends StateNode {\n\tstatic override id = 'lasering'\n\n\tscribbleId = 'id'\n\n\toverride onEnter() {\n\t\tconst scribble = this.editor.scribbles.addScribble({\n\t\t\tcolor: 'laser',\n\t\t\topacity: 0.7,\n\t\t\tsize: 4,\n\t\t\tdelay: this.editor.options.laserDelayMs,\n\t\t\tshrink: 0.05,\n\t\t\ttaper: true,\n\t\t})\n\t\tthis.scribbleId = scribble.id\n\t\tthis.pushPointToScribble()\n\t}\n\n\toverride onExit() {\n\t\tthis.editor.scribbles.stop(this.scribbleId)\n\t}\n\n\toverride onPointerMove() {\n\t\tthis.pushPointToScribble()\n\t}\n\n\toverride onPointerUp() {\n\t\tthis.complete()\n\t}\n\n\tprivate pushPointToScribble() {\n\t\tconst { x, y } = this.editor.inputs.currentPagePoint\n\t\tthis.editor.scribbles.addPoint(this.scribbleId, x, y)\n\t}\n\n\toverride onCancel() {\n\t\tthis.cancel()\n\t}\n\n\toverride onComplete() {\n\t\tthis.complete()\n\t}\n\n\tprivate complete() {\n\t\tthis.parent.transition('idle')\n\t}\n\n\tprivate cancel() {\n\t\tthis.parent.transition('idle')\n\t}\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,iBAAiB;;AAEnB,MAAM,8MAAiB,YAAA,CAAU;IACvC,OAAgB,KAAK,WAAA;IAErB,aAAa,KAAA;IAEJ,UAAU;QAClB,MAAM,WAAW,IAAA,CAAK,MAAA,CAAO,SAAA,CAAU,WAAA,CAAY;YAClD,OAAO;YACP,SAAS;YACT,MAAM;YACN,OAAO,IAAA,CAAK,MAAA,CAAO,OAAA,CAAQ,YAAA;YAC3B,QAAQ;YACR,OAAO;QACR,CAAC;QACD,IAAA,CAAK,UAAA,GAAa,SAAS,EAAA;QAC3B,IAAA,CAAK,mBAAA,CAAoB;IAC1B;IAES,SAAS;QACjB,IAAA,CAAK,MAAA,CAAO,SAAA,CAAU,IAAA,CAAK,IAAA,CAAK,UAAU;IAC3C;IAES,gBAAgB;QACxB,IAAA,CAAK,mBAAA,CAAoB;IAC1B;IAES,cAAc;QACtB,IAAA,CAAK,QAAA,CAAS;IACf;IAEQ,sBAAsB;QAC7B,MAAM,EAAE,CAAA,EAAG,CAAA,CAAE,CAAA,GAAI,IAAA,CAAK,MAAA,CAAO,MAAA,CAAO,gBAAA;QACpC,IAAA,CAAK,MAAA,CAAO,SAAA,CAAU,QAAA,CAAS,IAAA,CAAK,UAAA,EAAY,GAAG,CAAC;IACrD;IAES,WAAW;QACnB,IAAA,CAAK,MAAA,CAAO;IACb;IAES,aAAa;QACrB,IAAA,CAAK,QAAA,CAAS;IACf;IAEQ,WAAW;QAClB,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,MAAM;IAC9B;IAEQ,SAAS;QAChB,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,MAAM;IAC9B;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 603, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/LaserTool/LaserTool.ts"],"sourcesContent":["import { StateNode, TLStateNodeConstructor } from '@tldraw/editor'\nimport { Idle } from './childStates/Idle'\nimport { Lasering } from './childStates/Lasering'\n\n/** @public */\nexport class LaserTool extends StateNode {\n\tstatic override id = 'laser'\n\tstatic override initial = 'idle'\n\tstatic override children(): TLStateNodeConstructor[] {\n\t\treturn [Idle, Lasering]\n\t}\n\tstatic override isLockable = false\n\n\toverride onEnter() {\n\t\tthis.editor.setCursor({ type: 'cross', rotation: 0 })\n\t}\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,iBAAyC;AAClD,SAAS,YAAY;AACrB,SAAS,gBAAgB;;;;AAGlB,MAAM,+MAAkB,YAAA,CAAU;IACxC,OAAgB,KAAK,QAAA;IACrB,OAAgB,UAAU,OAAA;IAC1B,OAAgB,WAAqC;QACpD,OAAO;0MAAC,OAAA;8MAAM,WAAQ;SAAA;IACvB;IACA,OAAgB,aAAa,MAAA;IAEpB,UAAU;QAClB,IAAA,CAAK,MAAA,CAAO,SAAA,CAAU;YAAE,MAAM;YAAS,UAAU;QAAE,CAAC;IACrD;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 638, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/SelectTool/childStates/Brushing.ts"],"sourcesContent":["import {\n\tBox,\n\tMat,\n\tStateNode,\n\tTLCancelEventInfo,\n\tTLFrameShape,\n\tTLGroupShape,\n\tTLKeyboardEventInfo,\n\tTLPageId,\n\tTLPointerEventInfo,\n\tTLShape,\n\tTLShapeId,\n\tTLTickEventInfo,\n\tVec,\n\tpointInPolygon,\n\tpolygonsIntersect,\n\treact,\n} from '@tldraw/editor'\n\nexport class Brushing extends StateNode {\n\tstatic override id = 'brushing'\n\n\tinfo = {} as TLPointerEventInfo & { target: 'canvas' }\n\n\tinitialSelectedShapeIds: TLShapeId[] = []\n\texcludedShapeIds = new Set<TLShapeId>()\n\tisWrapMode = false\n\n\tviewportDidChange = false\n\tcleanupViewportChangeReactor() {\n\t\tvoid null\n\t} // cleanup function for the viewport reactor\n\n\toverride onEnter(info: TLPointerEventInfo & { target: 'canvas' }) {\n\t\tconst { editor } = this\n\t\tconst { altKey } = editor.inputs\n\n\t\tthis.isWrapMode = editor.user.getIsWrapMode()\n\n\t\tthis.viewportDidChange = false\n\n\t\tlet isInitialCheck = true\n\n\t\tthis.cleanupViewportChangeReactor = react('viewport change while brushing', () => {\n\t\t\teditor.getViewportPageBounds() // capture the viewport change\n\t\t\tif (!isInitialCheck && !this.viewportDidChange) {\n\t\t\t\tthis.viewportDidChange = true\n\t\t\t}\n\t\t})\n\n\t\tif (altKey) {\n\t\t\tthis.parent.transition('scribble_brushing', info)\n\t\t\treturn\n\t\t}\n\n\t\tthis.excludedShapeIds = new Set(\n\t\t\teditor\n\t\t\t\t.getCurrentPageShapes()\n\t\t\t\t.filter(\n\t\t\t\t\t(shape) =>\n\t\t\t\t\t\teditor.isShapeOfType<TLGroupShape>(shape, 'group') ||\n\t\t\t\t\t\teditor.isShapeOrAncestorLocked(shape)\n\t\t\t\t)\n\t\t\t\t.map((shape) => shape.id)\n\t\t)\n\n\t\tthis.info = info\n\t\tthis.initialSelectedShapeIds = editor.getSelectedShapeIds().slice()\n\t\tthis.hitTestShapes()\n\t\tisInitialCheck = false\n\t}\n\n\toverride onExit() {\n\t\tthis.initialSelectedShapeIds = []\n\t\tthis.editor.updateInstanceState({ brush: null })\n\n\t\tthis.cleanupViewportChangeReactor()\n\t}\n\n\toverride onTick({ elapsed }: TLTickEventInfo) {\n\t\tconst { editor } = this\n\t\teditor.edgeScrollManager.updateEdgeScrolling(elapsed)\n\t}\n\n\toverride onPointerMove() {\n\t\tthis.hitTestShapes()\n\t}\n\n\toverride onPointerUp() {\n\t\tthis.complete()\n\t}\n\n\toverride onComplete() {\n\t\tthis.complete()\n\t}\n\n\toverride onCancel(info: TLCancelEventInfo) {\n\t\tthis.editor.setSelectedShapes(this.initialSelectedShapeIds)\n\t\tthis.parent.transition('idle', info)\n\t}\n\n\toverride onKeyDown(info: TLKeyboardEventInfo) {\n\t\tif (this.editor.inputs.altKey) {\n\t\t\tthis.parent.transition('scribble_brushing', info)\n\t\t} else {\n\t\t\tthis.hitTestShapes()\n\t\t}\n\t}\n\n\toverride onKeyUp() {\n\t\tthis.hitTestShapes()\n\t}\n\n\tprivate complete() {\n\t\tthis.hitTestShapes()\n\t\tthis.parent.transition('idle')\n\t}\n\n\tprivate hitTestShapes() {\n\t\tconst { editor, excludedShapeIds, isWrapMode } = this\n\t\tconst {\n\t\t\tinputs: { originPagePoint, currentPagePoint, shiftKey, ctrlKey },\n\t\t} = editor\n\n\t\t// We'll be collecting shape ids of selected shapes; if we're holding shift key, we start from our initial shapes\n\t\tconst results = new Set(shiftKey ? this.initialSelectedShapeIds : [])\n\n\t\t// In wrap mode, we need to completely enclose a shape to select it\n\t\tconst isWrapping = isWrapMode ? !ctrlKey : ctrlKey\n\n\t\t// Set the brush to contain the current and origin points\n\t\tconst brush = Box.FromPoints([originPagePoint, currentPagePoint])\n\n\t\t// We'll be testing the corners of the brush against the shapes\n\t\tconst { corners } = brush\n\n\t\tlet A: Vec,\n\t\t\tB: Vec,\n\t\t\tshape: TLShape,\n\t\t\tpageBounds: Box | undefined,\n\t\t\tpageTransform: Mat | undefined,\n\t\t\tlocalCorners: Vec[]\n\n\t\t// Some notes on optimization. We could easily cache all of the shape positions at\n\t\t// the start of the interaction and then do very fast checks against them, but that\n\t\t// would mean changes introduced by other collaborators wouldn't be reflectedâ€”a user\n\t\t// could select a shape by selecting where it _used_ to be.\n\n\t\t// We still want to avoid hit tests as much as possible, however, so we test only the\n\t\t// shapes that are on screen UNLESS: the user has scrolled their viewpor; or the user\n\t\t// is dragging outside of the screen (e.g. in a window). In those cases, we need to\n\t\t// test all shapes.\n\n\t\t// On a page with ~5000 shapes, on-screen hit tests are about 2x faster than\n\t\t// testing all shapes.\n\n\t\tconst brushBoxIsInsideViewport = editor.getViewportPageBounds().contains(brush)\n\t\tconst shapesToHitTest =\n\t\t\tbrushBoxIsInsideViewport && !this.viewportDidChange\n\t\t\t\t? editor.getCurrentPageRenderingShapesSorted()\n\t\t\t\t: editor.getCurrentPageShapesSorted()\n\n\t\tconst currentPageId = editor.getCurrentPageId()\n\n\t\ttestAllShapes: for (let i = 0, n = shapesToHitTest.length; i < n; i++) {\n\t\t\tshape = shapesToHitTest[i]\n\t\t\tif (excludedShapeIds.has(shape.id) || results.has(shape.id)) continue testAllShapes\n\n\t\t\tpageBounds = editor.getShapePageBounds(shape)\n\t\t\tif (!pageBounds) continue testAllShapes\n\n\t\t\t// If the brush fully wraps a shape, it's almost certainly a hit\n\t\t\tif (brush.contains(pageBounds)) {\n\t\t\t\tthis.handleHit(shape, currentPagePoint, currentPageId, results, corners)\n\t\t\t\tcontinue testAllShapes\n\t\t\t}\n\n\t\t\t// If we're in wrap mode and the brush did not fully encloses the shape, it's a miss\n\t\t\t// We also skip frames unless we've completely selected the frame.\n\t\t\tif (isWrapping || editor.isShapeOfType<TLFrameShape>(shape, 'frame')) {\n\t\t\t\tcontinue testAllShapes\n\t\t\t}\n\n\t\t\t// If the brush collides the page bounds, then do hit tests against\n\t\t\t// each of the brush's four sides.\n\t\t\tif (brush.collides(pageBounds)) {\n\t\t\t\t// Shapes expect to hit test line segments in their own coordinate system,\n\t\t\t\t// so we first need to get the brush corners in the shape's local space.\n\t\t\t\tpageTransform = editor.getShapePageTransform(shape)\n\t\t\t\tif (!pageTransform) continue testAllShapes\n\t\t\t\tlocalCorners = pageTransform.clone().invert().applyToPoints(corners)\n\t\t\t\t// See if any of the edges intersect the shape's geometry\n\t\t\t\tconst geometry = editor.getShapeGeometry(shape)\n\t\t\t\thitTestBrushEdges: for (let i = 0; i < 4; i++) {\n\t\t\t\t\tA = localCorners[i]\n\t\t\t\t\tB = localCorners[(i + 1) % 4]\n\t\t\t\t\tif (geometry.hitTestLineSegment(A, B, 0)) {\n\t\t\t\t\t\tthis.handleHit(shape, currentPagePoint, currentPageId, results, corners)\n\t\t\t\t\t\tbreak hitTestBrushEdges\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst currentBrush = editor.getInstanceState().brush\n\t\tif (!currentBrush || !brush.equals(currentBrush)) {\n\t\t\teditor.updateInstanceState({ brush: { ...brush.toJson() } })\n\t\t}\n\n\t\tconst current = editor.getSelectedShapeIds()\n\t\tif (current.length !== results.size || current.some((id) => !results.has(id))) {\n\t\t\teditor.setSelectedShapes(Array.from(results))\n\t\t}\n\t}\n\n\toverride onInterrupt() {\n\t\tthis.editor.updateInstanceState({ brush: null })\n\t}\n\n\tprivate handleHit(\n\t\tshape: TLShape,\n\t\tcurrentPagePoint: Vec,\n\t\tcurrentPageId: TLPageId,\n\t\tresults: Set<TLShapeId>,\n\t\tcorners: Vec[]\n\t) {\n\t\tif (shape.parentId === currentPageId) {\n\t\t\tresults.add(shape.id)\n\t\t\treturn\n\t\t}\n\n\t\t// Find the outermost selectable shape, check to see if it has a\n\t\t// page mask; and if so, check to see if the brush intersects it\n\t\tconst selectedShape = this.editor.getOutermostSelectableShape(shape)\n\t\tconst pageMask = this.editor.getShapeMask(selectedShape.id)\n\t\tif (\n\t\t\tpageMask &&\n\t\t\t!polygonsIntersect(pageMask, corners) &&\n\t\t\t!pointInPolygon(currentPagePoint, pageMask)\n\t\t) {\n\t\t\treturn\n\t\t}\n\t\tresults.add(selectedShape.id)\n\t}\n}\n"],"names":["i"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 797, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/SelectTool/childStates/PointingResizeHandle.ts"],"sourcesContent":["import { StateNode, TLCursorType, TLPointerEventInfo, TLSelectionHandle } from '@tldraw/editor'\n\nexport const CursorTypeMap: Record<TLSelectionHandle, TLCursorType> = {\n\tbottom: 'ns-resize',\n\ttop: 'ns-resize',\n\tleft: 'ew-resize',\n\tright: 'ew-resize',\n\tbottom_left: 'nesw-resize',\n\tbottom_right: 'nwse-resize',\n\ttop_left: 'nwse-resize',\n\ttop_right: 'nesw-resize',\n\tbottom_left_rotate: 'swne-rotate',\n\tbottom_right_rotate: 'senw-rotate',\n\ttop_left_rotate: 'nwse-rotate',\n\ttop_right_rotate: 'nesw-rotate',\n\tmobile_rotate: 'grabbing',\n}\n\ntype PointingResizeHandleInfo = Extract<TLPointerEventInfo, { target: 'selection' }> & {\n\tonInteractionEnd?: string\n}\n\nexport class PointingResizeHandle extends StateNode {\n\tstatic override id = 'pointing_resize_handle'\n\n\tprivate info = {} as PointingResizeHandleInfo\n\n\tprivate updateCursor() {\n\t\tconst selected = this.editor.getSelectedShapes()\n\t\tconst cursorType = CursorTypeMap[this.info.handle!]\n\t\tthis.editor.setCursor({\n\t\t\ttype: cursorType,\n\t\t\trotation: selected.length === 1 ? this.editor.getSelectionRotation() : 0,\n\t\t})\n\t}\n\n\toverride onEnter(info: PointingResizeHandleInfo) {\n\t\tthis.info = info\n\t\tthis.updateCursor()\n\t}\n\n\toverride onPointerMove() {\n\t\tif (this.editor.inputs.isDragging) {\n\t\t\tthis.startResizing()\n\t\t}\n\t}\n\n\toverride onLongPress() {\n\t\tthis.startResizing()\n\t}\n\n\tprivate startResizing() {\n\t\tif (this.editor.getIsReadonly()) return\n\t\tthis.parent.transition('resizing', this.info)\n\t}\n\n\toverride onPointerUp() {\n\t\tthis.complete()\n\t}\n\n\toverride onCancel() {\n\t\tthis.cancel()\n\t}\n\n\toverride onComplete() {\n\t\tthis.cancel()\n\t}\n\n\toverride onInterrupt() {\n\t\tthis.cancel()\n\t}\n\n\tprivate complete() {\n\t\tif (this.info.onInteractionEnd) {\n\t\t\tthis.editor.setCurrentTool(this.info.onInteractionEnd, {})\n\t\t} else {\n\t\t\tthis.parent.transition('idle')\n\t\t}\n\t}\n\n\tprivate cancel() {\n\t\tif (this.info.onInteractionEnd) {\n\t\t\tthis.editor.setCurrentTool(this.info.onInteractionEnd, {})\n\t\t} else {\n\t\t\tthis.parent.transition('idle')\n\t\t}\n\t}\n}\n"],"names":[],"mappings":";;;;;AAAA,SAAS,iBAAsE;;AAExE,MAAM,gBAAyD;IACrE,QAAQ;IACR,KAAK;IACL,MAAM;IACN,OAAO;IACP,aAAa;IACb,cAAc;IACd,UAAU;IACV,WAAW;IACX,oBAAoB;IACpB,qBAAqB;IACrB,iBAAiB;IACjB,kBAAkB;IAClB,eAAe;AAChB;AAMO,MAAM,0NAA6B,YAAA,CAAU;IACnD,OAAgB,KAAK,yBAAA;IAEb,OAAO,CAAC,EAAA;IAER,eAAe;QACtB,MAAM,WAAW,IAAA,CAAK,MAAA,CAAO,iBAAA,CAAkB;QAC/C,MAAM,aAAa,aAAA,CAAc,IAAA,CAAK,IAAA,CAAK,MAAO,CAAA;QAClD,IAAA,CAAK,MAAA,CAAO,SAAA,CAAU;YACrB,MAAM;YACN,UAAU,SAAS,MAAA,KAAW,IAAI,IAAA,CAAK,MAAA,CAAO,oBAAA,CAAqB,IAAI;QACxE,CAAC;IACF;IAES,QAAQ,IAAA,EAAgC;QAChD,IAAA,CAAK,IAAA,GAAO;QACZ,IAAA,CAAK,YAAA,CAAa;IACnB;IAES,gBAAgB;QACxB,IAAI,IAAA,CAAK,MAAA,CAAO,MAAA,CAAO,UAAA,EAAY;YAClC,IAAA,CAAK,aAAA,CAAc;QACpB;IACD;IAES,cAAc;QACtB,IAAA,CAAK,aAAA,CAAc;IACpB;IAEQ,gBAAgB;QACvB,IAAI,IAAA,CAAK,MAAA,CAAO,aAAA,CAAc,EAAG,CAAA;QACjC,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,YAAY,IAAA,CAAK,IAAI;IAC7C;IAES,cAAc;QACtB,IAAA,CAAK,QAAA,CAAS;IACf;IAES,WAAW;QACnB,IAAA,CAAK,MAAA,CAAO;IACb;IAES,aAAa;QACrB,IAAA,CAAK,MAAA,CAAO;IACb;IAES,cAAc;QACtB,IAAA,CAAK,MAAA,CAAO;IACb;IAEQ,WAAW;QAClB,IAAI,IAAA,CAAK,IAAA,CAAK,gBAAA,EAAkB;YAC/B,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,IAAA,CAAK,IAAA,CAAK,gBAAA,EAAkB,CAAC,CAAC;QAC1D,OAAO;YACN,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,MAAM;QAC9B;IACD;IAEQ,SAAS;QAChB,IAAI,IAAA,CAAK,IAAA,CAAK,gBAAA,EAAkB;YAC/B,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,IAAA,CAAK,IAAA,CAAK,gBAAA,EAAkB,CAAC,CAAC;QAC1D,OAAO;YACN,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,MAAM;QAC9B;IACD;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 881, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/SelectTool/childStates/Crop/children/Cropping.ts"],"sourcesContent":["import {\n\tSelectionHandle,\n\tShapeWithCrop,\n\tStateNode,\n\tTLPointerEventInfo,\n\tVec,\n\tkickoutOccludedShapes,\n} from '@tldraw/editor'\nimport { getCropBox, getDefaultCrop, getUncroppedSize } from '../../../../../shapes/shared/crop'\nimport { CursorTypeMap } from '../../PointingResizeHandle'\n\ntype Snapshot = ReturnType<Cropping['createSnapshot']>\n\nexport class Cropping extends StateNode {\n\tstatic override id = 'cropping'\n\n\tinfo = {} as TLPointerEventInfo & {\n\t\ttarget: 'selection'\n\t\thandle: SelectionHandle\n\t\tonInteractionEnd?: string\n\t}\n\n\tmarkId = ''\n\n\tprivate snapshot = {} as any as Snapshot\n\n\toverride onEnter(\n\t\tinfo: TLPointerEventInfo & {\n\t\t\ttarget: 'selection'\n\t\t\thandle: SelectionHandle\n\t\t\tonInteractionEnd?: string\n\t\t}\n\t) {\n\t\tthis.info = info\n\t\tthis.markId = this.editor.markHistoryStoppingPoint('cropping')\n\t\tthis.snapshot = this.createSnapshot()\n\t\tthis.updateShapes()\n\t}\n\n\toverride onPointerMove() {\n\t\tthis.updateShapes()\n\t}\n\n\toverride onKeyDown() {\n\t\tthis.updateShapes()\n\t}\n\n\toverride onKeyUp() {\n\t\tthis.updateShapes()\n\t}\n\n\toverride onPointerUp() {\n\t\tthis.complete()\n\t}\n\n\toverride onComplete() {\n\t\tthis.complete()\n\t}\n\n\toverride onCancel() {\n\t\tthis.cancel()\n\t}\n\n\tprivate updateCursor() {\n\t\tconst selectedShape = this.editor.getSelectedShapes()[0]\n\t\tif (!selectedShape) return\n\n\t\tconst cursorType = CursorTypeMap[this.info.handle!]\n\t\tthis.editor.setCursor({ type: cursorType, rotation: this.editor.getSelectionRotation() })\n\t}\n\n\tprivate updateShapes() {\n\t\tconst { shape, cursorHandleOffset } = this.snapshot\n\n\t\tif (!shape) return\n\t\tconst util = this.editor.getShapeUtil<ShapeWithCrop>(shape.type)\n\t\tif (!util) return\n\n\t\tconst { shiftKey } = this.editor.inputs\n\t\tconst currentPagePoint = this.editor.inputs.currentPagePoint.clone().sub(cursorHandleOffset)\n\t\tconst originPagePoint = this.editor.inputs.originPagePoint.clone().sub(cursorHandleOffset)\n\t\tconst change = currentPagePoint.clone().sub(originPagePoint).rot(-shape.rotation)\n\n\t\tconst crop = shape.props.crop ?? getDefaultCrop()\n\t\tconst uncroppedSize = getUncroppedSize(shape.props, crop)\n\n\t\tconst cropFn = util.onCrop?.bind(util) ?? getCropBox\n\t\tconst partial = cropFn(shape, {\n\t\t\thandle: this.info.handle,\n\t\t\tchange,\n\t\t\tcrop,\n\t\t\tuncroppedSize,\n\t\t\tinitialShape: this.snapshot.shape,\n\t\t\taspectRatioLocked: shiftKey,\n\t\t})\n\t\tif (!partial) return\n\n\t\tthis.editor.updateShapes([\n\t\t\t{\n\t\t\t\tid: shape.id,\n\t\t\t\ttype: shape.type,\n\t\t\t\t...partial,\n\t\t\t},\n\t\t])\n\t\tthis.updateCursor()\n\t}\n\n\tprivate complete() {\n\t\tthis.updateShapes()\n\t\tkickoutOccludedShapes(this.editor, [this.snapshot.shape.id])\n\t\tif (this.info.onInteractionEnd) {\n\t\t\tthis.editor.setCurrentTool(this.info.onInteractionEnd, this.info)\n\t\t} else {\n\t\t\tthis.editor.setCroppingShape(null)\n\t\t\tthis.editor.setCurrentTool('select.idle')\n\t\t}\n\t}\n\n\tprivate cancel() {\n\t\tthis.editor.bailToMark(this.markId)\n\t\tif (this.info.onInteractionEnd) {\n\t\t\tthis.editor.setCurrentTool(this.info.onInteractionEnd, this.info)\n\t\t} else {\n\t\t\tthis.editor.setCroppingShape(null)\n\t\t\tthis.editor.setCurrentTool('select.idle')\n\t\t}\n\t}\n\n\tprivate createSnapshot() {\n\t\tconst selectionRotation = this.editor.getSelectionRotation()\n\t\tconst {\n\t\t\tinputs: { originPagePoint },\n\t\t} = this.editor\n\n\t\tconst shape = this.editor.getOnlySelectedShape() as ShapeWithCrop\n\n\t\tconst selectionBounds = this.editor.getSelectionRotatedPageBounds()!\n\n\t\tconst dragHandlePoint = Vec.RotWith(\n\t\t\tselectionBounds.getHandlePoint(this.info.handle!),\n\t\t\tselectionBounds.point,\n\t\t\tselectionRotation\n\t\t)\n\n\t\tconst cursorHandleOffset = Vec.Sub(originPagePoint, dragHandlePoint)\n\n\t\treturn {\n\t\t\tshape,\n\t\t\tcursorHandleOffset,\n\t\t}\n\t}\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1003, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/selection-logic/getHitShapeOnCanvasPointerDown.ts"],"sourcesContent":["import { Editor, TLShape } from '@tldraw/editor'\n\nexport function getHitShapeOnCanvasPointerDown(\n\teditor: Editor,\n\thitLabels = false\n): TLShape | undefined {\n\tconst zoomLevel = editor.getZoomLevel()\n\tconst {\n\t\tinputs: { currentPagePoint },\n\t} = editor\n\n\treturn (\n\t\t// hovered shape at point\n\t\teditor.getShapeAtPoint(currentPagePoint, {\n\t\t\thitInside: false,\n\t\t\thitLabels,\n\t\t\tmargin: editor.options.hitTestMargin / zoomLevel,\n\t\t\trenderingOnly: true,\n\t\t}) ??\n\t\t// selected shape at point\n\t\teditor.getSelectedShapeAtPoint(currentPagePoint)\n\t)\n}\n"],"names":[],"mappings":";;;AAEO,SAAS,+BACf,MAAA,EACA,YAAY,KAAA,EACU;IACtB,MAAM,YAAY,OAAO,YAAA,CAAa;IACtC,MAAM,EACL,QAAQ,EAAE,gBAAA,CAAiB,CAAA,EAC5B,GAAI;IAEJ,OAE0C,EACxC,KAAA,MAAW,SAAA,CAAA,kBAAA;QACX,WAAA;QACA,QAAQ,OAAO,QAAQ,gBAAgB;QACvC,QAAA,OAAe,OAAA,CAAA,aAAA,GAAA;QACf,eAAA;IAED,MAAA,CAAO,MAAA,kBAAwB,KAAA,CAAA,UAAgB;AAEjD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1024, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/SelectTool/childStates/Crop/children/crop_helpers.ts"],"sourcesContent":["import { Editor, ShapeWithCrop, TLShapePartial, Vec, clamp, structuredClone } from '@tldraw/editor'\nimport { getUncroppedSize } from '../../../../../shapes/shared/crop'\n\nexport function getTranslateCroppedImageChange(editor: Editor, shape: ShapeWithCrop, delta: Vec) {\n\tif (!shape) {\n\t\tthrow Error('Needs to translate a cropped shape!')\n\t}\n\n\tconst { crop: oldCrop } = shape.props\n\tif (!oldCrop) {\n\t\t// can't translate a shape that doesn't have an existing crop\n\t\treturn\n\t}\n\n\tconst flatten: 'x' | 'y' | null = editor.inputs.shiftKey\n\t\t? Math.abs(delta.x) < Math.abs(delta.y)\n\t\t\t? 'x'\n\t\t\t: 'y'\n\t\t: null\n\n\tif (flatten === 'x') {\n\t\tdelta.x = 0\n\t} else if (flatten === 'y') {\n\t\tdelta.y = 0\n\t}\n\n\tdelta.rot(-shape.rotation)\n\n\tconst { w, h } = getUncroppedSize(shape.props, oldCrop)\n\tconst xCropSize = oldCrop.bottomRight.x - oldCrop.topLeft.x\n\tconst yCropSize = oldCrop.bottomRight.y - oldCrop.topLeft.y\n\tconst newCrop = structuredClone(oldCrop)\n\n\tconst xMinWithCrop = 1 - xCropSize\n\tconst yMinWithCrop = 1 - yCropSize\n\tnewCrop.topLeft.x = clamp(newCrop.topLeft.x - delta.x / w, 0, xMinWithCrop)\n\tnewCrop.topLeft.y = clamp(newCrop.topLeft.y - delta.y / h, 0, yMinWithCrop)\n\n\tnewCrop.bottomRight.x = newCrop.topLeft.x + xCropSize\n\tnewCrop.bottomRight.y = newCrop.topLeft.y + yCropSize\n\n\tconst partial: TLShapePartial<typeof shape> = {\n\t\tid: shape.id,\n\t\ttype: shape.type,\n\t\tprops: {\n\t\t\tcrop: newCrop,\n\t\t},\n\t}\n\n\treturn partial\n}\n"],"names":[],"mappings":";;;AAAA,SAAqD,OAAO,uBAAuB;;;AACnF,SAAS,wBAAwB;;;AAE1B,SAAS,+BAA+B,MAAA,EAAgB,KAAA,EAAsB,KAAA,EAAY;IAChG,IAAI,CAAC,OAAO;QACX,MAAM,MAAM,qCAAqC;IAClD;IAEA,MAAM,EAAE,MAAM,OAAA,CAAQ,CAAA,GAAI,MAAM,KAAA;IAChC,IAAI,CAAC,SAAS;QAEb;IACD;IAEA,MAAM,UAA4B,OAAO,MAAA,CAAO,QAAA,GAC7C,KAAK,GAAA,CAAI,MAAM,CAAC,IAAI,KAAK,GAAA,CAAI,MAAM,CAAC,IACnC,MACA,MACD;IAEH,IAAI,YAAY,KAAK;QACpB,MAAM,CAAA,GAAI;IACX,OAAA,IAAW,YAAY,KAAK;QAC3B,MAAM,CAAA,GAAI;IACX;IAEA,MAAM,GAAA,CAAI,CAAC,MAAM,QAAQ;IAEzB,MAAM,EAAE,CAAA,EAAG,CAAA,CAAE,CAAA,oLAAI,mBAAA,EAAiB,MAAM,KAAA,EAAO,OAAO;IACtD,MAAM,YAAY,QAAQ,WAAA,CAAY,CAAA,GAAI,QAAQ,OAAA,CAAQ,CAAA;IAC1D,MAAM,YAAY,QAAQ,WAAA,CAAY,CAAA,GAAI,QAAQ,OAAA,CAAQ,CAAA;IAC1D,MAAM,WAAU,0LAAA,EAAgB,OAAO;IAEvC,MAAM,eAAe,IAAI;IACzB,MAAM,eAAe,IAAI;IACzB,QAAQ,OAAA,CAAQ,CAAA,2LAAI,QAAA,EAAM,QAAQ,OAAA,CAAQ,CAAA,GAAI,MAAM,CAAA,GAAI,GAAG,GAAG,YAAY;IAC1E,QAAQ,OAAA,CAAQ,CAAA,2LAAI,QAAA,EAAM,QAAQ,OAAA,CAAQ,CAAA,GAAI,MAAM,CAAA,GAAI,GAAG,GAAG,YAAY;IAE1E,QAAQ,WAAA,CAAY,CAAA,GAAI,QAAQ,OAAA,CAAQ,CAAA,GAAI;IAC5C,QAAQ,WAAA,CAAY,CAAA,GAAI,QAAQ,OAAA,CAAQ,CAAA,GAAI;IAE5C,MAAM,UAAwC;QAC7C,IAAI,MAAM,EAAA;QACV,MAAM,MAAM,IAAA;QACZ,OAAO;YACN,MAAM;QACP;IACD;IAEA,OAAO;AACR","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1075, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/SelectTool/childStates/Crop/children/Idle.ts"],"sourcesContent":["import {\n\tShapeWithCrop,\n\tStateNode,\n\tTLClickEventInfo,\n\tTLGroupShape,\n\tTLKeyboardEventInfo,\n\tTLPointerEventInfo,\n\tVec,\n} from '@tldraw/editor'\nimport { getHitShapeOnCanvasPointerDown } from '../../../../selection-logic/getHitShapeOnCanvasPointerDown'\nimport { getTranslateCroppedImageChange } from './crop_helpers'\n\nexport class Idle extends StateNode {\n\tstatic override id = 'idle'\n\n\toverride onEnter() {\n\t\tthis.editor.setCursor({ type: 'default', rotation: 0 })\n\n\t\tconst onlySelectedShape = this.editor.getOnlySelectedShape()\n\n\t\tif (onlySelectedShape) {\n\t\t\tthis.editor.setCroppingShape(onlySelectedShape.id)\n\t\t}\n\t}\n\n\toverride onExit() {\n\t\tthis.editor.setCursor({ type: 'default', rotation: 0 })\n\t}\n\n\toverride onCancel() {\n\t\tthis.editor.setCroppingShape(null)\n\t\tthis.editor.setCurrentTool('select.idle', {})\n\t}\n\n\toverride onPointerDown(info: TLPointerEventInfo) {\n\t\tif (info.accelKey) {\n\t\t\tthis.cancel()\n\t\t\t// feed the event back into the statechart\n\t\t\tthis.editor.root.handleEvent(info)\n\t\t\treturn\n\t\t}\n\n\t\tswitch (info.target) {\n\t\t\tcase 'canvas': {\n\t\t\t\tconst hitShape = getHitShapeOnCanvasPointerDown(this.editor)\n\t\t\t\tif (hitShape && !this.editor.isShapeOfType<TLGroupShape>(hitShape, 'group')) {\n\t\t\t\t\tthis.onPointerDown({\n\t\t\t\t\t\t...info,\n\t\t\t\t\t\tshape: hitShape,\n\t\t\t\t\t\ttarget: 'shape',\n\t\t\t\t\t})\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tthis.cancel()\n\t\t\t\t// feed the event back into the statechart\n\t\t\t\tthis.editor.root.handleEvent(info)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'shape': {\n\t\t\t\tif (info.shape.id === this.editor.getCroppingShapeId()) {\n\t\t\t\t\tthis.editor.setCurrentTool('select.crop.pointing_crop', info)\n\t\t\t\t\treturn\n\t\t\t\t} else {\n\t\t\t\t\tif (this.editor.getShapeUtil(info.shape)?.canCrop(info.shape)) {\n\t\t\t\t\t\tthis.editor.setCroppingShape(info.shape.id)\n\t\t\t\t\t\tthis.editor.setSelectedShapes([info.shape.id])\n\t\t\t\t\t\tthis.editor.setCurrentTool('select.crop.pointing_crop', info)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.cancel()\n\t\t\t\t\t\t// feed the event back into the statechart\n\t\t\t\t\t\tthis.editor.root.handleEvent(info)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'selection': {\n\t\t\t\tswitch (info.handle) {\n\t\t\t\t\tcase 'mobile_rotate':\n\t\t\t\t\tcase 'top_left_rotate':\n\t\t\t\t\tcase 'top_right_rotate':\n\t\t\t\t\tcase 'bottom_left_rotate':\n\t\t\t\t\tcase 'bottom_right_rotate': {\n\t\t\t\t\t\tthis.editor.setCurrentTool('select.pointing_rotate_handle', {\n\t\t\t\t\t\t\t...info,\n\t\t\t\t\t\t\tonInteractionEnd: 'select.crop.idle',\n\t\t\t\t\t\t})\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tcase 'top':\n\t\t\t\t\tcase 'right':\n\t\t\t\t\tcase 'bottom':\n\t\t\t\t\tcase 'left':\n\t\t\t\t\tcase 'top_left':\n\t\t\t\t\tcase 'top_right':\n\t\t\t\t\tcase 'bottom_left':\n\t\t\t\t\tcase 'bottom_right': {\n\t\t\t\t\t\tthis.editor.setCurrentTool('select.crop.pointing_crop_handle', {\n\t\t\t\t\t\t\t...info,\n\t\t\t\t\t\t\tonInteractionEnd: 'select.crop.idle',\n\t\t\t\t\t\t})\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tthis.cancel()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\toverride onDoubleClick(info: TLClickEventInfo) {\n\t\t// Without this, the double click's \"settle\" would trigger the reset\n\t\t// after the user double clicked the edge to begin cropping\n\t\tif (this.editor.inputs.shiftKey || info.phase !== 'up') return\n\n\t\tconst croppingShapeId = this.editor.getCroppingShapeId()\n\t\tif (!croppingShapeId) return\n\t\tconst shape = this.editor.getShape(croppingShapeId)\n\t\tif (!shape) return\n\n\t\tconst util = this.editor.getShapeUtil(shape)\n\t\tif (!util) return\n\n\t\tif (info.target === 'selection') {\n\t\t\tutil.onDoubleClickEdge?.(shape, info)\n\t\t\treturn\n\t\t}\n\n\t\t// If the user double clicks the canvas, we want to cancel cropping,\n\t\t// especially if it's an animated image, we want the image to continue playing.\n\t\tthis.cancel()\n\t\tthis.editor.root.handleEvent(info)\n\t}\n\n\toverride onKeyDown() {\n\t\tthis.nudgeCroppingImage(false)\n\t}\n\n\toverride onKeyRepeat() {\n\t\tthis.nudgeCroppingImage(true)\n\t}\n\n\toverride onKeyUp(info: TLKeyboardEventInfo) {\n\t\tswitch (info.code) {\n\t\t\tcase 'Enter': {\n\t\t\t\tthis.editor.setCroppingShape(null)\n\t\t\t\tthis.editor.setCurrentTool('select.idle', {})\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate cancel() {\n\t\tthis.editor.setCroppingShape(null)\n\t\tthis.editor.setCurrentTool('select.idle', {})\n\t}\n\n\tprivate nudgeCroppingImage(ephemeral = false) {\n\t\tconst {\n\t\t\teditor: {\n\t\t\t\tinputs: { keys },\n\t\t\t},\n\t\t} = this\n\n\t\t// We want to use the \"actual\" shift key state,\n\t\t// not the one that's in the editor.inputs.shiftKey,\n\t\t// because that one uses a short timeout on release\n\t\tconst shiftKey = keys.has('ShiftLeft')\n\n\t\tconst delta = new Vec(0, 0)\n\n\t\tif (keys.has('ArrowLeft')) delta.x += 1\n\t\tif (keys.has('ArrowRight')) delta.x -= 1\n\t\tif (keys.has('ArrowUp')) delta.y += 1\n\t\tif (keys.has('ArrowDown')) delta.y -= 1\n\n\t\tif (delta.equals(new Vec(0, 0))) return\n\n\t\tif (shiftKey) delta.mul(10)\n\n\t\tconst shape = this.editor.getShape(this.editor.getCroppingShapeId()!) as ShapeWithCrop\n\t\tif (!shape) return\n\t\tconst partial = getTranslateCroppedImageChange(this.editor, shape, delta)\n\n\t\tif (partial) {\n\t\t\tif (!ephemeral) {\n\t\t\t\t// We don't want to create new marks if the user\n\t\t\t\t// is just holding down the arrow keys\n\t\t\t\tthis.editor.markHistoryStoppingPoint('translate crop')\n\t\t\t}\n\n\t\t\tthis.editor.updateShapes<ShapeWithCrop>([partial])\n\t\t}\n\t}\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1254, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/SelectTool/childStates/Crop/children/PointingCrop.ts"],"sourcesContent":["import { StateNode, TLPointerEventInfo } from '@tldraw/editor'\n\nexport class PointingCrop extends StateNode {\n\tstatic override id = 'pointing_crop'\n\n\toverride onCancel() {\n\t\tthis.editor.setCurrentTool('select.crop.idle', {})\n\t}\n\n\toverride onPointerMove(info: TLPointerEventInfo) {\n\t\tif (this.editor.inputs.isDragging) {\n\t\t\tthis.startDragging(info)\n\t\t}\n\t}\n\toverride onLongPress(info: TLPointerEventInfo) {\n\t\tthis.startDragging(info)\n\t}\n\n\toverride onPointerUp(info: TLPointerEventInfo) {\n\t\tthis.editor.setCurrentTool('select.crop.idle', info)\n\t}\n\n\tstartDragging(info: TLPointerEventInfo) {\n\t\tthis.editor.setCurrentTool('select.crop.translating_crop', info)\n\t}\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,iBAAqC;;AAEvC,MAAM,kNAAqB,YAAA,CAAU;IAC3C,OAAgB,KAAK,gBAAA;IAEZ,WAAW;QACnB,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,oBAAoB,CAAC,CAAC;IAClD;IAES,cAAc,IAAA,EAA0B;QAChD,IAAI,IAAA,CAAK,MAAA,CAAO,MAAA,CAAO,UAAA,EAAY;YAClC,IAAA,CAAK,aAAA,CAAc,IAAI;QACxB;IACD;IACS,YAAY,IAAA,EAA0B;QAC9C,IAAA,CAAK,aAAA,CAAc,IAAI;IACxB;IAES,YAAY,IAAA,EAA0B;QAC9C,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,oBAAoB,IAAI;IACpD;IAEA,cAAc,IAAA,EAA0B;QACvC,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,gCAAgC,IAAI;IAChE;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1288, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/SelectTool/childStates/Crop/children/PointingCropHandle.ts"],"sourcesContent":["import { StateNode, TLPointerEventInfo } from '@tldraw/editor'\nimport { CursorTypeMap } from '../../PointingResizeHandle'\n\ntype TLPointingCropHandleInfo = TLPointerEventInfo & {\n\ttarget: 'selection'\n} & {\n\tonInteractionEnd?: string\n}\n\nexport class PointingCropHandle extends StateNode {\n\tstatic override id = 'pointing_crop_handle'\n\n\tprivate info = {} as TLPointingCropHandleInfo\n\n\toverride onEnter(info: TLPointingCropHandleInfo) {\n\t\tthis.info = info\n\t\tthis.parent.setCurrentToolIdMask(info.onInteractionEnd)\n\t\tconst selectedShape = this.editor.getSelectedShapes()[0]\n\t\tif (!selectedShape) return\n\n\t\tconst cursorType = CursorTypeMap[this.info.handle!]\n\t\tthis.editor.setCursor({ type: cursorType, rotation: this.editor.getSelectionRotation() })\n\t\tthis.editor.setCroppingShape(selectedShape.id)\n\t}\n\n\toverride onExit() {\n\t\tthis.editor.setCursor({ type: 'default', rotation: 0 })\n\t\tthis.parent.setCurrentToolIdMask(undefined)\n\t}\n\n\toverride onPointerMove() {\n\t\tif (this.editor.inputs.isDragging) {\n\t\t\tthis.startCropping()\n\t\t}\n\t}\n\n\toverride onLongPress() {\n\t\tthis.startCropping()\n\t}\n\n\tprivate startCropping() {\n\t\tif (this.editor.getIsReadonly()) return\n\t\tthis.parent.transition('cropping', {\n\t\t\t...this.info,\n\t\t\tonInteractionEnd: this.info.onInteractionEnd,\n\t\t})\n\t}\n\n\toverride onPointerUp() {\n\t\tif (this.info.onInteractionEnd) {\n\t\t\tthis.editor.setCurrentTool(this.info.onInteractionEnd, this.info)\n\t\t} else {\n\t\t\tthis.editor.setCroppingShape(null)\n\t\t\tthis.editor.setCurrentTool('select.idle')\n\t\t}\n\t}\n\n\toverride onCancel() {\n\t\tthis.cancel()\n\t}\n\n\toverride onComplete() {\n\t\tthis.cancel()\n\t}\n\n\toverride onInterrupt() {\n\t\tthis.cancel()\n\t}\n\n\tprivate cancel() {\n\t\tif (this.info.onInteractionEnd) {\n\t\t\tthis.editor.setCurrentTool(this.info.onInteractionEnd, this.info)\n\t\t} else {\n\t\t\tthis.editor.setCroppingShape(null)\n\t\t\tthis.editor.setCurrentTool('select.idle')\n\t\t}\n\t}\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,iBAAqC;AAC9C,SAAS,qBAAqB;;;AAQvB,MAAM,wNAA2B,YAAA,CAAU;IACjD,OAAgB,KAAK,uBAAA;IAEb,OAAO,CAAC,EAAA;IAEP,QAAQ,IAAA,EAAgC;QAChD,IAAA,CAAK,IAAA,GAAO;QACZ,IAAA,CAAK,MAAA,CAAO,oBAAA,CAAqB,KAAK,gBAAgB;QACtD,MAAM,gBAAgB,IAAA,CAAK,MAAA,CAAO,iBAAA,CAAkB,CAAA,CAAE,CAAC,CAAA;QACvD,IAAI,CAAC,cAAe,CAAA;QAEpB,MAAM,4NAAa,gBAAA,CAAc,IAAA,CAAK,IAAA,CAAK,MAAO,CAAA;QAClD,IAAA,CAAK,MAAA,CAAO,SAAA,CAAU;YAAE,MAAM;YAAY,UAAU,IAAA,CAAK,MAAA,CAAO,oBAAA,CAAqB;QAAE,CAAC;QACxF,IAAA,CAAK,MAAA,CAAO,gBAAA,CAAiB,cAAc,EAAE;IAC9C;IAES,SAAS;QACjB,IAAA,CAAK,MAAA,CAAO,SAAA,CAAU;YAAE,MAAM;YAAW,UAAU;QAAE,CAAC;QACtD,IAAA,CAAK,MAAA,CAAO,oBAAA,CAAqB,KAAA,CAAS;IAC3C;IAES,gBAAgB;QACxB,IAAI,IAAA,CAAK,MAAA,CAAO,MAAA,CAAO,UAAA,EAAY;YAClC,IAAA,CAAK,aAAA,CAAc;QACpB;IACD;IAES,cAAc;QACtB,IAAA,CAAK,aAAA,CAAc;IACpB;IAEQ,gBAAgB;QACvB,IAAI,IAAA,CAAK,MAAA,CAAO,aAAA,CAAc,EAAG,CAAA;QACjC,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,YAAY;YAClC,GAAG,IAAA,CAAK,IAAA;YACR,kBAAkB,IAAA,CAAK,IAAA,CAAK,gBAAA;QAC7B,CAAC;IACF;IAES,cAAc;QACtB,IAAI,IAAA,CAAK,IAAA,CAAK,gBAAA,EAAkB;YAC/B,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,IAAA,CAAK,IAAA,CAAK,gBAAA,EAAkB,IAAA,CAAK,IAAI;QACjE,OAAO;YACN,IAAA,CAAK,MAAA,CAAO,gBAAA,CAAiB,IAAI;YACjC,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,aAAa;QACzC;IACD;IAES,WAAW;QACnB,IAAA,CAAK,MAAA,CAAO;IACb;IAES,aAAa;QACrB,IAAA,CAAK,MAAA,CAAO;IACb;IAES,cAAc;QACtB,IAAA,CAAK,MAAA,CAAO;IACb;IAEQ,SAAS;QAChB,IAAI,IAAA,CAAK,IAAA,CAAK,gBAAA,EAAkB;YAC/B,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,IAAA,CAAK,IAAA,CAAK,gBAAA,EAAkB,IAAA,CAAK,IAAI;QACjE,OAAO;YACN,IAAA,CAAK,MAAA,CAAO,gBAAA,CAAiB,IAAI;YACjC,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,aAAa;QACzC;IACD;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1367, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/SelectTool/childStates/Crop/children/TranslatingCrop.ts"],"sourcesContent":["import { ShapeWithCrop, StateNode, TLKeyboardEventInfo, TLPointerEventInfo } from '@tldraw/editor'\nimport { getTranslateCroppedImageChange } from './crop_helpers'\n\ntype Snapshot = ReturnType<TranslatingCrop['createSnapshot']>\n\nexport class TranslatingCrop extends StateNode {\n\tstatic override id = 'translating_crop'\n\n\tinfo = {} as TLPointerEventInfo & {\n\t\ttarget: 'shape'\n\t\tisCreating?: boolean\n\t\tonInteractionEnd?: string\n\t}\n\n\tmarkId = ''\n\n\tprivate snapshot = {} as any as Snapshot\n\n\toverride onEnter(\n\t\tinfo: TLPointerEventInfo & {\n\t\t\ttarget: 'shape'\n\t\t\tisCreating?: boolean\n\t\t\tonInteractionEnd?: string\n\t\t}\n\t) {\n\t\tthis.info = info\n\t\tthis.snapshot = this.createSnapshot()\n\n\t\tthis.markId = this.editor.markHistoryStoppingPoint('translating_crop')\n\t\tthis.editor.setCursor({ type: 'move', rotation: 0 })\n\t\tthis.updateShapes()\n\t}\n\n\toverride onExit() {\n\t\tthis.editor.setCursor({ type: 'default', rotation: 0 })\n\t}\n\n\toverride onPointerMove() {\n\t\tthis.updateShapes()\n\t}\n\n\toverride onPointerUp() {\n\t\tthis.complete()\n\t}\n\n\toverride onComplete() {\n\t\tthis.complete()\n\t}\n\n\toverride onCancel() {\n\t\tthis.cancel()\n\t}\n\n\toverride onKeyDown(info: TLKeyboardEventInfo) {\n\t\tswitch (info.key) {\n\t\t\tcase 'Alt':\n\t\t\tcase 'Shift': {\n\t\t\t\tthis.updateShapes()\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\n\toverride onKeyUp(info: TLKeyboardEventInfo) {\n\t\tswitch (info.key) {\n\t\t\tcase 'Enter': {\n\t\t\t\tthis.complete()\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcase 'Alt':\n\t\t\tcase 'Shift': {\n\t\t\t\tthis.updateShapes()\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected complete() {\n\t\tthis.updateShapes()\n\t\tthis.editor.setCurrentTool('select.crop.idle', this.info)\n\t}\n\n\tprivate cancel() {\n\t\tthis.editor.bailToMark(this.markId)\n\t\tthis.editor.setCurrentTool('select.crop.idle', this.info)\n\t}\n\n\tprivate createSnapshot() {\n\t\tconst shape = this.editor.getOnlySelectedShape() as ShapeWithCrop\n\t\treturn { shape }\n\t}\n\n\tprotected updateShapes() {\n\t\tconst shape = this.snapshot.shape as ShapeWithCrop\n\n\t\tif (!shape) return\n\n\t\tconst { originPagePoint, currentPagePoint } = this.editor.inputs\n\t\tconst delta = currentPagePoint.clone().sub(originPagePoint)\n\t\tconst partial = getTranslateCroppedImageChange(this.editor, shape, delta)\n\n\t\tif (partial) {\n\t\t\tthis.editor.updateShapes([partial])\n\t\t}\n\t}\n}\n"],"names":[],"mappings":";;;AAAA,SAAwB,iBAA0D;;AAClF,SAAS,sCAAsC;;;AAIxC,MAAM,qNAAwB,YAAA,CAAU;IAC9C,OAAgB,KAAK,mBAAA;IAErB,OAAO,CAAC,EAAA;IAMR,SAAS,GAAA;IAED,WAAW,CAAC,EAAA;IAEX,QACR,IAAA,EAKC;QACD,IAAA,CAAK,IAAA,GAAO;QACZ,IAAA,CAAK,QAAA,GAAW,IAAA,CAAK,cAAA,CAAe;QAEpC,IAAA,CAAK,MAAA,GAAS,IAAA,CAAK,MAAA,CAAO,wBAAA,CAAyB,kBAAkB;QACrE,IAAA,CAAK,MAAA,CAAO,SAAA,CAAU;YAAE,MAAM;YAAQ,UAAU;QAAE,CAAC;QACnD,IAAA,CAAK,YAAA,CAAa;IACnB;IAES,SAAS;QACjB,IAAA,CAAK,MAAA,CAAO,SAAA,CAAU;YAAE,MAAM;YAAW,UAAU;QAAE,CAAC;IACvD;IAES,gBAAgB;QACxB,IAAA,CAAK,YAAA,CAAa;IACnB;IAES,cAAc;QACtB,IAAA,CAAK,QAAA,CAAS;IACf;IAES,aAAa;QACrB,IAAA,CAAK,QAAA,CAAS;IACf;IAES,WAAW;QACnB,IAAA,CAAK,MAAA,CAAO;IACb;IAES,UAAU,IAAA,EAA2B;QAC7C,OAAQ,KAAK,GAAA,EAAK;YACjB,KAAK;YACL,KAAK;gBAAS;oBACb,IAAA,CAAK,YAAA,CAAa;oBAClB;gBACD;QACD;IACD;IAES,QAAQ,IAAA,EAA2B;QAC3C,OAAQ,KAAK,GAAA,EAAK;YACjB,KAAK;gBAAS;oBACb,IAAA,CAAK,QAAA,CAAS;oBACd;gBACD;YACA,KAAK;YACL,KAAK;gBAAS;oBACb,IAAA,CAAK,YAAA,CAAa;gBACnB;QACD;IACD;IAEU,WAAW;QACpB,IAAA,CAAK,YAAA,CAAa;QAClB,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,oBAAoB,IAAA,CAAK,IAAI;IACzD;IAEQ,SAAS;QAChB,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,IAAA,CAAK,MAAM;QAClC,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,oBAAoB,IAAA,CAAK,IAAI;IACzD;IAEQ,iBAAiB;QACxB,MAAM,QAAQ,IAAA,CAAK,MAAA,CAAO,oBAAA,CAAqB;QAC/C,OAAO;YAAE;QAAM;IAChB;IAEU,eAAe;QACxB,MAAM,QAAQ,IAAA,CAAK,QAAA,CAAS,KAAA;QAE5B,IAAI,CAAC,MAAO,CAAA;QAEZ,MAAM,EAAE,eAAA,EAAiB,gBAAA,CAAiB,CAAA,GAAI,IAAA,CAAK,MAAA,CAAO,MAAA;QAC1D,MAAM,QAAQ,iBAAiB,KAAA,CAAM,EAAE,GAAA,CAAI,eAAe;QAC1D,MAAM,yOAAU,iCAAA,EAA+B,IAAA,CAAK,MAAA,EAAQ,OAAO,KAAK;QAExE,IAAI,SAAS;YACZ,IAAA,CAAK,MAAA,CAAO,YAAA,CAAa;gBAAC,OAAO;aAAC;QACnC;IACD;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1467, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/SelectTool/childStates/Crop/Crop.ts"],"sourcesContent":["import { StateNode, TLStateNodeConstructor } from '@tldraw/editor'\nimport { Cropping } from './children/Cropping'\nimport { Idle } from './children/Idle'\nimport { PointingCrop } from './children/PointingCrop'\nimport { PointingCropHandle } from './children/PointingCropHandle'\nimport { TranslatingCrop } from './children/TranslatingCrop'\n\nexport class Crop extends StateNode {\n\tstatic override id = 'crop'\n\tstatic override initial = 'idle'\n\tstatic override children(): TLStateNodeConstructor[] {\n\t\treturn [Idle, TranslatingCrop, PointingCrop, PointingCropHandle, Cropping]\n\t}\n\n\tmarkId = ''\n\n\toverride onEnter() {\n\t\tthis.didExit = false\n\t\tthis.markId = this.editor.markHistoryStoppingPoint('crop')\n\t}\n\tdidExit = false\n\toverride onExit() {\n\t\tif (!this.didExit) {\n\t\t\tthis.didExit = true\n\t\t\tthis.editor.squashToMark(this.markId)\n\t\t}\n\t}\n\toverride onCancel() {\n\t\tif (!this.didExit) {\n\t\t\tthis.didExit = true\n\t\t\tthis.editor.bailToMark(this.markId)\n\t\t}\n\t}\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,iBAAyC;AAClD,SAAS,gBAAgB;AACzB,SAAS,YAAY;AACrB,SAAS,oBAAoB;AAC7B,SAAS,0BAA0B;AACnC,SAAS,uBAAuB;;;;;;;AAEzB,MAAM,0MAAa,YAAA,CAAU;IACnC,OAAgB,KAAK,OAAA;IACrB,OAAgB,UAAU,OAAA;IAC1B,OAAgB,WAAqC;QACpD,OAAO;+NAAC,OAAA;0OAAM,kBAAA;uOAAiB,eAAA;6OAAc,qBAAA;mOAAoB,WAAQ;SAAA;IAC1E;IAEA,SAAS,GAAA;IAEA,UAAU;QAClB,IAAA,CAAK,OAAA,GAAU;QACf,IAAA,CAAK,MAAA,GAAS,IAAA,CAAK,MAAA,CAAO,wBAAA,CAAyB,MAAM;IAC1D;IACA,UAAU,MAAA;IACD,SAAS;QACjB,IAAI,CAAC,IAAA,CAAK,OAAA,EAAS;YAClB,IAAA,CAAK,OAAA,GAAU;YACf,IAAA,CAAK,MAAA,CAAO,YAAA,CAAa,IAAA,CAAK,MAAM;QACrC;IACD;IACS,WAAW;QACnB,IAAI,CAAC,IAAA,CAAK,OAAA,EAAS;YAClB,IAAA,CAAK,OAAA,GAAU;YACf,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,IAAA,CAAK,MAAM;QACnC;IACD;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1522, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/SelectTool/childStates/DraggingHandle.tsx"],"sourcesContent":["import {\n\tMat,\n\tStateNode,\n\tTLArrowShape,\n\tTLHandle,\n\tTLLineShape,\n\tTLPointerEventInfo,\n\tTLShapeId,\n\tTLShapePartial,\n\tVec,\n\tkickoutOccludedShapes,\n\tsnapAngle,\n\tsortByIndex,\n\tstructuredClone,\n} from '@tldraw/editor'\nimport { clearArrowTargetState } from '../../../shapes/arrow/arrowTargetState'\nimport { getArrowBindings } from '../../../shapes/arrow/shared'\n\nexport type DraggingHandleInfo = TLPointerEventInfo & {\n\tshape: TLArrowShape | TLLineShape\n\ttarget: 'handle'\n\tonInteractionEnd?: string\n\tisCreating?: boolean\n\tcreatingMarkId?: string\n}\n\nexport class DraggingHandle extends StateNode {\n\tstatic override id = 'dragging_handle'\n\n\tshapeId!: TLShapeId\n\tinitialHandle!: TLHandle\n\tinitialAdjacentHandle!: TLHandle | null\n\tinitialPagePoint!: Vec\n\n\tmarkId!: string\n\tinitialPageTransform!: Mat\n\tinitialPageRotation!: number\n\n\tinfo!: DraggingHandleInfo\n\n\tisPrecise = false\n\tisPreciseId: TLShapeId | null = null\n\tpointingId: TLShapeId | null = null\n\n\toverride onEnter(info: DraggingHandleInfo) {\n\t\tconst { shape, isCreating, creatingMarkId, handle } = info\n\t\tthis.info = info\n\t\tthis.parent.setCurrentToolIdMask(info.onInteractionEnd)\n\t\tthis.shapeId = shape.id\n\t\tthis.markId = ''\n\n\t\tif (isCreating) {\n\t\t\tif (creatingMarkId) {\n\t\t\t\tthis.markId = creatingMarkId\n\t\t\t} else {\n\t\t\t\t// handle legacy implicit `creating:{shapeId}` marks\n\t\t\t\tconst markId = this.editor.getMarkIdMatching(\n\t\t\t\t\t`creating:${this.editor.getOnlySelectedShapeId()}`\n\t\t\t\t)\n\t\t\t\tif (markId) {\n\t\t\t\t\tthis.markId = markId\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthis.markId = this.editor.markHistoryStoppingPoint('dragging handle')\n\t\t}\n\n\t\tthis.initialHandle = structuredClone(handle)\n\n\t\tthis.initialPageTransform = this.editor.getShapePageTransform(shape)!\n\t\tthis.initialPageRotation = this.initialPageTransform.rotation()\n\t\tthis.initialPagePoint = this.editor.inputs.originPagePoint.clone()\n\n\t\tthis.editor.setCursor({ type: isCreating ? 'cross' : 'grabbing', rotation: 0 })\n\n\t\tconst handles = this.editor.getShapeHandles(shape)!.sort(sortByIndex)\n\t\tconst index = handles.findIndex((h) => h.id === info.handle.id)\n\n\t\t// Find the adjacent handle\n\t\tthis.initialAdjacentHandle = null\n\n\t\t// Start from the handle and work forward\n\t\tfor (let i = index + 1; i < handles.length; i++) {\n\t\t\tconst handle = handles[i]\n\t\t\tif (handle.type === 'vertex' && handle.id !== 'middle' && handle.id !== info.handle.id) {\n\t\t\t\tthis.initialAdjacentHandle = handle\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// If still no handle, start from the end and work backward\n\t\tif (!this.initialAdjacentHandle) {\n\t\t\tfor (let i = handles.length - 1; i >= 0; i--) {\n\t\t\t\tconst handle = handles[i]\n\t\t\t\tif (handle.type === 'vertex' && handle.id !== 'middle' && handle.id !== info.handle.id) {\n\t\t\t\t\tthis.initialAdjacentHandle = handle\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// <!-- Only relevant to arrows\n\t\tif (this.editor.isShapeOfType<TLArrowShape>(shape, 'arrow')) {\n\t\t\tconst initialBinding = getArrowBindings(this.editor, shape)[info.handle.id as 'start' | 'end']\n\n\t\t\tthis.isPrecise = false\n\n\t\t\tif (initialBinding) {\n\t\t\t\tthis.isPrecise = initialBinding.props.isPrecise\n\t\t\t\tif (this.isPrecise) {\n\t\t\t\t\tthis.isPreciseId = initialBinding.toId\n\t\t\t\t} else {\n\t\t\t\t\tthis.resetExactTimeout()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// -->\n\n\t\t// Call onHandleDragStart callback\n\t\tconst handleDragInfo = {\n\t\t\thandle: this.initialHandle,\n\t\t\tisPrecise: this.isPrecise,\n\t\t\tinitial: shape,\n\t\t}\n\t\tconst util = this.editor.getShapeUtil(shape)\n\t\tconst startChanges = util.onHandleDragStart?.(shape, handleDragInfo)\n\t\tif (startChanges) {\n\t\t\tthis.editor.updateShapes([{ ...startChanges, id: shape.id, type: shape.type }])\n\t\t}\n\n\t\tthis.update()\n\n\t\tthis.editor.select(this.shapeId)\n\t}\n\n\t// Only relevant to arrows\n\tprivate exactTimeout = -1 as any\n\n\t// Only relevant to arrows\n\tprivate resetExactTimeout() {\n\t\tif (this.exactTimeout !== -1) {\n\t\t\tthis.clearExactTimeout()\n\t\t}\n\n\t\tthis.exactTimeout = this.editor.timers.setTimeout(() => {\n\t\t\tif (this.getIsActive() && !this.isPrecise) {\n\t\t\t\tthis.isPrecise = true\n\t\t\t\tthis.isPreciseId = this.pointingId\n\t\t\t\tthis.update()\n\t\t\t}\n\t\t\tthis.exactTimeout = -1\n\t\t}, 750)\n\t}\n\n\t// Only relevant to arrows\n\tprivate clearExactTimeout() {\n\t\tif (this.exactTimeout !== -1) {\n\t\t\tclearTimeout(this.exactTimeout)\n\t\t\tthis.exactTimeout = -1\n\t\t}\n\t}\n\n\toverride onPointerMove() {\n\t\tthis.update()\n\t}\n\n\toverride onKeyDown() {\n\t\tthis.update()\n\t}\n\n\toverride onKeyUp() {\n\t\tthis.update()\n\t}\n\n\toverride onPointerUp() {\n\t\tthis.complete()\n\t}\n\n\toverride onComplete() {\n\t\tthis.update()\n\t\tthis.complete()\n\t}\n\n\toverride onCancel() {\n\t\tthis.cancel()\n\t}\n\n\toverride onExit() {\n\t\tthis.parent.setCurrentToolIdMask(undefined)\n\t\tclearArrowTargetState(this.editor)\n\t\tthis.editor.snaps.clearIndicators()\n\n\t\tthis.editor.setCursor({ type: 'default', rotation: 0 })\n\t}\n\n\tprivate complete() {\n\t\tthis.editor.snaps.clearIndicators()\n\t\tkickoutOccludedShapes(this.editor, [this.shapeId])\n\n\t\t// Call onHandleDragEnd callback before state transitions\n\t\tconst shape = this.editor.getShape(this.shapeId)\n\t\tif (shape) {\n\t\t\tconst util = this.editor.getShapeUtil(shape)\n\t\t\tconst handleDragInfo = {\n\t\t\t\thandle: this.initialHandle,\n\t\t\t\tisPrecise: this.isPrecise,\n\t\t\t\tinitial: this.info.shape,\n\t\t\t}\n\t\t\tconst endChanges = util.onHandleDragEnd?.(shape, handleDragInfo)\n\t\t\tif (endChanges) {\n\t\t\t\tthis.editor.updateShapes([{ ...endChanges, id: shape.id, type: shape.type }])\n\t\t\t}\n\t\t}\n\n\t\tconst { onInteractionEnd } = this.info\n\t\tif (this.editor.getInstanceState().isToolLocked && onInteractionEnd) {\n\t\t\t// Return to the tool that was active before this one,\n\t\t\t// but only if tool lock is turned on!\n\t\t\tthis.editor.setCurrentTool(onInteractionEnd, { shapeId: this.shapeId })\n\t\t\treturn\n\t\t}\n\n\t\tthis.parent.transition('idle')\n\t}\n\n\tprivate cancel() {\n\t\t// Call onHandleDragCancel callback before bailing to mark\n\t\tconst shape = this.editor.getShape(this.shapeId)\n\t\tif (shape) {\n\t\t\tconst util = this.editor.getShapeUtil(shape)\n\t\t\tconst handleDragInfo = {\n\t\t\t\thandle: this.initialHandle,\n\t\t\t\tisPrecise: this.isPrecise,\n\t\t\t\tinitial: this.info.shape,\n\t\t\t}\n\t\t\tutil.onHandleDragCancel?.(shape, handleDragInfo)\n\t\t}\n\n\t\tthis.editor.bailToMark(this.markId)\n\t\tthis.editor.snaps.clearIndicators()\n\n\t\tconst { onInteractionEnd } = this.info\n\t\tif (onInteractionEnd) {\n\t\t\t// Return to the tool that was active before this one,\n\t\t\t// whether tool lock is turned on or not!\n\t\t\tthis.editor.setCurrentTool(onInteractionEnd, { shapeId: this.shapeId })\n\t\t\treturn\n\t\t}\n\n\t\tthis.parent.transition('idle')\n\t}\n\n\tprivate update() {\n\t\tconst { editor, shapeId, initialPagePoint } = this\n\t\tconst { initialHandle, initialPageRotation, initialAdjacentHandle } = this\n\t\tconst isSnapMode = this.editor.user.getIsSnapMode()\n\t\tconst {\n\t\t\tsnaps,\n\t\t\tinputs: { currentPagePoint, shiftKey, ctrlKey, altKey, pointerVelocity },\n\t\t} = editor\n\n\t\tconst initial = this.info.shape\n\n\t\tconst shape = editor.getShape(shapeId)\n\t\tif (!shape) return\n\t\tconst util = editor.getShapeUtil(shape)\n\n\t\tconst initialBinding = editor.isShapeOfType<TLArrowShape>(shape, 'arrow')\n\t\t\t? getArrowBindings(editor, shape)[initialHandle.id as 'start' | 'end']\n\t\t\t: undefined\n\n\t\tlet point = currentPagePoint\n\t\t\t.clone()\n\t\t\t.sub(initialPagePoint)\n\t\t\t.rot(-initialPageRotation)\n\t\t\t.add(initialHandle)\n\n\t\tif (shiftKey && initialAdjacentHandle && initialHandle.id !== 'middle') {\n\t\t\tconst angle = Vec.Angle(initialAdjacentHandle, point)\n\t\t\tconst snappedAngle = snapAngle(angle, 24)\n\t\t\tconst angleDifference = snappedAngle - angle\n\t\t\tpoint = Vec.RotWith(point, initialAdjacentHandle, angleDifference)\n\t\t}\n\n\t\t// Clear any existing snaps\n\t\teditor.snaps.clearIndicators()\n\n\t\tlet nextHandle = { ...initialHandle, x: point.x, y: point.y }\n\n\t\tif (initialHandle.canSnap && (isSnapMode ? !ctrlKey : ctrlKey)) {\n\t\t\t// We're snapping\n\t\t\tconst pageTransform = editor.getShapePageTransform(shape.id)\n\t\t\tif (!pageTransform) throw Error('Expected a page transform')\n\n\t\t\tconst snap = snaps.handles.snapHandle({ currentShapeId: shapeId, handle: nextHandle })\n\n\t\t\tif (snap) {\n\t\t\t\tsnap.nudge.rot(-editor.getShapeParentTransform(shape)!.rotation())\n\t\t\t\tpoint.add(snap.nudge)\n\t\t\t\tnextHandle = { ...initialHandle, x: point.x, y: point.y }\n\t\t\t}\n\t\t}\n\n\t\tconst changes = util.onHandleDrag?.(shape, {\n\t\t\thandle: nextHandle,\n\t\t\tisPrecise: this.isPrecise || altKey,\n\t\t\tinitial: initial,\n\t\t})\n\n\t\tconst next: TLShapePartial<any> = { id: shape.id, type: shape.type, ...changes }\n\n\t\t// Arrows\n\t\tif (\n\t\t\tinitialHandle.type === 'vertex' &&\n\t\t\tthis.editor.isShapeOfType<TLArrowShape>(shape, 'arrow')\n\t\t) {\n\t\t\tconst bindingAfter = getArrowBindings(editor, shape)[initialHandle.id as 'start' | 'end']\n\n\t\t\tif (bindingAfter) {\n\t\t\t\tif (initialBinding?.toId !== bindingAfter.toId) {\n\t\t\t\t\tthis.pointingId = bindingAfter.toId\n\t\t\t\t\tthis.isPrecise = pointerVelocity.len() < 0.5 || altKey\n\t\t\t\t\tthis.isPreciseId = this.isPrecise ? bindingAfter.toId : null\n\t\t\t\t\tthis.resetExactTimeout()\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (initialBinding) {\n\t\t\t\t\tthis.pointingId = null\n\t\t\t\t\tthis.isPrecise = false\n\t\t\t\t\tthis.isPreciseId = null\n\t\t\t\t\tthis.resetExactTimeout()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (changes) {\n\t\t\teditor.updateShapes([next])\n\t\t}\n\t}\n}\n"],"names":["handle"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1815, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/SelectTool/childStates/EditingShape.ts"],"sourcesContent":["import {\n\tStateNode,\n\tTLCancelEventInfo,\n\tTLCompleteEventInfo,\n\ttlenv,\n\tTLFrameShape,\n\tTLPointerEventInfo,\n\tTLShape,\n\tTLTextShape,\n} from '@tldraw/editor'\nimport { getTextLabels } from '../../../utils/shapes/shapes'\nimport { renderPlaintextFromRichText } from '../../../utils/text/richText'\nimport { getHitShapeOnCanvasPointerDown } from '../../selection-logic/getHitShapeOnCanvasPointerDown'\nimport { updateHoveredShapeId } from '../../selection-logic/updateHoveredShapeId'\n\ninterface EditingShapeInfo {\n\tisCreatingTextWhileToolLocked?: boolean\n}\n\nexport class EditingShape extends StateNode {\n\tstatic override id = 'editing_shape'\n\n\thitShapeForPointerUp: TLShape | null = null\n\tprivate info = {} as EditingShapeInfo\n\n\toverride onEnter(info: EditingShapeInfo) {\n\t\tconst editingShape = this.editor.getEditingShape()\n\t\tif (!editingShape) throw Error('Entered editing state without an editing shape')\n\t\tthis.hitShapeForPointerUp = null\n\n\t\tthis.info = info\n\n\t\tif (info.isCreatingTextWhileToolLocked) {\n\t\t\tthis.parent.setCurrentToolIdMask('text')\n\t\t}\n\n\t\tupdateHoveredShapeId(this.editor)\n\t\tthis.editor.select(editingShape)\n\t}\n\n\toverride onExit() {\n\t\tconst { editingShapeId } = this.editor.getCurrentPageState()\n\t\tif (!editingShapeId) return\n\n\t\t// Clear the editing shape\n\t\tthis.editor.setEditingShape(null)\n\n\t\tupdateHoveredShapeId.cancel()\n\n\t\tif (this.info.isCreatingTextWhileToolLocked) {\n\t\t\tthis.parent.setCurrentToolIdMask(undefined)\n\t\t\tthis.editor.setCurrentTool('text', {})\n\t\t}\n\t}\n\n\toverride onPointerMove(info: TLPointerEventInfo) {\n\t\t// In the case where on pointer down we hit a shape's label, we need to check if the user is dragging.\n\t\t// and if they are, we need to transition to translating instead.\n\t\tif (this.hitShapeForPointerUp && this.editor.inputs.isDragging) {\n\t\t\tif (this.editor.getIsReadonly()) return\n\t\t\tif (this.hitShapeForPointerUp.isLocked) return\n\t\t\tthis.editor.select(this.hitShapeForPointerUp)\n\t\t\tthis.parent.transition('translating', info)\n\t\t\tthis.hitShapeForPointerUp = null\n\t\t\treturn\n\t\t}\n\n\t\tswitch (info.target) {\n\t\t\tcase 'shape':\n\t\t\tcase 'canvas': {\n\t\t\t\tupdateHoveredShapeId(this.editor)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\n\toverride onPointerDown(info: TLPointerEventInfo) {\n\t\tthis.hitShapeForPointerUp = null\n\n\t\tswitch (info.target) {\n\t\t\t// N.B. This bit of logic has a bit of history to it.\n\t\t\t// There was a PR that got rid of this logic: https://github.com/tldraw/tldraw/pull/4237\n\t\t\t// But here we bring it back to help support the new rich text world.\n\t\t\t// The original issue which is visible in the video attachments in the PR now seem\n\t\t\t// to have been resolved anyway via some other layer.\n\t\t\tcase 'canvas': {\n\t\t\t\tconst hitShape = getHitShapeOnCanvasPointerDown(this.editor, true /* hitLabels */)\n\t\t\t\tif (hitShape) {\n\t\t\t\t\tthis.onPointerDown({\n\t\t\t\t\t\t...info,\n\t\t\t\t\t\tshape: hitShape,\n\t\t\t\t\t\ttarget: 'shape',\n\t\t\t\t\t})\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'shape': {\n\t\t\t\tconst { shape: selectingShape } = info\n\t\t\t\tconst editingShape = this.editor.getEditingShape()\n\n\t\t\t\tif (!editingShape) {\n\t\t\t\t\tthrow Error('Expected an editing shape!')\n\t\t\t\t}\n\n\t\t\t\t// for shapes with labels, check to see if the click was inside of the shape's label\n\t\t\t\tconst geometry = this.editor.getShapeUtil(selectingShape).getGeometry(selectingShape)\n\t\t\t\tconst textLabels = getTextLabels(geometry)\n\t\t\t\tconst textLabel = textLabels.length === 1 ? textLabels[0] : undefined\n\t\t\t\t// N.B. One nuance here is that we want empty text fields to be removed from the canvas when the user clicks away from them.\n\t\t\t\tconst isEmptyTextShape =\n\t\t\t\t\tthis.editor.isShapeOfType<TLTextShape>(editingShape, 'text') &&\n\t\t\t\t\trenderPlaintextFromRichText(this.editor, editingShape.props.richText).trim() === ''\n\t\t\t\tif (textLabel && !isEmptyTextShape) {\n\t\t\t\t\tconst pointInShapeSpace = this.editor.getPointInShapeSpace(\n\t\t\t\t\t\tselectingShape,\n\t\t\t\t\t\tthis.editor.inputs.currentPagePoint\n\t\t\t\t\t)\n\t\t\t\t\tif (\n\t\t\t\t\t\ttextLabel.bounds.containsPoint(pointInShapeSpace, 0) &&\n\t\t\t\t\t\ttextLabel.hitTestPoint(pointInShapeSpace)\n\t\t\t\t\t) {\n\t\t\t\t\t\t// it's a hit to the label!\n\t\t\t\t\t\tif (selectingShape.id === editingShape.id) {\n\t\t\t\t\t\t\t// If we clicked on the editing geo / arrow shape's label, do nothing\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.hitShapeForPointerUp = selectingShape\n\n\t\t\t\t\t\t\tthis.editor.markHistoryStoppingPoint('editing on pointer up')\n\t\t\t\t\t\t\tthis.editor.select(selectingShape.id)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (selectingShape.id === editingShape.id) {\n\t\t\t\t\t\t// If we clicked on a frame, while editing its heading, cancel editing\n\t\t\t\t\t\tif (this.editor.isShapeOfType<TLFrameShape>(selectingShape, 'frame')) {\n\t\t\t\t\t\t\tthis.editor.setEditingShape(null)\n\t\t\t\t\t\t\tthis.parent.transition('idle', info)\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// If we clicked on the editing shape (which isn't a shape with a label), do nothing\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// But if we clicked on a different shape of the same type, transition to pointing_shape instead\n\t\t\t\t\t\tthis.parent.transition('pointing_shape', info)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// still here? Cancel editing and transition back to select idle\n\t\tthis.parent.transition('idle', info)\n\t\t// then feed the pointer down event back into the state chart as if it happened in that state\n\t\tthis.editor.root.handleEvent(info)\n\t}\n\n\toverride onPointerUp(info: TLPointerEventInfo) {\n\t\t// If we're not dragging, and it's a hit to the label, begin editing the shape.\n\t\tconst hitShape = this.hitShapeForPointerUp\n\t\tif (!hitShape) return\n\t\tthis.hitShapeForPointerUp = null\n\n\t\t// Stay in edit mode to maintain flow of editing.\n\t\tconst util = this.editor.getShapeUtil(hitShape)\n\t\tif (hitShape.isLocked) return\n\n\t\tif (this.editor.getIsReadonly()) {\n\t\t\tif (!util.canEditInReadonly(hitShape)) {\n\t\t\t\tthis.parent.transition('pointing_shape', info)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tthis.editor.select(hitShape.id)\n\n\t\tconst currentEditingShape = this.editor.getEditingShape()\n\t\tconst isEditToEditAction = currentEditingShape && currentEditingShape.id !== hitShape.id\n\t\tthis.editor.setEditingShape(hitShape.id)\n\n\t\tconst isMobile = tlenv.isIos || tlenv.isAndroid\n\t\tif (!isMobile || !isEditToEditAction) {\n\t\t\tthis.editor.emit('place-caret', { shapeId: hitShape.id, point: info.point })\n\t\t} else if (isMobile && isEditToEditAction) {\n\t\t\tthis.editor.emit('select-all-text', { shapeId: hitShape.id })\n\t\t}\n\t\tupdateHoveredShapeId(this.editor)\n\t}\n\n\toverride onComplete(info: TLCompleteEventInfo) {\n\t\tthis.editor.getContainer().focus()\n\t\tthis.parent.transition('idle', info)\n\t}\n\n\toverride onCancel(info: TLCancelEventInfo) {\n\t\tthis.editor.getContainer().focus()\n\t\tthis.parent.transition('idle', info)\n\t}\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1981, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/selection-logic/getShouldEnterCropModeOnPointerDown.ts"],"sourcesContent":["import { Editor } from '@tldraw/editor'\n\nexport function getShouldEnterCropMode(editor: Editor): boolean {\n\tconst onlySelectedShape = editor.getOnlySelectedShape()\n\treturn !!(\n\t\tonlySelectedShape &&\n\t\t!editor.isShapeOrAncestorLocked(onlySelectedShape) &&\n\t\teditor.getShapeUtil(onlySelectedShape).canCrop(onlySelectedShape)\n\t)\n}\n"],"names":[],"mappings":";;;AAEO,SAAS,uBAAuB,MAAA,EAAyB;IAC/D,MAAM,oBAAoB,OAAO,oBAAA,CAAqB;IACtD,OAAO,CAAC,CAAA,CACP,qBACA,CAAC,OAAO,uBAAA,CAAwB,iBAAiB,KACjD,OAAO,YAAA,CAAa,iBAAiB,EAAE,OAAA,CAAQ,iBAAiB,CAAA;AAElE","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1996, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/selection-logic/selectOnCanvasPointerUp.ts"],"sourcesContent":["import { Editor, TLClickEventInfo, TLPointerEventInfo, TLShape, isShapeId } from '@tldraw/editor'\n\nexport function selectOnCanvasPointerUp(\n\teditor: Editor,\n\tinfo: TLPointerEventInfo | TLClickEventInfo\n) {\n\tconst selectedShapeIds = editor.getSelectedShapeIds()\n\tconst { currentPagePoint } = editor.inputs\n\tconst { shiftKey, altKey, accelKey } = info\n\tconst additiveSelectionKey = shiftKey || accelKey\n\n\tconst hitShape = editor.getShapeAtPoint(currentPagePoint, {\n\t\thitInside: false,\n\t\tmargin: editor.options.hitTestMargin / editor.getZoomLevel(),\n\t\thitLabels: true,\n\t\trenderingOnly: true,\n\t\tfilter: (shape) => !shape.isLocked,\n\t})\n\n\t// Note at the start: if we select a shape that is inside of a group,\n\t// the editor will automatically adjust the selection to the outermost\n\t// selectable shape (the group)\n\n\t// If the shape's outermost selected id (e.g. the group that contains\n\t// the shape) is not the same as the editor's only selected shape, then\n\t// we want to select the outermost selected shape instead of the shape\n\n\tif (hitShape) {\n\t\tconst outermostSelectableShape = editor.getOutermostSelectableShape(hitShape)\n\t\t// If the user is holding shift, they're either adding to or removing from\n\t\t// their selection.\n\t\tif (additiveSelectionKey && !altKey) {\n\t\t\teditor.cancelDoubleClick() // fuckin eh\n\n\t\t\tif (selectedShapeIds.includes(outermostSelectableShape.id)) {\n\t\t\t\t// Remove it from selected shapes\n\t\t\t\teditor.markHistoryStoppingPoint('deselecting shape')\n\t\t\t\teditor.deselect(outermostSelectableShape)\n\t\t\t} else {\n\t\t\t\t// Add it to selected shapes\n\t\t\t\teditor.markHistoryStoppingPoint('shift selecting shape')\n\t\t\t\teditor.setSelectedShapes([...selectedShapeIds, outermostSelectableShape.id])\n\t\t\t}\n\t\t} else {\n\t\t\tlet shapeToSelect: TLShape | undefined = undefined\n\n\t\t\tif (outermostSelectableShape === hitShape) {\n\t\t\t\t// There's no group around the shape, so we can select it.\n\t\t\t\tshapeToSelect = hitShape\n\t\t\t} else {\n\t\t\t\t// There's a group around the hit shape.\n\t\t\t\t// If the group is the current focus layer, OR if the group is\n\t\t\t\t// already selected, then we can select the shape inside the group.\n\t\t\t\t// Otherwise, if the group isn't selected and isn't our current\n\t\t\t\t// focus layer, then we need to select the group instead.\n\t\t\t\tif (\n\t\t\t\t\toutermostSelectableShape.id === editor.getFocusedGroupId() ||\n\t\t\t\t\tselectedShapeIds.includes(outermostSelectableShape.id)\n\t\t\t\t) {\n\t\t\t\t\tshapeToSelect = hitShape\n\t\t\t\t} else {\n\t\t\t\t\tshapeToSelect = outermostSelectableShape\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (shapeToSelect && !selectedShapeIds.includes(shapeToSelect.id)) {\n\t\t\t\teditor.markHistoryStoppingPoint('selecting shape')\n\t\t\t\teditor.select(shapeToSelect.id)\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// We didn't hit anything...\n\t\tif (additiveSelectionKey) {\n\t\t\t// If we were holding shift, then it's a noop. We keep the\n\t\t\t// current selection because we didn't add anything to it\n\t\t\treturn\n\t\t} else {\n\t\t\t// Otherwise, we clear the selction because the user selected\n\t\t\t// nothing instead of their current selection.\n\n\t\t\tif (selectedShapeIds.length > 0) {\n\t\t\t\teditor.markHistoryStoppingPoint('selecting none')\n\t\t\t\teditor.selectNone()\n\t\t\t}\n\n\t\t\t// If the click was inside of the current focused group, then\n\t\t\t// we keep that focused group; otherwise we clear the focused\n\t\t\t// group (reset it to the page)\n\t\t\tconst focusedGroupId = editor.getFocusedGroupId()\n\n\t\t\tif (isShapeId(focusedGroupId)) {\n\t\t\t\tconst groupShape = editor.getShape(focusedGroupId)!\n\t\t\t\tif (!editor.isPointInShape(groupShape, currentPagePoint, { margin: 0, hitInside: true })) {\n\t\t\t\t\teditor.setFocusedGroup(null)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"],"names":[],"mappings":";;;AAAA,SAAgE,iBAAiB;;;AAE1E,SAAS,wBACf,MAAA,EACA,IAAA,EACC;IACD,MAAM,mBAAmB,OAAO,mBAAA,CAAoB;IACpD,MAAM,EAAE,gBAAA,CAAiB,CAAA,GAAI,OAAO,MAAA;IACpC,MAAM,EAAE,QAAA,EAAU,MAAA,EAAQ,QAAA,CAAS,CAAA,GAAI;IACvC,MAAM,uBAAuB,YAAY;IAEzC,MAAM,WAAW,OAAO,eAAA,CAAgB,kBAAkB;QACzD,WAAW;QACX,QAAQ,OAAO,OAAA,CAAQ,aAAA,GAAgB,OAAO,YAAA,CAAa;QAC3D,WAAW;QACX,eAAe;QACf,QAAQ,CAAC,QAAU,CAAC,MAAM,QAAA;IAC3B,CAAC;IAUD,IAAI,UAAU;QACb,MAAM,2BAA2B,OAAO,2BAAA,CAA4B,QAAQ;QAG5E,IAAI,wBAAwB,CAAC,QAAQ;YACpC,OAAO,iBAAA,CAAkB;YAEzB,IAAI,iBAAiB,QAAA,CAAS,yBAAyB,EAAE,GAAG;gBAE3D,OAAO,wBAAA,CAAyB,mBAAmB;gBACnD,OAAO,QAAA,CAAS,wBAAwB;YACzC,OAAO;gBAEN,OAAO,wBAAA,CAAyB,uBAAuB;gBACvD,OAAO,iBAAA,CAAkB,CAAC;uBAAG;oBAAkB,yBAAyB,EAAE;iBAAC;YAC5E;QACD,OAAO;YACN,IAAI,gBAAqC,KAAA;YAEzC,IAAI,6BAA6B,UAAU;gBAE1C,gBAAgB;YACjB,OAAO;gBAMN,IACC,yBAAyB,EAAA,KAAO,OAAO,iBAAA,CAAkB,KACzD,iBAAiB,QAAA,CAAS,yBAAyB,EAAE,GACpD;oBACD,gBAAgB;gBACjB,OAAO;oBACN,gBAAgB;gBACjB;YACD;YAEA,IAAI,iBAAiB,CAAC,iBAAiB,QAAA,CAAS,cAAc,EAAE,GAAG;gBAClE,OAAO,wBAAA,CAAyB,iBAAiB;gBACjD,OAAO,MAAA,CAAO,cAAc,EAAE;YAC/B;QACD;IACD,OAAO;QAEN,IAAI,sBAAsB;YAGzB;QACD,OAAO;YAIN,IAAI,iBAAiB,MAAA,GAAS,GAAG;gBAChC,OAAO,wBAAA,CAAyB,gBAAgB;gBAChD,OAAO,UAAA,CAAW;YACnB;YAKA,MAAM,iBAAiB,OAAO,iBAAA,CAAkB;YAEhD,sLAAI,YAAA,EAAU,cAAc,GAAG;gBAC9B,MAAM,aAAa,OAAO,QAAA,CAAS,cAAc;gBACjD,IAAI,CAAC,OAAO,cAAA,CAAe,YAAY,kBAAkB;oBAAE,QAAQ;oBAAG,WAAW;gBAAK,CAAC,GAAG;oBACzF,OAAO,eAAA,CAAgB,IAAI;gBAC5B;YACD;QACD;IACD;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2073, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/SelectTool/childStates/Idle.ts"],"sourcesContent":["import {\n\tEditor,\n\tGroup2d,\n\tStateNode,\n\tTLAdjacentDirection,\n\tTLArrowShape,\n\tTLClickEventInfo,\n\tTLGroupShape,\n\tTLKeyboardEventInfo,\n\tTLPointerEventInfo,\n\tTLShape,\n\tTLTextShape,\n\tVec,\n\tVecLike,\n\tcreateShapeId,\n\tdebugFlags,\n\tkickoutOccludedShapes,\n\tpointInPolygon,\n\ttoRichText,\n} from '@tldraw/editor'\nimport { getHitShapeOnCanvasPointerDown } from '../../selection-logic/getHitShapeOnCanvasPointerDown'\nimport { getShouldEnterCropMode } from '../../selection-logic/getShouldEnterCropModeOnPointerDown'\nimport { selectOnCanvasPointerUp } from '../../selection-logic/selectOnCanvasPointerUp'\nimport { updateHoveredShapeId } from '../../selection-logic/updateHoveredShapeId'\nimport { startEditingShapeWithLabel } from '../selectHelpers'\n\nconst SKIPPED_KEYS_FOR_AUTO_EDITING = [\n\t'Delete',\n\t'Backspace',\n\t'[',\n\t']',\n\t'Enter',\n\t' ',\n\t'Shift',\n\t'Tab',\n]\n\nexport class Idle extends StateNode {\n\tstatic override id = 'idle'\n\n\tselectedShapesOnKeyDown: TLShape[] = []\n\n\toverride onEnter() {\n\t\tthis.parent.setCurrentToolIdMask(undefined)\n\t\tupdateHoveredShapeId(this.editor)\n\t\tthis.selectedShapesOnKeyDown = []\n\t\tthis.editor.setCursor({ type: 'default', rotation: 0 })\n\t}\n\n\toverride onExit() {\n\t\tupdateHoveredShapeId.cancel()\n\t}\n\n\toverride onPointerMove() {\n\t\tupdateHoveredShapeId(this.editor)\n\t}\n\n\toverride onPointerDown(info: TLPointerEventInfo) {\n\t\tconst shouldEnterCropMode = info.ctrlKey && getShouldEnterCropMode(this.editor)\n\n\t\tswitch (info.target) {\n\t\t\tcase 'canvas': {\n\t\t\t\t// Check to see if we hit any shape under the pointer; if so,\n\t\t\t\t// handle this as a pointer down on the shape instead of the canvas\n\t\t\t\tconst hitShape = getHitShapeOnCanvasPointerDown(this.editor)\n\t\t\t\tif (hitShape && !hitShape.isLocked) {\n\t\t\t\t\tthis.onPointerDown({\n\t\t\t\t\t\t...info,\n\t\t\t\t\t\tshape: hitShape,\n\t\t\t\t\t\ttarget: 'shape',\n\t\t\t\t\t})\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tconst selectedShapeIds = this.editor.getSelectedShapeIds()\n\t\t\t\tconst onlySelectedShape = this.editor.getOnlySelectedShape()\n\t\t\t\tconst {\n\t\t\t\t\tinputs: { currentPagePoint },\n\t\t\t\t} = this.editor\n\n\t\t\t\tif (\n\t\t\t\t\tselectedShapeIds.length > 1 ||\n\t\t\t\t\t(onlySelectedShape &&\n\t\t\t\t\t\t!this.editor.getShapeUtil(onlySelectedShape).hideSelectionBoundsBg(onlySelectedShape))\n\t\t\t\t) {\n\t\t\t\t\tif (isPointInRotatedSelectionBounds(this.editor, currentPagePoint)) {\n\t\t\t\t\t\tthis.onPointerDown({\n\t\t\t\t\t\t\t...info,\n\t\t\t\t\t\t\ttarget: 'selection',\n\t\t\t\t\t\t})\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.parent.transition('pointing_canvas', info)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'shape': {\n\t\t\t\tconst { shape } = info\n\n\t\t\t\tif (this.isOverArrowLabelTest(shape)) {\n\t\t\t\t\t// We're moving the label on a shape.\n\t\t\t\t\tthis.parent.transition('pointing_arrow_label', info)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tif (this.editor.isShapeOrAncestorLocked(shape)) {\n\t\t\t\t\tthis.parent.transition('pointing_canvas', info)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\t// If we're holding ctrl key, we might select it, or start brushing...\n\t\t\t\tthis.parent.transition('pointing_shape', info)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'handle': {\n\t\t\t\tif (this.editor.getIsReadonly()) break\n\t\t\t\tif (this.editor.inputs.altKey) {\n\t\t\t\t\tthis.parent.transition('pointing_shape', info)\n\t\t\t\t} else {\n\t\t\t\t\t// If we're holding ctrl key, we might select it, or start brushing...\n\t\t\t\t\tthis.parent.transition('pointing_handle', info)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'selection': {\n\t\t\t\tswitch (info.handle) {\n\t\t\t\t\tcase 'mobile_rotate':\n\t\t\t\t\tcase 'top_left_rotate':\n\t\t\t\t\tcase 'top_right_rotate':\n\t\t\t\t\tcase 'bottom_left_rotate':\n\t\t\t\t\tcase 'bottom_right_rotate': {\n\t\t\t\t\t\tif (info.accelKey) {\n\t\t\t\t\t\t\tthis.parent.transition('brushing', info)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.parent.transition('pointing_rotate_handle', info)\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tcase 'top':\n\t\t\t\t\tcase 'right':\n\t\t\t\t\tcase 'bottom':\n\t\t\t\t\tcase 'left':\n\t\t\t\t\tcase 'top_left':\n\t\t\t\t\tcase 'top_right':\n\t\t\t\t\tcase 'bottom_left':\n\t\t\t\t\tcase 'bottom_right': {\n\t\t\t\t\t\tif (shouldEnterCropMode) {\n\t\t\t\t\t\t\tthis.parent.transition('crop.pointing_crop_handle', info)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (info.accelKey) {\n\t\t\t\t\t\t\t\tthis.parent.transition('brushing', info)\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.parent.transition('pointing_resize_handle', info)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tconst hoveredShape = this.editor.getHoveredShape()\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\thoveredShape &&\n\t\t\t\t\t\t\t!this.editor.getSelectedShapeIds().includes(hoveredShape.id) &&\n\t\t\t\t\t\t\t!hoveredShape.isLocked\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tthis.onPointerDown({\n\t\t\t\t\t\t\t\t...info,\n\t\t\t\t\t\t\t\tshape: hoveredShape,\n\t\t\t\t\t\t\t\ttarget: 'shape',\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.parent.transition('pointing_selection', info)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\toverride onDoubleClick(info: TLClickEventInfo) {\n\t\tif (this.editor.inputs.shiftKey || info.phase !== 'up') return\n\n\t\t// We don't want to double click while toggling shapes\n\t\tif (info.ctrlKey || info.shiftKey) return\n\n\t\tswitch (info.target) {\n\t\t\tcase 'canvas': {\n\t\t\t\tconst hoveredShape = this.editor.getHoveredShape()\n\n\t\t\t\t// todo\n\t\t\t\t// double clicking on the middle of a hollow geo shape without a label, or\n\t\t\t\t// over the label of a hollwo shape that has a label, should start editing\n\t\t\t\t// that shape's label. We can't support \"double click anywhere inside\"\n\t\t\t\t// of the shape yet because that also creates text shapes, and can produce\n\t\t\t\t// unexpected results when working \"inside of\" a hollow shape.\n\n\t\t\t\tconst hitShape =\n\t\t\t\t\thoveredShape && !this.editor.isShapeOfType<TLGroupShape>(hoveredShape, 'group')\n\t\t\t\t\t\t? hoveredShape\n\t\t\t\t\t\t: (this.editor.getSelectedShapeAtPoint(this.editor.inputs.currentPagePoint) ??\n\t\t\t\t\t\t\tthis.editor.getShapeAtPoint(this.editor.inputs.currentPagePoint, {\n\t\t\t\t\t\t\t\tmargin: this.editor.options.hitTestMargin / this.editor.getZoomLevel(),\n\t\t\t\t\t\t\t\thitInside: false,\n\t\t\t\t\t\t\t}))\n\n\t\t\t\tconst focusedGroupId = this.editor.getFocusedGroupId()\n\n\t\t\t\tif (hitShape) {\n\t\t\t\t\tif (this.editor.isShapeOfType<TLGroupShape>(hitShape, 'group')) {\n\t\t\t\t\t\t// Probably select the shape\n\t\t\t\t\t\tselectOnCanvasPointerUp(this.editor, info)\n\t\t\t\t\t\treturn\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst parent = this.editor.getShape(hitShape.parentId)\n\t\t\t\t\t\tif (parent && this.editor.isShapeOfType<TLGroupShape>(parent, 'group')) {\n\t\t\t\t\t\t\t// The shape is the direct child of a group. If the group is\n\t\t\t\t\t\t\t// selected, then we can select the shape. If the group is the\n\t\t\t\t\t\t\t// focus layer id, then we can double click into it as usual.\n\t\t\t\t\t\t\tif (focusedGroupId && parent.id === focusedGroupId) {\n\t\t\t\t\t\t\t\t// noop, double click on the shape as normal below\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// The shape is the child of some group other than our current\n\t\t\t\t\t\t\t\t// focus layer. We should probably select the group instead.\n\t\t\t\t\t\t\t\tselectOnCanvasPointerUp(this.editor, info)\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// double click on the shape. We'll start editing the\n\t\t\t\t\t// shape if it's editable or else do a double click on\n\t\t\t\t\t// the canvas.\n\t\t\t\t\tthis.onDoubleClick({\n\t\t\t\t\t\t...info,\n\t\t\t\t\t\tshape: hitShape,\n\t\t\t\t\t\ttarget: 'shape',\n\t\t\t\t\t})\n\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif (!this.editor.inputs.shiftKey) {\n\t\t\t\t\tthis.handleDoubleClickOnCanvas(info)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'selection': {\n\t\t\t\tif (this.editor.getIsReadonly()) break\n\n\t\t\t\tconst onlySelectedShape = this.editor.getOnlySelectedShape()\n\n\t\t\t\tif (onlySelectedShape) {\n\t\t\t\t\tconst util = this.editor.getShapeUtil(onlySelectedShape)\n\n\t\t\t\t\tif (!this.canInteractWithShapeInReadOnly(onlySelectedShape)) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\t// Test edges for an onDoubleClickEdge handler\n\t\t\t\t\tif (\n\t\t\t\t\t\tinfo.handle === 'right' ||\n\t\t\t\t\t\tinfo.handle === 'left' ||\n\t\t\t\t\t\tinfo.handle === 'top' ||\n\t\t\t\t\t\tinfo.handle === 'bottom'\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst change = util.onDoubleClickEdge?.(onlySelectedShape, info)\n\t\t\t\t\t\tif (change) {\n\t\t\t\t\t\t\tthis.editor.markHistoryStoppingPoint('double click edge')\n\t\t\t\t\t\t\tthis.editor.updateShapes([change])\n\t\t\t\t\t\t\tkickoutOccludedShapes(this.editor, [onlySelectedShape.id])\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tinfo.handle === 'top_left' ||\n\t\t\t\t\t\tinfo.handle === 'top_right' ||\n\t\t\t\t\t\tinfo.handle === 'bottom_right' ||\n\t\t\t\t\t\tinfo.handle === 'bottom_left'\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst change = util.onDoubleClickCorner?.(onlySelectedShape, info)\n\t\t\t\t\t\tif (change) {\n\t\t\t\t\t\t\tthis.editor.markHistoryStoppingPoint('double click corner')\n\t\t\t\t\t\t\tthis.editor.updateShapes([change])\n\t\t\t\t\t\t\tkickoutOccludedShapes(this.editor, [onlySelectedShape.id])\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// For corners OR edges but NOT rotation corners\n\t\t\t\t\tif (\n\t\t\t\t\t\tutil.canCrop(onlySelectedShape) &&\n\t\t\t\t\t\t!this.editor.isShapeOrAncestorLocked(onlySelectedShape)\n\t\t\t\t\t) {\n\t\t\t\t\t\tthis.parent.transition('crop', info)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.shouldStartEditingShape(onlySelectedShape)) {\n\t\t\t\t\t\tthis.startEditingShape(onlySelectedShape, info, true /* select all */)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'shape': {\n\t\t\t\tconst { shape } = info\n\t\t\t\tconst util = this.editor.getShapeUtil(shape)\n\n\t\t\t\t// Allow playing videos and embeds\n\t\t\t\tif (shape.type !== 'video' && shape.type !== 'embed' && this.editor.getIsReadonly()) break\n\n\t\t\t\tif (util.onDoubleClick) {\n\t\t\t\t\t// Call the shape's double click handler\n\t\t\t\t\tconst change = util.onDoubleClick?.(shape)\n\t\t\t\t\tif (change) {\n\t\t\t\t\t\tthis.editor.updateShapes([change])\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (util.canCrop(shape) && !this.editor.isShapeOrAncestorLocked(shape)) {\n\t\t\t\t\t// crop image etc on double click\n\t\t\t\t\tthis.editor.markHistoryStoppingPoint('select and crop')\n\t\t\t\t\tthis.editor.select(info.shape?.id)\n\t\t\t\t\tthis.parent.transition('crop', info)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// If the shape can edit, then begin editing\n\t\t\t\tif (this.shouldStartEditingShape(shape)) {\n\t\t\t\t\tthis.startEditingShape(shape, info, true /* select all */)\n\t\t\t\t} else {\n\t\t\t\t\t// If the shape's double click handler has not created a change,\n\t\t\t\t\t// and if the shape cannot edit, then create a text shape and\n\t\t\t\t\t// begin editing the text shape\n\t\t\t\t\tthis.handleDoubleClickOnCanvas(info)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'handle': {\n\t\t\t\tif (this.editor.getIsReadonly()) break\n\t\t\t\tconst { shape, handle } = info\n\n\t\t\t\tconst util = this.editor.getShapeUtil(shape)\n\t\t\t\tconst changes = util.onDoubleClickHandle?.(shape, handle)\n\n\t\t\t\tif (changes) {\n\t\t\t\t\tthis.editor.updateShapes([changes])\n\t\t\t\t} else {\n\t\t\t\t\t// If the shape's double click handler has not created a change,\n\t\t\t\t\t// and if the shape can edit, then begin editing the shape.\n\t\t\t\t\tif (this.shouldStartEditingShape(shape)) {\n\t\t\t\t\t\tthis.startEditingShape(shape, info, true /* select all */)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\toverride onRightClick(info: TLPointerEventInfo) {\n\t\tswitch (info.target) {\n\t\t\tcase 'canvas': {\n\t\t\t\tconst hoveredShape = this.editor.getHoveredShape()\n\t\t\t\tconst hitShape =\n\t\t\t\t\thoveredShape && !this.editor.isShapeOfType<TLGroupShape>(hoveredShape, 'group')\n\t\t\t\t\t\t? hoveredShape\n\t\t\t\t\t\t: this.editor.getShapeAtPoint(this.editor.inputs.currentPagePoint, {\n\t\t\t\t\t\t\t\tmargin: this.editor.options.hitTestMargin / this.editor.getZoomLevel(),\n\t\t\t\t\t\t\t\thitInside: false,\n\t\t\t\t\t\t\t\thitLabels: true,\n\t\t\t\t\t\t\t\thitLocked: true,\n\t\t\t\t\t\t\t\thitFrameInside: true,\n\t\t\t\t\t\t\t\trenderingOnly: true,\n\t\t\t\t\t\t\t})\n\n\t\t\t\tif (hitShape) {\n\t\t\t\t\tthis.onRightClick({\n\t\t\t\t\t\t...info,\n\t\t\t\t\t\tshape: hitShape,\n\t\t\t\t\t\ttarget: 'shape',\n\t\t\t\t\t})\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tconst selectedShapeIds = this.editor.getSelectedShapeIds()\n\t\t\t\tconst onlySelectedShape = this.editor.getOnlySelectedShape()\n\t\t\t\tconst {\n\t\t\t\t\tinputs: { currentPagePoint },\n\t\t\t\t} = this.editor\n\n\t\t\t\tif (\n\t\t\t\t\tselectedShapeIds.length > 1 ||\n\t\t\t\t\t(onlySelectedShape &&\n\t\t\t\t\t\t!this.editor.getShapeUtil(onlySelectedShape).hideSelectionBoundsBg(onlySelectedShape))\n\t\t\t\t) {\n\t\t\t\t\tif (isPointInRotatedSelectionBounds(this.editor, currentPagePoint)) {\n\t\t\t\t\t\tthis.onRightClick({\n\t\t\t\t\t\t\t...info,\n\t\t\t\t\t\t\ttarget: 'selection',\n\t\t\t\t\t\t})\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.editor.selectNone()\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'shape': {\n\t\t\t\tconst { selectedShapeIds } = this.editor.getCurrentPageState()\n\t\t\t\tconst { shape } = info\n\n\t\t\t\tconst targetShape = this.editor.getOutermostSelectableShape(\n\t\t\t\t\tshape,\n\t\t\t\t\t(parent) => !selectedShapeIds.includes(parent.id)\n\t\t\t\t)\n\n\t\t\t\tif (\n\t\t\t\t\t!selectedShapeIds.includes(targetShape.id) &&\n\t\t\t\t\t!this.editor.findShapeAncestor(targetShape, (shape) =>\n\t\t\t\t\t\tselectedShapeIds.includes(shape.id)\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tthis.editor.markHistoryStoppingPoint('selecting shape')\n\t\t\t\t\tthis.editor.setSelectedShapes([targetShape.id])\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\toverride onCancel() {\n\t\tif (\n\t\t\tthis.editor.getFocusedGroupId() !== this.editor.getCurrentPageId() &&\n\t\t\tthis.editor.getSelectedShapeIds().length > 0\n\t\t) {\n\t\t\tthis.editor.popFocusedGroupId()\n\t\t} else {\n\t\t\tthis.editor.markHistoryStoppingPoint('clearing selection')\n\t\t\tthis.editor.selectNone()\n\t\t}\n\t}\n\n\toverride onKeyDown(info: TLKeyboardEventInfo) {\n\t\tthis.selectedShapesOnKeyDown = this.editor.getSelectedShapes()\n\n\t\tswitch (info.code) {\n\t\t\tcase 'ArrowLeft':\n\t\t\tcase 'ArrowRight':\n\t\t\tcase 'ArrowUp':\n\t\t\tcase 'ArrowDown': {\n\t\t\t\tif (info.accelKey) {\n\t\t\t\t\tif (info.shiftKey) {\n\t\t\t\t\t\tif (info.code === 'ArrowDown') {\n\t\t\t\t\t\t\tthis.editor.selectFirstChildShape()\n\t\t\t\t\t\t} else if (info.code === 'ArrowUp') {\n\t\t\t\t\t\t\tthis.editor.selectParentShape()\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.editor.selectAdjacentShape(\n\t\t\t\t\t\t\tinfo.code.replace('Arrow', '').toLowerCase() as TLAdjacentDirection\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tthis.nudgeSelectedShapes(false)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif (debugFlags['editOnType'].get()) {\n\t\t\t// This feature flag lets us start editing a note shape's label when a key is pressed.\n\t\t\t// We exclude certain keys to avoid conflicting with modifiers, but there are conflicts\n\t\t\t// with other action kbds, hence why this is kept behind a feature flag.\n\t\t\tif (!SKIPPED_KEYS_FOR_AUTO_EDITING.includes(info.key) && !info.altKey && !info.ctrlKey) {\n\t\t\t\t// If the only selected shape is editable, then begin editing it\n\t\t\t\tconst onlySelectedShape = this.editor.getOnlySelectedShape()\n\t\t\t\tif (\n\t\t\t\t\tonlySelectedShape &&\n\t\t\t\t\t// If it's a note shape, then edit on type\n\t\t\t\t\tthis.editor.isShapeOfType(onlySelectedShape, 'note') &&\n\t\t\t\t\t// If it's not locked or anything\n\t\t\t\t\tthis.shouldStartEditingShape(onlySelectedShape)\n\t\t\t\t) {\n\t\t\t\t\tthis.startEditingShape(\n\t\t\t\t\t\tonlySelectedShape,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t...info,\n\t\t\t\t\t\t\ttarget: 'shape',\n\t\t\t\t\t\t\tshape: onlySelectedShape,\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttrue /* select all */\n\t\t\t\t\t)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\toverride onKeyRepeat(info: TLKeyboardEventInfo) {\n\t\tswitch (info.code) {\n\t\t\tcase 'ArrowLeft':\n\t\t\tcase 'ArrowRight':\n\t\t\tcase 'ArrowUp':\n\t\t\tcase 'ArrowDown': {\n\t\t\t\tif (info.accelKey) {\n\t\t\t\t\tthis.editor.selectAdjacentShape(\n\t\t\t\t\t\tinfo.code.replace('Arrow', '').toLowerCase() as TLAdjacentDirection\n\t\t\t\t\t)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tthis.nudgeSelectedShapes(true)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'Tab': {\n\t\t\t\tconst selectedShapes = this.editor.getSelectedShapes()\n\t\t\t\tif (selectedShapes.length) {\n\t\t\t\t\tthis.editor.selectAdjacentShape(info.shiftKey ? 'prev' : 'next')\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\toverride onKeyUp(info: TLKeyboardEventInfo) {\n\t\tswitch (info.code) {\n\t\t\tcase 'Enter': {\n\t\t\t\t// Because Enter onKeyDown can happen outside the canvas (but then focus the canvas potentially),\n\t\t\t\t// we need to check if the canvas was initially selecting something before continuing.\n\t\t\t\tif (!this.selectedShapesOnKeyDown.length) return\n\n\t\t\t\tconst selectedShapes = this.editor.getSelectedShapes()\n\n\t\t\t\t// On enter, if every selected shape is a group, then select all of the children of the groups\n\t\t\t\tif (\n\t\t\t\t\tselectedShapes.every((shape) => this.editor.isShapeOfType<TLGroupShape>(shape, 'group'))\n\t\t\t\t) {\n\t\t\t\t\tthis.editor.setSelectedShapes(\n\t\t\t\t\t\tselectedShapes.flatMap((shape) => this.editor.getSortedChildIdsForParent(shape.id))\n\t\t\t\t\t)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// If the only selected shape is editable, then begin editing it\n\t\t\t\tconst onlySelectedShape = this.editor.getOnlySelectedShape()\n\t\t\t\tif (onlySelectedShape && this.shouldStartEditingShape(onlySelectedShape)) {\n\t\t\t\t\tthis.startEditingShape(\n\t\t\t\t\t\tonlySelectedShape,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t...info,\n\t\t\t\t\t\t\ttarget: 'shape',\n\t\t\t\t\t\t\tshape: onlySelectedShape,\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttrue /* select all */\n\t\t\t\t\t)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// If the only selected shape is croppable, then begin cropping it\n\t\t\t\tif (getShouldEnterCropMode(this.editor)) {\n\t\t\t\t\tthis.parent.transition('crop', info)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'Tab': {\n\t\t\t\tconst selectedShapes = this.editor.getSelectedShapes()\n\t\t\t\tif (selectedShapes.length) {\n\t\t\t\t\tthis.editor.selectAdjacentShape(info.shiftKey ? 'prev' : 'next')\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate shouldStartEditingShape(\n\t\tshape: TLShape | null = this.editor.getOnlySelectedShape()\n\t): boolean {\n\t\tif (!shape) return false\n\t\tif (this.editor.isShapeOrAncestorLocked(shape) && shape.type !== 'embed') return false\n\t\tif (!this.canInteractWithShapeInReadOnly(shape)) return false\n\t\treturn this.editor.getShapeUtil(shape).canEdit(shape)\n\t}\n\n\tprivate startEditingShape(\n\t\tshape: TLShape,\n\t\tinfo: TLClickEventInfo | TLKeyboardEventInfo,\n\t\tshouldSelectAll?: boolean\n\t) {\n\t\tif (this.editor.isShapeOrAncestorLocked(shape) && shape.type !== 'embed') return\n\t\tthis.editor.markHistoryStoppingPoint('editing shape')\n\t\tstartEditingShapeWithLabel(this.editor, shape, shouldSelectAll)\n\t\tthis.parent.transition('editing_shape', info)\n\t}\n\n\tisOverArrowLabelTest(shape: TLShape | undefined) {\n\t\tif (!shape) return false\n\n\t\t// todo: Extract into general hit test for arrows\n\t\tif (this.editor.isShapeOfType<TLArrowShape>(shape, 'arrow')) {\n\t\t\tconst pointInShapeSpace = this.editor.getPointInShapeSpace(\n\t\t\t\tshape,\n\t\t\t\tthis.editor.inputs.currentPagePoint\n\t\t\t)\n\t\t\t// How should we handle multiple labels? Do shapes ever have multiple labels?\n\t\t\tconst labelGeometry = this.editor.getShapeGeometry<Group2d>(shape).children[1]\n\t\t\t// Knowing what we know about arrows... if the shape has no text in its label,\n\t\t\t// then the label geometry should not be there.\n\t\t\tif (labelGeometry && pointInPolygon(pointInShapeSpace, labelGeometry.vertices)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\n\t\treturn false\n\t}\n\n\thandleDoubleClickOnCanvas(info: TLClickEventInfo) {\n\t\t// Create text shape and transition to editing_shape\n\t\tif (this.editor.getIsReadonly()) return\n\n\t\tif (!this.editor.options.createTextOnCanvasDoubleClick) return\n\n\t\tthis.editor.markHistoryStoppingPoint('creating text shape')\n\n\t\tconst id = createShapeId()\n\n\t\tconst { x, y } = this.editor.inputs.currentPagePoint\n\n\t\t// Allow this to trigger the max shapes reached alert\n\t\tthis.editor.createShapes<TLTextShape>([\n\t\t\t{\n\t\t\t\tid,\n\t\t\t\ttype: 'text',\n\t\t\t\tx,\n\t\t\t\ty,\n\t\t\t\tprops: {\n\t\t\t\t\trichText: toRichText(''),\n\t\t\t\t\tautoSize: true,\n\t\t\t\t},\n\t\t\t},\n\t\t])\n\n\t\tconst shape = this.editor.getShape(id)\n\t\tif (!shape) return\n\n\t\tconst util = this.editor.getShapeUtil(shape)\n\t\tif (this.editor.getIsReadonly()) {\n\t\t\tif (!util.canEditInReadonly(shape)) {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tthis.editor.setEditingShape(id)\n\t\tthis.editor.select(id)\n\t\tthis.parent.transition('editing_shape', info)\n\t}\n\n\tprivate nudgeSelectedShapes(ephemeral = false) {\n\t\tconst {\n\t\t\teditor: {\n\t\t\t\tinputs: { keys },\n\t\t\t},\n\t\t} = this\n\n\t\t// We want to use the \"actual\" shift key state,\n\t\t// not the one that's in the editor.inputs.shiftKey,\n\t\t// because that one uses a short timeout on release\n\t\tconst shiftKey = keys.has('ShiftLeft')\n\n\t\tconst delta = new Vec(0, 0)\n\n\t\tif (keys.has('ArrowLeft')) delta.x -= 1\n\t\tif (keys.has('ArrowRight')) delta.x += 1\n\t\tif (keys.has('ArrowUp')) delta.y -= 1\n\t\tif (keys.has('ArrowDown')) delta.y += 1\n\n\t\tif (delta.equals(new Vec(0, 0))) return\n\n\t\tif (!ephemeral) this.editor.markHistoryStoppingPoint('nudge shapes')\n\n\t\tconst { gridSize } = this.editor.getDocumentSettings()\n\n\t\tconst step = this.editor.getInstanceState().isGridMode\n\t\t\t? shiftKey\n\t\t\t\t? gridSize * GRID_INCREMENT\n\t\t\t\t: gridSize\n\t\t\t: shiftKey\n\t\t\t\t? MAJOR_NUDGE_FACTOR\n\t\t\t\t: MINOR_NUDGE_FACTOR\n\n\t\tconst selectedShapeIds = this.editor.getSelectedShapeIds()\n\t\tthis.editor.nudgeShapes(selectedShapeIds, delta.mul(step))\n\t\tkickoutOccludedShapes(this.editor, selectedShapeIds)\n\t}\n\n\tprivate canInteractWithShapeInReadOnly(shape: TLShape) {\n\t\tif (!this.editor.getIsReadonly()) return true\n\t\tconst util = this.editor.getShapeUtil(shape)\n\t\tif (util.canEditInReadonly(shape)) return true\n\t\treturn false\n\t}\n}\n\nexport const MAJOR_NUDGE_FACTOR = 10\nexport const MINOR_NUDGE_FACTOR = 1\nexport const GRID_INCREMENT = 5\n\nfunction isPointInRotatedSelectionBounds(editor: Editor, point: VecLike) {\n\tconst selectionBounds = editor.getSelectionRotatedPageBounds()\n\tif (!selectionBounds) return false\n\n\tconst selectionRotation = editor.getSelectionRotation()\n\tif (!selectionRotation) return selectionBounds.containsPoint(point)\n\n\treturn pointInPolygon(\n\t\tpoint,\n\t\tselectionBounds.corners.map((c) => Vec.RotWith(c, selectionBounds.point, selectionRotation))\n\t)\n}\n"],"names":["shape"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2611, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/SelectTool/childStates/PointingArrowLabel.ts"],"sourcesContent":["import {\n\tGroup2d,\n\tStateNode,\n\tTLArrowShape,\n\tTLPointerEventInfo,\n\tTLShapeId,\n\tVec,\n} from '@tldraw/editor'\nimport { ArrowShapeUtil } from '../../../shapes/arrow/ArrowShapeUtil'\nimport {\n\tgetArrowBodyGeometry,\n\tgetArrowLabelDefaultPosition,\n} from '../../../shapes/arrow/arrowLabel'\n\nexport class PointingArrowLabel extends StateNode {\n\tstatic override id = 'pointing_arrow_label'\n\n\tshapeId = '' as TLShapeId\n\tmarkId = ''\n\twasAlreadySelected = false\n\tdidDrag = false\n\tdidCtrlOnEnter = false\n\n\tprivate info = {} as TLPointerEventInfo & {\n\t\tshape: TLArrowShape\n\t\tonInteractionEnd?: string\n\t\tisCreating: boolean\n\t}\n\n\tprivate updateCursor() {\n\t\tthis.editor.setCursor({ type: 'grabbing', rotation: 0 })\n\t}\n\n\toverride onEnter(\n\t\tinfo: TLPointerEventInfo & {\n\t\t\tshape: TLArrowShape\n\t\t\tonInteractionEnd?: string\n\t\t\tisCreating: boolean\n\t\t}\n\t) {\n\t\tconst { shape } = info\n\t\tthis.parent.setCurrentToolIdMask(info.onInteractionEnd)\n\t\tthis.info = info\n\t\tthis.shapeId = shape.id\n\t\tthis.didDrag = false\n\t\tthis.didCtrlOnEnter = info.accelKey\n\t\tthis.wasAlreadySelected = this.editor.getOnlySelectedShapeId() === shape.id\n\t\tthis.updateCursor()\n\n\t\tconst geometry = this.editor.getShapeGeometry<Group2d>(shape)\n\t\tconst labelGeometry = geometry.children[1]\n\t\tif (!labelGeometry) {\n\t\t\tthrow Error(`Expected to find an arrow label geometry for shape: ${shape.id}`)\n\t\t}\n\t\tconst { currentPagePoint } = this.editor.inputs\n\t\tconst pointInShapeSpace = this.editor.getPointInShapeSpace(shape, currentPagePoint)\n\n\t\tthis._labelDragOffset = Vec.Sub(labelGeometry.center, pointInShapeSpace)\n\n\t\tthis.markId = this.editor.markHistoryStoppingPoint('label-drag start')\n\n\t\tconst additiveSelectionKey = info.shiftKey || info.accelKey\n\t\tif (additiveSelectionKey) {\n\t\t\tconst selectedShapeIds = this.editor.getSelectedShapeIds()\n\t\t\tthis.editor.setSelectedShapes([...selectedShapeIds, this.shapeId])\n\n\t\t\treturn\n\t\t}\n\n\t\tthis.editor.setSelectedShapes([this.shapeId])\n\t}\n\n\toverride onExit() {\n\t\tthis.parent.setCurrentToolIdMask(undefined)\n\n\t\tthis.editor.setCursor({ type: 'default', rotation: 0 })\n\t}\n\n\tprivate _labelDragOffset = new Vec(0, 0)\n\n\toverride onPointerMove() {\n\t\tconst { isDragging } = this.editor.inputs\n\t\tif (!isDragging) return\n\n\t\tif (this.didCtrlOnEnter) {\n\t\t\tthis.parent.transition('brushing', this.info)\n\t\t\treturn\n\t\t}\n\n\t\tconst shape = this.editor.getShape<TLArrowShape>(this.shapeId)\n\t\tif (!shape) return\n\n\t\tconst options = this.editor.getShapeUtil<ArrowShapeUtil>('arrow').options\n\t\tconst geometry = getArrowBodyGeometry(this.editor, shape)\n\t\tconst transform = this.editor.getShapePageTransform(shape.id)\n\n\t\tconst pointInShapeSpace = this.editor\n\t\t\t.getPointInShapeSpace(shape, this.editor.inputs.currentPagePoint)\n\t\t\t.add(this._labelDragOffset)\n\n\t\tconst defaultLabelPosition = getArrowLabelDefaultPosition(this.editor, shape)\n\n\t\tlet nextLabelPosition = geometry.uninterpolateAlongEdge(pointInShapeSpace)\n\n\t\tif (isNaN(nextLabelPosition)) {\n\t\t\tnextLabelPosition = defaultLabelPosition\n\t\t}\n\n\t\tconst nextLabelPoint = transform.applyToPoint(geometry.interpolateAlongEdge(nextLabelPosition))\n\t\tconst labelDefaultPoint = transform.applyToPoint(\n\t\t\tgeometry.interpolateAlongEdge(defaultLabelPosition)\n\t\t)\n\n\t\tif (\n\t\t\tVec.DistMin(\n\t\t\t\tnextLabelPoint,\n\t\t\t\tlabelDefaultPoint,\n\t\t\t\toptions.labelCenterSnapDistance / this.editor.getZoomLevel()\n\t\t\t)\n\t\t) {\n\t\t\tnextLabelPosition = defaultLabelPosition\n\t\t}\n\n\t\tthis.didDrag = true\n\t\tthis.editor.updateShape<TLArrowShape>({\n\t\t\tid: shape.id,\n\t\t\ttype: shape.type,\n\t\t\tprops: { labelPosition: nextLabelPosition },\n\t\t})\n\t}\n\n\toverride onPointerUp() {\n\t\tconst shape = this.editor.getShape<TLArrowShape>(this.shapeId)\n\t\tif (!shape) return\n\n\t\tif (this.didDrag || !this.wasAlreadySelected) {\n\t\t\tthis.complete()\n\t\t} else if (!this.editor.getIsReadonly()) {\n\t\t\t// Go into edit mode.\n\t\t\tthis.editor.setEditingShape(shape.id)\n\t\t\tthis.editor.setCurrentTool('select.editing_shape')\n\t\t}\n\t}\n\n\toverride onCancel() {\n\t\tthis.cancel()\n\t}\n\n\toverride onComplete() {\n\t\tthis.cancel()\n\t}\n\n\toverride onInterrupt() {\n\t\tthis.cancel()\n\t}\n\n\tprivate complete() {\n\t\tif (this.info.onInteractionEnd) {\n\t\t\tthis.editor.setCurrentTool(this.info.onInteractionEnd, {})\n\t\t} else {\n\t\t\tthis.parent.transition('idle')\n\t\t}\n\t}\n\n\tprivate cancel() {\n\t\tthis.editor.bailToMark(this.markId)\n\n\t\tif (this.info.onInteractionEnd) {\n\t\t\tthis.editor.setCurrentTool(this.info.onInteractionEnd, {})\n\t\t} else {\n\t\t\tthis.parent.transition('idle')\n\t\t}\n\t}\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2748, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/SelectTool/childStates/PointingCanvas.ts"],"sourcesContent":["import { StateNode, TLPointerEventInfo } from '@tldraw/editor'\nimport { selectOnCanvasPointerUp } from '../../selection-logic/selectOnCanvasPointerUp'\n\nexport class PointingCanvas extends StateNode {\n\tstatic override id = 'pointing_canvas'\n\n\toverride onEnter(info: TLPointerEventInfo & { target: 'canvas' }) {\n\t\tconst additiveSelectionKey = info.shiftKey || info.accelKey\n\n\t\tif (!additiveSelectionKey) {\n\t\t\tif (this.editor.getSelectedShapeIds().length > 0) {\n\t\t\t\tthis.editor.markHistoryStoppingPoint('selecting none')\n\t\t\t\tthis.editor.selectNone()\n\t\t\t}\n\t\t}\n\t}\n\n\toverride onPointerMove(info: TLPointerEventInfo) {\n\t\tif (this.editor.inputs.isDragging) {\n\t\t\tthis.parent.transition('brushing', info)\n\t\t}\n\t}\n\n\toverride onPointerUp(info: TLPointerEventInfo) {\n\t\t// todo: also make this deselect\n\t\tselectOnCanvasPointerUp(this.editor, info)\n\t\tthis.complete()\n\t}\n\n\toverride onComplete() {\n\t\tthis.complete()\n\t}\n\n\toverride onInterrupt() {\n\t\tthis.parent.transition('idle')\n\t}\n\n\tprivate complete() {\n\t\tthis.parent.transition('idle')\n\t}\n}\n"],"names":[],"mappings":";;;AAAA,SAAS,iBAAqC;;AAC9C,SAAS,+BAA+B;;;AAEjC,MAAM,oNAAuB,YAAA,CAAU;IAC7C,OAAgB,KAAK,kBAAA;IAEZ,QAAQ,IAAA,EAAiD;QACjE,MAAM,uBAAuB,KAAK,QAAA,IAAY,KAAK,QAAA;QAEnD,IAAI,CAAC,sBAAsB;YAC1B,IAAI,IAAA,CAAK,MAAA,CAAO,mBAAA,CAAoB,EAAE,MAAA,GAAS,GAAG;gBACjD,IAAA,CAAK,MAAA,CAAO,wBAAA,CAAyB,gBAAgB;gBACrD,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW;YACxB;QACD;IACD;IAES,cAAc,IAAA,EAA0B;QAChD,IAAI,IAAA,CAAK,MAAA,CAAO,MAAA,CAAO,UAAA,EAAY;YAClC,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,YAAY,IAAI;QACxC;IACD;IAES,YAAY,IAAA,EAA0B;QAE9C,CAAA,GAAA,0MAAA,CAAA,0BAAA,EAAwB,IAAA,CAAK,MAAA,EAAQ,IAAI;QACzC,IAAA,CAAK,QAAA,CAAS;IACf;IAES,aAAa;QACrB,IAAA,CAAK,QAAA,CAAS;IACf;IAES,cAAc;QACtB,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,MAAM;IAC9B;IAEQ,WAAW;QAClB,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,MAAM;IAC9B;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2794, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/SelectTool/childStates/PointingHandle.ts"],"sourcesContent":["import {\n\tEditor,\n\tStateNode,\n\tTLArrowShape,\n\tTLHandle,\n\tTLNoteShape,\n\tTLPointerEventInfo,\n\tVec,\n} from '@tldraw/editor'\nimport { updateArrowTargetState } from '../../../shapes/arrow/arrowTargetState'\nimport { getArrowBindings } from '../../../shapes/arrow/shared'\nimport {\n\tNOTE_CENTER_OFFSET,\n\tgetNoteAdjacentPositions,\n\tgetNoteShapeForAdjacentPosition,\n} from '../../../shapes/note/noteHelpers'\nimport { startEditingShapeWithLabel } from '../selectHelpers'\n\nexport class PointingHandle extends StateNode {\n\tstatic override id = 'pointing_handle'\n\n\tdidCtrlOnEnter = false\n\n\tinfo = {} as TLPointerEventInfo & { target: 'handle' }\n\n\toverride onEnter(info: TLPointerEventInfo & { target: 'handle' }) {\n\t\tthis.info = info\n\n\t\tthis.didCtrlOnEnter = info.accelKey\n\n\t\tconst { shape } = info\n\t\tif (this.editor.isShapeOfType<TLArrowShape>(shape, 'arrow')) {\n\t\t\tconst initialBindings = getArrowBindings(this.editor, shape)\n\t\t\tconst currentBinding = initialBindings[info.handle.id as 'start' | 'end']\n\t\t\tconst oppositeBinding = initialBindings[info.handle.id === 'start' ? 'end' : 'start']\n\t\t\tconst arrowTransform = this.editor.getShapePageTransform(shape.id)!\n\n\t\t\tif (currentBinding) {\n\t\t\t\tupdateArrowTargetState({\n\t\t\t\t\teditor: this.editor,\n\t\t\t\t\tpointInPageSpace: arrowTransform.applyToPoint(info.handle),\n\t\t\t\t\tarrow: shape,\n\t\t\t\t\tisPrecise: currentBinding.props.isPrecise,\n\t\t\t\t\tcurrentBinding: currentBinding,\n\t\t\t\t\toppositeBinding: oppositeBinding,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\tthis.editor.setCursor({ type: 'grabbing', rotation: 0 })\n\t}\n\n\toverride onExit() {\n\t\tthis.editor.setHintingShapes([])\n\t\tthis.editor.setCursor({ type: 'default', rotation: 0 })\n\t}\n\n\toverride onPointerUp() {\n\t\tconst { shape, handle } = this.info\n\n\t\tif (this.editor.isShapeOfType<TLNoteShape>(shape, 'note')) {\n\t\t\tconst { editor } = this\n\t\t\tconst nextNote = getNoteForAdjacentPosition(editor, shape, handle, false)\n\t\t\tif (nextNote) {\n\t\t\t\tstartEditingShapeWithLabel(editor, nextNote, true /* selectAll */)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tthis.parent.transition('idle', this.info)\n\t}\n\n\toverride onPointerMove(info: TLPointerEventInfo) {\n\t\tconst { editor } = this\n\t\tif (editor.inputs.isDragging) {\n\t\t\tif (this.didCtrlOnEnter) {\n\t\t\t\tthis.parent.transition('brushing', info)\n\t\t\t} else {\n\t\t\t\tthis.startDraggingHandle()\n\t\t\t}\n\t\t}\n\t}\n\n\toverride onLongPress() {\n\t\tthis.startDraggingHandle()\n\t}\n\n\tprivate startDraggingHandle() {\n\t\tconst { editor } = this\n\t\tif (editor.getIsReadonly()) return\n\t\tconst { shape, handle } = this.info\n\n\t\tif (editor.isShapeOfType<TLNoteShape>(shape, 'note')) {\n\t\t\tconst nextNote = getNoteForAdjacentPosition(editor, shape, handle, true)\n\t\t\tif (nextNote) {\n\t\t\t\t// Center the shape on the current pointer\n\t\t\t\tconst centeredOnPointer = editor\n\t\t\t\t\t.getPointInParentSpace(nextNote, editor.inputs.originPagePoint)\n\t\t\t\t\t.sub(Vec.Rot(NOTE_CENTER_OFFSET.clone().mul(shape.props.scale), nextNote.rotation))\n\t\t\t\teditor.updateShape({ ...nextNote, x: centeredOnPointer.x, y: centeredOnPointer.y })\n\n\t\t\t\t// Then select and begin translating the shape\n\t\t\t\teditor\n\t\t\t\t\t.setHoveredShape(nextNote.id) // important!\n\t\t\t\t\t.select(nextNote.id)\n\t\t\t\t\t.setCurrentTool('select.translating', {\n\t\t\t\t\t\t...this.info,\n\t\t\t\t\t\ttarget: 'shape',\n\t\t\t\t\t\tshape: editor.getShape(nextNote),\n\t\t\t\t\t\tonInteractionEnd: 'note',\n\t\t\t\t\t\tisCreating: true,\n\t\t\t\t\t\tonCreate: () => {\n\t\t\t\t\t\t\t// When we're done, start editing it\n\t\t\t\t\t\t\tstartEditingShapeWithLabel(editor, nextNote, true /* selectAll */)\n\t\t\t\t\t\t},\n\t\t\t\t\t})\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tthis.parent.transition('dragging_handle', this.info)\n\t}\n\n\toverride onCancel() {\n\t\tthis.cancel()\n\t}\n\n\toverride onComplete() {\n\t\tthis.cancel()\n\t}\n\n\toverride onInterrupt() {\n\t\tthis.cancel()\n\t}\n\n\tprivate cancel() {\n\t\tthis.parent.transition('idle')\n\t}\n}\n\nfunction getNoteForAdjacentPosition(\n\teditor: Editor,\n\tshape: TLNoteShape,\n\thandle: TLHandle,\n\tforceNew: boolean\n) {\n\tconst pageTransform = editor.getShapePageTransform(shape.id)!\n\tconst pagePoint = pageTransform.point()\n\tconst pageRotation = pageTransform.rotation()\n\tconst positions = getNoteAdjacentPositions(\n\t\teditor,\n\t\tpagePoint,\n\t\tpageRotation,\n\t\tshape.props.growY * shape.props.scale,\n\t\t0,\n\t\tshape.props.scale\n\t)\n\tconst position = positions[handle.index]\n\tif (position) {\n\t\treturn getNoteShapeForAdjacentPosition(editor, shape, position, pageRotation, forceNew)\n\t}\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2929, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/SelectTool/childStates/PointingRotateHandle.ts"],"sourcesContent":["import { RotateCorner, StateNode, TLPointerEventInfo } from '@tldraw/editor'\nimport { CursorTypeMap } from './PointingResizeHandle'\n\ntype PointingRotateHandleInfo = Extract<TLPointerEventInfo, { target: 'selection' }> & {\n\tonInteractionEnd?: string\n}\n\nexport class PointingRotateHandle extends StateNode {\n\tstatic override id = 'pointing_rotate_handle'\n\n\tprivate info = {} as PointingRotateHandleInfo\n\n\tprivate updateCursor() {\n\t\tthis.editor.setCursor({\n\t\t\ttype: CursorTypeMap[this.info.handle as RotateCorner],\n\t\t\trotation: this.editor.getSelectionRotation(),\n\t\t})\n\t}\n\n\toverride onEnter(info: PointingRotateHandleInfo) {\n\t\tthis.parent.setCurrentToolIdMask(info.onInteractionEnd)\n\t\tthis.info = info\n\t\tthis.updateCursor()\n\t}\n\n\toverride onExit() {\n\t\tthis.parent.setCurrentToolIdMask(undefined)\n\t\tthis.editor.setCursor({ type: 'default', rotation: 0 })\n\t}\n\n\toverride onPointerMove() {\n\t\tif (this.editor.inputs.isDragging) {\n\t\t\tthis.startRotating()\n\t\t}\n\t}\n\n\toverride onLongPress() {\n\t\tthis.startRotating()\n\t}\n\n\tprivate startRotating() {\n\t\tif (this.editor.getIsReadonly()) return\n\t\tthis.parent.transition('rotating', this.info)\n\t}\n\n\toverride onPointerUp() {\n\t\tthis.complete()\n\t}\n\n\toverride onCancel() {\n\t\tthis.cancel()\n\t}\n\n\toverride onComplete() {\n\t\tthis.cancel()\n\t}\n\n\toverride onInterrupt() {\n\t\tthis.cancel()\n\t}\n\n\tprivate complete() {\n\t\tif (this.info.onInteractionEnd) {\n\t\t\tthis.editor.setCurrentTool(this.info.onInteractionEnd, {})\n\t\t} else {\n\t\t\tthis.parent.transition('idle')\n\t\t}\n\t}\n\n\tprivate cancel() {\n\t\tif (this.info.onInteractionEnd) {\n\t\t\tthis.editor.setCurrentTool(this.info.onInteractionEnd, {})\n\t\t} else {\n\t\t\tthis.parent.transition('idle')\n\t\t}\n\t}\n}\n"],"names":[],"mappings":";;;;AAAA,SAAuB,iBAAqC;AAC5D,SAAS,qBAAqB;;;AAMvB,MAAM,0NAA6B,YAAA,CAAU;IACnD,OAAgB,KAAK,yBAAA;IAEb,OAAO,CAAC,EAAA;IAER,eAAe;QACtB,IAAA,CAAK,MAAA,CAAO,SAAA,CAAU;YACrB,qNAAM,gBAAA,CAAc,IAAA,CAAK,IAAA,CAAK,MAAsB,CAAA;YACpD,UAAU,IAAA,CAAK,MAAA,CAAO,oBAAA,CAAqB;QAC5C,CAAC;IACF;IAES,QAAQ,IAAA,EAAgC;QAChD,IAAA,CAAK,MAAA,CAAO,oBAAA,CAAqB,KAAK,gBAAgB;QACtD,IAAA,CAAK,IAAA,GAAO;QACZ,IAAA,CAAK,YAAA,CAAa;IACnB;IAES,SAAS;QACjB,IAAA,CAAK,MAAA,CAAO,oBAAA,CAAqB,KAAA,CAAS;QAC1C,IAAA,CAAK,MAAA,CAAO,SAAA,CAAU;YAAE,MAAM;YAAW,UAAU;QAAE,CAAC;IACvD;IAES,gBAAgB;QACxB,IAAI,IAAA,CAAK,MAAA,CAAO,MAAA,CAAO,UAAA,EAAY;YAClC,IAAA,CAAK,aAAA,CAAc;QACpB;IACD;IAES,cAAc;QACtB,IAAA,CAAK,aAAA,CAAc;IACpB;IAEQ,gBAAgB;QACvB,IAAI,IAAA,CAAK,MAAA,CAAO,aAAA,CAAc,EAAG,CAAA;QACjC,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,YAAY,IAAA,CAAK,IAAI;IAC7C;IAES,cAAc;QACtB,IAAA,CAAK,QAAA,CAAS;IACf;IAES,WAAW;QACnB,IAAA,CAAK,MAAA,CAAO;IACb;IAES,aAAa;QACrB,IAAA,CAAK,MAAA,CAAO;IACb;IAES,cAAc;QACtB,IAAA,CAAK,MAAA,CAAO;IACb;IAEQ,WAAW;QAClB,IAAI,IAAA,CAAK,IAAA,CAAK,gBAAA,EAAkB;YAC/B,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,IAAA,CAAK,IAAA,CAAK,gBAAA,EAAkB,CAAC,CAAC;QAC1D,OAAO;YACN,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,MAAM;QAC9B;IACD;IAEQ,SAAS;QAChB,IAAI,IAAA,CAAK,IAAA,CAAK,gBAAA,EAAkB;YAC/B,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,IAAA,CAAK,IAAA,CAAK,gBAAA,EAAkB,CAAC,CAAC;QAC1D,OAAO;YACN,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,MAAM;QAC9B;IACD;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3005, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/SelectTool/childStates/PointingSelection.ts"],"sourcesContent":["import { StateNode, TLClickEventInfo, TLGroupShape, TLPointerEventInfo } from '@tldraw/editor'\nimport { selectOnCanvasPointerUp } from '../../selection-logic/selectOnCanvasPointerUp'\n\nexport class PointingSelection extends StateNode {\n\tstatic override id = 'pointing_selection'\n\n\tinfo = {} as TLPointerEventInfo & {\n\t\ttarget: 'selection'\n\t}\n\n\toverride onEnter(info: TLPointerEventInfo & { target: 'selection' }) {\n\t\tthis.info = info\n\t}\n\n\toverride onPointerUp(info: TLPointerEventInfo) {\n\t\tselectOnCanvasPointerUp(this.editor, info)\n\t\tthis.parent.transition('idle', info)\n\t}\n\n\toverride onPointerMove(info: TLPointerEventInfo) {\n\t\tif (this.editor.inputs.isDragging) {\n\t\t\tthis.startTranslating(info)\n\t\t}\n\t}\n\n\toverride onLongPress(info: TLPointerEventInfo) {\n\t\tthis.startTranslating(info)\n\t}\n\n\tprivate startTranslating(info: TLPointerEventInfo) {\n\t\tif (this.editor.getIsReadonly()) return\n\t\tthis.parent.transition('translating', info)\n\t}\n\n\toverride onDoubleClick?(info: TLClickEventInfo) {\n\t\tconst hoveredShape = this.editor.getHoveredShape()\n\t\tconst hitShape =\n\t\t\thoveredShape && !this.editor.isShapeOfType<TLGroupShape>(hoveredShape, 'group')\n\t\t\t\t? hoveredShape\n\t\t\t\t: this.editor.getShapeAtPoint(this.editor.inputs.currentPagePoint, {\n\t\t\t\t\t\thitInside: true,\n\t\t\t\t\t\tmargin: 0,\n\t\t\t\t\t\trenderingOnly: true,\n\t\t\t\t\t})\n\n\t\tif (hitShape) {\n\t\t\t// todo: extract the double click shape logic from idle so that we can share it here\n\t\t\tthis.parent.transition('idle')\n\t\t\tthis.parent.onDoubleClick?.({\n\t\t\t\t...info,\n\t\t\t\ttarget: 'shape',\n\t\t\t\tshape: this.editor.getShape(hitShape)!,\n\t\t\t})\n\t\t\treturn\n\t\t}\n\t}\n\n\toverride onCancel() {\n\t\tthis.cancel()\n\t}\n\n\toverride onComplete() {\n\t\tthis.cancel()\n\t}\n\n\toverride onInterrupt() {\n\t\tthis.cancel()\n\t}\n\n\tprivate cancel() {\n\t\tthis.parent.transition('idle')\n\t}\n}\n"],"names":[],"mappings":";;;AAAA,SAAS,iBAAqE;;AAC9E,SAAS,+BAA+B;;;AAEjC,MAAM,uNAA0B,YAAA,CAAU;IAChD,OAAgB,KAAK,qBAAA;IAErB,OAAO,CAAC,EAAA;IAIC,QAAQ,IAAA,EAAoD;QACpE,IAAA,CAAK,IAAA,GAAO;IACb;IAES,YAAY,IAAA,EAA0B;QAC9C,CAAA,GAAA,0MAAA,CAAA,0BAAA,EAAwB,IAAA,CAAK,MAAA,EAAQ,IAAI;QACzC,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,QAAQ,IAAI;IACpC;IAES,cAAc,IAAA,EAA0B;QAChD,IAAI,IAAA,CAAK,MAAA,CAAO,MAAA,CAAO,UAAA,EAAY;YAClC,IAAA,CAAK,gBAAA,CAAiB,IAAI;QAC3B;IACD;IAES,YAAY,IAAA,EAA0B;QAC9C,IAAA,CAAK,gBAAA,CAAiB,IAAI;IAC3B;IAEQ,iBAAiB,IAAA,EAA0B;QAClD,IAAI,IAAA,CAAK,MAAA,CAAO,aAAA,CAAc,EAAG,CAAA;QACjC,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,eAAe,IAAI;IAC3C;IAES,cAAe,IAAA,EAAwB;QAC/C,MAAM,eAAe,IAAA,CAAK,MAAA,CAAO,eAAA,CAAgB;QACjD,MAAM,WACL,gBAAgB,CAAC,IAAA,CAAK,MAAA,CAAO,aAAA,CAA4B,cAAc,OAAO,IAC3E,eACA,IAAA,CAAK,MAAA,CAAO,eAAA,CAAgB,IAAA,CAAK,MAAA,CAAO,MAAA,CAAO,gBAAA,EAAkB;YACjE,WAAW;YACX,QAAQ;YACR,eAAe;QAChB,CAAC;QAEJ,IAAI,UAAU;YAEb,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,MAAM;YAC7B,IAAA,CAAK,MAAA,CAAO,aAAA,GAAgB;gBAC3B,GAAG,IAAA;gBACH,QAAQ;gBACR,OAAO,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,QAAQ;YACrC,CAAC;YACD;QACD;IACD;IAES,WAAW;QACnB,IAAA,CAAK,MAAA,CAAO;IACb;IAES,aAAa;QACrB,IAAA,CAAK,MAAA,CAAO;IACb;IAES,cAAc;QACtB,IAAA,CAAK,MAAA,CAAO;IACb;IAEQ,SAAS;QAChB,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,MAAM;IAC9B;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3073, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/SelectTool/childStates/PointingShape.ts"],"sourcesContent":["import { StateNode, TLPointerEventInfo, TLShape } from '@tldraw/editor'\nimport { getTextLabels } from '../../../utils/shapes/shapes'\n\nexport class PointingShape extends StateNode {\n\tstatic override id = 'pointing_shape'\n\n\thitShape = {} as TLShape\n\thitShapeForPointerUp = {} as TLShape\n\tisDoubleClick = false\n\n\tdidCtrlOnEnter = false\n\tdidSelectOnEnter = false\n\n\toverride onEnter(info: TLPointerEventInfo & { target: 'shape' }) {\n\t\tconst selectedShapeIds = this.editor.getSelectedShapeIds()\n\t\tconst selectionBounds = this.editor.getSelectionRotatedPageBounds()\n\t\tconst focusedGroupId = this.editor.getFocusedGroupId()\n\t\tconst {\n\t\t\tinputs: { currentPagePoint },\n\t\t} = this.editor\n\t\tconst { shiftKey, altKey, accelKey } = info\n\n\t\tthis.hitShape = info.shape\n\t\tthis.isDoubleClick = false\n\t\tthis.didCtrlOnEnter = accelKey\n\t\tconst outermostSelectingShape = this.editor.getOutermostSelectableShape(info.shape)\n\t\tconst selectedAncestor = this.editor.findShapeAncestor(outermostSelectingShape, (parent) =>\n\t\t\tselectedShapeIds.includes(parent.id)\n\t\t)\n\n\t\tif (\n\t\t\tthis.didCtrlOnEnter ||\n\t\t\t// If the shape has an onClick handler\n\t\t\tthis.editor.getShapeUtil(info.shape).onClick ||\n\t\t\t// ...or if the shape is the focused layer (e.g. group)\n\t\t\toutermostSelectingShape.id === focusedGroupId ||\n\t\t\t// ...or if the shape is within the selection\n\t\t\tselectedShapeIds.includes(outermostSelectingShape.id) ||\n\t\t\t// ...or if an ancestor of the shape is selected\n\t\t\tselectedAncestor ||\n\t\t\t// ...or if the current point is NOT within the selection bounds\n\t\t\t(selectedShapeIds.length > 1 && selectionBounds?.containsPoint(currentPagePoint))\n\t\t) {\n\t\t\t// We won't select the shape on enter, though we might select it on pointer up!\n\t\t\tthis.didSelectOnEnter = false\n\t\t\tthis.hitShapeForPointerUp = outermostSelectingShape\n\t\t\treturn\n\t\t}\n\n\t\tthis.didSelectOnEnter = true\n\n\t\tif (shiftKey && !altKey) {\n\t\t\tthis.editor.cancelDoubleClick()\n\t\t\tif (!selectedShapeIds.includes(outermostSelectingShape.id)) {\n\t\t\t\tthis.editor.markHistoryStoppingPoint('shift selecting shape')\n\t\t\t\tthis.editor.setSelectedShapes([...selectedShapeIds, outermostSelectingShape.id])\n\t\t\t}\n\t\t} else {\n\t\t\tthis.editor.markHistoryStoppingPoint('selecting shape')\n\t\t\tthis.editor.setSelectedShapes([outermostSelectingShape.id])\n\t\t}\n\t}\n\n\toverride onPointerUp(info: TLPointerEventInfo) {\n\t\tconst selectedShapeIds = this.editor.getSelectedShapeIds()\n\t\tconst focusedGroupId = this.editor.getFocusedGroupId()\n\t\tconst zoomLevel = this.editor.getZoomLevel()\n\t\tconst {\n\t\t\tinputs: { currentPagePoint },\n\t\t} = this.editor\n\n\t\tconst additiveSelectionKey = info.shiftKey || info.accelKey\n\n\t\tconst hitShape =\n\t\t\tthis.editor.getShapeAtPoint(currentPagePoint, {\n\t\t\t\tmargin: this.editor.options.hitTestMargin / zoomLevel,\n\t\t\t\thitInside: true,\n\t\t\t\trenderingOnly: true,\n\t\t\t}) ?? this.hitShape\n\n\t\tconst selectingShape = hitShape\n\t\t\t? this.editor.getOutermostSelectableShape(hitShape)\n\t\t\t: this.hitShapeForPointerUp\n\n\t\tif (selectingShape) {\n\t\t\t// If the selecting shape has a click handler, call it instead of selecting the shape\n\t\t\tconst util = this.editor.getShapeUtil(selectingShape)\n\t\t\tif (util.onClick) {\n\t\t\t\tconst change = util.onClick?.(selectingShape)\n\t\t\t\tif (change) {\n\t\t\t\t\tthis.editor.markHistoryStoppingPoint('shape on click')\n\t\t\t\t\tthis.editor.updateShapes([change])\n\t\t\t\t\tthis.parent.transition('idle', info)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (selectingShape.id === focusedGroupId) {\n\t\t\t\tif (selectedShapeIds.length > 0) {\n\t\t\t\t\tthis.editor.markHistoryStoppingPoint('clearing shape ids')\n\t\t\t\t\tthis.editor.setSelectedShapes([])\n\t\t\t\t} else {\n\t\t\t\t\tthis.editor.popFocusedGroupId()\n\t\t\t\t}\n\t\t\t\tthis.parent.transition('idle', info)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif (!this.didSelectOnEnter) {\n\t\t\t// if the shape has an ancestor which is a focusable layer and it is not focused but it is selected\n\t\t\t// then we should focus the layer and select the shape\n\n\t\t\tconst outermostSelectableShape = this.editor.getOutermostSelectableShape(\n\t\t\t\thitShape,\n\t\t\t\t// if a group is selected, we want to stop before reaching that group\n\t\t\t\t// so we can drill down into the group\n\t\t\t\t(parent) => !selectedShapeIds.includes(parent.id)\n\t\t\t)\n\n\t\t\t// If the outermost shape is selected, then either select or deselect the SELECTING shape\n\t\t\tif (selectedShapeIds.includes(outermostSelectableShape.id)) {\n\t\t\t\t// same shape, so deselect it if shift is pressed, otherwise deselect all others\n\t\t\t\tif (additiveSelectionKey) {\n\t\t\t\t\tthis.editor.markHistoryStoppingPoint('deselecting on pointer up')\n\t\t\t\t\tthis.editor.deselect(selectingShape)\n\t\t\t\t} else {\n\t\t\t\t\tif (selectedShapeIds.includes(selectingShape.id)) {\n\t\t\t\t\t\t// todo\n\t\t\t\t\t\t// if the shape is editable and we're inside of an editable part of that shape, e.g. the label of a geo shape,\n\t\t\t\t\t\t// then we would want to begin editing the shape. At the moment we're relying on the shape label's onPointerUp\n\t\t\t\t\t\t// handler to do this logic, and prevent the regular pointer up event, so we won't be here in that case.\n\n\t\t\t\t\t\t// if the shape has a text label, and we're inside of the label, then we want to begin editing the label.\n\t\t\t\t\t\tif (selectedShapeIds.length === 1) {\n\t\t\t\t\t\t\tconst geometry = this.editor.getShapeUtil(selectingShape).getGeometry(selectingShape)\n\t\t\t\t\t\t\tconst textLabels = getTextLabels(geometry)\n\t\t\t\t\t\t\tconst textLabel = textLabels.length === 1 ? textLabels[0] : undefined\n\t\t\t\t\t\t\t// N.B. we're only interested if there is exactly one text label. We don't handle the\n\t\t\t\t\t\t\t// case if there's potentially more than one text label at the moment.\n\t\t\t\t\t\t\tif (textLabel) {\n\t\t\t\t\t\t\t\tconst pointInShapeSpace = this.editor.getPointInShapeSpace(\n\t\t\t\t\t\t\t\t\tselectingShape,\n\t\t\t\t\t\t\t\t\tcurrentPagePoint\n\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\ttextLabel.bounds.containsPoint(pointInShapeSpace, 0) &&\n\t\t\t\t\t\t\t\t\ttextLabel.hitTestPoint(pointInShapeSpace)\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tthis.editor.run(() => {\n\t\t\t\t\t\t\t\t\t\tthis.editor.markHistoryStoppingPoint('editing on pointer up')\n\t\t\t\t\t\t\t\t\t\tthis.editor.select(selectingShape.id)\n\n\t\t\t\t\t\t\t\t\t\tconst util = this.editor.getShapeUtil(selectingShape)\n\t\t\t\t\t\t\t\t\t\tif (this.editor.getIsReadonly()) {\n\t\t\t\t\t\t\t\t\t\t\tif (!util.canEditInReadonly(selectingShape)) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tthis.editor.setEditingShape(selectingShape.id)\n\t\t\t\t\t\t\t\t\t\tthis.editor.setCurrentTool('select.editing_shape')\n\n\t\t\t\t\t\t\t\t\t\tif (this.isDoubleClick) {\n\t\t\t\t\t\t\t\t\t\t\tthis.editor.emit('select-all-text', { shapeId: selectingShape.id })\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tthis.editor.emit('place-caret', {\n\t\t\t\t\t\t\t\t\t\t\t\tshapeId: selectingShape.id,\n\t\t\t\t\t\t\t\t\t\t\t\tpoint: info.point,\n\t\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// We just want to select the single shape from the selection\n\t\t\t\t\t\tthis.editor.markHistoryStoppingPoint('selecting on pointer up')\n\t\t\t\t\t\tthis.editor.select(selectingShape.id)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.editor.markHistoryStoppingPoint('selecting on pointer up')\n\t\t\t\t\t\tthis.editor.select(selectingShape)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (additiveSelectionKey) {\n\t\t\t\t// Different shape, so we are drilling down into a group with shift key held.\n\t\t\t\t// Deselect any ancestors and add the target shape to the selection\n\t\t\t\tconst ancestors = this.editor.getShapeAncestors(outermostSelectableShape)\n\n\t\t\t\tthis.editor.markHistoryStoppingPoint('shift deselecting on pointer up')\n\t\t\t\tthis.editor.setSelectedShapes([\n\t\t\t\t\t...this.editor.getSelectedShapeIds().filter((id) => !ancestors.find((a) => a.id === id)),\n\t\t\t\t\toutermostSelectableShape.id,\n\t\t\t\t])\n\t\t\t} else {\n\t\t\t\tthis.editor.markHistoryStoppingPoint('selecting on pointer up')\n\t\t\t\t// different shape and we are drilling down, but no shift held so just select it straight up\n\t\t\t\tthis.editor.setSelectedShapes([outermostSelectableShape.id])\n\t\t\t}\n\t\t}\n\n\t\tthis.parent.transition('idle', info)\n\t}\n\n\toverride onDoubleClick() {\n\t\tthis.isDoubleClick = true\n\t}\n\n\toverride onPointerMove(info: TLPointerEventInfo) {\n\t\tif (this.editor.inputs.isDragging) {\n\t\t\tif (this.didCtrlOnEnter) {\n\t\t\t\tthis.parent.transition('brushing', info)\n\t\t\t} else {\n\t\t\t\tthis.startTranslating(info)\n\t\t\t}\n\t\t}\n\t}\n\n\toverride onLongPress(info: TLPointerEventInfo) {\n\t\tthis.startTranslating(info)\n\t}\n\n\tprivate startTranslating(info: TLPointerEventInfo) {\n\t\tif (this.editor.getIsReadonly()) return\n\n\t\t// Re-focus the editor, just in case the text label of the shape has stolen focus\n\t\tthis.editor.focus()\n\t\tthis.parent.transition('translating', info)\n\t}\n\n\toverride onCancel() {\n\t\tthis.cancel()\n\t}\n\toverride onComplete() {\n\t\tthis.cancel()\n\t}\n\n\toverride onInterrupt() {\n\t\tthis.cancel()\n\t}\n\n\tprivate cancel() {\n\t\tthis.parent.transition('idle')\n\t}\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3269, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/SelectTool/childStates/Resizing.ts"],"sourcesContent":["import {\n\tBox,\n\tHALF_PI,\n\tMat,\n\tPI,\n\tPI2,\n\tSelectionCorner,\n\tSelectionEdge,\n\tStateNode,\n\tTLFrameShape,\n\tTLPointerEventInfo,\n\tTLShape,\n\tTLShapeId,\n\tTLShapePartial,\n\tTLTextShape,\n\tTLTickEventInfo,\n\tVec,\n\tVecLike,\n\tareAnglesCompatible,\n\tcompact,\n\tisAccelKey,\n\tkickoutOccludedShapes,\n} from '@tldraw/editor'\n\nexport type ResizingInfo = TLPointerEventInfo & {\n\ttarget: 'selection'\n\thandle: SelectionEdge | SelectionCorner\n\tisCreating?: boolean\n\tcreatingMarkId?: string\n\tonCreate?(shape: TLShape | null): void\n\tcreationCursorOffset?: VecLike\n\tonInteractionEnd?: string\n}\n\nexport class Resizing extends StateNode {\n\tstatic override id = 'resizing'\n\n\tinfo = {} as ResizingInfo\n\n\tmarkId = ''\n\n\t// A switch to detect when the user is holding ctrl\n\tprivate didHoldCommand = false\n\n\t// we transition into the resizing state from the geo pointing state, which starts with a shape of size w: 1, h: 1,\n\t// so if the user drags x: +50, y: +50 after mouseDown, the shape will be w: 51, h: 51, which is too many pixels, alas\n\t// so we allow passing a further offset into this state to negate such issues\n\tcreationCursorOffset = { x: 0, y: 0 } as VecLike\n\n\tprivate snapshot = {} as any as Snapshot\n\n\toverride onEnter(info: ResizingInfo) {\n\t\tconst { isCreating = false, creatingMarkId, creationCursorOffset = { x: 0, y: 0 } } = info\n\n\t\tthis.info = info\n\t\tthis.didHoldCommand = false\n\n\t\tthis.parent.setCurrentToolIdMask(info.onInteractionEnd)\n\t\tthis.creationCursorOffset = creationCursorOffset\n\n\t\ttry {\n\t\t\t// On rare and mysterious occasions, the user can enter the resizing state with no shapes selected\n\t\t\tthis.snapshot = this._createSnapshot()\n\t\t} catch (e) {\n\t\t\tconsole.error(e)\n\t\t\tthis.cancel()\n\t\t\treturn\n\t\t}\n\n\t\tthis.markId = ''\n\n\t\tif (isCreating) {\n\t\t\tif (creatingMarkId) {\n\t\t\t\tthis.markId = creatingMarkId\n\t\t\t} else {\n\t\t\t\t// handle legacy implicit `creating:{shapeId}` marks\n\t\t\t\tconst markId = this.editor.getMarkIdMatching(\n\t\t\t\t\t`creating:${this.editor.getOnlySelectedShapeId()}`\n\t\t\t\t)\n\t\t\t\tif (markId) {\n\t\t\t\t\tthis.markId = markId\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthis.markId = this.editor.markHistoryStoppingPoint('starting resizing')\n\t\t}\n\n\t\tif (isCreating) {\n\t\t\tthis.editor.setCursor({ type: 'cross', rotation: 0 })\n\t\t}\n\n\t\tthis.handleResizeStart()\n\t\tthis.updateShapes()\n\t}\n\n\toverride onTick({ elapsed }: TLTickEventInfo) {\n\t\tconst { editor } = this\n\t\teditor.edgeScrollManager.updateEdgeScrolling(elapsed)\n\t}\n\n\toverride onPointerMove() {\n\t\tthis.updateShapes()\n\t}\n\n\toverride onKeyDown() {\n\t\tthis.updateShapes()\n\t}\n\toverride onKeyUp() {\n\t\tthis.updateShapes()\n\t}\n\n\toverride onPointerUp() {\n\t\tthis.complete()\n\t}\n\n\toverride onComplete() {\n\t\tthis.complete()\n\t}\n\n\toverride onCancel() {\n\t\tthis.cancel()\n\t}\n\n\tprivate cancel() {\n\t\t// Call onResizeCancel callback before resetting\n\t\tconst { shapeSnapshots } = this.snapshot\n\n\t\tshapeSnapshots.forEach(({ shape }) => {\n\t\t\tconst current = this.editor.getShape(shape.id)\n\t\t\tif (current) {\n\t\t\t\tconst util = this.editor.getShapeUtil(shape)\n\t\t\t\tutil.onResizeCancel?.(shape, current)\n\t\t\t}\n\t\t})\n\n\t\tthis.editor.bailToMark(this.markId)\n\n\t\tif (this.info.onInteractionEnd) {\n\t\t\tthis.editor.setCurrentTool(this.info.onInteractionEnd, {})\n\t\t} else {\n\t\t\tthis.parent.transition('idle')\n\t\t}\n\t}\n\n\tprivate complete() {\n\t\tkickoutOccludedShapes(this.editor, this.snapshot.selectedShapeIds)\n\n\t\tthis.handleResizeEnd()\n\n\t\tif (this.info.isCreating && this.info.onCreate) {\n\t\t\tthis.info.onCreate?.(this.editor.getOnlySelectedShape())\n\t\t\treturn\n\t\t}\n\n\t\tif (this.editor.getInstanceState().isToolLocked && this.info.onInteractionEnd) {\n\t\t\tthis.editor.setCurrentTool(this.info.onInteractionEnd, {})\n\t\t\treturn\n\t\t}\n\n\t\tthis.parent.transition('idle')\n\t}\n\n\tprivate handleResizeStart() {\n\t\tconst { shapeSnapshots } = this.snapshot\n\n\t\tconst changes: TLShapePartial[] = []\n\n\t\tshapeSnapshots.forEach(({ shape }) => {\n\t\t\tconst util = this.editor.getShapeUtil(shape)\n\t\t\tconst change = util.onResizeStart?.(shape)\n\t\t\tif (change) {\n\t\t\t\tchanges.push(change)\n\t\t\t}\n\t\t})\n\n\t\tif (changes.length > 0) {\n\t\t\tthis.editor.updateShapes(changes)\n\t\t}\n\t}\n\n\tprivate handleResizeEnd() {\n\t\tconst { shapeSnapshots } = this.snapshot\n\n\t\tconst changes: TLShapePartial[] = []\n\n\t\tshapeSnapshots.forEach(({ shape }) => {\n\t\t\tconst current = this.editor.getShape(shape.id)!\n\t\t\tconst util = this.editor.getShapeUtil(shape)\n\t\t\tconst change = util.onResizeEnd?.(shape, current)\n\t\t\tif (change) {\n\t\t\t\tchanges.push(change)\n\t\t\t}\n\t\t})\n\n\t\tif (changes.length > 0) {\n\t\t\tthis.editor.updateShapes(changes)\n\t\t}\n\t}\n\n\tprivate updateShapes() {\n\t\tconst { altKey, shiftKey } = this.editor.inputs\n\t\tconst {\n\t\t\tframes,\n\t\t\tshapeSnapshots,\n\t\t\tselectionBounds,\n\t\t\tcursorHandleOffset,\n\t\t\tselectedShapeIds,\n\t\t\tselectionRotation,\n\t\t\tcanShapesDeform,\n\t\t} = this.snapshot\n\n\t\tlet isAspectRatioLocked = shiftKey || !canShapesDeform\n\n\t\tif (shapeSnapshots.size === 1) {\n\t\t\tconst onlySnapshot = [...shapeSnapshots.values()][0]!\n\t\t\tif (this.editor.isShapeOfType<TLTextShape>(onlySnapshot.shape, 'text')) {\n\t\t\t\tisAspectRatioLocked = !(this.info.handle === 'left' || this.info.handle === 'right')\n\t\t\t}\n\t\t}\n\n\t\t// first negate the 'cursor handle offset'\n\t\t// we need to do this because we do grid snapping based on the page point of the handle\n\t\t// rather than the page point of the cursor, so it's easier to pretend that the cursor\n\t\t// is really where the handle actually is\n\t\t//\n\t\t// *** Massively zoomed-in diagram of the initial mouseDown ***\n\t\t//\n\t\t//\n\t\t//                         â”‚\n\t\t//                         â”‚\n\t\t//                         â”‚\n\t\t//                         â”‚\n\t\t//                         â”‚\n\t\t//                         â”‚\n\t\t//                         â”‚\n\t\t//                         â”‚corner handle\n\t\t//                     â”Œâ”€â”€â”€â”´â”€â”€â”€â”\n\t\t//   selection         â”‚       â”‚\n\t\t//  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   xâ—„â”€â”€â”¼â”€â”€â”€â”€ drag handle point   â–²\n\t\t//                     â”‚       â”‚                         â”‚\n\t\t//                     â””â”€â”€â”€â”€â”€â”€â”€â”˜                         â”œâ”€ cursorHandleOffset.y\n\t\t//                                                       â”‚\n\t\t//        originPagePointâ”€â”€â”€â”€â”€â”€â”€â–ºxâ”€â”                     â–¼\n\t\t//                               â”‚ â””â”€â”\n\t\t//                               â”‚   â””â”€â”\n\t\t//                               â”‚     â”‚ mouse (sorry)\n\t\t//                               â””â”€â”€â” â”Œâ”˜\n\t\t//                                  â”‚ â”‚\n\t\t//                                  â””â”€â”˜\n\t\t//                         â—„â”€â”€â”¬â”€â”€â–º\n\t\t//                            â”‚\n\t\t//                   cursorHandleOffset.x\n\n\t\tconst isHoldingAccel = isAccelKey(this.editor.inputs)\n\n\t\tconst currentPagePoint = this.editor.inputs.currentPagePoint\n\t\t\t.clone()\n\t\t\t.sub(cursorHandleOffset)\n\t\t\t.sub(this.creationCursorOffset)\n\n\t\tconst originPagePoint = this.editor.inputs.originPagePoint.clone().sub(cursorHandleOffset)\n\n\t\tif (this.editor.getInstanceState().isGridMode && !isHoldingAccel) {\n\t\t\tconst { gridSize } = this.editor.getDocumentSettings()\n\t\t\tcurrentPagePoint.snapToGrid(gridSize)\n\t\t}\n\n\t\tconst dragHandle = this.info.handle as SelectionCorner | SelectionEdge\n\t\tconst scaleOriginHandle = rotateSelectionHandle(dragHandle, Math.PI)\n\n\t\tthis.editor.snaps.clearIndicators()\n\n\t\tconst shouldSnap = this.editor.user.getIsSnapMode() ? !isHoldingAccel : isHoldingAccel\n\n\t\tif (shouldSnap && selectionRotation % HALF_PI === 0) {\n\t\t\tconst { nudge } = this.editor.snaps.shapeBounds.snapResizeShapes({\n\t\t\t\tdragDelta: Vec.Sub(currentPagePoint, originPagePoint),\n\t\t\t\tinitialSelectionPageBounds: this.snapshot.initialSelectionPageBounds,\n\t\t\t\thandle: rotateSelectionHandle(dragHandle, selectionRotation),\n\t\t\t\tisAspectRatioLocked,\n\t\t\t\tisResizingFromCenter: altKey,\n\t\t\t})\n\n\t\t\tcurrentPagePoint.add(nudge)\n\t\t}\n\n\t\t// get the page point of the selection handle opposite to the drag handle\n\t\t// or the center of the selection box if altKey is pressed\n\t\tconst scaleOriginPage = Vec.RotWith(\n\t\t\taltKey ? selectionBounds.center : selectionBounds.getHandlePoint(scaleOriginHandle),\n\t\t\tselectionBounds.point,\n\t\t\tselectionRotation\n\t\t)\n\n\t\t// calculate the scale by measuring the current distance between the drag handle and the scale origin\n\t\t// and dividing by the original distance between the drag handle and the scale origin\n\n\t\t// bug: for edges, the page point doesn't matter, the\n\n\t\tconst distanceFromScaleOriginNow = Vec.Sub(currentPagePoint, scaleOriginPage).rot(\n\t\t\t-selectionRotation\n\t\t)\n\n\t\tconst distanceFromScaleOriginAtStart = Vec.Sub(originPagePoint, scaleOriginPage).rot(\n\t\t\t-selectionRotation\n\t\t)\n\n\t\tconst scale = Vec.DivV(distanceFromScaleOriginNow, distanceFromScaleOriginAtStart)\n\n\t\tif (!Number.isFinite(scale.x)) scale.x = 1\n\t\tif (!Number.isFinite(scale.y)) scale.y = 1\n\n\t\tconst isXLocked = dragHandle === 'top' || dragHandle === 'bottom'\n\t\tconst isYLocked = dragHandle === 'left' || dragHandle === 'right'\n\n\t\t// lock an axis if required\n\t\tif (isAspectRatioLocked) {\n\t\t\tif (isYLocked) {\n\t\t\t\t// holding shift and dragging either the left or the right edge\n\t\t\t\tscale.y = Math.abs(scale.x)\n\t\t\t} else if (isXLocked) {\n\t\t\t\t// holding shift and dragging either the top or the bottom edge\n\t\t\t\tscale.x = Math.abs(scale.y)\n\t\t\t} else if (Math.abs(scale.x) > Math.abs(scale.y)) {\n\t\t\t\t// holding shift and the drag has moved further in the x dimension\n\t\t\t\tscale.y = Math.abs(scale.x) * (scale.y < 0 ? -1 : 1)\n\t\t\t} else {\n\t\t\t\t// holding shift and the drag has moved further in the y dimension\n\t\t\t\tscale.x = Math.abs(scale.y) * (scale.x < 0 ? -1 : 1)\n\t\t\t}\n\t\t} else {\n\t\t\t// not holding shift, but still need to lock axes if dragging an edge\n\t\t\tif (isXLocked) {\n\t\t\t\tscale.x = 1\n\t\t\t}\n\t\t\tif (isYLocked) {\n\t\t\t\tscale.y = 1\n\t\t\t}\n\t\t}\n\n\t\tif (!this.info.isCreating) {\n\t\t\tthis.updateCursor({\n\t\t\t\tdragHandle,\n\t\t\t\tisFlippedX: scale.x < 0,\n\t\t\t\tisFlippedY: scale.y < 0,\n\t\t\t\trotation: selectionRotation,\n\t\t\t})\n\t\t}\n\n\t\tfor (const id of shapeSnapshots.keys()) {\n\t\t\tconst snapshot = shapeSnapshots.get(id)!\n\n\t\t\tthis.editor.resizeShape(id, scale, {\n\t\t\t\tinitialShape: snapshot.shape,\n\t\t\t\tinitialBounds: snapshot.bounds,\n\t\t\t\tinitialPageTransform: snapshot.pageTransform,\n\t\t\t\tdragHandle,\n\t\t\t\tmode:\n\t\t\t\t\tselectedShapeIds.length === 1 && id === selectedShapeIds[0]\n\t\t\t\t\t\t? 'resize_bounds'\n\t\t\t\t\t\t: 'scale_shape',\n\t\t\t\tscaleOrigin: scaleOriginPage,\n\t\t\t\tisAspectRatioLocked,\n\t\t\t\tscaleAxisRotation: selectionRotation,\n\t\t\t\tskipStartAndEndCallbacks: true,\n\t\t\t})\n\t\t}\n\n\t\t// If there's only one shape snapshot and it's a frame and the user is holding ctrl,\n\t\t// then we preserve the position of the frame's children, almost like the user is cropping\n\t\t// the frame rather than resizing it.\n\t\tif (isHoldingAccel) {\n\t\t\tthis.didHoldCommand = true\n\n\t\t\tfor (const { id, children } of frames) {\n\t\t\t\tif (!children.length) continue\n\t\t\t\tconst initial = shapeSnapshots.get(id)!.shape\n\t\t\t\tconst current = this.editor.getShape(id)!\n\t\t\t\tif (!(initial && current)) continue\n\n\t\t\t\tconst dx = current.x - initial.x\n\t\t\t\tconst dy = current.y - initial.y\n\n\t\t\t\tconst delta = new Vec(dx, dy).rot(-initial.rotation)\n\n\t\t\t\tif (delta.x !== 0 || delta.y !== 0) {\n\t\t\t\t\tfor (const child of children) {\n\t\t\t\t\t\tthis.editor.updateShape({\n\t\t\t\t\t\t\tid: child.id,\n\t\t\t\t\t\t\ttype: child.type,\n\t\t\t\t\t\t\tx: child.x - delta.x,\n\t\t\t\t\t\t\ty: child.y - delta.y,\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.didHoldCommand) {\n\t\t\t// If we're no longer holding the command key...\n\t\t\tthis.didHoldCommand = false\n\n\t\t\tfor (const { children } of frames) {\n\t\t\t\tif (!children.length) continue\n\t\t\t\tfor (const child of children) {\n\t\t\t\t\tthis.editor.updateShape({\n\t\t\t\t\t\tid: child.id,\n\t\t\t\t\t\ttype: child.type,\n\t\t\t\t\t\tx: child.x,\n\t\t\t\t\t\ty: child.y,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// ---\n\n\tprivate updateCursor({\n\t\tdragHandle,\n\t\tisFlippedX,\n\t\tisFlippedY,\n\t\trotation,\n\t}: {\n\t\tdragHandle: SelectionCorner | SelectionEdge\n\t\tisFlippedX: boolean\n\t\tisFlippedY: boolean\n\t\trotation: number\n\t}) {\n\t\tconst nextCursor = { ...this.editor.getInstanceState().cursor }\n\n\t\tswitch (dragHandle) {\n\t\t\tcase 'top_left':\n\t\t\tcase 'bottom_right': {\n\t\t\t\tnextCursor.type = 'nwse-resize'\n\t\t\t\tif (isFlippedX !== isFlippedY) {\n\t\t\t\t\tnextCursor.type = 'nesw-resize'\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'top_right':\n\t\t\tcase 'bottom_left': {\n\t\t\t\tnextCursor.type = 'nesw-resize'\n\t\t\t\tif (isFlippedX !== isFlippedY) {\n\t\t\t\t\tnextCursor.type = 'nwse-resize'\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tnextCursor.rotation = rotation\n\n\t\tthis.editor.setCursor(nextCursor)\n\t}\n\n\toverride onExit() {\n\t\tthis.parent.setCurrentToolIdMask(undefined)\n\t\tthis.editor.setCursor({ type: 'default', rotation: 0 })\n\t\tthis.editor.snaps.clearIndicators()\n\t}\n\n\tprivate _createSnapshot() {\n\t\tconst { editor } = this\n\t\tconst selectedShapeIds = editor.getSelectedShapeIds()\n\t\tconst selectionRotation = editor.getSelectionRotation()\n\t\tconst {\n\t\t\tinputs: { originPagePoint },\n\t\t} = editor\n\n\t\tconst selectionBounds = editor.getSelectionRotatedPageBounds()\n\t\tif (!selectionBounds) throw Error('Resizing but nothing is selected')\n\n\t\tconst dragHandlePoint = Vec.RotWith(\n\t\t\tselectionBounds.getHandlePoint(this.info.handle!),\n\t\t\tselectionBounds.point,\n\t\t\tselectionRotation\n\t\t)\n\n\t\tconst cursorHandleOffset = Vec.Sub(originPagePoint, dragHandlePoint)\n\n\t\tconst shapeSnapshots = new Map<\n\t\t\tTLShapeId,\n\t\t\t{\n\t\t\t\tshape: TLShape\n\t\t\t\tbounds: Box\n\t\t\t\tpageTransform: Mat\n\t\t\t\tpageRotation: number\n\t\t\t\tisAspectRatioLocked: boolean\n\t\t\t}\n\t\t>()\n\n\t\tconst frames: { id: TLShapeId; children: TLShape[] }[] = []\n\n\t\tconst populateResizingShapes = (shapeId: TLShapeId): false | undefined => {\n\t\t\tconst shape = editor.getShape(shapeId)\n\t\t\tif (!shape) return false\n\n\t\t\tconst util = editor.getShapeUtil(shape)\n\n\t\t\t// If the shape can resize, add it to the resizing shapes snapshots\n\t\t\tif (util.canResize(shape)) {\n\t\t\t\tconst pageTransform = editor.getShapePageTransform(shape)!\n\t\t\t\tshapeSnapshots.set(shape.id, {\n\t\t\t\t\tshape,\n\t\t\t\t\tbounds: editor.getShapeGeometry(shape).bounds,\n\t\t\t\t\tpageTransform,\n\t\t\t\t\tpageRotation: Mat.Decompose(pageTransform).rotation,\n\t\t\t\t\tisAspectRatioLocked: util.isAspectRatioLocked(shape),\n\t\t\t\t})\n\t\t\t}\n\n\t\t\t// Special case:\n\t\t\t// For frames, we don't want to resize children but we DO want to get a snapshot of their children so that we can restore their\n\t\t\t// positions with the accel key behavior. We could break this further into APIs, for example by collecting snapshots of all\n\t\t\t// descendants (easy) but also flagging with behavior like \"resize\" or \"keep absolute position\" or \"reposition only with accel key\",\n\t\t\t// though I'm not sure where that would be defined; perhaps better handled with onResizeStart / onResize callbacks on the util, and\n\t\t\t// pass `accelKeyIsPressed` as well as `accelKeyWasPressed`?\n\t\t\tif (editor.isShapeOfType<TLFrameShape>(shape, 'frame')) {\n\t\t\t\tframes.push({\n\t\t\t\t\tid: shape.id,\n\t\t\t\t\tchildren: compact(\n\t\t\t\t\t\teditor.getSortedChildIdsForParent(shape).map((id) => editor.getShape(id))\n\t\t\t\t\t),\n\t\t\t\t})\n\t\t\t}\n\n\t\t\t// This will stop the traversal of descendants\n\t\t\tif (!util.canResizeChildren(shape)) return false\n\t\t}\n\n\t\tselectedShapeIds.forEach((shapeId) => {\n\t\t\tconst keepDescending = populateResizingShapes(shapeId)\n\t\t\tif (keepDescending === false) return\n\t\t\teditor.visitDescendants(shapeId, populateResizingShapes)\n\t\t})\n\n\t\tconst canShapesDeform = ![...shapeSnapshots.values()].some(\n\t\t\t(shape) =>\n\t\t\t\t!areAnglesCompatible(shape.pageRotation, selectionRotation) || shape.isAspectRatioLocked\n\t\t)\n\n\t\treturn {\n\t\t\tshapeSnapshots,\n\t\t\tselectionBounds,\n\t\t\tcursorHandleOffset,\n\t\t\tselectionRotation,\n\t\t\tselectedShapeIds,\n\t\t\tcanShapesDeform,\n\t\t\tinitialSelectionPageBounds: this.editor.getSelectionPageBounds()!,\n\t\t\tframes,\n\t\t}\n\t}\n}\n\ntype Snapshot = ReturnType<Resizing['_createSnapshot']>\n\nconst ORDERED_SELECTION_HANDLES: (SelectionEdge | SelectionCorner)[] = [\n\t'top',\n\t'top_right',\n\t'right',\n\t'bottom_right',\n\t'bottom',\n\t'bottom_left',\n\t'left',\n\t'top_left',\n]\n\nexport function rotateSelectionHandle(handle: SelectionEdge | SelectionCorner, rotation: number) {\n\t// first find out how many tau we need to rotate by\n\trotation = rotation % PI2\n\tconst numSteps = Math.round(rotation / (PI / 4))\n\n\tconst currentIndex = ORDERED_SELECTION_HANDLES.indexOf(handle)\n\treturn ORDERED_SELECTION_HANDLES[(currentIndex + numSteps) % ORDERED_SELECTION_HANDLES.length]\n}\n"],"names":[],"mappings":";;;;;AAAA;;;;;;;;AAkCO,MAAM,8MAAiB,YAAA,CAAU;IACvC,OAAgB,KAAK,WAAA;IAErB,OAAO,CAAC,EAAA;IAER,SAAS,GAAA;IAAA,mDAAA;IAGD,iBAAiB,MAAA;IAAA,mHAAA;IAAA,sHAAA;IAAA,6EAAA;IAKzB,uBAAuB;QAAE,GAAG;QAAG,GAAG;IAAE,EAAA;IAE5B,WAAW,CAAC,EAAA;IAEX,QAAQ,IAAA,EAAoB;QACpC,MAAM,EAAE,aAAa,KAAA,EAAO,cAAA,EAAgB,uBAAuB;YAAE,GAAG;YAAG,GAAG;QAAE,CAAA,CAAE,CAAA,GAAI;QAEtF,IAAA,CAAK,IAAA,GAAO;QACZ,IAAA,CAAK,cAAA,GAAiB;QAEtB,IAAA,CAAK,MAAA,CAAO,oBAAA,CAAqB,KAAK,gBAAgB;QACtD,IAAA,CAAK,oBAAA,GAAuB;QAE5B,IAAI;YAEH,IAAA,CAAK,QAAA,GAAW,IAAA,CAAK,eAAA,CAAgB;QACtC,EAAA,OAAS,GAAG;YACX,QAAQ,KAAA,CAAM,CAAC;YACf,IAAA,CAAK,MAAA,CAAO;YACZ;QACD;QAEA,IAAA,CAAK,MAAA,GAAS;QAEd,IAAI,YAAY;YACf,IAAI,gBAAgB;gBACnB,IAAA,CAAK,MAAA,GAAS;YACf,OAAO;gBAEN,MAAM,SAAS,IAAA,CAAK,MAAA,CAAO,iBAAA,CAC1B,CAAA,SAAA,EAAY,IAAA,CAAK,MAAA,CAAO,sBAAA,CAAuB,CAAC,EAAA;gBAEjD,IAAI,QAAQ;oBACX,IAAA,CAAK,MAAA,GAAS;gBACf;YACD;QACD,OAAO;YACN,IAAA,CAAK,MAAA,GAAS,IAAA,CAAK,MAAA,CAAO,wBAAA,CAAyB,mBAAmB;QACvE;QAEA,IAAI,YAAY;YACf,IAAA,CAAK,MAAA,CAAO,SAAA,CAAU;gBAAE,MAAM;gBAAS,UAAU;YAAE,CAAC;QACrD;QAEA,IAAA,CAAK,iBAAA,CAAkB;QACvB,IAAA,CAAK,YAAA,CAAa;IACnB;IAES,OAAO,EAAE,OAAA,CAAQ,CAAA,EAAoB;QAC7C,MAAM,EAAE,MAAA,CAAO,CAAA,GAAI,IAAA;QACnB,OAAO,iBAAA,CAAkB,mBAAA,CAAoB,OAAO;IACrD;IAES,gBAAgB;QACxB,IAAA,CAAK,YAAA,CAAa;IACnB;IAES,YAAY;QACpB,IAAA,CAAK,YAAA,CAAa;IACnB;IACS,UAAU;QAClB,IAAA,CAAK,YAAA,CAAa;IACnB;IAES,cAAc;QACtB,IAAA,CAAK,QAAA,CAAS;IACf;IAES,aAAa;QACrB,IAAA,CAAK,QAAA,CAAS;IACf;IAES,WAAW;QACnB,IAAA,CAAK,MAAA,CAAO;IACb;IAEQ,SAAS;QAEhB,MAAM,EAAE,cAAA,CAAe,CAAA,GAAI,IAAA,CAAK,QAAA;QAEhC,eAAe,OAAA,CAAQ,CAAC,EAAE,KAAA,CAAM,CAAA,KAAM;YACrC,MAAM,UAAU,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,MAAM,EAAE;YAC7C,IAAI,SAAS;gBACZ,MAAM,OAAO,IAAA,CAAK,MAAA,CAAO,YAAA,CAAa,KAAK;gBAC3C,KAAK,cAAA,GAAiB,OAAO,OAAO;YACrC;QACD,CAAC;QAED,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,IAAA,CAAK,MAAM;QAElC,IAAI,IAAA,CAAK,IAAA,CAAK,gBAAA,EAAkB;YAC/B,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,IAAA,CAAK,IAAA,CAAK,gBAAA,EAAkB,CAAC,CAAC;QAC1D,OAAO;YACN,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,MAAM;QAC9B;IACD;IAEQ,WAAW;QAClB,CAAA,GAAA,oLAAA,CAAA,wBAAA,EAAsB,IAAA,CAAK,MAAA,EAAQ,IAAA,CAAK,QAAA,CAAS,gBAAgB;QAEjE,IAAA,CAAK,eAAA,CAAgB;QAErB,IAAI,IAAA,CAAK,IAAA,CAAK,UAAA,IAAc,IAAA,CAAK,IAAA,CAAK,QAAA,EAAU;YAC/C,IAAA,CAAK,IAAA,CAAK,QAAA,GAAW,IAAA,CAAK,MAAA,CAAO,oBAAA,CAAqB,CAAC;YACvD;QACD;QAEA,IAAI,IAAA,CAAK,MAAA,CAAO,gBAAA,CAAiB,EAAE,YAAA,IAAgB,IAAA,CAAK,IAAA,CAAK,gBAAA,EAAkB;YAC9E,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,IAAA,CAAK,IAAA,CAAK,gBAAA,EAAkB,CAAC,CAAC;YACzD;QACD;QAEA,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,MAAM;IAC9B;IAEQ,oBAAoB;QAC3B,MAAM,EAAE,cAAA,CAAe,CAAA,GAAI,IAAA,CAAK,QAAA;QAEhC,MAAM,UAA4B,CAAC,CAAA;QAEnC,eAAe,OAAA,CAAQ,CAAC,EAAE,KAAA,CAAM,CAAA,KAAM;YACrC,MAAM,OAAO,IAAA,CAAK,MAAA,CAAO,YAAA,CAAa,KAAK;YAC3C,MAAM,SAAS,KAAK,aAAA,GAAgB,KAAK;YACzC,IAAI,QAAQ;gBACX,QAAQ,IAAA,CAAK,MAAM;YACpB;QACD,CAAC;QAED,IAAI,QAAQ,MAAA,GAAS,GAAG;YACvB,IAAA,CAAK,MAAA,CAAO,YAAA,CAAa,OAAO;QACjC;IACD;IAEQ,kBAAkB;QACzB,MAAM,EAAE,cAAA,CAAe,CAAA,GAAI,IAAA,CAAK,QAAA;QAEhC,MAAM,UAA4B,CAAC,CAAA;QAEnC,eAAe,OAAA,CAAQ,CAAC,EAAE,KAAA,CAAM,CAAA,KAAM;YACrC,MAAM,UAAU,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,MAAM,EAAE;YAC7C,MAAM,OAAO,IAAA,CAAK,MAAA,CAAO,YAAA,CAAa,KAAK;YAC3C,MAAM,SAAS,KAAK,WAAA,GAAc,OAAO,OAAO;YAChD,IAAI,QAAQ;gBACX,QAAQ,IAAA,CAAK,MAAM;YACpB;QACD,CAAC;QAED,IAAI,QAAQ,MAAA,GAAS,GAAG;YACvB,IAAA,CAAK,MAAA,CAAO,YAAA,CAAa,OAAO;QACjC;IACD;IAEQ,eAAe;QACtB,MAAM,EAAE,MAAA,EAAQ,QAAA,CAAS,CAAA,GAAI,IAAA,CAAK,MAAA,CAAO,MAAA;QACzC,MAAM,EACL,MAAA,EACA,cAAA,EACA,eAAA,EACA,kBAAA,EACA,gBAAA,EACA,iBAAA,EACA,eAAA,EACD,GAAI,IAAA,CAAK,QAAA;QAET,IAAI,sBAAsB,YAAY,CAAC;QAEvC,IAAI,eAAe,IAAA,KAAS,GAAG;YAC9B,MAAM,eAAe,CAAC;mBAAG,eAAe,MAAA,CAAO,CAAC;aAAA,CAAE,CAAC,CAAA;YACnD,IAAI,IAAA,CAAK,MAAA,CAAO,aAAA,CAA2B,aAAa,KAAA,EAAO,MAAM,GAAG;gBACvE,sBAAsB,CAAA,CAAE,IAAA,CAAK,IAAA,CAAK,MAAA,KAAW,UAAU,IAAA,CAAK,IAAA,CAAK,MAAA,KAAW,OAAA;YAC7E;QACD;QAmCA,MAAM,uMAAiB,aAAA,EAAW,IAAA,CAAK,MAAA,CAAO,MAAM;QAEpD,MAAM,mBAAmB,IAAA,CAAK,MAAA,CAAO,MAAA,CAAO,gBAAA,CAC1C,KAAA,CAAM,EACN,GAAA,CAAI,kBAAkB,EACtB,GAAA,CAAI,IAAA,CAAK,oBAAoB;QAE/B,MAAM,kBAAkB,IAAA,CAAK,MAAA,CAAO,MAAA,CAAO,eAAA,CAAgB,KAAA,CAAM,EAAE,GAAA,CAAI,kBAAkB;QAEzF,IAAI,IAAA,CAAK,MAAA,CAAO,gBAAA,CAAiB,EAAE,UAAA,IAAc,CAAC,gBAAgB;YACjE,MAAM,EAAE,QAAA,CAAS,CAAA,GAAI,IAAA,CAAK,MAAA,CAAO,mBAAA,CAAoB;YACrD,iBAAiB,UAAA,CAAW,QAAQ;QACrC;QAEA,MAAM,aAAa,IAAA,CAAK,IAAA,CAAK,MAAA;QAC7B,MAAM,oBAAoB,sBAAsB,YAAY,KAAK,EAAE;QAEnE,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,eAAA,CAAgB;QAElC,MAAM,aAAa,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,aAAA,CAAc,IAAI,CAAC,iBAAiB;QAExE,IAAI,cAAc,wMAAoB,UAAA,KAAY,GAAG;YACpD,MAAM,EAAE,KAAA,CAAM,CAAA,GAAI,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,WAAA,CAAY,gBAAA,CAAiB;gBAChE,6LAAW,MAAA,CAAI,GAAA,CAAI,kBAAkB,eAAe;gBACpD,4BAA4B,IAAA,CAAK,QAAA,CAAS,0BAAA;gBAC1C,QAAQ,sBAAsB,YAAY,iBAAiB;gBAC3D;gBACA,sBAAsB;YACvB,CAAC;YAED,iBAAiB,GAAA,CAAI,KAAK;QAC3B;QAIA,MAAM,oMAAkB,MAAA,CAAI,OAAA,CAC3B,SAAS,gBAAgB,MAAA,GAAS,gBAAgB,cAAA,CAAe,iBAAiB,GAClF,gBAAgB,KAAA,EAChB;QAQD,MAAM,+MAA6B,MAAA,CAAI,GAAA,CAAI,kBAAkB,eAAe,EAAE,GAAA,CAC7E,CAAC;QAGF,MAAM,mNAAiC,MAAA,CAAI,GAAA,CAAI,iBAAiB,eAAe,EAAE,GAAA,CAChF,CAAC;QAGF,MAAM,0LAAQ,MAAA,CAAI,IAAA,CAAK,4BAA4B,8BAA8B;QAEjF,IAAI,CAAC,OAAO,QAAA,CAAS,MAAM,CAAC,EAAG,CAAA,MAAM,CAAA,GAAI;QACzC,IAAI,CAAC,OAAO,QAAA,CAAS,MAAM,CAAC,EAAG,CAAA,MAAM,CAAA,GAAI;QAEzC,MAAM,YAAY,eAAe,SAAS,eAAe;QACzD,MAAM,YAAY,eAAe,UAAU,eAAe;QAG1D,IAAI,qBAAqB;YACxB,IAAI,WAAW;gBAEd,MAAM,CAAA,GAAI,KAAK,GAAA,CAAI,MAAM,CAAC;YAC3B,OAAA,IAAW,WAAW;gBAErB,MAAM,CAAA,GAAI,KAAK,GAAA,CAAI,MAAM,CAAC;YAC3B,OAAA,IAAW,KAAK,GAAA,CAAI,MAAM,CAAC,IAAI,KAAK,GAAA,CAAI,MAAM,CAAC,GAAG;gBAEjD,MAAM,CAAA,GAAI,KAAK,GAAA,CAAI,MAAM,CAAC,IAAA,CAAK,MAAM,CAAA,GAAI,IAAI,CAAA,IAAK,CAAA;YACnD,OAAO;gBAEN,MAAM,CAAA,GAAI,KAAK,GAAA,CAAI,MAAM,CAAC,IAAA,CAAK,MAAM,CAAA,GAAI,IAAI,CAAA,IAAK,CAAA;YACnD;QACD,OAAO;YAEN,IAAI,WAAW;gBACd,MAAM,CAAA,GAAI;YACX;YACA,IAAI,WAAW;gBACd,MAAM,CAAA,GAAI;YACX;QACD;QAEA,IAAI,CAAC,IAAA,CAAK,IAAA,CAAK,UAAA,EAAY;YAC1B,IAAA,CAAK,YAAA,CAAa;gBACjB;gBACA,YAAY,MAAM,CAAA,GAAI;gBACtB,YAAY,MAAM,CAAA,GAAI;gBACtB,UAAU;YACX,CAAC;QACF;QAEA,KAAA,MAAW,MAAM,eAAe,IAAA,CAAK,EAAG;YACvC,MAAM,WAAW,eAAe,GAAA,CAAI,EAAE;YAEtC,IAAA,CAAK,MAAA,CAAO,WAAA,CAAY,IAAI,OAAO;gBAClC,cAAc,SAAS,KAAA;gBACvB,eAAe,SAAS,MAAA;gBACxB,sBAAsB,SAAS,aAAA;gBAC/B;gBACA,MACC,iBAAiB,MAAA,KAAW,KAAK,OAAO,gBAAA,CAAiB,CAAC,CAAA,GACvD,kBACA;gBACJ,aAAa;gBACb;gBACA,mBAAmB;gBACnB,0BAA0B;YAC3B,CAAC;QACF;QAKA,IAAI,gBAAgB;YACnB,IAAA,CAAK,cAAA,GAAiB;YAEtB,KAAA,MAAW,EAAE,EAAA,EAAI,QAAA,CAAS,CAAA,IAAK,OAAQ;gBACtC,IAAI,CAAC,SAAS,MAAA,CAAQ,CAAA;gBACtB,MAAM,UAAU,eAAe,GAAA,CAAI,EAAE,EAAG,KAAA;gBACxC,MAAM,UAAU,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,EAAE;gBACvC,IAAI,CAAA,CAAE,WAAW,OAAA,EAAU,CAAA;gBAE3B,MAAM,KAAK,QAAQ,CAAA,GAAI,QAAQ,CAAA;gBAC/B,MAAM,KAAK,QAAQ,CAAA,GAAI,QAAQ,CAAA;gBAE/B,MAAM,QAAQ,sLAAI,MAAA,CAAI,IAAI,EAAE,EAAE,GAAA,CAAI,CAAC,QAAQ,QAAQ;gBAEnD,IAAI,MAAM,CAAA,KAAM,KAAK,MAAM,CAAA,KAAM,GAAG;oBACnC,KAAA,MAAW,SAAS,SAAU;wBAC7B,IAAA,CAAK,MAAA,CAAO,WAAA,CAAY;4BACvB,IAAI,MAAM,EAAA;4BACV,MAAM,MAAM,IAAA;4BACZ,GAAG,MAAM,CAAA,GAAI,MAAM,CAAA;4BACnB,GAAG,MAAM,CAAA,GAAI,MAAM,CAAA;wBACpB,CAAC;oBACF;gBACD;YACD;QACD,OAAA,IAAW,IAAA,CAAK,cAAA,EAAgB;YAE/B,IAAA,CAAK,cAAA,GAAiB;YAEtB,KAAA,MAAW,EAAE,QAAA,CAAS,CAAA,IAAK,OAAQ;gBAClC,IAAI,CAAC,SAAS,MAAA,CAAQ,CAAA;gBACtB,KAAA,MAAW,SAAS,SAAU;oBAC7B,IAAA,CAAK,MAAA,CAAO,WAAA,CAAY;wBACvB,IAAI,MAAM,EAAA;wBACV,MAAM,MAAM,IAAA;wBACZ,GAAG,MAAM,CAAA;wBACT,GAAG,MAAM,CAAA;oBACV,CAAC;gBACF;YACD;QACD;IACD;IAAA,MAAA;IAIQ,aAAa,EACpB,UAAA,EACA,UAAA,EACA,UAAA,EACA,QAAA,EACD,EAKG;QACF,MAAM,aAAa;YAAE,GAAG,IAAA,CAAK,MAAA,CAAO,gBAAA,CAAiB,EAAE,MAAA;QAAO;QAE9D,OAAQ,YAAY;YACnB,KAAK;YACL,KAAK;gBAAgB;oBACpB,WAAW,IAAA,GAAO;oBAClB,IAAI,eAAe,YAAY;wBAC9B,WAAW,IAAA,GAAO;oBACnB;oBACA;gBACD;YACA,KAAK;YACL,KAAK;gBAAe;oBACnB,WAAW,IAAA,GAAO;oBAClB,IAAI,eAAe,YAAY;wBAC9B,WAAW,IAAA,GAAO;oBACnB;oBACA;gBACD;QACD;QAEA,WAAW,QAAA,GAAW;QAEtB,IAAA,CAAK,MAAA,CAAO,SAAA,CAAU,UAAU;IACjC;IAES,SAAS;QACjB,IAAA,CAAK,MAAA,CAAO,oBAAA,CAAqB,KAAA,CAAS;QAC1C,IAAA,CAAK,MAAA,CAAO,SAAA,CAAU;YAAE,MAAM;YAAW,UAAU;QAAE,CAAC;QACtD,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,eAAA,CAAgB;IACnC;IAEQ,kBAAkB;QACzB,MAAM,EAAE,MAAA,CAAO,CAAA,GAAI,IAAA;QACnB,MAAM,mBAAmB,OAAO,mBAAA,CAAoB;QACpD,MAAM,oBAAoB,OAAO,oBAAA,CAAqB;QACtD,MAAM,EACL,QAAQ,EAAE,eAAA,CAAgB,CAAA,EAC3B,GAAI;QAEJ,MAAM,kBAAkB,OAAO,6BAAA,CAA8B;QAC7D,IAAI,CAAC,gBAAiB,CAAA,MAAM,MAAM,kCAAkC;QAEpE,MAAM,oMAAkB,MAAA,CAAI,OAAA,CAC3B,gBAAgB,cAAA,CAAe,IAAA,CAAK,IAAA,CAAK,MAAO,GAChD,gBAAgB,KAAA,EAChB;QAGD,MAAM,qBAAqB,wLAAA,CAAI,GAAA,CAAI,iBAAiB,eAAe;QAEnE,MAAM,iBAAiB,aAAA,GAAA,IAAI,IASzB;QAEF,MAAM,SAAmD,CAAC,CAAA;QAE1D,MAAM,yBAAyB,CAAC,YAA0C;YACzE,MAAM,QAAQ,OAAO,QAAA,CAAS,OAAO;YACrC,IAAI,CAAC,MAAO,CAAA,OAAO;YAEnB,MAAM,OAAO,OAAO,YAAA,CAAa,KAAK;YAGtC,IAAI,KAAK,SAAA,CAAU,KAAK,GAAG;gBAC1B,MAAM,gBAAgB,OAAO,qBAAA,CAAsB,KAAK;gBACxD,eAAe,GAAA,CAAI,MAAM,EAAA,EAAI;oBAC5B;oBACA,QAAQ,OAAO,gBAAA,CAAiB,KAAK,EAAE,MAAA;oBACvC;oBACA,+LAAc,OAAA,CAAI,SAAA,CAAU,aAAa,EAAE,QAAA;oBAC3C,qBAAqB,KAAK,mBAAA,CAAoB,KAAK;gBACpD,CAAC;YACF;YAQA,IAAI,OAAO,aAAA,CAA4B,OAAO,OAAO,GAAG;gBACvD,OAAO,IAAA,CAAK;oBACX,IAAI,MAAM,EAAA;oBACV,mLAAU,UAAA,EACT,OAAO,0BAAA,CAA2B,KAAK,EAAE,GAAA,CAAI,CAAC,KAAO,OAAO,QAAA,CAAS,EAAE,CAAC;gBAE1E,CAAC;YACF;YAGA,IAAI,CAAC,KAAK,iBAAA,CAAkB,KAAK,EAAG,CAAA,OAAO;QAC5C;QAEA,iBAAiB,OAAA,CAAQ,CAAC,YAAY;YACrC,MAAM,iBAAiB,uBAAuB,OAAO;YACrD,IAAI,mBAAmB,MAAO,CAAA;YAC9B,OAAO,gBAAA,CAAiB,SAAS,sBAAsB;QACxD,CAAC;QAED,MAAM,kBAAkB,CAAC,CAAC;eAAG,eAAe,MAAA,CAAO,CAAC;SAAA,CAAE,IAAA,CACrD,CAAC,QACA,yLAAC,sBAAA,EAAoB,MAAM,YAAA,EAAc,iBAAiB,KAAK,MAAM,mBAAA;QAGvE,OAAO;YACN;YACA;YACA;YACA;YACA;YACA;YACA,4BAA4B,IAAA,CAAK,MAAA,CAAO,sBAAA,CAAuB;YAC/D;QACD;IACD;AACD;AAIA,MAAM,4BAAiE;IACtE;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AAEO,SAAS,sBAAsB,MAAA,EAAyC,QAAA,EAAkB;IAEhG,WAAW,+LAAW,MAAA;IACtB,MAAM,WAAW,KAAK,KAAA,CAAM,WAAA,qLAAY,KAAA,GAAK,CAAA,CAAE;IAE/C,MAAM,eAAe,0BAA0B,OAAA,CAAQ,MAAM;IAC7D,OAAO,yBAAA,CAAA,CAA2B,eAAe,QAAA,IAAY,0BAA0B,MAAM,CAAA;AAC9F","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3644, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/SelectTool/childStates/Rotating.ts"],"sourcesContent":["import {\n\tRotateCorner,\n\tStateNode,\n\tTLPointerEventInfo,\n\tTLRotationSnapshot,\n\tapplyRotationToSnapshotShapes,\n\tdegreesToRadians,\n\tgetRotationSnapshot,\n\tkickoutOccludedShapes,\n\tshortAngleDist,\n\tsnapAngle,\n} from '@tldraw/editor'\nimport { CursorTypeMap } from './PointingResizeHandle'\n\nconst ONE_DEGREE = Math.PI / 180\n\nexport class Rotating extends StateNode {\n\tstatic override id = 'rotating'\n\n\tsnapshot = {} as TLRotationSnapshot\n\n\tinfo = {} as Extract<TLPointerEventInfo, { target: 'selection' }> & { onInteractionEnd?: string }\n\n\tmarkId = ''\n\n\toverride onEnter(info: TLPointerEventInfo & { target: 'selection'; onInteractionEnd?: string }) {\n\t\t// Store the event information\n\t\tthis.info = info\n\t\tthis.parent.setCurrentToolIdMask(info.onInteractionEnd)\n\n\t\tthis.markId = this.editor.markHistoryStoppingPoint('rotate start')\n\n\t\tconst snapshot = getRotationSnapshot({\n\t\t\teditor: this.editor,\n\t\t\tids: this.editor.getSelectedShapeIds(),\n\t\t})\n\t\tif (!snapshot) return this.parent.transition('idle', this.info)\n\t\tthis.snapshot = snapshot\n\n\t\t// Trigger a pointer move\n\t\tconst newSelectionRotation = this._getRotationFromPointerPosition({\n\t\t\tsnapToNearestDegree: false,\n\t\t})\n\n\t\tapplyRotationToSnapshotShapes({\n\t\t\teditor: this.editor,\n\t\t\tdelta: this._getRotationFromPointerPosition({ snapToNearestDegree: false }),\n\t\t\tsnapshot: this.snapshot,\n\t\t\tstage: 'start',\n\t\t})\n\n\t\t// Update cursor\n\t\tthis.editor.setCursor({\n\t\t\ttype: CursorTypeMap[this.info.handle as RotateCorner],\n\t\t\trotation: newSelectionRotation + this.snapshot.initialShapesRotation,\n\t\t})\n\t}\n\n\toverride onExit() {\n\t\tthis.editor.setCursor({ type: 'default', rotation: 0 })\n\t\tthis.parent.setCurrentToolIdMask(undefined)\n\n\t\tthis.snapshot = {} as TLRotationSnapshot\n\t}\n\n\toverride onPointerMove() {\n\t\tthis.update()\n\t}\n\n\toverride onKeyDown() {\n\t\tthis.update()\n\t}\n\n\toverride onKeyUp() {\n\t\tthis.update()\n\t}\n\n\toverride onPointerUp() {\n\t\tthis.complete()\n\t}\n\n\toverride onComplete() {\n\t\tthis.complete()\n\t}\n\n\toverride onCancel() {\n\t\tthis.cancel()\n\t}\n\n\t// ---\n\n\tprivate update() {\n\t\tconst newSelectionRotation = this._getRotationFromPointerPosition({\n\t\t\tsnapToNearestDegree: false,\n\t\t})\n\n\t\tapplyRotationToSnapshotShapes({\n\t\t\teditor: this.editor,\n\t\t\tdelta: newSelectionRotation,\n\t\t\tsnapshot: this.snapshot,\n\t\t\tstage: 'update',\n\t\t})\n\n\t\t// Update cursor\n\t\tthis.editor.setCursor({\n\t\t\ttype: CursorTypeMap[this.info.handle as RotateCorner],\n\t\t\trotation: newSelectionRotation + this.snapshot.initialShapesRotation,\n\t\t})\n\t}\n\n\tprivate cancel() {\n\t\t// Call onRotateCancel callback before bailing to mark\n\t\tconst { shapeSnapshots } = this.snapshot\n\n\t\tshapeSnapshots.forEach(({ shape }) => {\n\t\t\tconst current = this.editor.getShape(shape.id)\n\t\t\tif (current) {\n\t\t\t\tconst util = this.editor.getShapeUtil(shape)\n\t\t\t\tutil.onRotateCancel?.(shape, current)\n\t\t\t}\n\t\t})\n\n\t\tthis.editor.bailToMark(this.markId)\n\t\tif (this.info.onInteractionEnd) {\n\t\t\tthis.editor.setCurrentTool(this.info.onInteractionEnd, this.info)\n\t\t} else {\n\t\t\tthis.parent.transition('idle', this.info)\n\t\t}\n\t}\n\n\tprivate complete() {\n\t\tapplyRotationToSnapshotShapes({\n\t\t\teditor: this.editor,\n\t\t\tdelta: this._getRotationFromPointerPosition({ snapToNearestDegree: true }),\n\t\t\tsnapshot: this.snapshot,\n\t\t\tstage: 'end',\n\t\t})\n\t\tkickoutOccludedShapes(\n\t\t\tthis.editor,\n\t\t\tthis.snapshot.shapeSnapshots.map((s) => s.shape.id)\n\t\t)\n\t\tif (this.info.onInteractionEnd) {\n\t\t\tthis.editor.setCurrentTool(this.info.onInteractionEnd, this.info)\n\t\t} else {\n\t\t\tthis.parent.transition('idle', this.info)\n\t\t}\n\t}\n\n\t_getRotationFromPointerPosition({ snapToNearestDegree }: { snapToNearestDegree: boolean }) {\n\t\tconst {\n\t\t\tinputs: { shiftKey, currentPagePoint },\n\t\t} = this.editor\n\t\tconst { initialCursorAngle, initialShapesRotation, initialPageCenter } = this.snapshot\n\n\t\t// The delta is the difference between the current angle and the initial angle\n\t\tconst preSnapRotationDelta = initialPageCenter.angle(currentPagePoint) - initialCursorAngle\n\t\tlet newSelectionRotation = initialShapesRotation + preSnapRotationDelta\n\n\t\tif (shiftKey) {\n\t\t\tnewSelectionRotation = snapAngle(newSelectionRotation, 24)\n\t\t} else if (snapToNearestDegree) {\n\t\t\tnewSelectionRotation = Math.round(newSelectionRotation / ONE_DEGREE) * ONE_DEGREE\n\n\t\t\tif (this.editor.getInstanceState().isCoarsePointer) {\n\t\t\t\tconst snappedToRightAngle = snapAngle(newSelectionRotation, 4)\n\t\t\t\tconst angleToRightAngle = shortAngleDist(newSelectionRotation, snappedToRightAngle)\n\t\t\t\tif (Math.abs(angleToRightAngle) < degreesToRadians(5)) {\n\t\t\t\t\tnewSelectionRotation = snappedToRightAngle\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn newSelectionRotation - initialShapesRotation\n\t}\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3789, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/SelectTool/childStates/ScribbleBrushing.ts"],"sourcesContent":["import {\n\tGeometry2d,\n\tStateNode,\n\tTLFrameShape,\n\tTLGroupShape,\n\tTLShape,\n\tTLShapeId,\n\tVec,\n\tintersectLineSegmentPolygon,\n\tpointInPolygon,\n} from '@tldraw/editor'\n\nexport class ScribbleBrushing extends StateNode {\n\tstatic override id = 'scribble_brushing'\n\n\thits = new Set<TLShapeId>()\n\n\tsize = 0\n\n\tscribbleId = 'id'\n\n\tinitialSelectedShapeIds = new Set<TLShapeId>()\n\tnewlySelectedShapeIds = new Set<TLShapeId>()\n\n\toverride onEnter() {\n\t\tthis.initialSelectedShapeIds = new Set<TLShapeId>(\n\t\t\tthis.editor.inputs.shiftKey ? this.editor.getSelectedShapeIds() : []\n\t\t)\n\t\tthis.newlySelectedShapeIds = new Set<TLShapeId>()\n\t\tthis.size = 0\n\t\tthis.hits.clear()\n\n\t\tconst scribbleItem = this.editor.scribbles.addScribble({\n\t\t\tcolor: 'selection-stroke',\n\t\t\topacity: 0.32,\n\t\t\tsize: 12,\n\t\t})\n\n\t\tthis.scribbleId = scribbleItem.id\n\n\t\tthis.updateScribbleSelection(true)\n\n\t\tthis.editor.updateInstanceState({ brush: null })\n\t}\n\n\toverride onExit() {\n\t\tthis.editor.scribbles.stop(this.scribbleId)\n\t}\n\n\toverride onPointerMove() {\n\t\tthis.updateScribbleSelection(true)\n\t}\n\n\toverride onPointerUp() {\n\t\tthis.complete()\n\t}\n\n\toverride onKeyDown() {\n\t\tthis.updateScribbleSelection(false)\n\t}\n\n\toverride onKeyUp() {\n\t\tif (!this.editor.inputs.altKey) {\n\t\t\tthis.parent.transition('brushing')\n\t\t} else {\n\t\t\tthis.updateScribbleSelection(false)\n\t\t}\n\t}\n\n\toverride onCancel() {\n\t\tthis.cancel()\n\t}\n\n\toverride onComplete() {\n\t\tthis.complete()\n\t}\n\n\tprivate pushPointToScribble() {\n\t\tconst { x, y } = this.editor.inputs.currentPagePoint\n\t\tthis.editor.scribbles.addPoint(this.scribbleId, x, y)\n\t}\n\n\tprivate updateScribbleSelection(addPoint: boolean) {\n\t\tconst { editor } = this\n\t\t// const zoomLevel = this.editor.getZoomLevel()\n\t\tconst currentPageShapes = this.editor.getCurrentPageRenderingShapesSorted()\n\t\tconst {\n\t\t\tinputs: { shiftKey, originPagePoint, previousPagePoint, currentPagePoint },\n\t\t} = this.editor\n\n\t\tconst { newlySelectedShapeIds, initialSelectedShapeIds } = this\n\n\t\tif (addPoint) {\n\t\t\tthis.pushPointToScribble()\n\t\t}\n\n\t\tconst shapes = currentPageShapes\n\t\tlet shape: TLShape, geometry: Geometry2d, A: Vec, B: Vec\n\n\t\tconst minDist = 0 // this.editor.options.hitTestMargin / zoomLevel\n\n\t\tfor (let i = 0, n = shapes.length; i < n; i++) {\n\t\t\tshape = shapes[i]\n\n\t\t\t// If the shape is a group or is already selected or locked, don't select it\n\t\t\tif (\n\t\t\t\teditor.isShapeOfType<TLGroupShape>(shape, 'group') ||\n\t\t\t\tnewlySelectedShapeIds.has(shape.id) ||\n\t\t\t\teditor.isShapeOrAncestorLocked(shape)\n\t\t\t) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tgeometry = editor.getShapeGeometry(shape)\n\n\t\t\t// If the scribble started inside of the frame, don't select it\n\t\t\tif (\n\t\t\t\teditor.isShapeOfType<TLFrameShape>(shape, 'frame') &&\n\t\t\t\tgeometry.bounds.containsPoint(editor.getPointInShapeSpace(shape, originPagePoint))\n\t\t\t) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Hit test the shape using a line segment\n\t\t\tconst pageTransform = editor.getShapePageTransform(shape)\n\t\t\tif (!geometry || !pageTransform) continue\n\t\t\tconst pt = pageTransform.clone().invert()\n\t\t\tA = pt.applyToPoint(previousPagePoint)\n\t\t\tB = pt.applyToPoint(currentPagePoint)\n\n\t\t\t// If the line segment is entirely above / below / left / right of the shape's bounding box, skip the hit test\n\t\t\tconst { bounds } = geometry\n\t\t\tif (\n\t\t\t\tbounds.minX - minDist > Math.max(A.x, B.x) ||\n\t\t\t\tbounds.minY - minDist > Math.max(A.y, B.y) ||\n\t\t\t\tbounds.maxX + minDist < Math.min(A.x, B.x) ||\n\t\t\t\tbounds.maxY + minDist < Math.min(A.y, B.y)\n\t\t\t) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif (geometry.hitTestLineSegment(A, B, minDist)) {\n\t\t\t\tconst outermostShape = this.editor.getOutermostSelectableShape(shape)\n\t\t\t\tconst pageMask = this.editor.getShapeMask(outermostShape.id)\n\t\t\t\tif (pageMask) {\n\t\t\t\t\tconst intersection = intersectLineSegmentPolygon(\n\t\t\t\t\t\tpreviousPagePoint,\n\t\t\t\t\t\tcurrentPagePoint,\n\t\t\t\t\t\tpageMask\n\t\t\t\t\t)\n\t\t\t\t\tif (intersection !== null) {\n\t\t\t\t\t\tconst isInMask = pointInPolygon(currentPagePoint, pageMask)\n\t\t\t\t\t\tif (!isInMask) continue\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tnewlySelectedShapeIds.add(outermostShape.id)\n\t\t\t}\n\t\t}\n\n\t\tconst current = editor.getSelectedShapeIds()\n\t\tconst next = new Set<TLShapeId>(\n\t\t\tshiftKey ? [...newlySelectedShapeIds, ...initialSelectedShapeIds] : [...newlySelectedShapeIds]\n\t\t)\n\t\tif (current.length !== next.size || current.some((id) => !next.has(id))) {\n\t\t\tthis.editor.setSelectedShapes(Array.from(next))\n\t\t}\n\t}\n\n\tprivate complete() {\n\t\tthis.updateScribbleSelection(true)\n\t\tthis.parent.transition('idle')\n\t}\n\n\tprivate cancel() {\n\t\tthis.editor.setSelectedShapes([...this.initialSelectedShapeIds])\n\t\tthis.parent.transition('idle')\n\t}\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3921, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/SelectTool/DragAndDropManager.ts"],"sourcesContent":["import {\n\tEditor,\n\tIndexKey,\n\tTLGroupShape,\n\tTLParentId,\n\tTLShape,\n\tTLShapeId,\n\tVec,\n\tbind,\n\tcompact,\n\tisShapeId,\n} from '@tldraw/editor'\n\nconst SLOW_POINTER_LAG_DURATION = 320\nconst FAST_POINTER_LAG_DURATION = 60\n\n/** @public */\nexport class DragAndDropManager {\n\tconstructor(public editor: Editor) {\n\t\teditor.disposables.add(this.dispose)\n\t}\n\n\tshapesToActuallyMove: TLShape[] = []\n\tdraggedOverShapeIds = new Set<TLShapeId>()\n\n\tinitialGroupIds = new Map<TLShapeId, TLShapeId>()\n\tinitialParentIds = new Map<TLShapeId, TLParentId>()\n\tinitialIndices = new Map<TLShapeId, IndexKey>()\n\n\tinitialDraggingOverShape?: TLShape\n\tprevDraggingOverShape?: TLShape\n\tprevPagePoint = new Vec()\n\n\tintervalTimerId = -1\n\n\tstartDraggingShapes(movingShapes: TLShape[], point: Vec, cb: () => void) {\n\t\tconst { editor } = this\n\n\t\t// Only start dragging if we're not already dragging\n\t\tif (this.intervalTimerId !== -1) return\n\n\t\tconst shapesToActuallyMove = new Set(movingShapes)\n\t\tconst movingGroups = new Set<TLGroupShape>()\n\n\t\tfor (const shape of shapesToActuallyMove) {\n\t\t\tconst parent = editor.getShapeParent(shape)\n\t\t\tif (parent && editor.isShapeOfType<TLGroupShape>(parent, 'group')) {\n\t\t\t\tif (!movingGroups.has(parent)) {\n\t\t\t\t\tmovingGroups.add(parent)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If all of a group's children are moving, then move the group instead\n\t\tfor (const movingGroup of movingGroups) {\n\t\t\tconst children = compact(\n\t\t\t\teditor.getSortedChildIdsForParent(movingGroup).map((id) => editor.getShape(id))\n\t\t\t)\n\t\t\tshapesToActuallyMove.add(movingGroup)\n\t\t\tfor (const child of children) {\n\t\t\t\tshapesToActuallyMove.delete(child)\n\t\t\t}\n\t\t}\n\n\t\tthis.initialParentIds.clear()\n\t\tfor (const shape of shapesToActuallyMove) {\n\t\t\tconst parent = editor.getShapeParent(shape)\n\t\t\tif (parent) {\n\t\t\t\tthis.initialParentIds.set(shape.id, parent.id)\n\t\t\t}\n\t\t\tthis.initialIndices.set(shape.id, shape.index)\n\n\t\t\tconst group = editor.findShapeAncestor(shape, (s) =>\n\t\t\t\teditor.isShapeOfType<TLGroupShape>(s, 'group')\n\t\t\t)\n\t\t\tif (group) {\n\t\t\t\tthis.initialGroupIds.set(shape.id, group.id)\n\t\t\t}\n\t\t}\n\n\t\tconst allShapes = editor.getCurrentPageShapesSorted()\n\t\tthis.shapesToActuallyMove = Array.from(shapesToActuallyMove)\n\t\t\t.filter((s) => !s.isLocked)\n\t\t\t.sort((a, b) => allShapes.indexOf(a) - allShapes.indexOf(b))\n\n\t\tthis.initialDraggingOverShape = editor.getDraggingOverShape(point, this.shapesToActuallyMove)\n\t\tthis.prevDraggingOverShape = this.initialDraggingOverShape\n\n\t\t// run once on first frame\n\t\tthis.updateDraggingShapes(point, cb)\n\n\t\t// then once on an interval, skipping frames if moving quickly\n\t\tlet skip2of3FramesWhileMovingFast = 0\n\t\tthis.intervalTimerId = this.editor.timers.setInterval(\n\t\t\t() => {\n\t\t\t\tskip2of3FramesWhileMovingFast++\n\t\t\t\tif (skip2of3FramesWhileMovingFast % 3 && this.editor.inputs.pointerVelocity.len() > 0.5) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tthis.updateDraggingShapes(editor.inputs.currentPagePoint, cb)\n\t\t\t},\n\t\t\tmovingShapes.length > 10 ? SLOW_POINTER_LAG_DURATION : FAST_POINTER_LAG_DURATION\n\t\t)\n\t}\n\n\tdropShapes(shapes: TLShape[]) {\n\t\tconst { editor } = this\n\t\tthis.updateDraggingShapes(editor.inputs.currentPagePoint)\n\n\t\tconst draggingOverShape = editor.getDraggingOverShape(editor.inputs.currentPagePoint, shapes)\n\n\t\tif (draggingOverShape) {\n\t\t\tconst util = editor.getShapeUtil(draggingOverShape)\n\t\t\tutil.onDropShapesOver?.(draggingOverShape, shapes, {\n\t\t\t\tinitialDraggingOverShapeId: this.initialDraggingOverShape?.id ?? null,\n\t\t\t\tinitialParentIds: this.initialParentIds,\n\t\t\t\tinitialIndices: this.initialIndices,\n\t\t\t})\n\t\t}\n\n\t\tthis.dispose()\n\t}\n\n\tclear() {\n\t\tclearInterval(this.intervalTimerId)\n\t\tthis.intervalTimerId = -1\n\n\t\tthis.initialParentIds.clear()\n\t\tthis.initialIndices.clear()\n\t\tthis.shapesToActuallyMove = []\n\t\tthis.initialDraggingOverShape = undefined\n\t\tthis.prevDraggingOverShape = undefined\n\t\tthis.editor.setHintingShapes([])\n\t}\n\n\t@bind\n\tdispose() {\n\t\tthis.clear()\n\t}\n\n\tprivate updateDraggingShapes(point: Vec, cb?: () => void): void {\n\t\tconst { editor } = this\n\n\t\t// get fresh moving shapes\n\t\tconst draggingShapes = compact(this.shapesToActuallyMove.map((s) => editor.getShape(s)))\n\n\t\tif (!draggingShapes.length) return\n\n\t\t// This is the shape under the pointer that can handle at least one of the dragging shapes\n\t\tconst nextDraggingOverShape = editor.getDraggingOverShape(point, this.shapesToActuallyMove)\n\n\t\tconst cursorDidMove = !this.prevPagePoint.equals(editor.inputs.currentPagePoint)\n\t\tthis.prevPagePoint.setTo(editor.inputs.currentPagePoint)\n\n\t\teditor.run(() => {\n\t\t\tif (this.prevDraggingOverShape?.id === nextDraggingOverShape?.id) {\n\t\t\t\tif (\n\t\t\t\t\tcursorDidMove &&\n\t\t\t\t\tnextDraggingOverShape &&\n\t\t\t\t\tisShapeId(nextDraggingOverShape.id) &&\n\t\t\t\t\t!editor.inputs.previousPagePoint.equals(editor.inputs.currentPagePoint)\n\t\t\t\t) {\n\t\t\t\t\t// If the cursor moved, call onDragShapesOver for the previous dragging over shape\n\t\t\t\t\tconst util = editor.getShapeUtil(nextDraggingOverShape)\n\t\t\t\t\tutil.onDragShapesOver?.(nextDraggingOverShape, draggingShapes, {\n\t\t\t\t\t\tinitialDraggingOverShapeId: this.initialDraggingOverShape?.id ?? null,\n\t\t\t\t\t\tinitialParentIds: this.initialParentIds,\n\t\t\t\t\t\tinitialIndices: this.initialIndices,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif (this.prevDraggingOverShape) {\n\t\t\t\tconst util = editor.getShapeUtil(this.prevDraggingOverShape)\n\t\t\t\tutil.onDragShapesOut?.(this.editor.getShape(this.prevDraggingOverShape)!, draggingShapes, {\n\t\t\t\t\tnextDraggingOverShapeId: nextDraggingOverShape?.id ?? null,\n\t\t\t\t\tinitialDraggingOverShapeId: this.initialDraggingOverShape?.id ?? null,\n\t\t\t\t\tinitialParentIds: this.initialParentIds,\n\t\t\t\t\tinitialIndices: this.initialIndices,\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tif (nextDraggingOverShape) {\n\t\t\t\tconst util = editor.getShapeUtil(nextDraggingOverShape)\n\t\t\t\tutil.onDragShapesIn?.(nextDraggingOverShape, draggingShapes, {\n\t\t\t\t\tinitialDraggingOverShapeId: this.initialDraggingOverShape?.id ?? null,\n\t\t\t\t\tprevDraggingOverShapeId: this.prevDraggingOverShape?.id ?? null,\n\t\t\t\t\tinitialParentIds: this.initialParentIds,\n\t\t\t\t\tinitialIndices: this.initialIndices,\n\t\t\t\t})\n\t\t\t\teditor.setHintingShapes([nextDraggingOverShape.id])\n\t\t\t} else if (this.prevDraggingOverShape) {\n\t\t\t\teditor.setHintingShapes([])\n\t\t\t}\n\n\t\t\t// This is the reparenting logic\n\t\t\tcb?.()\n\t\t})\n\n\t\tthis.prevDraggingOverShape = nextDraggingOverShape\n\t}\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4166, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/SelectTool/childStates/Translating.ts"],"sourcesContent":["import {\n\tBoundsSnapPoint,\n\tEditor,\n\tMat,\n\tMatModel,\n\tPageRecordType,\n\tStateNode,\n\tTLNoteShape,\n\tTLPointerEventInfo,\n\tTLShape,\n\tTLShapePartial,\n\tTLTickEventInfo,\n\tVec,\n\tbind,\n\tcompact,\n\tisPageId,\n\tkickoutOccludedShapes,\n} from '@tldraw/editor'\nimport {\n\tNOTE_ADJACENT_POSITION_SNAP_RADIUS,\n\tNOTE_CENTER_OFFSET,\n\tgetAvailableNoteAdjacentPositions,\n} from '../../../shapes/note/noteHelpers'\nimport { DragAndDropManager } from '../DragAndDropManager'\n\nexport type TranslatingInfo = TLPointerEventInfo & {\n\ttarget: 'shape'\n\tisCreating?: boolean\n\tcreatingMarkId?: string\n\tonCreate?(): void\n\tdidStartInPit?: boolean\n\tonInteractionEnd?: string\n}\n\nexport class Translating extends StateNode {\n\tstatic override id = 'translating'\n\n\tinfo = {} as TranslatingInfo\n\n\tselectionSnapshot: TranslatingSnapshot = {} as any\n\n\tsnapshot: TranslatingSnapshot = {} as any\n\n\tmarkId = ''\n\n\tisCloning = false\n\tisCreating = false\n\tonCreate(_shape: TLShape | null): void {\n\t\treturn\n\t}\n\n\tdragAndDropManager = new DragAndDropManager(this.editor)\n\n\toverride onEnter(info: TranslatingInfo) {\n\t\tconst { isCreating = false, creatingMarkId, onCreate = () => void null } = info\n\n\t\tif (!this.editor.getSelectedShapeIds()?.length) {\n\t\t\tthis.parent.transition('idle')\n\t\t\treturn\n\t\t}\n\n\t\tthis.info = info\n\t\tthis.parent.setCurrentToolIdMask(info.onInteractionEnd)\n\t\tthis.isCreating = isCreating\n\n\t\tthis.markId = ''\n\n\t\tif (isCreating) {\n\t\t\tif (creatingMarkId) {\n\t\t\t\tthis.markId = creatingMarkId\n\t\t\t} else {\n\t\t\t\t// handle legacy implicit `creating:{shapeId}` marks\n\t\t\t\tconst markId = this.editor.getMarkIdMatching(\n\t\t\t\t\t`creating:${this.editor.getOnlySelectedShapeId()}`\n\t\t\t\t)\n\t\t\t\tif (markId) {\n\t\t\t\t\tthis.markId = markId\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthis.markId = this.editor.markHistoryStoppingPoint('translating')\n\t\t}\n\n\t\tthis.onCreate = onCreate\n\n\t\tthis.isCloning = false\n\t\tthis.info = info\n\n\t\tthis.editor.setCursor({ type: 'move', rotation: 0 })\n\t\tthis.selectionSnapshot = getTranslatingSnapshot(this.editor)\n\n\t\t// Don't clone on create; otherwise clone on altKey\n\t\tif (!this.isCreating) {\n\t\t\tif (this.editor.inputs.altKey) {\n\t\t\t\tthis.startCloning()\n\t\t\t\tif (this.isCloning) return\n\t\t\t}\n\t\t}\n\n\t\tthis.snapshot = this.selectionSnapshot\n\t\tthis.handleStart()\n\t\tthis.updateShapes()\n\t}\n\n\toverride onExit() {\n\t\tthis.parent.setCurrentToolIdMask(undefined)\n\t\tthis.selectionSnapshot = {} as any\n\t\tthis.snapshot = {} as any\n\t\tthis.editor.snaps.clearIndicators()\n\t\tthis.editor.setCursor({ type: 'default', rotation: 0 })\n\t\tthis.dragAndDropManager.clear()\n\t}\n\n\toverride onTick({ elapsed }: TLTickEventInfo) {\n\t\tconst { editor } = this\n\t\teditor.edgeScrollManager.updateEdgeScrolling(elapsed)\n\t}\n\n\toverride onPointerMove() {\n\t\tthis.updateShapes()\n\t}\n\n\toverride onKeyDown() {\n\t\tif (this.editor.inputs.altKey && !this.isCloning) {\n\t\t\tthis.startCloning()\n\t\t\tif (this.isCloning) return\n\t\t}\n\n\t\t// need to update in case user pressed a different modifier key\n\t\tthis.updateShapes()\n\t}\n\n\toverride onKeyUp() {\n\t\tif (!this.editor.inputs.altKey && this.isCloning) {\n\t\t\tthis.stopCloning()\n\t\t\treturn\n\t\t}\n\n\t\t// need to update in case user pressed a different modifier key\n\t\tthis.updateShapes()\n\t}\n\n\toverride onPointerUp() {\n\t\tthis.complete()\n\t}\n\n\toverride onComplete() {\n\t\tthis.complete()\n\t}\n\n\toverride onCancel() {\n\t\tthis.cancel()\n\t}\n\n\tprotected startCloning() {\n\t\tif (this.isCreating) return\n\t\tconst shapeIds = Array.from(this.editor.getSelectedShapeIds())\n\n\t\t// If we can't create the shapes, don't even start cloning\n\t\tif (!this.editor.canCreateShapes(shapeIds)) return\n\n\t\tthis.isCloning = true\n\t\tthis.reset()\n\t\tthis.markId = this.editor.markHistoryStoppingPoint('translate cloning')\n\n\t\tthis.editor.duplicateShapes(Array.from(this.editor.getSelectedShapeIds()))\n\n\t\tthis.snapshot = getTranslatingSnapshot(this.editor)\n\t\tthis.handleStart()\n\t\tthis.updateShapes()\n\t}\n\n\tprotected stopCloning() {\n\t\tthis.isCloning = false\n\t\tthis.snapshot = this.selectionSnapshot\n\t\tthis.reset()\n\t\tthis.markId = this.editor.markHistoryStoppingPoint('translate')\n\t\tthis.updateShapes()\n\t}\n\n\treset() {\n\t\tthis.editor.bailToMark(this.markId)\n\t}\n\n\tprotected complete() {\n\t\tthis.updateShapes()\n\t\tthis.dragAndDropManager.dropShapes(this.snapshot.movingShapes)\n\t\tthis.handleEnd()\n\t\tkickoutOccludedShapes(\n\t\t\tthis.editor,\n\t\t\tthis.snapshot.movingShapes.map((s) => s.id)\n\t\t)\n\n\t\tif (this.editor.getInstanceState().isToolLocked && this.info.onInteractionEnd) {\n\t\t\tthis.editor.setCurrentTool(this.info.onInteractionEnd)\n\t\t} else {\n\t\t\tif (this.isCreating) {\n\t\t\t\tthis.onCreate?.(this.editor.getOnlySelectedShape())\n\t\t\t} else {\n\t\t\t\tthis.parent.transition('idle')\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate cancel() {\n\t\t// Call onTranslateCancel callback before resetting\n\t\tconst { movingShapes } = this.snapshot\n\n\t\tmovingShapes.forEach((shape) => {\n\t\t\tconst current = this.editor.getShape(shape.id)\n\t\t\tif (current) {\n\t\t\t\tconst util = this.editor.getShapeUtil(shape)\n\t\t\t\tutil.onTranslateCancel?.(shape, current)\n\t\t\t}\n\t\t})\n\n\t\tthis.reset()\n\t\tif (this.info.onInteractionEnd) {\n\t\t\tthis.editor.setCurrentTool(this.info.onInteractionEnd)\n\t\t} else {\n\t\t\tthis.parent.transition('idle', this.info)\n\t\t}\n\t}\n\n\tprotected handleStart() {\n\t\tconst { movingShapes } = this.snapshot\n\n\t\tconst changes: TLShapePartial[] = []\n\n\t\tmovingShapes.forEach((shape) => {\n\t\t\tconst util = this.editor.getShapeUtil(shape)\n\t\t\tconst change = util.onTranslateStart?.(shape)\n\t\t\tif (change) {\n\t\t\t\tchanges.push(change)\n\t\t\t}\n\t\t})\n\n\t\tif (changes.length > 0) {\n\t\t\tthis.editor.updateShapes(changes)\n\t\t}\n\n\t\tthis.dragAndDropManager.startDraggingShapes(\n\t\t\t// Get fresh shapes from the snapshot, in case onTranslateStart mutates the shape\n\t\t\tcompact(this.snapshot.movingShapes.map((s) => this.editor.getShape(s.id))),\n\t\t\t// Start from the place where the user started dragging\n\t\t\tthis.editor.inputs.originPagePoint,\n\t\t\tthis.updateParentTransforms\n\t\t)\n\n\t\tthis.editor.setHoveredShape(null)\n\t}\n\n\tprotected handleEnd() {\n\t\tconst { movingShapes } = this.snapshot\n\n\t\tif (this.isCloning && movingShapes.length > 0) {\n\t\t\tconst currentAveragePagePoint = Vec.Average(\n\t\t\t\tmovingShapes.map((s) => this.editor.getShapePageTransform(s.id)!.point())\n\t\t\t)\n\t\t\tconst offset = Vec.Sub(currentAveragePagePoint, this.selectionSnapshot.averagePagePoint)\n\t\t\tif (!Vec.IsNaN(offset)) {\n\t\t\t\tthis.editor.updateInstanceState({\n\t\t\t\t\tduplicateProps: {\n\t\t\t\t\t\tshapeIds: movingShapes.map((s) => s.id),\n\t\t\t\t\t\toffset: { x: offset.x, y: offset.y },\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\tconst changes: TLShapePartial[] = []\n\n\t\tmovingShapes.forEach((shape) => {\n\t\t\tconst current = this.editor.getShape(shape.id)!\n\t\t\tconst util = this.editor.getShapeUtil(shape)\n\t\t\tconst change = util.onTranslateEnd?.(shape, current)\n\t\t\tif (change) {\n\t\t\t\tchanges.push(change)\n\t\t\t}\n\t\t})\n\n\t\tif (changes.length > 0) {\n\t\t\tthis.editor.updateShapes(changes)\n\t\t}\n\t}\n\n\tprotected updateShapes() {\n\t\tconst { snapshot } = this\n\n\t\t// We should have started already, but hey\n\t\tthis.dragAndDropManager.startDraggingShapes(\n\t\t\tsnapshot.movingShapes,\n\t\t\tthis.editor.inputs.originPagePoint,\n\t\t\tthis.updateParentTransforms\n\t\t)\n\n\t\tmoveShapesToPoint({\n\t\t\teditor: this.editor,\n\t\t\tsnapshot,\n\t\t})\n\n\t\tconst { movingShapes } = snapshot\n\n\t\tconst changes: TLShapePartial[] = []\n\n\t\tmovingShapes.forEach((shape) => {\n\t\t\tconst current = this.editor.getShape(shape.id)!\n\t\t\tconst util = this.editor.getShapeUtil(shape)\n\t\t\tconst change = util.onTranslate?.(shape, current)\n\t\t\tif (change) {\n\t\t\t\tchanges.push(change)\n\t\t\t}\n\t\t})\n\n\t\tif (changes.length > 0) {\n\t\t\tthis.editor.updateShapes(changes)\n\t\t}\n\t}\n\n\t@bind\n\tprotected updateParentTransforms() {\n\t\tconst {\n\t\t\teditor,\n\t\t\tsnapshot: { shapeSnapshots },\n\t\t} = this\n\t\tconst movingShapes: TLShape[] = []\n\n\t\tshapeSnapshots.forEach((shapeSnapshot) => {\n\t\t\tconst shape = editor.getShape(shapeSnapshot.shape.id)\n\t\t\tif (!shape) return null\n\t\t\tmovingShapes.push(shape)\n\n\t\t\tconst parentTransform = isPageId(shape.parentId)\n\t\t\t\t? null\n\t\t\t\t: Mat.Inverse(editor.getShapePageTransform(shape.parentId)!)\n\n\t\t\tshapeSnapshot.parentTransform = parentTransform\n\t\t})\n\t}\n}\n\nfunction getTranslatingSnapshot(editor: Editor) {\n\tconst movingShapes: TLShape[] = []\n\tconst pagePoints: Vec[] = []\n\n\tconst selectedShapeIds = editor.getSelectedShapeIds()\n\tconst shapeSnapshots = compact(\n\t\tselectedShapeIds.map((id): null | MovingShapeSnapshot => {\n\t\t\tconst shape = editor.getShape(id)\n\t\t\tif (!shape) return null\n\t\t\tmovingShapes.push(shape)\n\n\t\t\tconst pageTransform = editor.getShapePageTransform(id)\n\t\t\tconst pagePoint = pageTransform.point()\n\t\t\tconst pageRotation = pageTransform.rotation()\n\n\t\t\tpagePoints.push(pagePoint)\n\n\t\t\tconst parentTransform = PageRecordType.isId(shape.parentId)\n\t\t\t\t? null\n\t\t\t\t: Mat.Inverse(editor.getShapePageTransform(shape.parentId)!)\n\n\t\t\treturn {\n\t\t\t\tshape,\n\t\t\t\tpagePoint,\n\t\t\t\tpageRotation,\n\t\t\t\tparentTransform,\n\t\t\t}\n\t\t})\n\t)\n\n\tconst onlySelectedShape = editor.getOnlySelectedShape()\n\n\tlet initialSnapPoints: BoundsSnapPoint[] = []\n\n\tif (onlySelectedShape) {\n\t\tinitialSnapPoints = editor.snaps.shapeBounds.getSnapPoints(onlySelectedShape.id)!\n\t} else {\n\t\tconst selectionPageBounds = editor.getSelectionPageBounds()\n\t\tif (selectionPageBounds) {\n\t\t\tinitialSnapPoints = selectionPageBounds.cornersAndCenter.map((p, i) => ({\n\t\t\t\tid: 'selection:' + i,\n\t\t\t\tx: p.x,\n\t\t\t\ty: p.y,\n\t\t\t}))\n\t\t}\n\t}\n\n\tlet noteAdjacentPositions: Vec[] | undefined\n\tlet noteSnapshot: (MovingShapeSnapshot & { shape: TLNoteShape }) | undefined\n\n\tconst { originPagePoint } = editor.inputs\n\n\tconst allHoveredNotes = shapeSnapshots.filter(\n\t\t(s) =>\n\t\t\teditor.isShapeOfType<TLNoteShape>(s.shape, 'note') &&\n\t\t\teditor.isPointInShape(s.shape, originPagePoint)\n\t) as (MovingShapeSnapshot & { shape: TLNoteShape })[]\n\n\tif (allHoveredNotes.length === 0) {\n\t\t// noop\n\t} else if (allHoveredNotes.length === 1) {\n\t\t// just one, easy\n\t\tnoteSnapshot = allHoveredNotes[0]\n\t} else {\n\t\t// More than one under the cursor, so we need to find the highest shape in z-order\n\t\tconst allShapesSorted = editor.getCurrentPageShapesSorted()\n\t\tnoteSnapshot = allHoveredNotes\n\t\t\t.map((s) => ({\n\t\t\t\tsnapshot: s,\n\t\t\t\tindex: allShapesSorted.findIndex((shape) => shape.id === s.shape.id),\n\t\t\t}))\n\t\t\t.sort((a, b) => b.index - a.index)[0]?.snapshot // highest up first\n\t}\n\n\tif (noteSnapshot) {\n\t\tnoteAdjacentPositions = getAvailableNoteAdjacentPositions(\n\t\t\teditor,\n\t\t\tnoteSnapshot.pageRotation,\n\t\t\tnoteSnapshot.shape.props.scale,\n\t\t\tnoteSnapshot.shape.props.growY ?? 0\n\t\t)\n\t}\n\n\treturn {\n\t\taveragePagePoint: Vec.Average(pagePoints),\n\t\tmovingShapes,\n\t\tshapeSnapshots,\n\t\tinitialPageBounds: editor.getSelectionPageBounds()!,\n\t\tinitialSnapPoints,\n\t\tnoteAdjacentPositions,\n\t\tnoteSnapshot,\n\t}\n}\n\nexport type TranslatingSnapshot = ReturnType<typeof getTranslatingSnapshot>\n\nexport interface MovingShapeSnapshot {\n\tshape: TLShape\n\tpagePoint: Vec\n\tpageRotation: number\n\tparentTransform: MatModel | null\n}\n\nexport function moveShapesToPoint({\n\teditor,\n\tsnapshot,\n}: {\n\teditor: Editor\n\tsnapshot: TranslatingSnapshot\n}) {\n\tconst { inputs } = editor\n\n\tconst {\n\t\tnoteSnapshot,\n\t\tnoteAdjacentPositions,\n\t\tinitialPageBounds,\n\t\tinitialSnapPoints,\n\t\tshapeSnapshots,\n\t\taveragePagePoint,\n\t} = snapshot\n\n\tconst isGridMode = editor.getInstanceState().isGridMode\n\n\tconst gridSize = editor.getDocumentSettings().gridSize\n\n\tconst delta = Vec.Sub(inputs.currentPagePoint, inputs.originPagePoint)\n\n\tconst flatten: 'x' | 'y' | null = editor.inputs.shiftKey\n\t\t? Math.abs(delta.x) < Math.abs(delta.y)\n\t\t\t? 'x'\n\t\t\t: 'y'\n\t\t: null\n\n\tif (flatten === 'x') {\n\t\tdelta.x = 0\n\t} else if (flatten === 'y') {\n\t\tdelta.y = 0\n\t}\n\n\t// Provisional snapping\n\teditor.snaps.clearIndicators()\n\n\t// If the user isn't moving super quick\n\tconst isSnapping = editor.user.getIsSnapMode() ? !inputs.ctrlKey : inputs.ctrlKey\n\tlet snappedToPit = false\n\tif (isSnapping && editor.inputs.pointerVelocity.len() < 0.5) {\n\t\t// snapping\n\t\tconst { nudge } = editor.snaps.shapeBounds.snapTranslateShapes({\n\t\t\tdragDelta: delta,\n\t\t\tinitialSelectionPageBounds: initialPageBounds,\n\t\t\tlockedAxis: flatten,\n\t\t\tinitialSelectionSnapPoints: initialSnapPoints,\n\t\t})\n\n\t\tdelta.add(nudge)\n\t} else {\n\t\t// for sticky notes, snap to grid position next to other notes\n\t\tif (noteSnapshot && noteAdjacentPositions) {\n\t\t\tconst { scale } = noteSnapshot.shape.props\n\t\t\tconst pageCenter = noteSnapshot.pagePoint\n\t\t\t\t.clone()\n\t\t\t\t.add(delta)\n\t\t\t\t// use the middle of the note, disregarding extra height\n\t\t\t\t.add(NOTE_CENTER_OFFSET.clone().mul(scale).rot(noteSnapshot.pageRotation))\n\n\t\t\t// Find the pit with the center closest to the put center\n\t\t\tlet min = NOTE_ADJACENT_POSITION_SNAP_RADIUS / editor.getZoomLevel() // in screen space\n\t\t\tlet offset = new Vec(0, 0)\n\t\t\tfor (const pit of noteAdjacentPositions) {\n\t\t\t\t// We've already filtered pits with the same page rotation\n\t\t\t\tconst deltaToPit = Vec.Sub(pageCenter, pit)\n\t\t\t\tconst dist = deltaToPit.len()\n\t\t\t\tif (dist < min) {\n\t\t\t\t\tsnappedToPit = true\n\t\t\t\t\tmin = dist\n\t\t\t\t\toffset = deltaToPit\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdelta.sub(offset)\n\t\t}\n\t}\n\n\tconst averageSnappedPoint = Vec.Add(averagePagePoint, delta)\n\n\t// we don't want to snap to the grid if we're holding the ctrl key, if we've already snapped into a pit, or if we're showing snapping indicators\n\tconst snapIndicators = editor.snaps.getIndicators()\n\tif (isGridMode && !inputs.ctrlKey && !snappedToPit && snapIndicators.length === 0) {\n\t\taverageSnappedPoint.snapToGrid(gridSize)\n\t}\n\n\tconst averageSnap = Vec.Sub(averageSnappedPoint, averagePagePoint)\n\n\teditor.updateShapes(\n\t\tcompact(\n\t\t\tshapeSnapshots.map(({ shape, pagePoint, parentTransform }): TLShapePartial | null => {\n\t\t\t\tconst newPagePoint = Vec.Add(pagePoint, averageSnap)\n\n\t\t\t\tconst newLocalPoint = parentTransform\n\t\t\t\t\t? Mat.applyToPoint(parentTransform, newPagePoint)\n\t\t\t\t\t: newPagePoint\n\n\t\t\t\treturn {\n\t\t\t\t\tid: shape.id,\n\t\t\t\t\ttype: shape.type,\n\t\t\t\t\tx: newLocalPoint.x,\n\t\t\t\t\ty: newLocalPoint.y,\n\t\t\t\t}\n\t\t\t})\n\t\t)\n\t)\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4630, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/SelectTool/SelectTool.ts"],"sourcesContent":["import { StateNode, TLStateNodeConstructor, react } from '@tldraw/editor'\nimport { Brushing } from './childStates/Brushing'\nimport { Crop } from './childStates/Crop/Crop'\nimport { Cropping } from './childStates/Crop/children/Cropping'\nimport { PointingCropHandle } from './childStates/Crop/children/PointingCropHandle'\nimport { DraggingHandle } from './childStates/DraggingHandle'\nimport { EditingShape } from './childStates/EditingShape'\nimport { Idle } from './childStates/Idle'\nimport { PointingArrowLabel } from './childStates/PointingArrowLabel'\nimport { PointingCanvas } from './childStates/PointingCanvas'\nimport { PointingHandle } from './childStates/PointingHandle'\nimport { PointingResizeHandle } from './childStates/PointingResizeHandle'\nimport { PointingRotateHandle } from './childStates/PointingRotateHandle'\nimport { PointingSelection } from './childStates/PointingSelection'\nimport { PointingShape } from './childStates/PointingShape'\nimport { Resizing } from './childStates/Resizing'\nimport { Rotating } from './childStates/Rotating'\nimport { ScribbleBrushing } from './childStates/ScribbleBrushing'\nimport { Translating } from './childStates/Translating'\n\n/** @public */\nexport class SelectTool extends StateNode {\n\tstatic override id = 'select'\n\tstatic override initial = 'idle'\n\tstatic override isLockable = false\n\treactor: undefined | (() => void) = undefined\n\n\tstatic override children(): TLStateNodeConstructor[] {\n\t\treturn [\n\t\t\tCrop,\n\t\t\tCropping,\n\t\t\tIdle,\n\t\t\tPointingCanvas,\n\t\t\tPointingShape,\n\t\t\tTranslating,\n\t\t\tBrushing,\n\t\t\tScribbleBrushing,\n\t\t\tPointingCropHandle,\n\t\t\tPointingSelection,\n\t\t\tPointingResizeHandle,\n\t\t\tEditingShape,\n\t\t\tResizing,\n\t\t\tRotating,\n\t\t\tPointingRotateHandle,\n\t\t\tPointingArrowLabel,\n\t\t\tPointingHandle,\n\t\t\tDraggingHandle,\n\t\t]\n\t}\n\n\t// We want to clean up the duplicate props when the selection changes\n\tcleanUpDuplicateProps() {\n\t\tconst selectedShapeIds = this.editor.getSelectedShapeIds()\n\t\tconst instance = this.editor.getInstanceState()\n\t\tif (!instance.duplicateProps) return\n\t\tconst duplicatedShapes = new Set(instance.duplicateProps.shapeIds)\n\t\tif (\n\t\t\tselectedShapeIds.length === duplicatedShapes.size &&\n\t\t\tselectedShapeIds.every((shapeId) => duplicatedShapes.has(shapeId))\n\t\t) {\n\t\t\treturn\n\t\t}\n\t\tthis.editor.updateInstanceState({\n\t\t\tduplicateProps: null,\n\t\t})\n\t}\n\n\toverride onEnter() {\n\t\tthis.reactor = react('clean duplicate props', () => {\n\t\t\ttry {\n\t\t\t\tthis.cleanUpDuplicateProps()\n\t\t\t} catch (e) {\n\t\t\t\tif (typeof process !== 'undefined' && process.env.NODE_ENV === 'test') {\n\t\t\t\t\t// ignore errors at test time\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error(e)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\toverride onExit() {\n\t\tthis.reactor?.()\n\t\tif (this.editor.getCurrentPageState().editingShapeId) {\n\t\t\tthis.editor.setEditingShape(null)\n\t\t}\n\t}\n}\n"],"names":[],"mappings":";;;AAwEe,YAAY,eAAe,QAAQ,IAAI,aAAa;AAxEnE,SAAS,WAAmC,aAAa;;;AACzD,SAAS,gBAAgB;AACzB,SAAS,YAAY;AACrB,SAAS,gBAAgB;AACzB,SAAS,0BAA0B;AACnC,SAAS,sBAAsB;AAC/B,SAAS,oBAAoB;AAC7B,SAAS,YAAY;AACrB,SAAS,0BAA0B;AACnC,SAAS,sBAAsB;AAC/B,SAAS,sBAAsB;AAC/B,SAAS,4BAA4B;AACrC,SAAS,4BAA4B;AACrC,SAAS,yBAAyB;AAClC,SAAS,qBAAqB;AAC9B,SAAS,gBAAgB;AACzB,SAAS,gBAAgB;AACzB,SAAS,wBAAwB;AACjC,SAAS,mBAAmB;;;;;;;;;;;;;;;;;;;;AAGrB,MAAM,+MAAmB,aAAA,CAAU;IACzC,OAAgB,KAAK,SAAA;IACrB,OAAgB,UAAU,OAAA;IAC1B,OAAgB,aAAa,MAAA;IAC7B,UAAoC,KAAA,EAAA;IAEpC,OAAgB,WAAqC;QACpD,OAAO;mNACN,OAAA;mOACA,WAAA;2MACA,OAAA;qNACA,iBAAA;oNACA,gBAAA;kNACA,cAAA;8MACA,YAAA;uNACA,mBAAA;6OACA,qBAAA;wNACA,oBAAA;2NACA,uBAAA;mNACA,eAAA;+MACA,WAAA;YACA,8MAAA;2NACA,uBAAA;yNACA,qBAAA;qNACA,iBAAA;qNACA,iBAAA;SACD;IACD;IAAA,qEAAA;IAGA,wBAAwB;QACvB,MAAM,mBAAmB,IAAA,CAAK,MAAA,CAAO,mBAAA,CAAoB;QACzD,MAAM,WAAW,IAAA,CAAK,MAAA,CAAO,gBAAA,CAAiB;QAC9C,IAAI,CAAC,SAAS,cAAA,CAAgB,CAAA;QAC9B,MAAM,mBAAmB,IAAI,IAAI,SAAS,cAAA,CAAe,QAAQ;QACjE,IACC,iBAAiB,MAAA,KAAW,iBAAiB,IAAA,IAC7C,iBAAiB,KAAA,CAAM,CAAC,UAAY,iBAAiB,GAAA,CAAI,OAAO,CAAC,GAChE;YACD;QACD;QACA,IAAA,CAAK,MAAA,CAAO,mBAAA,CAAoB;YAC/B,gBAAgB;QACjB,CAAC;IACF;IAES,UAAU;QAClB,IAAA,CAAK,OAAA,GAAU,2LAAA,EAAM,yBAAyB,MAAM;YACnD,IAAI;gBACH,IAAA,CAAK,qBAAA,CAAsB;YAC5B,EAAA,OAAS,GAAG;gBACX,IAAI,mCAAmE,CAEvE,OAAO;oBACN,QAAQ,KAAA,CAAM,CAAC;gBAChB;YACD;QACD,CAAC;IACF;IAES,SAAS;QACjB,IAAA,CAAK,OAAA,GAAU;QACf,IAAI,IAAA,CAAK,MAAA,CAAO,mBAAA,CAAoB,EAAE,cAAA,EAAgB;YACrD,IAAA,CAAK,MAAA,CAAO,eAAA,CAAgB,IAAI;QACjC;IACD;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4740, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/ZoomTool/childStates/Idle.ts"],"sourcesContent":["import { StateNode, TLPointerEventInfo } from '@tldraw/editor'\n\nexport class Idle extends StateNode {\n\tstatic override id = 'idle'\n\n\tinfo = {} as TLPointerEventInfo & { onInteractionEnd?: string }\n\n\toverride onEnter(info: TLPointerEventInfo & { onInteractionEnd: string }) {\n\t\tthis.info = info\n\t}\n\n\toverride onPointerDown() {\n\t\tthis.parent.transition('pointing', this.info)\n\t}\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,iBAAqC;;AAEvC,MAAM,0MAAa,YAAA,CAAU;IACnC,OAAgB,KAAK,OAAA;IAErB,OAAO,CAAC,EAAA;IAEC,QAAQ,IAAA,EAAyD;QACzE,IAAA,CAAK,IAAA,GAAO;IACb;IAES,gBAAgB;QACxB,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,YAAY,IAAA,CAAK,IAAI;IAC7C;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4764, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/ZoomTool/childStates/Pointing.ts"],"sourcesContent":["import { StateNode, TLPointerEventInfo } from '@tldraw/editor'\n\nexport class Pointing extends StateNode {\n\tstatic override id = 'pointing'\n\n\tinfo = {} as TLPointerEventInfo & { onInteractionEnd?: string }\n\n\toverride onEnter(info: TLPointerEventInfo & { onInteractionEnd: string }) {\n\t\tthis.info = info\n\t}\n\n\toverride onPointerUp() {\n\t\tthis.complete()\n\t}\n\n\toverride onPointerMove() {\n\t\tif (this.editor.inputs.isDragging) {\n\t\t\tthis.parent.transition('zoom_brushing', this.info)\n\t\t}\n\t}\n\n\toverride onCancel() {\n\t\tthis.cancel()\n\t}\n\n\tprivate complete() {\n\t\tconst { currentScreenPoint } = this.editor.inputs\n\t\tif (this.editor.inputs.altKey) {\n\t\t\tthis.editor.zoomOut(currentScreenPoint, { animation: { duration: 220 } })\n\t\t} else {\n\t\t\tthis.editor.zoomIn(currentScreenPoint, { animation: { duration: 220 } })\n\t\t}\n\t\tthis.parent.transition('idle', this.info)\n\t}\n\n\tprivate cancel() {\n\t\tthis.parent.transition('idle', this.info)\n\t}\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,iBAAqC;;AAEvC,MAAM,8MAAiB,YAAA,CAAU;IACvC,OAAgB,KAAK,WAAA;IAErB,OAAO,CAAC,EAAA;IAEC,QAAQ,IAAA,EAAyD;QACzE,IAAA,CAAK,IAAA,GAAO;IACb;IAES,cAAc;QACtB,IAAA,CAAK,QAAA,CAAS;IACf;IAES,gBAAgB;QACxB,IAAI,IAAA,CAAK,MAAA,CAAO,MAAA,CAAO,UAAA,EAAY;YAClC,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,iBAAiB,IAAA,CAAK,IAAI;QAClD;IACD;IAES,WAAW;QACnB,IAAA,CAAK,MAAA,CAAO;IACb;IAEQ,WAAW;QAClB,MAAM,EAAE,kBAAA,CAAmB,CAAA,GAAI,IAAA,CAAK,MAAA,CAAO,MAAA;QAC3C,IAAI,IAAA,CAAK,MAAA,CAAO,MAAA,CAAO,MAAA,EAAQ;YAC9B,IAAA,CAAK,MAAA,CAAO,OAAA,CAAQ,oBAAoB;gBAAE,WAAW;oBAAE,UAAU;gBAAI;YAAE,CAAC;QACzE,OAAO;YACN,IAAA,CAAK,MAAA,CAAO,MAAA,CAAO,oBAAoB;gBAAE,WAAW;oBAAE,UAAU;gBAAI;YAAE,CAAC;QACxE;QACA,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,QAAQ,IAAA,CAAK,IAAI;IACzC;IAEQ,SAAS;QAChB,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,QAAQ,IAAA,CAAK,IAAI;IACzC;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4816, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/ZoomTool/childStates/ZoomBrushing.ts"],"sourcesContent":["import { Box, StateNode, TLPointerEventInfo } from '@tldraw/editor'\n\nexport class ZoomBrushing extends StateNode {\n\tstatic override id = 'zoom_brushing'\n\n\tinfo = {} as TLPointerEventInfo & { onInteractionEnd?: string }\n\n\tzoomBrush = new Box()\n\n\toverride onEnter(info: TLPointerEventInfo & { onInteractionEnd: string }) {\n\t\tthis.info = info\n\t\tthis.update()\n\t}\n\n\toverride onExit() {\n\t\tthis.editor.updateInstanceState({ zoomBrush: null })\n\t}\n\n\toverride onPointerMove() {\n\t\tthis.update()\n\t}\n\n\toverride onPointerUp() {\n\t\tthis.complete()\n\t}\n\n\toverride onCancel() {\n\t\tthis.cancel()\n\t}\n\n\tprivate update() {\n\t\tconst {\n\t\t\tinputs: { originPagePoint, currentPagePoint },\n\t\t} = this.editor\n\n\t\tthis.zoomBrush.setTo(Box.FromPoints([originPagePoint, currentPagePoint]))\n\t\tthis.editor.updateInstanceState({ zoomBrush: this.zoomBrush.toJson() })\n\t}\n\n\tprivate cancel() {\n\t\tthis.parent.transition('idle', this.info)\n\t}\n\n\tprivate complete() {\n\t\tconst { zoomBrush } = this\n\t\tconst threshold = 8 / this.editor.getZoomLevel()\n\t\t// If the selected area is small then treat it as a click\n\t\tif (zoomBrush.width < threshold && zoomBrush.height < threshold) {\n\t\t\tconst point = this.editor.inputs.currentScreenPoint\n\t\t\tif (this.editor.inputs.altKey) {\n\t\t\t\tthis.editor.zoomOut(point, { animation: { duration: 220 } })\n\t\t\t} else {\n\t\t\t\tthis.editor.zoomIn(point, { animation: { duration: 220 } })\n\t\t\t}\n\t\t} else {\n\t\t\tconst targetZoom = this.editor.inputs.altKey ? this.editor.getZoomLevel() / 2 : undefined\n\t\t\tthis.editor.zoomToBounds(zoomBrush, { targetZoom, animation: { duration: 220 } })\n\t\t}\n\n\t\tthis.parent.transition('idle', this.info)\n\t}\n}\n"],"names":[],"mappings":";;;;;AAAA,SAAS,KAAK,iBAAqC;;AAE5C,MAAM,kNAAqB,YAAA,CAAU;IAC3C,OAAgB,KAAK,gBAAA;IAErB,OAAO,CAAC,EAAA;IAER,YAAY,sLAAI,MAAA,CAAI,EAAA;IAEX,QAAQ,IAAA,EAAyD;QACzE,IAAA,CAAK,IAAA,GAAO;QACZ,IAAA,CAAK,MAAA,CAAO;IACb;IAES,SAAS;QACjB,IAAA,CAAK,MAAA,CAAO,mBAAA,CAAoB;YAAE,WAAW;QAAK,CAAC;IACpD;IAES,gBAAgB;QACxB,IAAA,CAAK,MAAA,CAAO;IACb;IAES,cAAc;QACtB,IAAA,CAAK,QAAA,CAAS;IACf;IAES,WAAW;QACnB,IAAA,CAAK,MAAA,CAAO;IACb;IAEQ,SAAS;QAChB,MAAM,EACL,QAAQ,EAAE,eAAA,EAAiB,gBAAA,CAAiB,CAAA,EAC7C,GAAI,IAAA,CAAK,MAAA;QAET,IAAA,CAAK,SAAA,CAAU,KAAA,mLAAM,MAAA,CAAI,UAAA,CAAW;YAAC;YAAiB,gBAAgB;SAAC,CAAC;QACxE,IAAA,CAAK,MAAA,CAAO,mBAAA,CAAoB;YAAE,WAAW,IAAA,CAAK,SAAA,CAAU,MAAA,CAAO;QAAE,CAAC;IACvE;IAEQ,SAAS;QAChB,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,QAAQ,IAAA,CAAK,IAAI;IACzC;IAEQ,WAAW;QAClB,MAAM,EAAE,SAAA,CAAU,CAAA,GAAI,IAAA;QACtB,MAAM,YAAY,IAAI,IAAA,CAAK,MAAA,CAAO,YAAA,CAAa;QAE/C,IAAI,UAAU,KAAA,GAAQ,aAAa,UAAU,MAAA,GAAS,WAAW;YAChE,MAAM,QAAQ,IAAA,CAAK,MAAA,CAAO,MAAA,CAAO,kBAAA;YACjC,IAAI,IAAA,CAAK,MAAA,CAAO,MAAA,CAAO,MAAA,EAAQ;gBAC9B,IAAA,CAAK,MAAA,CAAO,OAAA,CAAQ,OAAO;oBAAE,WAAW;wBAAE,UAAU;oBAAI;gBAAE,CAAC;YAC5D,OAAO;gBACN,IAAA,CAAK,MAAA,CAAO,MAAA,CAAO,OAAO;oBAAE,WAAW;wBAAE,UAAU;oBAAI;gBAAE,CAAC;YAC3D;QACD,OAAO;YACN,MAAM,aAAa,IAAA,CAAK,MAAA,CAAO,MAAA,CAAO,MAAA,GAAS,IAAA,CAAK,MAAA,CAAO,YAAA,CAAa,IAAI,IAAI,KAAA;YAChF,IAAA,CAAK,MAAA,CAAO,YAAA,CAAa,WAAW;gBAAE;gBAAY,WAAW;oBAAE,UAAU;gBAAI;YAAE,CAAC;QACjF;QAEA,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,QAAQ,IAAA,CAAK,IAAI;IACzC;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4896, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/an/studio/node_modules/tldraw/src/lib/tools/ZoomTool/ZoomTool.ts"],"sourcesContent":["import {\n\tStateNode,\n\tTLKeyboardEventInfo,\n\tTLPointerEventInfo,\n\tTLStateNodeConstructor,\n} from '@tldraw/editor'\nimport { Idle } from './childStates/Idle'\nimport { Pointing } from './childStates/Pointing'\nimport { ZoomBrushing } from './childStates/ZoomBrushing'\n\n/** @public */\nexport class ZoomTool extends StateNode {\n\tstatic override id = 'zoom'\n\tstatic override initial = 'idle'\n\tstatic override children(): TLStateNodeConstructor[] {\n\t\treturn [Idle, ZoomBrushing, Pointing]\n\t}\n\tstatic override isLockable = false\n\n\tinfo = {} as TLPointerEventInfo & { onInteractionEnd?: string }\n\n\toverride onEnter(info: TLPointerEventInfo & { onInteractionEnd: string }) {\n\t\tthis.info = info\n\t\tthis.parent.setCurrentToolIdMask(info.onInteractionEnd)\n\t\tthis.updateCursor()\n\t}\n\n\toverride onExit() {\n\t\tthis.parent.setCurrentToolIdMask(undefined)\n\t\tthis.editor.updateInstanceState({ zoomBrush: null, cursor: { type: 'default', rotation: 0 } })\n\t\tthis.parent.setCurrentToolIdMask(undefined)\n\t}\n\n\toverride onKeyDown() {\n\t\tthis.updateCursor()\n\t}\n\n\toverride onKeyUp(info: TLKeyboardEventInfo) {\n\t\tthis.updateCursor()\n\n\t\tif (info.code === 'KeyZ') {\n\t\t\tthis.complete()\n\t\t}\n\t}\n\n\toverride onInterrupt() {\n\t\tthis.complete()\n\t}\n\n\tprivate complete() {\n\t\t// Go back to the previous tool. If we are already in select we want to transition to idle\n\t\tif (this.info.onInteractionEnd && this.info.onInteractionEnd !== 'select') {\n\t\t\tthis.editor.setCurrentTool(this.info.onInteractionEnd, this.info)\n\t\t} else {\n\t\t\tthis.parent.transition('select')\n\t\t}\n\t}\n\n\tprivate updateCursor() {\n\t\tif (this.editor.inputs.altKey) {\n\t\t\tthis.editor.setCursor({ type: 'zoom-out', rotation: 0 })\n\t\t} else {\n\t\t\tthis.editor.setCursor({ type: 'zoom-in', rotation: 0 })\n\t\t}\n\t}\n}\n"],"names":[],"mappings":";;;;AAAA;AAMA,SAAS,YAAY;AACrB,SAAS,gBAAgB;AACzB,SAAS,oBAAoB;;;;;AAGtB,MAAM,8MAAiB,YAAA,CAAU;IACvC,OAAgB,KAAK,OAAA;IACrB,OAAgB,UAAU,OAAA;IAC1B,OAAgB,WAAqC;QACpD,OAAO;yMAAC,OAAA;iNAAM,eAAA;6MAAc,WAAQ;SAAA;IACrC;IACA,OAAgB,aAAa,MAAA;IAE7B,OAAO,CAAC,EAAA;IAEC,QAAQ,IAAA,EAAyD;QACzE,IAAA,CAAK,IAAA,GAAO;QACZ,IAAA,CAAK,MAAA,CAAO,oBAAA,CAAqB,KAAK,gBAAgB;QACtD,IAAA,CAAK,YAAA,CAAa;IACnB;IAES,SAAS;QACjB,IAAA,CAAK,MAAA,CAAO,oBAAA,CAAqB,KAAA,CAAS;QAC1C,IAAA,CAAK,MAAA,CAAO,mBAAA,CAAoB;YAAE,WAAW;YAAM,QAAQ;gBAAE,MAAM;gBAAW,UAAU;YAAE;QAAE,CAAC;QAC7F,IAAA,CAAK,MAAA,CAAO,oBAAA,CAAqB,KAAA,CAAS;IAC3C;IAES,YAAY;QACpB,IAAA,CAAK,YAAA,CAAa;IACnB;IAES,QAAQ,IAAA,EAA2B;QAC3C,IAAA,CAAK,YAAA,CAAa;QAElB,IAAI,KAAK,IAAA,KAAS,QAAQ;YACzB,IAAA,CAAK,QAAA,CAAS;QACf;IACD;IAES,cAAc;QACtB,IAAA,CAAK,QAAA,CAAS;IACf;IAEQ,WAAW;QAElB,IAAI,IAAA,CAAK,IAAA,CAAK,gBAAA,IAAoB,IAAA,CAAK,IAAA,CAAK,gBAAA,KAAqB,UAAU;YAC1E,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,IAAA,CAAK,IAAA,CAAK,gBAAA,EAAkB,IAAA,CAAK,IAAI;QACjE,OAAO;YACN,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,QAAQ;QAChC;IACD;IAEQ,eAAe;QACtB,IAAI,IAAA,CAAK,MAAA,CAAO,MAAA,CAAO,MAAA,EAAQ;YAC9B,IAAA,CAAK,MAAA,CAAO,SAAA,CAAU;gBAAE,MAAM;gBAAY,UAAU;YAAE,CAAC;QACxD,OAAO;YACN,IAAA,CAAK,MAAA,CAAO,SAAA,CAAU;gBAAE,MAAM;gBAAW,UAAU;YAAE,CAAC;QACvD;IACD;AACD","ignoreList":[0],"debugId":null}}]
}