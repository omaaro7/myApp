{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/shared/PathBuilder.tsx"],"sourcesContent":["import {\n\tapproximately,\n\tassert,\n\tassertExists,\n\tclamp,\n\tCubicBezier2d,\n\tEdge2d,\n\texhaustiveSwitchError,\n\tGeometry2d,\n\tGeometry2dFilters,\n\tGeometry2dOptions,\n\tgetPerfectDashProps,\n\tgetVerticesCountForArcLength,\n\tGroup2d,\n\tmodulate,\n\tPerfectDashTerminal,\n\trng,\n\ttoDomPrecision,\n\tVec,\n\tVecLike,\n\tVecModel,\n} from '@tldraw/editor'\nimport { ReactNode, SVGProps } from 'react'\n\n/** @public */\nexport interface BasePathBuilderOpts {\n\tstrokeWidth: number\n\tforceSolid?: boolean\n\tonlyFilled?: boolean\n\tprops?: SVGProps<SVGPathElement & SVGGElement>\n}\n\n/** @public */\nexport interface SolidPathBuilderOpts extends BasePathBuilderOpts {\n\tstyle: 'solid'\n}\n\n/** @public */\nexport interface DashedPathBuilderOpts extends BasePathBuilderOpts {\n\tstyle: 'dashed' | 'dotted'\n\tsnap?: number\n\tend?: PerfectDashTerminal\n\tstart?: PerfectDashTerminal\n\tlengthRatio?: number\n}\n\n/** @public */\nexport interface DrawPathBuilderDOpts {\n\tstrokeWidth: number\n\trandomSeed: string\n\toffset?: number\n\troundness?: number\n\tpasses?: number\n\tonlyFilled?: boolean\n}\n\n/** @public */\nexport interface DrawPathBuilderOpts extends BasePathBuilderOpts, DrawPathBuilderDOpts {\n\tstyle: 'draw'\n}\n\n/** @public */\nexport type PathBuilderOpts = SolidPathBuilderOpts | DashedPathBuilderOpts | DrawPathBuilderOpts\n\n/** @public */\nexport interface PathBuilderCommandOpts {\n\t/**\n\t * When converting to a draw-style line, how much offset from the original point should be\n\t * applied?\n\t */\n\toffset?: number\n\t/**\n\t * When converting to a draw-style line, how much roundness should be applied to the end of this\n\t * line?\n\t */\n\troundness?: number\n\t/**\n\t * When converting to a dash- or dot-style line, should the current segment be merged with the\n\t * previous segment when calculating the dash pattern? This is false by default, meaning each\n\t * command will start/end on a dash/dot boundary.\n\t */\n\tmergeWithPrevious?: boolean\n}\n\n/** @internal */\nexport interface PathBuilderCommandInfo {\n\ttangentStart: VecModel\n\ttangentEnd: VecModel\n\tlength: number\n}\n\n/** @internal */\nexport interface PathBuilderCommandBase {\n\topts?: PathBuilderCommandOpts\n\tx: number\n\ty: number\n\tisClose: boolean\n\t_info?: PathBuilderCommandInfo\n}\n\n/** @public */\nexport interface PathBuilderLineOpts extends PathBuilderCommandOpts {\n\tgeometry?: Omit<Geometry2dOptions, 'isClosed'> | false\n\tdashStart?: PerfectDashTerminal\n\tdashEnd?: PerfectDashTerminal\n}\n\n/** @internal */\nexport interface MoveToPathBuilderCommand extends PathBuilderCommandBase {\n\ttype: 'move'\n\tcloseIdx: number | null\n\topts?: PathBuilderLineOpts\n}\n\n/** @internal */\nexport interface LineToPathBuilderCommand extends PathBuilderCommandBase {\n\ttype: 'line'\n}\n\n/** @internal */\nexport interface CubicBezierToPathBuilderCommand extends PathBuilderCommandBase {\n\ttype: 'cubic'\n\tcp1: VecModel\n\tcp2: VecModel\n\tresolution?: number\n}\n\n/** @internal */\nexport type PathBuilderCommand =\n\t| MoveToPathBuilderCommand\n\t| LineToPathBuilderCommand\n\t| CubicBezierToPathBuilderCommand\n\n/** @public */\nexport interface PathBuilderToDOpts {\n\tstartIdx?: number\n\tendIdx?: number\n\tonlyFilled?: boolean\n}\n\n/** @public */\nexport class PathBuilder {\n\tstatic lineThroughPoints(\n\t\tpoints: VecLike[],\n\t\topts?: PathBuilderLineOpts & { endOffsets?: number }\n\t) {\n\t\tconst path = new PathBuilder()\n\t\tpath.moveTo(points[0].x, points[0].y, { ...opts, offset: opts?.endOffsets ?? opts?.offset })\n\t\tfor (let i = 1; i < points.length; i++) {\n\t\t\tconst isLast = i === points.length - 1\n\t\t\tpath.lineTo(points[i].x, points[i].y, isLast ? { offset: opts?.endOffsets } : undefined)\n\t\t}\n\t\treturn path\n\t}\n\n\tstatic cubicSplineThroughPoints(\n\t\tpoints: VecLike[],\n\t\topts?: PathBuilderLineOpts & { endOffsets?: number }\n\t) {\n\t\tconst path = new PathBuilder()\n\t\tconst len = points.length\n\t\tconst last = len - 2\n\t\tconst k = 1.25\n\n\t\tpath.moveTo(points[0].x, points[0].y, { ...opts, offset: opts?.endOffsets ?? opts?.offset })\n\n\t\tfor (let i = 0; i < len - 1; i++) {\n\t\t\tconst p0 = i === 0 ? points[0] : points[i - 1]\n\t\t\tconst p1 = points[i]\n\t\t\tconst p2 = points[i + 1]\n\t\t\tconst p3 = i === last ? p2 : points[i + 2]\n\n\t\t\tlet cp1x, cp1y, cp2x, cp2y\n\t\t\tif (i === 0) {\n\t\t\t\tcp1x = p0.x\n\t\t\t\tcp1y = p0.y\n\t\t\t} else {\n\t\t\t\tcp1x = p1.x + ((p2.x - p0.x) / 6) * k\n\t\t\t\tcp1y = p1.y + ((p2.y - p0.y) / 6) * k\n\t\t\t}\n\n\t\t\tlet pointOpts = undefined\n\t\t\tif (i === last) {\n\t\t\t\tcp2x = p2.x\n\t\t\t\tcp2y = p2.y\n\t\t\t\tpointOpts = { offset: opts?.endOffsets }\n\t\t\t} else {\n\t\t\t\tcp2x = p2.x - ((p3.x - p1.x) / 6) * k\n\t\t\t\tcp2y = p2.y - ((p3.y - p1.y) / 6) * k\n\t\t\t}\n\n\t\t\tpath.cubicBezierTo(p2.x, p2.y, cp1x, cp1y, cp2x, cp2y, pointOpts)\n\t\t}\n\n\t\treturn path\n\t}\n\n\tconstructor() {}\n\n\t/** @internal */\n\tcommands: PathBuilderCommand[] = []\n\n\tprivate lastMoveTo: MoveToPathBuilderCommand | null = null\n\tprivate assertHasMoveTo() {\n\t\tassert(this.lastMoveTo, 'Start an SVGPathBuilder with `.moveTo()`')\n\t\treturn this.lastMoveTo\n\t}\n\n\tmoveTo(x: number, y: number, opts?: PathBuilderLineOpts) {\n\t\tthis.lastMoveTo = { type: 'move', x, y, closeIdx: null, isClose: false, opts }\n\t\tthis.commands.push(this.lastMoveTo)\n\t\treturn this\n\t}\n\n\tlineTo(x: number, y: number, opts?: PathBuilderCommandOpts) {\n\t\tthis.assertHasMoveTo()\n\t\tthis.commands.push({ type: 'line', x, y, isClose: false, opts })\n\t\treturn this\n\t}\n\n\tcircularArcTo(\n\t\tradius: number,\n\t\tlargeArcFlag: boolean,\n\t\tsweepFlag: boolean,\n\t\tx2: number,\n\t\ty2: number,\n\t\topts?: PathBuilderCommandOpts\n\t) {\n\t\treturn this.arcTo(radius, radius, largeArcFlag, sweepFlag, 0, x2, y2, opts)\n\t}\n\n\tarcTo(\n\t\trx: number,\n\t\try: number,\n\t\tlargeArcFlag: boolean,\n\t\tsweepFlag: boolean,\n\t\txAxisRotationRadians: number,\n\t\tx2: number,\n\t\ty2: number,\n\t\topts?: PathBuilderCommandOpts\n\t) {\n\t\t// As arc flags make them very sensitive to offsets when we render them in draw mode, we\n\t\t// approximate arcs by converting them to up to 4 (1 per 90Â° segment) cubic bezier curves.\n\t\t// This algorithm is a Claude special:\n\t\t// https://claude.ai/public/artifacts/5ea0bf18-4afb-4b3d-948d-31b8a77ef1e2\n\n\t\tthis.assertHasMoveTo()\n\n\t\tconst x1 = this.commands[this.commands.length - 1].x\n\t\tconst y1 = this.commands[this.commands.length - 1].y\n\n\t\t// If the endpoints are identical, don't add a command\n\t\tif (x1 === x2 && y1 === y2) {\n\t\t\treturn this\n\t\t}\n\n\t\t// If rx or ry is 0, return a straight line\n\t\tif (rx === 0 || ry === 0) {\n\t\t\treturn this.lineTo(x2, y2, opts)\n\t\t}\n\n\t\t// Convert angle from degrees to radians\n\t\tconst phi = xAxisRotationRadians\n\t\tconst sinPhi = Math.sin(phi)\n\t\tconst cosPhi = Math.cos(phi)\n\n\t\t// Ensure rx and ry are positive\n\t\tlet rx1 = Math.abs(rx)\n\t\tlet ry1 = Math.abs(ry)\n\n\t\t// Step 1: Compute (x1', y1') - transform from ellipse coordinate system to unit circle\n\t\tconst dx = (x1 - x2) / 2\n\t\tconst dy = (y1 - y2) / 2\n\t\tconst x1p = cosPhi * dx + sinPhi * dy\n\t\tconst y1p = -sinPhi * dx + cosPhi * dy\n\n\t\t// Correction of out-of-range radii\n\t\tconst lambda = (x1p * x1p) / (rx1 * rx1) + (y1p * y1p) / (ry1 * ry1)\n\t\tif (lambda > 1) {\n\t\t\tconst sqrtLambda = Math.sqrt(lambda)\n\t\t\trx1 *= sqrtLambda\n\t\t\try1 *= sqrtLambda\n\t\t}\n\n\t\t// Step 2: Compute (cx', cy') - center of ellipse in transformed system\n\t\tconst sign = largeArcFlag !== sweepFlag ? 1 : -1\n\n\t\tconst term = rx1 * rx1 * ry1 * ry1 - rx1 * rx1 * y1p * y1p - ry1 * ry1 * x1p * x1p\n\t\tconst numerator = rx1 * rx1 * y1p * y1p + ry1 * ry1 * x1p * x1p\n\n\t\tlet radicand = term / numerator\n\t\tradicand = radicand < 0 ? 0 : radicand\n\n\t\tconst coef = sign * Math.sqrt(radicand)\n\n\t\tconst cxp = coef * ((rx1 * y1p) / ry1)\n\t\tconst cyp = coef * (-(ry1 * x1p) / rx1)\n\n\t\t// Step 3: Compute (cx, cy) from (cx', cy') - transform back to original coordinate system\n\t\tconst cx = cosPhi * cxp - sinPhi * cyp + (x1 + x2) / 2\n\t\tconst cy = sinPhi * cxp + cosPhi * cyp + (y1 + y2) / 2\n\n\t\t// Step 4: Compute the start and end angles\n\t\tconst ux = (x1p - cxp) / rx1\n\t\tconst uy = (y1p - cyp) / ry1\n\t\tconst vx = (-x1p - cxp) / rx1\n\t\tconst vy = (-y1p - cyp) / ry1\n\n\t\tconst startAngle = Math.atan2(uy, ux)\n\t\tlet endAngle = Math.atan2(vy, vx)\n\n\t\t// Ensure correct sweep direction\n\t\tif (!sweepFlag && endAngle > startAngle) {\n\t\t\tendAngle -= 2 * Math.PI\n\t\t} else if (sweepFlag && endAngle < startAngle) {\n\t\t\tendAngle += 2 * Math.PI\n\t\t}\n\n\t\t// Calculate the sweep angle\n\t\tconst sweepAngle = endAngle - startAngle\n\n\t\t// Calculate the approximate arc length. General ellipse arc length is expensive - there's\n\t\t// no closed form solution, so we have to do iterative numerical approximation. As we only\n\t\t// use this to control the resolution of later approximations, let's cheat and just use the\n\t\t// circular arc length with the largest radius:\n\t\tconst approximateArcLength = Math.max(rx1, ry1) * Math.abs(sweepAngle)\n\n\t\t// Approximate the arc using cubic bezier curves\n\t\tconst numSegments = Math.min(4, Math.ceil(Math.abs(sweepAngle) / (Math.PI / 2)))\n\t\tconst resolutionPerSegment = Math.ceil(\n\t\t\tgetVerticesCountForArcLength(approximateArcLength) / numSegments\n\t\t)\n\t\tconst anglePerSegment = sweepAngle / numSegments\n\n\t\t// Helper function to compute point on ellipse\n\t\tconst ellipsePoint = (angle: number) => {\n\t\t\treturn {\n\t\t\t\tx: cx + rx1 * Math.cos(angle) * cosPhi - ry1 * Math.sin(angle) * sinPhi,\n\t\t\t\ty: cy + rx1 * Math.cos(angle) * sinPhi + ry1 * Math.sin(angle) * cosPhi,\n\t\t\t}\n\t\t}\n\n\t\t// Helper function to compute derivative (tangent vector) at a point on the ellipse\n\t\tconst ellipseDerivative = (angle: number) => {\n\t\t\treturn {\n\t\t\t\tx: -rx1 * Math.sin(angle) * cosPhi - ry1 * Math.cos(angle) * sinPhi,\n\t\t\t\ty: -rx1 * Math.sin(angle) * sinPhi + ry1 * Math.cos(angle) * cosPhi,\n\t\t\t}\n\t\t}\n\n\t\t// Generate cubic bezier approximations\n\t\tfor (let i = 0; i < numSegments; i++) {\n\t\t\tconst theta1 = startAngle + i * anglePerSegment\n\t\t\tconst theta2 = startAngle + (i + 1) * anglePerSegment\n\t\t\tconst deltaTheta = theta2 - theta1\n\n\t\t\tconst start = ellipsePoint(theta1)\n\t\t\tconst end = ellipsePoint(theta2)\n\n\t\t\t// Get the derivative at the start and end points\n\t\t\tconst d1 = ellipseDerivative(theta1)\n\t\t\tconst d2 = ellipseDerivative(theta2)\n\n\t\t\t// Calculate the length of the tangent handles\n\t\t\t// This is a key factor for the accuracy of the approximation\n\t\t\t// For a 90Â° arc, the handle length should be 4/3 * tan(Ï/8) * r\n\t\t\t// For smaller arcs, we scale this value by the angle ratio\n\t\t\tconst handleScale = (4 / 3) * Math.tan(deltaTheta / 4)\n\n\t\t\t// Create control points that are tangent to the ellipse at the endpoints\n\t\t\tconst cp1x = start.x + handleScale * d1.x\n\t\t\tconst cp1y = start.y + handleScale * d1.y\n\n\t\t\tconst cp2x = end.x - handleScale * d2.x\n\t\t\tconst cp2y = end.y - handleScale * d2.y\n\n\t\t\tconst bezierOpts = i === 0 ? opts : { ...opts, mergeWithPrevious: true }\n\t\t\tthis.cubicBezierToWithResolution(\n\t\t\t\tend.x,\n\t\t\t\tend.y,\n\t\t\t\tcp1x,\n\t\t\t\tcp1y,\n\t\t\t\tcp2x,\n\t\t\t\tcp2y,\n\t\t\t\tbezierOpts,\n\t\t\t\tresolutionPerSegment\n\t\t\t)\n\t\t}\n\n\t\treturn this\n\t}\n\n\tcubicBezierTo(\n\t\tx: number,\n\t\ty: number,\n\t\tcp1X: number,\n\t\tcp1Y: number,\n\t\tcp2X: number,\n\t\tcp2Y: number,\n\t\topts?: PathBuilderCommandOpts\n\t) {\n\t\treturn this.cubicBezierToWithResolution(x, y, cp1X, cp1Y, cp2X, cp2Y, opts)\n\t}\n\tprivate cubicBezierToWithResolution(\n\t\tx: number,\n\t\ty: number,\n\t\tcp1X: number,\n\t\tcp1Y: number,\n\t\tcp2X: number,\n\t\tcp2Y: number,\n\t\topts?: PathBuilderCommandOpts,\n\t\tresolution?: number\n\t) {\n\t\tthis.assertHasMoveTo()\n\t\tthis.commands.push({\n\t\t\ttype: 'cubic',\n\t\t\tx,\n\t\t\ty,\n\t\t\tcp1: { x: cp1X, y: cp1Y },\n\t\t\tcp2: { x: cp2X, y: cp2Y },\n\t\t\tisClose: false,\n\t\t\topts,\n\t\t\tresolution,\n\t\t})\n\t\treturn this\n\t}\n\n\tclose() {\n\t\tconst lastMoveTo = this.assertHasMoveTo()\n\t\tconst lastCommand = this.commands[this.commands.length - 1]\n\n\t\tif (approximately(lastMoveTo.x, lastCommand.x) && approximately(lastMoveTo.y, lastCommand.y)) {\n\t\t\tlastCommand.isClose = true\n\t\t} else {\n\t\t\tthis.commands.push({\n\t\t\t\ttype: 'line',\n\t\t\t\tx: lastMoveTo.x,\n\t\t\t\ty: lastMoveTo.y,\n\t\t\t\tisClose: true,\n\t\t\t})\n\t\t}\n\n\t\tlastMoveTo.closeIdx = this.commands.length - 1\n\t\tthis.lastMoveTo = null\n\t\treturn this\n\t}\n\n\ttoD(opts: PathBuilderToDOpts = {}) {\n\t\tconst { startIdx = 0, endIdx = this.commands.length, onlyFilled = false } = opts\n\t\tconst parts = []\n\n\t\tlet isSkippingCurrentLine = false\n\n\t\tlet didAddMove = false\n\t\tlet didAddNaturalMove = false\n\n\t\tconst addMoveIfNeeded = (i: number) => {\n\t\t\tif (didAddMove || i === 0) return\n\t\t\tdidAddMove = true\n\t\t\tconst command = this.commands[i - 1]\n\t\t\tparts.push('M', toDomPrecision(command.x), toDomPrecision(command.y))\n\t\t}\n\n\t\tfor (let i = startIdx; i < endIdx; i++) {\n\t\t\tconst command = this.commands[i]\n\t\t\tswitch (command.type) {\n\t\t\t\tcase 'move': {\n\t\t\t\t\tconst isFilled =\n\t\t\t\t\t\tcommand.opts?.geometry === false ? false : (command.opts?.geometry?.isFilled ?? false)\n\t\t\t\t\tif (onlyFilled && !isFilled) {\n\t\t\t\t\t\tisSkippingCurrentLine = true\n\t\t\t\t\t} else {\n\t\t\t\t\t\tisSkippingCurrentLine = false\n\t\t\t\t\t\tdidAddMove = true\n\t\t\t\t\t\tdidAddNaturalMove = true\n\t\t\t\t\t\tparts.push('M', toDomPrecision(command.x), toDomPrecision(command.y))\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'line':\n\t\t\t\t\tif (isSkippingCurrentLine) break\n\t\t\t\t\taddMoveIfNeeded(i)\n\t\t\t\t\tif (command.isClose && didAddNaturalMove) {\n\t\t\t\t\t\tparts.push('Z')\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparts.push('L', toDomPrecision(command.x), toDomPrecision(command.y))\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\tcase 'cubic':\n\t\t\t\t\tif (isSkippingCurrentLine) break\n\t\t\t\t\taddMoveIfNeeded(i)\n\t\t\t\t\tparts.push(\n\t\t\t\t\t\t'C',\n\t\t\t\t\t\ttoDomPrecision(command.cp1.x),\n\t\t\t\t\t\ttoDomPrecision(command.cp1.y),\n\t\t\t\t\t\ttoDomPrecision(command.cp2.x),\n\t\t\t\t\t\ttoDomPrecision(command.cp2.y),\n\t\t\t\t\t\ttoDomPrecision(command.x),\n\t\t\t\t\t\ttoDomPrecision(command.y)\n\t\t\t\t\t)\n\t\t\t\t\tbreak\n\t\t\t\tdefault:\n\t\t\t\t\texhaustiveSwitchError(command, 'type')\n\t\t\t}\n\t\t}\n\t\treturn parts.join(' ')\n\t}\n\n\ttoSvg(opts: PathBuilderOpts) {\n\t\tif (opts.forceSolid) {\n\t\t\treturn this.toSolidSvg(opts)\n\t\t}\n\t\tswitch (opts.style) {\n\t\t\tcase 'solid':\n\t\t\t\treturn this.toSolidSvg(opts)\n\t\t\tcase 'dashed':\n\t\t\tcase 'dotted':\n\t\t\t\treturn this.toDashedSvg(opts)\n\t\t\tcase 'draw': {\n\t\t\t\tconst d = this.toDrawSvg(opts)\n\t\t\t\treturn d\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\texhaustiveSwitchError(opts, 'style')\n\t\t}\n\t}\n\n\ttoGeometry(): PathBuilderGeometry2d | Group2d {\n\t\tconst geometries = []\n\n\t\tlet current: null | {\n\t\t\tstartIdx: number\n\t\t\tmoveCommand: MoveToPathBuilderCommand\n\t\t\tisClosed: boolean\n\t\t\topts?: PathBuilderLineOpts\n\t\t} = null\n\t\tfor (let i = 0; i < this.commands.length; i++) {\n\t\t\tconst command = this.commands[i]\n\n\t\t\tif (command.type === 'move') {\n\t\t\t\tif (current && current.opts?.geometry !== false) {\n\t\t\t\t\tgeometries.push(\n\t\t\t\t\t\tnew PathBuilderGeometry2d(this, current.startIdx, i, {\n\t\t\t\t\t\t\t...current.opts?.geometry,\n\t\t\t\t\t\t\tisFilled: current.opts?.geometry?.isFilled ?? false,\n\t\t\t\t\t\t\tisClosed: current.moveCommand.closeIdx !== null,\n\t\t\t\t\t\t})\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\tcurrent = { startIdx: i, moveCommand: command, opts: command.opts, isClosed: false }\n\t\t\t}\n\n\t\t\tif (command.isClose) {\n\t\t\t\tassert(current, 'No current move command')\n\t\t\t\tcurrent.isClosed = true\n\t\t\t}\n\t\t}\n\n\t\tif (current && current.opts?.geometry !== false) {\n\t\t\tgeometries.push(\n\t\t\t\tnew PathBuilderGeometry2d(this, current.startIdx, this.commands.length, {\n\t\t\t\t\t...current.opts?.geometry,\n\t\t\t\t\tisFilled: current.opts?.geometry?.isFilled ?? false,\n\t\t\t\t\tisClosed: current.moveCommand.closeIdx !== null,\n\t\t\t\t})\n\t\t\t)\n\t\t}\n\n\t\tassert(geometries.length > 0)\n\t\tif (geometries.length === 1) return geometries[0]\n\t\treturn new Group2d({ children: geometries })\n\t}\n\n\tprivate toSolidSvg(opts: PathBuilderOpts) {\n\t\tconst { strokeWidth, props } = opts\n\n\t\treturn (\n\t\t\t<path strokeWidth={strokeWidth} d={this.toD({ onlyFilled: opts.onlyFilled })} {...props} />\n\t\t)\n\t}\n\n\tprivate toDashedSvg(opts: DashedPathBuilderOpts) {\n\t\tconst {\n\t\t\tstyle,\n\t\t\tstrokeWidth,\n\t\t\tsnap,\n\t\t\tlengthRatio,\n\t\t\tprops: { markerStart, markerEnd, ...props } = {},\n\t\t} = opts\n\n\t\tconst parts: ReactNode[] = []\n\n\t\tlet isCurrentPathClosed = false\n\t\tlet isSkippingCurrentLine = false\n\t\tlet currentLineOpts: PathBuilderLineOpts | undefined = undefined\n\n\t\tlet currentRun: {\n\t\t\tstartIdx: number\n\t\t\tendIdx: number\n\t\t\tisFirst: boolean\n\t\t\tisLast: boolean\n\t\t\tlength: number\n\t\t\tlineOpts: PathBuilderLineOpts | undefined\n\t\t\tpathIsClosed: boolean\n\t\t} | null = null\n\n\t\tconst addCurrentRun = () => {\n\t\t\tif (!currentRun) return\n\t\t\tconst { startIdx, endIdx, isFirst, isLast, length, lineOpts, pathIsClosed } = currentRun\n\t\t\tcurrentRun = null\n\n\t\t\tif (startIdx === endIdx && this.commands[startIdx].type === 'move') return\n\n\t\t\tconst start = lineOpts?.dashStart ?? opts.start\n\t\t\tconst end = lineOpts?.dashEnd ?? opts.end\n\t\t\tconst { strokeDasharray, strokeDashoffset } = getPerfectDashProps(length, strokeWidth, {\n\t\t\t\tstyle,\n\t\t\t\tsnap,\n\t\t\t\tlengthRatio,\n\t\t\t\tstart: isFirst ? (start ?? (pathIsClosed ? 'outset' : 'none')) : 'outset',\n\t\t\t\tend: isLast ? (end ?? (pathIsClosed ? 'outset' : 'none')) : 'outset',\n\t\t\t})\n\n\t\t\tconst d = this.toD({ startIdx, endIdx: endIdx + 1 })\n\t\t\tparts.push(\n\t\t\t\t<path\n\t\t\t\t\tkey={parts.length}\n\t\t\t\t\td={d}\n\t\t\t\t\tstrokeDasharray={strokeDasharray}\n\t\t\t\t\tstrokeDashoffset={strokeDashoffset}\n\t\t\t\t\tmarkerStart={isFirst ? markerStart : undefined}\n\t\t\t\t\tmarkerEnd={isLast ? markerEnd : undefined}\n\t\t\t\t/>\n\t\t\t)\n\t\t}\n\n\t\tfor (let i = 0; i < this.commands.length; i++) {\n\t\t\tconst command = this.commands[i]\n\t\t\tconst lastCommand = this.commands[i - 1]\n\t\t\tif (command.type === 'move') {\n\t\t\t\tisCurrentPathClosed = command.closeIdx !== null\n\t\t\t\tconst isFilled =\n\t\t\t\t\tcommand.opts?.geometry === false ? false : (command.opts?.geometry?.isFilled ?? false)\n\t\t\t\tif (opts.onlyFilled && !isFilled) {\n\t\t\t\t\tisSkippingCurrentLine = true\n\t\t\t\t} else {\n\t\t\t\t\tisSkippingCurrentLine = false\n\t\t\t\t\tcurrentLineOpts = command.opts\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif (isSkippingCurrentLine) continue\n\n\t\t\tconst segmentLength = this.calculateSegmentLength(lastCommand, command)\n\t\t\tconst isFirst = lastCommand.type === 'move'\n\t\t\tconst isLast =\n\t\t\t\tcommand.isClose || i === this.commands.length - 1 || this.commands[i + 1]?.type === 'move'\n\n\t\t\tif (currentRun && command.opts?.mergeWithPrevious) {\n\t\t\t\tcurrentRun.length += segmentLength\n\t\t\t\tcurrentRun.endIdx = i\n\t\t\t\tcurrentRun.isLast = isLast\n\t\t\t} else {\n\t\t\t\taddCurrentRun()\n\t\t\t\tcurrentRun = {\n\t\t\t\t\tstartIdx: i,\n\t\t\t\t\tendIdx: i,\n\t\t\t\t\tisFirst,\n\t\t\t\t\tisLast,\n\t\t\t\t\tlength: segmentLength,\n\t\t\t\t\tlineOpts: currentLineOpts,\n\t\t\t\t\tpathIsClosed: isCurrentPathClosed,\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\taddCurrentRun()\n\n\t\treturn (\n\t\t\t<g strokeWidth={strokeWidth} {...props}>\n\t\t\t\t{parts}\n\t\t\t</g>\n\t\t)\n\t}\n\n\tprivate toDrawSvg(opts: DrawPathBuilderOpts) {\n\t\treturn <path strokeWidth={opts.strokeWidth} d={this.toDrawD(opts)} {...opts.props} />\n\t}\n\n\ttoDrawD(opts: DrawPathBuilderDOpts) {\n\t\tconst {\n\t\t\tstrokeWidth,\n\t\t\trandomSeed,\n\t\t\toffset: defaultOffset = strokeWidth / 3,\n\t\t\troundness: defaultRoundness = strokeWidth * 2,\n\t\t\tpasses = 2,\n\t\t\tonlyFilled = false,\n\t\t} = opts\n\n\t\tconst parts = []\n\n\t\tconst commandInfo = this.getCommandInfo()\n\n\t\t// for each command, we draw the line for the command, plus the corner to the next command.\n\t\tconst drawCommands = []\n\t\tlet lastMoveCommandIdx = null\n\t\tfor (let i = 0; i < this.commands.length; i++) {\n\t\t\tconst command = this.commands[i]\n\t\t\tconst offset = command.opts?.offset ?? defaultOffset\n\t\t\tconst roundness = command.opts?.roundness ?? defaultRoundness\n\n\t\t\tif (command.type === 'move') {\n\t\t\t\tlastMoveCommandIdx = i\n\t\t\t}\n\n\t\t\tconst nextIdx = command.isClose\n\t\t\t\t? assertExists(lastMoveCommandIdx) + 1\n\t\t\t\t: !this.commands[i + 1] || this.commands[i + 1].type === 'move'\n\t\t\t\t\t? undefined\n\t\t\t\t\t: i + 1\n\n\t\t\tconst nextInfo =\n\t\t\t\tnextIdx !== undefined && this.commands[nextIdx] && this.commands[nextIdx]?.type !== 'move'\n\t\t\t\t\t? commandInfo[nextIdx]\n\t\t\t\t\t: undefined\n\n\t\t\tconst currentSupportsRoundness = commandsSupportingRoundness[command.type]\n\t\t\tconst nextSupportsRoundness =\n\t\t\t\tnextIdx !== undefined ? commandsSupportingRoundness[this.commands[nextIdx].type] : false\n\n\t\t\tconst currentInfo = commandInfo[i]\n\n\t\t\tconst tangentToPrev = currentInfo?.tangentEnd\n\t\t\tconst tangentToNext = nextInfo?.tangentStart\n\n\t\t\tconst roundnessClampedForAngle =\n\t\t\t\tcurrentSupportsRoundness &&\n\t\t\t\tnextSupportsRoundness &&\n\t\t\t\ttangentToPrev &&\n\t\t\t\ttangentToNext &&\n\t\t\t\tVec.Len2(tangentToPrev) > 0.01 &&\n\t\t\t\tVec.Len2(tangentToNext) > 0.01\n\t\t\t\t\t? modulate(\n\t\t\t\t\t\t\tMath.abs(Vec.AngleBetween(tangentToPrev, tangentToNext)),\n\t\t\t\t\t\t\t[Math.PI / 2, Math.PI],\n\t\t\t\t\t\t\t[roundness, 0],\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t)\n\t\t\t\t\t: 0\n\n\t\t\tconst shortestDistance = Math.min(\n\t\t\t\tcurrentInfo?.length ?? Infinity,\n\t\t\t\tnextInfo?.length ?? Infinity\n\t\t\t)\n\t\t\tconst offsetLimit = shortestDistance - roundnessClampedForAngle * 2\n\n\t\t\tconst offsetAmount = clamp(offset, 0, offsetLimit / 4)\n\n\t\t\tconst roundnessBeforeClampedForLength = Math.min(\n\t\t\t\troundnessClampedForAngle,\n\t\t\t\t(currentInfo?.length ?? Infinity) / 4\n\t\t\t)\n\t\t\tconst roundnessAfterClampedForLength = Math.min(\n\t\t\t\troundnessClampedForAngle,\n\t\t\t\t(nextInfo?.length ?? Infinity) / 4\n\t\t\t)\n\n\t\t\tconst drawCommand = {\n\t\t\t\tcommand,\n\t\t\t\toffsetAmount,\n\t\t\t\troundnessBefore: roundnessBeforeClampedForLength,\n\t\t\t\troundnessAfter: roundnessAfterClampedForLength,\n\t\t\t\ttangentToPrev: commandInfo[i]?.tangentEnd,\n\t\t\t\ttangentToNext: nextInfo?.tangentStart,\n\t\t\t\tmoveDidClose: false,\n\t\t\t}\n\n\t\t\tdrawCommands.push(drawCommand)\n\n\t\t\tif (command.isClose && lastMoveCommandIdx !== null) {\n\t\t\t\tconst lastMoveCommand = drawCommands[lastMoveCommandIdx]\n\t\t\t\tlastMoveCommand.moveDidClose = true\n\t\t\t\tlastMoveCommand.roundnessAfter = roundnessAfterClampedForLength\n\t\t\t} else if (command.type === 'move') {\n\t\t\t\tlastMoveCommandIdx = i\n\t\t\t}\n\t\t}\n\n\t\tfor (let pass = 0; pass < passes; pass++) {\n\t\t\tconst random = rng(randomSeed + pass)\n\n\t\t\tlet lastMoveToOffset = { x: 0, y: 0 }\n\t\t\tlet isSkippingCurrentLine = false\n\t\t\tfor (const {\n\t\t\t\tcommand,\n\t\t\t\toffsetAmount,\n\t\t\t\troundnessBefore,\n\t\t\t\troundnessAfter,\n\t\t\t\ttangentToNext,\n\t\t\t\ttangentToPrev,\n\t\t\t} of drawCommands) {\n\t\t\t\tconst offset = command.isClose\n\t\t\t\t\t? lastMoveToOffset\n\t\t\t\t\t: { x: random() * offsetAmount, y: random() * offsetAmount }\n\n\t\t\t\tif (command.type === 'move') {\n\t\t\t\t\tlastMoveToOffset = offset\n\t\t\t\t\tconst isFilled =\n\t\t\t\t\t\tcommand.opts?.geometry === false ? false : (command.opts?.geometry?.isFilled ?? false)\n\t\t\t\t\tif (onlyFilled && !isFilled) {\n\t\t\t\t\t\tisSkippingCurrentLine = true\n\t\t\t\t\t} else {\n\t\t\t\t\t\tisSkippingCurrentLine = false\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (isSkippingCurrentLine) continue\n\n\t\t\t\tconst offsetPoint = Vec.Add(command, offset)\n\n\t\t\t\tconst endPoint =\n\t\t\t\t\ttangentToNext && roundnessAfter > 0\n\t\t\t\t\t\t? Vec.Mul(tangentToNext, -roundnessAfter).add(offsetPoint)\n\t\t\t\t\t\t: offsetPoint\n\n\t\t\t\tconst startPoint =\n\t\t\t\t\ttangentToPrev && roundnessBefore > 0\n\t\t\t\t\t\t? Vec.Mul(tangentToPrev, roundnessBefore).add(offsetPoint)\n\t\t\t\t\t\t: offsetPoint\n\n\t\t\t\tif (endPoint === offsetPoint || startPoint === offsetPoint) {\n\t\t\t\t\tswitch (command.type) {\n\t\t\t\t\t\tcase 'move':\n\t\t\t\t\t\t\tparts.push('M', toDomPrecision(endPoint.x), toDomPrecision(endPoint.y))\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tcase 'line':\n\t\t\t\t\t\t\tparts.push('L', toDomPrecision(endPoint.x), toDomPrecision(endPoint.y))\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tcase 'cubic': {\n\t\t\t\t\t\t\tconst offsetCp1 = Vec.Add(command.cp1, offset)\n\t\t\t\t\t\t\tconst offsetCp2 = Vec.Add(command.cp2, offset)\n\t\t\t\t\t\t\tparts.push(\n\t\t\t\t\t\t\t\t'C',\n\t\t\t\t\t\t\t\ttoDomPrecision(offsetCp1.x),\n\t\t\t\t\t\t\t\ttoDomPrecision(offsetCp1.y),\n\t\t\t\t\t\t\t\ttoDomPrecision(offsetCp2.x),\n\t\t\t\t\t\t\t\ttoDomPrecision(offsetCp2.y),\n\t\t\t\t\t\t\t\ttoDomPrecision(endPoint.x),\n\t\t\t\t\t\t\t\ttoDomPrecision(endPoint.y)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\texhaustiveSwitchError(command, 'type')\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tswitch (command.type) {\n\t\t\t\t\t\tcase 'move':\n\t\t\t\t\t\t\tparts.push('M', toDomPrecision(endPoint.x), toDomPrecision(endPoint.y))\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tcase 'line':\n\t\t\t\t\t\t\tparts.push(\n\t\t\t\t\t\t\t\t'L',\n\t\t\t\t\t\t\t\ttoDomPrecision(startPoint.x),\n\t\t\t\t\t\t\t\ttoDomPrecision(startPoint.y),\n\n\t\t\t\t\t\t\t\t'Q',\n\t\t\t\t\t\t\t\ttoDomPrecision(offsetPoint.x),\n\t\t\t\t\t\t\t\ttoDomPrecision(offsetPoint.y),\n\t\t\t\t\t\t\t\ttoDomPrecision(endPoint.x),\n\t\t\t\t\t\t\t\ttoDomPrecision(endPoint.y)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tcase 'cubic': {\n\t\t\t\t\t\t\tconst offsetCp1 = Vec.Add(command.cp1, offset)\n\t\t\t\t\t\t\tconst offsetCp2 = Vec.Add(command.cp2, offset)\n\t\t\t\t\t\t\tparts.push(\n\t\t\t\t\t\t\t\t'C',\n\t\t\t\t\t\t\t\ttoDomPrecision(offsetCp1.x),\n\t\t\t\t\t\t\t\ttoDomPrecision(offsetCp1.y),\n\t\t\t\t\t\t\t\ttoDomPrecision(offsetCp2.x),\n\t\t\t\t\t\t\t\ttoDomPrecision(offsetCp2.y),\n\t\t\t\t\t\t\t\ttoDomPrecision(offsetPoint.x),\n\t\t\t\t\t\t\t\ttoDomPrecision(offsetPoint.y)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\texhaustiveSwitchError(command, 'type')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn parts.join(' ')\n\t}\n\n\tprivate calculateSegmentLength(lastPoint: VecLike, command: PathBuilderCommand) {\n\t\tswitch (command.type) {\n\t\t\tcase 'move':\n\t\t\t\treturn 0\n\t\t\tcase 'line':\n\t\t\t\treturn Vec.Dist(lastPoint, command)\n\t\t\tcase 'cubic':\n\t\t\t\treturn CubicBezier.length(\n\t\t\t\t\tlastPoint.x,\n\t\t\t\t\tlastPoint.y,\n\t\t\t\t\tcommand.cp1.x,\n\t\t\t\t\tcommand.cp1.y,\n\t\t\t\t\tcommand.cp2.x,\n\t\t\t\t\tcommand.cp2.y,\n\t\t\t\t\tcommand.x,\n\t\t\t\t\tcommand.y\n\t\t\t\t)\n\t\t\tdefault:\n\t\t\t\texhaustiveSwitchError(command, 'type')\n\t\t}\n\t}\n\n\t/** @internal */\n\tgetCommands(): readonly PathBuilderCommand[] {\n\t\treturn this.commands\n\t}\n\n\t/** @internal */\n\tgetCommandInfo() {\n\t\tconst commandInfo: Array<undefined | PathBuilderCommandInfo> = []\n\t\tfor (let i = 1; i < this.commands.length; i++) {\n\t\t\tconst previous = this.commands[i - 1]\n\t\t\tconst current = this.commands[i]\n\n\t\t\tif (current._info) {\n\t\t\t\tcommandInfo[i] = current._info\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif (current.type === 'move') {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tlet tangentStart, tangentEnd\n\t\t\tswitch (current.type) {\n\t\t\t\tcase 'line':\n\t\t\t\t\ttangentStart = tangentEnd = Vec.Sub(previous, current).uni()\n\t\t\t\t\tbreak\n\t\t\t\tcase 'cubic': {\n\t\t\t\t\ttangentStart = Vec.Sub(current.cp1, previous).uni()\n\t\t\t\t\ttangentEnd = Vec.Sub(current.cp2, current).uni()\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\texhaustiveSwitchError(current, 'type')\n\t\t\t}\n\n\t\t\tcurrent._info = {\n\t\t\t\ttangentStart,\n\t\t\t\ttangentEnd,\n\t\t\t\tlength: this.calculateSegmentLength(previous, current),\n\t\t\t}\n\t\t\tcommandInfo[i] = current._info\n\t\t}\n\n\t\treturn commandInfo\n\t}\n}\n\nconst commandsSupportingRoundness = {\n\tline: true,\n\tmove: true,\n\tcubic: false,\n} as const satisfies Record<PathBuilderCommand['type'], boolean>\n\n/** @public */\nexport class PathBuilderGeometry2d extends Geometry2d {\n\tconstructor(\n\t\tprivate readonly path: PathBuilder,\n\t\tprivate readonly startIdx: number,\n\t\tprivate readonly endIdx: number,\n\t\toptions: Geometry2dOptions\n\t) {\n\t\tsuper(options)\n\t}\n\n\tprivate _segments: Geometry2d[] | null = null\n\tgetSegments() {\n\t\tif (this._segments) return this._segments\n\n\t\tthis._segments = []\n\t\tlet last = this.path.commands[this.startIdx]\n\t\tassert(last.type === 'move')\n\n\t\tfor (let i = this.startIdx + 1; i < this.endIdx; i++) {\n\t\t\tconst command = this.path.commands[i]\n\t\t\tassert(command.type !== 'move')\n\n\t\t\tswitch (command.type) {\n\t\t\t\tcase 'line':\n\t\t\t\t\tthis._segments.push(new Edge2d({ start: Vec.From(last), end: Vec.From(command) }))\n\t\t\t\t\tbreak\n\t\t\t\tcase 'cubic': {\n\t\t\t\t\tthis._segments.push(\n\t\t\t\t\t\tnew CubicBezier2d({\n\t\t\t\t\t\t\tstart: Vec.From(last),\n\t\t\t\t\t\t\tcp1: Vec.From(command.cp1),\n\t\t\t\t\t\t\tcp2: Vec.From(command.cp2),\n\t\t\t\t\t\t\tend: Vec.From(command),\n\t\t\t\t\t\t\tresolution: command.resolution,\n\t\t\t\t\t\t})\n\t\t\t\t\t)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\texhaustiveSwitchError(command, 'type')\n\t\t\t}\n\n\t\t\tlast = command\n\t\t}\n\n\t\treturn this._segments\n\t}\n\n\toverride getVertices(filters: Geometry2dFilters): Vec[] {\n\t\tconst vs = this.getSegments()\n\t\t\t.flatMap((s) => s.getVertices(filters))\n\t\t\t.filter((vertex, i, vertices) => {\n\t\t\t\tconst prev = vertices[i - 1]\n\t\t\t\tif (!prev) return true\n\t\t\t\treturn !Vec.Equals(prev, vertex)\n\t\t\t})\n\n\t\tif (this.isClosed) {\n\t\t\tconst last = vs[vs.length - 1]\n\t\t\tconst first = vs[0]\n\t\t\tif (!Vec.Equals(last, first)) {\n\t\t\t\tvs.push(first)\n\t\t\t}\n\t\t}\n\n\t\treturn vs\n\t}\n\n\toverride nearestPoint(point: VecLike, _filters?: Geometry2dFilters): Vec {\n\t\tlet nearest: Vec | null = null\n\t\tlet nearestDistance = Infinity\n\n\t\tfor (const segment of this.getSegments()) {\n\t\t\tconst candidate = segment.nearestPoint(point)\n\t\t\tconst distance = Vec.Dist2(point, candidate)\n\t\t\tif (distance < nearestDistance) {\n\t\t\t\tnearestDistance = distance\n\t\t\t\tnearest = candidate\n\t\t\t}\n\t\t}\n\n\t\tassert(nearest, 'No nearest point found')\n\t\treturn nearest\n\t}\n\n\toverride hitTestLineSegment(\n\t\tA: VecLike,\n\t\tB: VecLike,\n\t\tdistance = 0,\n\t\tfilters?: Geometry2dFilters\n\t): boolean {\n\t\treturn super.hitTestLineSegment(A, B, distance, filters)\n\t}\n\toverride getSvgPathData(): string {\n\t\treturn this.path.toD({ startIdx: this.startIdx, endIdx: this.endIdx })\n\t}\n}\n\n/*!\n * Adapted from https://github.com/adobe-webplatform/Snap.svg/tree/master\n * Apache License: https://github.com/adobe-webplatform/Snap.svg/blob/master/LICENSE\n * https://github.com/adobe-webplatform/Snap.svg/blob/c8e483c9694517e24b282f8f59f985629f4994ce/dist/snap.svg.js#L5786\n */\nconst CubicBezier = {\n\tbase3(t: number, p1: number, p2: number, p3: number, p4: number) {\n\t\tconst t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4\n\t\tconst t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3\n\t\treturn t * t2 - 3 * p1 + 3 * p2\n\t},\n\t/**\n\t * Calculate the approximate length of a cubic bezier curve from (x1, y1) to (x4, y4) with\n\t * control points (x2, y2) and (x3, y3).\n\t */\n\tlength(\n\t\tx1: number,\n\t\ty1: number,\n\t\tx2: number,\n\t\ty2: number,\n\t\tx3: number,\n\t\ty3: number,\n\t\tx4: number,\n\t\ty4: number,\n\t\tz = 1\n\t) {\n\t\tz = z > 1 ? 1 : z < 0 ? 0 : z\n\t\tconst z2 = z / 2\n\t\tconst n = 12\n\n\t\tlet sum = 0\n\t\tsum = 0\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tconst ct = z2 * CubicBezier.Tvalues[i] + z2\n\t\t\tconst xbase = CubicBezier.base3(ct, x1, x2, x3, x4)\n\t\t\tconst ybase = CubicBezier.base3(ct, y1, y2, y3, y4)\n\t\t\tconst comb = xbase * xbase + ybase * ybase\n\t\t\tsum += CubicBezier.Cvalues[i] * Math.sqrt(comb)\n\t\t}\n\t\treturn z2 * sum\n\t},\n\tTvalues: [\n\t\t-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816,\n\t\t0.9816,\n\t],\n\tCvalues: [\n\t\t0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472,\n\t],\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 748, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/shared/usePrefersReducedMotion.tsx"],"sourcesContent":["import { useEffect, useState } from 'react'\n\n/** @public */\nexport function usePrefersReducedMotion() {\n\tconst [prefersReducedMotion, setPrefersReducedMotion] = useState(false)\n\n\tuseEffect(() => {\n\t\tif (typeof window === 'undefined' || !('matchMedia' in window)) return\n\t\tconst mql = window.matchMedia('(prefers-reduced-motion: reduce)')\n\t\tconst handler = () => {\n\t\t\tsetPrefersReducedMotion(mql.matches)\n\t\t}\n\t\thandler()\n\t\tmql.addEventListener('change', handler)\n\t\treturn () => mql.removeEventListener('change', handler)\n\t}, [])\n\n\treturn prefersReducedMotion\n}\n"],"names":[],"mappings":";;;AAAA,SAAS,WAAW,gBAAgB;;AAG7B,SAAS,0BAA0B;IACzC,MAAM,CAAC,sBAAsB,uBAAuB,CAAA,qKAAI,WAAA,EAAS,KAAK;IAEtE,CAAA,GAAA,6JAAA,CAAA,YAAA;6CAAU,MAAM;YACf,IAAI,OAAO,WAAW,eAAe,CAAA,CAAE,gBAAgB,MAAA,EAAS,CAAA;YAChE,MAAM,MAAM,OAAO,UAAA,CAAW,kCAAkC;YAChE,MAAM;6DAAU,MAAM;oBACrB,wBAAwB,IAAI,OAAO;gBACpC;;YACA,QAAQ;YACR,IAAI,gBAAA,CAAiB,UAAU,OAAO;YACtC;qDAAO,IAAM,IAAI,mBAAA,CAAoB,UAAU,OAAO;;QACvD;4CAAG,CAAC,CAAC;IAEL,OAAO;AACR","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 781, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/arrow/straight-arrow.ts"],"sourcesContent":["import { Editor, Mat, MatModel, TLArrowShape, Vec, VecLike } from '@tldraw/editor'\nimport { TLArrowInfo } from './arrow-types'\nimport {\n\tBOUND_ARROW_OFFSET,\n\tBoundShapeInfo,\n\tMIN_ARROW_LENGTH,\n\tSTROKE_SIZES,\n\tTLArrowBindings,\n\tgetArrowTerminalsInArrowSpace,\n\tgetBoundShapeInfoForTerminal,\n\tgetBoundShapeRelationships,\n} from './shared'\n\nexport function getStraightArrowInfo(\n\teditor: Editor,\n\tshape: TLArrowShape,\n\tbindings: TLArrowBindings\n): TLArrowInfo {\n\tconst { arrowheadStart, arrowheadEnd } = shape.props\n\n\tconst terminalsInArrowSpace = getArrowTerminalsInArrowSpace(editor, shape, bindings)\n\n\tconst a = terminalsInArrowSpace.start.clone()\n\tconst b = terminalsInArrowSpace.end.clone()\n\tconst c = Vec.Med(a, b)\n\n\tif (Vec.Equals(a, b)) {\n\t\treturn {\n\t\t\tbindings,\n\t\t\ttype: 'straight',\n\t\t\tstart: {\n\t\t\t\thandle: a,\n\t\t\t\tpoint: a,\n\t\t\t\tarrowhead: shape.props.arrowheadStart,\n\t\t\t},\n\t\t\tend: {\n\t\t\t\thandle: b,\n\t\t\t\tpoint: b,\n\t\t\t\tarrowhead: shape.props.arrowheadEnd,\n\t\t\t},\n\t\t\tmiddle: c,\n\t\t\tisValid: false,\n\t\t\tlength: 0,\n\t\t}\n\t}\n\n\tconst uAB = Vec.Sub(b, a).uni()\n\n\t// Update the arrowhead points using intersections with the bound shapes, if any.\n\n\tconst startShapeInfo = getBoundShapeInfoForTerminal(editor, shape, 'start')\n\tconst endShapeInfo = getBoundShapeInfoForTerminal(editor, shape, 'end')\n\n\tconst arrowPageTransform = editor.getShapePageTransform(shape)!\n\n\t// Update the position of the arrowhead's end point\n\tupdateArrowheadPointWithBoundShape(\n\t\tb, // <-- will be mutated\n\t\tterminalsInArrowSpace.start,\n\t\tarrowPageTransform,\n\t\tendShapeInfo\n\t)\n\n\t// Then update the position of the arrowhead's end point\n\tupdateArrowheadPointWithBoundShape(\n\t\ta, // <-- will be mutated\n\t\tterminalsInArrowSpace.end,\n\t\tarrowPageTransform,\n\t\tstartShapeInfo\n\t)\n\n\tlet offsetA = 0\n\tlet offsetB = 0\n\tlet strokeOffsetA = 0\n\tlet strokeOffsetB = 0\n\tlet minLength = MIN_ARROW_LENGTH * shape.props.scale\n\n\tconst isSelfIntersection =\n\t\tstartShapeInfo && endShapeInfo && startShapeInfo.shape === endShapeInfo.shape\n\n\tconst relationship =\n\t\tstartShapeInfo && endShapeInfo\n\t\t\t? getBoundShapeRelationships(editor, startShapeInfo.shape.id, endShapeInfo.shape.id)\n\t\t\t: 'safe'\n\n\tif (\n\t\trelationship === 'safe' &&\n\t\tstartShapeInfo &&\n\t\tendShapeInfo &&\n\t\t!isSelfIntersection &&\n\t\t!startShapeInfo.isExact &&\n\t\t!endShapeInfo.isExact\n\t) {\n\t\tif (endShapeInfo.didIntersect && !startShapeInfo.didIntersect) {\n\t\t\t// ...and if only the end shape intersected, then make it\n\t\t\t// a short arrow ending at the end shape intersection.\n\t\t\tif (startShapeInfo.isClosed) {\n\t\t\t\ta.setTo(b.clone().add(uAB.clone().mul(MIN_ARROW_LENGTH * shape.props.scale)))\n\t\t\t}\n\t\t} else if (!endShapeInfo.didIntersect) {\n\t\t\t// ...and if only the end shape intersected, or if neither\n\t\t\t// shape intersected, then make it a short arrow starting\n\t\t\t// at the start shape intersection.\n\t\t\tif (endShapeInfo.isClosed) {\n\t\t\t\tb.setTo(a.clone().sub(uAB.clone().mul(MIN_ARROW_LENGTH * shape.props.scale)))\n\t\t\t}\n\t\t}\n\t}\n\n\tconst distance = Vec.Sub(b, a)\n\t// Check for divide-by-zero before we call uni()\n\tconst u = Vec.Len(distance) ? distance.uni() : Vec.From(distance)\n\tconst didFlip = !Vec.Equals(u, uAB)\n\n\t// If the arrow is bound non-exact to a start shape and the\n\t// start point has an arrowhead, then offset the start point\n\tif (!isSelfIntersection) {\n\t\tif (\n\t\t\trelationship !== 'start-contains-end' &&\n\t\t\tstartShapeInfo &&\n\t\t\tarrowheadStart !== 'none' &&\n\t\t\t!startShapeInfo.isExact\n\t\t) {\n\t\t\tstrokeOffsetA =\n\t\t\t\tSTROKE_SIZES[shape.props.size] / 2 +\n\t\t\t\t('size' in startShapeInfo.shape.props\n\t\t\t\t\t? STROKE_SIZES[startShapeInfo.shape.props.size] / 2\n\t\t\t\t\t: 0)\n\t\t\toffsetA = (BOUND_ARROW_OFFSET + strokeOffsetA) * shape.props.scale\n\t\t\tminLength += strokeOffsetA * shape.props.scale\n\t\t}\n\n\t\t// If the arrow is bound non-exact to an end shape and the\n\t\t// end point has an arrowhead offset the end point\n\t\tif (\n\t\t\trelationship !== 'end-contains-start' &&\n\t\t\tendShapeInfo &&\n\t\t\tarrowheadEnd !== 'none' &&\n\t\t\t!endShapeInfo.isExact\n\t\t) {\n\t\t\tstrokeOffsetB =\n\t\t\t\tSTROKE_SIZES[shape.props.size] / 2 +\n\t\t\t\t('size' in endShapeInfo.shape.props ? STROKE_SIZES[endShapeInfo.shape.props.size] / 2 : 0)\n\t\t\toffsetB = (BOUND_ARROW_OFFSET + strokeOffsetB) * shape.props.scale\n\t\t\tminLength += strokeOffsetB * shape.props.scale\n\t\t}\n\t}\n\n\t// Adjust offsets if the length of the arrow is too small\n\n\tconst tA = a.clone().add(u.clone().mul(offsetA * (didFlip ? -1 : 1)))\n\tconst tB = b.clone().sub(u.clone().mul(offsetB * (didFlip ? -1 : 1)))\n\n\tif (Vec.DistMin(tA, tB, minLength)) {\n\t\tif (offsetA !== 0 && offsetB !== 0) {\n\t\t\t// both bound + offset\n\t\t\toffsetA *= -1.5\n\t\t\toffsetB *= -1.5\n\t\t} else if (offsetA !== 0) {\n\t\t\t// start bound + offset\n\t\t\toffsetA *= -1\n\t\t} else if (offsetB !== 0) {\n\t\t\t// end bound + offset\n\t\t\toffsetB *= -1\n\t\t} else {\n\t\t\t// noop, its just a really short arrow\n\t\t}\n\t}\n\n\ta.add(u.clone().mul(offsetA * (didFlip ? -1 : 1)))\n\tb.sub(u.clone().mul(offsetB * (didFlip ? -1 : 1)))\n\n\t// If the handles flipped their order, then set the center handle\n\t// to the midpoint of the terminals (rather than the midpoint of the\n\t// arrow body); otherwise, it may not be \"between\" the other terminals.\n\tif (didFlip) {\n\t\tif (startShapeInfo && endShapeInfo) {\n\t\t\t// If we have two bound shapes...then make the arrow a short arrow from\n\t\t\t// the start point towards where the end point should be.\n\t\t\tb.setTo(Vec.Add(a, u.clone().mul(-MIN_ARROW_LENGTH * shape.props.scale)))\n\t\t}\n\t\tc.setTo(Vec.Med(terminalsInArrowSpace.start, terminalsInArrowSpace.end))\n\t} else {\n\t\tc.setTo(Vec.Med(a, b))\n\t}\n\n\tconst length = Vec.Dist(a, b)\n\n\treturn {\n\t\tbindings,\n\t\ttype: 'straight',\n\t\tstart: {\n\t\t\thandle: terminalsInArrowSpace.start,\n\t\t\tpoint: a,\n\t\t\tarrowhead: shape.props.arrowheadStart,\n\t\t},\n\t\tend: {\n\t\t\thandle: terminalsInArrowSpace.end,\n\t\t\tpoint: b,\n\t\t\tarrowhead: shape.props.arrowheadEnd,\n\t\t},\n\t\tmiddle: c,\n\t\tisValid: length > 0,\n\t\tlength,\n\t}\n}\n\n/** Get an intersection point from A -> B with bound shape (target) from shape (arrow). */\nfunction updateArrowheadPointWithBoundShape(\n\tpoint: Vec,\n\topposite: Vec,\n\tarrowPageTransform: MatModel,\n\ttargetShapeInfo?: BoundShapeInfo\n) {\n\tif (targetShapeInfo === undefined) {\n\t\t// No bound shape? The arrowhead point will be at the arrow terminal.\n\t\treturn\n\t}\n\n\tif (targetShapeInfo.isExact) {\n\t\t// Exact type binding? The arrowhead point will be at the arrow terminal.\n\t\treturn\n\t}\n\n\t// From and To in page space\n\tconst pageFrom = Mat.applyToPoint(arrowPageTransform, opposite)\n\tconst pageTo = Mat.applyToPoint(arrowPageTransform, point)\n\n\t// From and To in local space of the target shape\n\tconst targetFrom = Mat.applyToPoint(Mat.Inverse(targetShapeInfo.transform), pageFrom)\n\tconst targetTo = Mat.applyToPoint(Mat.Inverse(targetShapeInfo.transform), pageTo)\n\n\tconst intersection = Array.from(\n\t\ttargetShapeInfo.geometry.intersectLineSegment(targetFrom, targetTo, {\n\t\t\tincludeLabels: false,\n\t\t\tincludeInternal: false,\n\t\t})\n\t)\n\n\tlet targetInt: VecLike | undefined\n\n\tif (intersection.length) {\n\t\ttargetInt =\n\t\t\tintersection.sort((p1, p2) => Vec.Dist2(p1, targetFrom) - Vec.Dist2(p2, targetFrom))[0] ??\n\t\t\t(targetShapeInfo.isClosed ? undefined : targetTo)\n\t}\n\n\tif (targetInt === undefined) {\n\t\t// No intersection? The arrowhead point will be at the arrow terminal.\n\t\t// if we _almost_ hit the target, just put the arrowhead at the target.\n\t\ttargetInt = targetShapeInfo.geometry.nearestPoint(targetTo)\n\t\tif (!Vec.DistMin(targetInt, targetTo, 1)) {\n\t\t\treturn\n\t\t}\n\t}\n\n\tconst pageInt = Mat.applyToPoint(targetShapeInfo.transform, targetInt)\n\tconst arrowInt = Mat.applyToPoint(Mat.Inverse(arrowPageTransform), pageInt)\n\n\tpoint.setTo(arrowInt)\n\n\ttargetShapeInfo.didIntersect = true\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 935, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/arrow/curved-arrow.ts"],"sourcesContent":["import {\n\tEditor,\n\tMat,\n\tPI,\n\tPI2,\n\tTLArrowShape,\n\tVec,\n\tVecLike,\n\tcenterOfCircleFromThreePoints,\n\tclockwiseAngleDist,\n\tcounterClockwiseAngleDist,\n\tisSafeFloat,\n} from '@tldraw/editor'\nimport { TLArcInfo, TLArrowInfo } from './arrow-types'\nimport {\n\tBOUND_ARROW_OFFSET,\n\tMIN_ARROW_LENGTH,\n\tSTROKE_SIZES,\n\tTLArrowBindings,\n\tWAY_TOO_BIG_ARROW_BEND_FACTOR,\n\tgetArrowTerminalsInArrowSpace,\n\tgetBoundShapeInfoForTerminal,\n\tgetBoundShapeRelationships,\n} from './shared'\nimport { getStraightArrowInfo } from './straight-arrow'\n\nexport function getCurvedArrowInfo(\n\teditor: Editor,\n\tshape: TLArrowShape,\n\tbindings: TLArrowBindings\n): TLArrowInfo {\n\tconst { arrowheadEnd, arrowheadStart } = shape.props\n\tconst bend = shape.props.bend\n\n\tif (\n\t\tMath.abs(bend) >\n\t\tMath.abs(shape.props.bend * (WAY_TOO_BIG_ARROW_BEND_FACTOR * shape.props.scale))\n\t) {\n\t\treturn getStraightArrowInfo(editor, shape, bindings)\n\t}\n\n\tconst terminalsInArrowSpace = getArrowTerminalsInArrowSpace(editor, shape, bindings)\n\n\tconst med = Vec.Med(terminalsInArrowSpace.start, terminalsInArrowSpace.end) // point between start and end\n\tconst distance = Vec.Sub(terminalsInArrowSpace.end, terminalsInArrowSpace.start)\n\t// Check for divide-by-zero before we call uni()\n\tconst u = Vec.Len(distance) ? distance.uni() : Vec.From(distance) // unit vector between start and end\n\tconst middle = Vec.Add(med, u.per().mul(-bend)) // middle handle\n\n\tconst startShapeInfo = getBoundShapeInfoForTerminal(editor, shape, 'start')\n\tconst endShapeInfo = getBoundShapeInfoForTerminal(editor, shape, 'end')\n\n\t// The positions of the body of the arrow, which may be different\n\t// than the arrow's start / end points if the arrow is bound to shapes\n\tconst a = terminalsInArrowSpace.start.clone()\n\tconst b = terminalsInArrowSpace.end.clone()\n\tconst c = middle.clone()\n\n\tif (Vec.Equals(a, b)) {\n\t\treturn {\n\t\t\tbindings,\n\t\t\ttype: 'straight',\n\t\t\tstart: {\n\t\t\t\thandle: a,\n\t\t\t\tpoint: a,\n\t\t\t\tarrowhead: shape.props.arrowheadStart,\n\t\t\t},\n\t\t\tend: {\n\t\t\t\thandle: b,\n\t\t\t\tpoint: b,\n\t\t\t\tarrowhead: shape.props.arrowheadEnd,\n\t\t\t},\n\t\t\tmiddle: c,\n\t\t\tisValid: false,\n\t\t\tlength: 0,\n\t\t}\n\t}\n\n\tconst isClockwise = shape.props.bend < 0\n\tconst distFn = isClockwise ? clockwiseAngleDist : counterClockwiseAngleDist\n\n\tconst handleArc = getArcInfo(a, b, c)\n\tconst handle_aCA = Vec.Angle(handleArc.center, a)\n\tconst handle_aCB = Vec.Angle(handleArc.center, b)\n\tconst handle_dAB = distFn(handle_aCA, handle_aCB)\n\n\tif (\n\t\thandleArc.length === 0 ||\n\t\thandleArc.size === 0 ||\n\t\t!isSafeFloat(handleArc.length) ||\n\t\t!isSafeFloat(handleArc.size)\n\t) {\n\t\treturn getStraightArrowInfo(editor, shape, bindings)\n\t}\n\n\tconst tempA = a.clone()\n\tconst tempB = b.clone()\n\tconst tempC = c.clone()\n\n\tconst arrowPageTransform = editor.getShapePageTransform(shape)!\n\n\tlet offsetA = 0\n\tlet offsetB = 0\n\n\tlet minLength = MIN_ARROW_LENGTH * shape.props.scale\n\n\tif (startShapeInfo && !startShapeInfo.isExact) {\n\t\tconst startInPageSpace = Mat.applyToPoint(arrowPageTransform, tempA)\n\t\tconst centerInPageSpace = Mat.applyToPoint(arrowPageTransform, handleArc.center)\n\t\tconst endInPageSpace = Mat.applyToPoint(arrowPageTransform, tempB)\n\n\t\tconst inverseTransform = Mat.Inverse(startShapeInfo.transform)\n\n\t\tconst startInStartShapeLocalSpace = Mat.applyToPoint(inverseTransform, startInPageSpace)\n\t\tconst centerInStartShapeLocalSpace = Mat.applyToPoint(inverseTransform, centerInPageSpace)\n\t\tconst endInStartShapeLocalSpace = Mat.applyToPoint(inverseTransform, endInPageSpace)\n\n\t\tconst { isClosed } = startShapeInfo\n\t\tlet point: VecLike | undefined\n\t\tlet intersections = Array.from(\n\t\t\tstartShapeInfo.geometry.intersectCircle(centerInStartShapeLocalSpace, handleArc.radius, {\n\t\t\t\tincludeLabels: false,\n\t\t\t\tincludeInternal: false,\n\t\t\t})\n\t\t)\n\n\t\tif (intersections.length) {\n\t\t\tconst angleToStart = centerInStartShapeLocalSpace.angle(startInStartShapeLocalSpace)\n\t\t\tconst angleToEnd = centerInStartShapeLocalSpace.angle(endInStartShapeLocalSpace)\n\t\t\tconst dAB = distFn(angleToStart, angleToEnd)\n\n\t\t\t// Filter out any intersections that aren't in the arc\n\t\t\tintersections = intersections.filter(\n\t\t\t\t(pt) => distFn(angleToStart, centerInStartShapeLocalSpace.angle(pt)) <= dAB\n\t\t\t)\n\n\t\t\tconst targetDist = dAB * 0.25\n\n\t\t\tintersections.sort(\n\t\t\t\tisClosed\n\t\t\t\t\t? (p0, p1) =>\n\t\t\t\t\t\t\tMath.abs(distFn(angleToStart, centerInStartShapeLocalSpace.angle(p0)) - targetDist) <\n\t\t\t\t\t\t\tMath.abs(distFn(angleToStart, centerInStartShapeLocalSpace.angle(p1)) - targetDist)\n\t\t\t\t\t\t\t\t? -1\n\t\t\t\t\t\t\t\t: 1\n\t\t\t\t\t: (p0, p1) =>\n\t\t\t\t\t\t\tdistFn(angleToStart, centerInStartShapeLocalSpace.angle(p0)) <\n\t\t\t\t\t\t\tdistFn(angleToStart, centerInStartShapeLocalSpace.angle(p1))\n\t\t\t\t\t\t\t\t? -1\n\t\t\t\t\t\t\t\t: 1\n\t\t\t)\n\n\t\t\tpoint = intersections[0]\n\t\t}\n\t\tif (!point) {\n\t\t\tif (isClosed) {\n\t\t\t\tconst nearestPoint = startShapeInfo.geometry.nearestPoint(startInStartShapeLocalSpace)\n\t\t\t\tif (Vec.DistMin(nearestPoint, startInStartShapeLocalSpace, 1)) {\n\t\t\t\t\tpoint = nearestPoint\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpoint = startInStartShapeLocalSpace\n\t\t\t}\n\t\t}\n\n\t\tif (point) {\n\t\t\ttempA.setTo(\n\t\t\t\teditor.getPointInShapeSpace(shape, Mat.applyToPoint(startShapeInfo.transform, point))\n\t\t\t)\n\n\t\t\tstartShapeInfo.didIntersect = true\n\n\t\t\tif (arrowheadStart !== 'none') {\n\t\t\t\tconst strokeOffset =\n\t\t\t\t\tSTROKE_SIZES[shape.props.size] / 2 +\n\t\t\t\t\t('size' in startShapeInfo.shape.props\n\t\t\t\t\t\t? STROKE_SIZES[startShapeInfo.shape.props.size] / 2\n\t\t\t\t\t\t: 0)\n\t\t\t\toffsetA = (BOUND_ARROW_OFFSET + strokeOffset) * shape.props.scale\n\t\t\t\tminLength += strokeOffset * shape.props.scale\n\t\t\t}\n\t\t}\n\t}\n\n\tif (endShapeInfo && !endShapeInfo.isExact) {\n\t\t// get points in shape's coordinates?\n\t\tconst startInPageSpace = Mat.applyToPoint(arrowPageTransform, tempA)\n\t\tconst endInPageSpace = Mat.applyToPoint(arrowPageTransform, tempB)\n\t\tconst centerInPageSpace = Mat.applyToPoint(arrowPageTransform, handleArc.center)\n\n\t\tconst inverseTransform = Mat.Inverse(endShapeInfo.transform)\n\n\t\tconst startInEndShapeLocalSpace = Mat.applyToPoint(inverseTransform, startInPageSpace)\n\t\tconst centerInEndShapeLocalSpace = Mat.applyToPoint(inverseTransform, centerInPageSpace)\n\t\tconst endInEndShapeLocalSpace = Mat.applyToPoint(inverseTransform, endInPageSpace)\n\n\t\tconst isClosed = endShapeInfo.isClosed\n\t\tlet point: VecLike | undefined\n\t\tlet intersections = Array.from(\n\t\t\tendShapeInfo.geometry.intersectCircle(centerInEndShapeLocalSpace, handleArc.radius, {\n\t\t\t\tincludeLabels: false,\n\t\t\t\tincludeInternal: false,\n\t\t\t})\n\t\t)\n\n\t\tif (intersections.length) {\n\t\t\tconst angleToStart = centerInEndShapeLocalSpace.angle(startInEndShapeLocalSpace)\n\t\t\tconst angleToEnd = centerInEndShapeLocalSpace.angle(endInEndShapeLocalSpace)\n\t\t\tconst dAB = distFn(angleToStart, angleToEnd)\n\t\t\tconst targetDist = dAB * 0.75\n\n\t\t\t// or simplified...\n\n\t\t\tintersections = intersections.filter(\n\t\t\t\t(pt) => distFn(angleToStart, centerInEndShapeLocalSpace.angle(pt)) <= dAB\n\t\t\t)\n\n\t\t\tintersections.sort(\n\t\t\t\tisClosed\n\t\t\t\t\t? (p0, p1) =>\n\t\t\t\t\t\t\tMath.abs(distFn(angleToStart, centerInEndShapeLocalSpace.angle(p0)) - targetDist) <\n\t\t\t\t\t\t\tMath.abs(distFn(angleToStart, centerInEndShapeLocalSpace.angle(p1)) - targetDist)\n\t\t\t\t\t\t\t\t? -1\n\t\t\t\t\t\t\t\t: 1\n\t\t\t\t\t: (p0, p1) =>\n\t\t\t\t\t\t\tdistFn(angleToStart, centerInEndShapeLocalSpace.angle(p0)) <\n\t\t\t\t\t\t\tdistFn(angleToStart, centerInEndShapeLocalSpace.angle(p1))\n\t\t\t\t\t\t\t\t? -1\n\t\t\t\t\t\t\t\t: 1\n\t\t\t)\n\n\t\t\tpoint = intersections[0]\n\t\t}\n\t\tif (!point) {\n\t\t\tif (isClosed) {\n\t\t\t\tconst nearestPoint = endShapeInfo.geometry.nearestPoint(endInEndShapeLocalSpace)\n\t\t\t\tif (Vec.DistMin(nearestPoint, endInEndShapeLocalSpace, 1)) {\n\t\t\t\t\tpoint = nearestPoint\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpoint = endInEndShapeLocalSpace\n\t\t\t}\n\t\t}\n\n\t\tif (point) {\n\t\t\t// Set b to target local point -> page point -> shape local point\n\t\t\ttempB.setTo(\n\t\t\t\teditor.getPointInShapeSpace(shape, Mat.applyToPoint(endShapeInfo.transform, point))\n\t\t\t)\n\n\t\t\tendShapeInfo.didIntersect = true\n\n\t\t\tif (arrowheadEnd !== 'none') {\n\t\t\t\tconst strokeOffset =\n\t\t\t\t\tSTROKE_SIZES[shape.props.size] / 2 +\n\t\t\t\t\t('size' in endShapeInfo.shape.props ? STROKE_SIZES[endShapeInfo.shape.props.size] / 2 : 0)\n\t\t\t\toffsetB = (BOUND_ARROW_OFFSET + strokeOffset) * shape.props.scale\n\t\t\t\tminLength += strokeOffset * shape.props.scale\n\t\t\t}\n\t\t}\n\t}\n\n\t// Apply arrowhead offsets\n\n\tlet aCA = Vec.Angle(handleArc.center, tempA) // angle center -> a\n\tlet aCB = Vec.Angle(handleArc.center, tempB) // angle center -> b\n\tlet dAB = distFn(aCA, aCB) // angle distance between a and b\n\tlet lAB = dAB * handleArc.radius // length of arc between a and b\n\n\t// Try the offsets first, then check whether the distance between the points is too small;\n\t// if it is, flip the offsets and expand them. We need to do this using temporary points\n\t// so that we can apply them both in a balanced way.\n\tconst tA = tempA.clone()\n\tconst tB = tempB.clone()\n\n\tif (offsetA !== 0) {\n\t\ttA.setTo(handleArc.center).add(\n\t\t\tVec.FromAngle(aCA + dAB * ((offsetA / lAB) * (isClockwise ? 1 : -1))).mul(handleArc.radius)\n\t\t)\n\t}\n\n\tif (offsetB !== 0) {\n\t\ttB.setTo(handleArc.center).add(\n\t\t\tVec.FromAngle(aCB + dAB * ((offsetB / lAB) * (isClockwise ? -1 : 1))).mul(handleArc.radius)\n\t\t)\n\t}\n\n\tif (Vec.DistMin(tA, tB, minLength)) {\n\t\tif (offsetA !== 0 && offsetB !== 0) {\n\t\t\toffsetA *= -1.5\n\t\t\toffsetB *= -1.5\n\t\t} else if (offsetA !== 0) {\n\t\t\toffsetA *= -2\n\t\t} else if (offsetB !== 0) {\n\t\t\toffsetB *= -2\n\t\t} else {\n\t\t\t// noop\n\t\t}\n\n\t\t// if we're using negative offsets, we need to make sure that the body arc doesn't end up\n\t\t// larger than the handle arc or things will get weird:\n\t\tconst minOffsetA = 0.1 - distFn(handle_aCA, aCA) * handleArc.radius\n\t\tconst minOffsetB = 0.1 - distFn(aCB, handle_aCB) * handleArc.radius\n\t\toffsetA = Math.max(offsetA, minOffsetA)\n\t\toffsetB = Math.max(offsetB, minOffsetB)\n\t}\n\n\tif (offsetA !== 0) {\n\t\ttempA\n\t\t\t.setTo(handleArc.center)\n\t\t\t.add(\n\t\t\t\tVec.FromAngle(aCA + dAB * ((offsetA / lAB) * (isClockwise ? 1 : -1))).mul(handleArc.radius)\n\t\t\t)\n\t}\n\n\tif (offsetB !== 0) {\n\t\ttempB\n\t\t\t.setTo(handleArc.center)\n\t\t\t.add(\n\t\t\t\tVec.FromAngle(aCB + dAB * ((offsetB / lAB) * (isClockwise ? -1 : 1))).mul(handleArc.radius)\n\t\t\t)\n\t}\n\n\t// Did we miss intersections? This happens when we have overlapping shapes.\n\tif (startShapeInfo && endShapeInfo && !startShapeInfo.isExact && !endShapeInfo.isExact) {\n\t\taCA = Vec.Angle(handleArc.center, tempA) // angle center -> a\n\t\taCB = Vec.Angle(handleArc.center, tempB) // angle center -> b\n\t\tdAB = distFn(aCA, aCB) // angle distance between a and b\n\t\tlAB = dAB * handleArc.radius // length of arc between a and b\n\t\tconst relationship = getBoundShapeRelationships(\n\t\t\teditor,\n\t\t\tstartShapeInfo.shape.id,\n\t\t\tendShapeInfo.shape.id\n\t\t)\n\n\t\tif (relationship === 'double-bound' && lAB < 30) {\n\t\t\ttempA.setTo(a)\n\t\t\ttempB.setTo(b)\n\t\t\ttempC.setTo(c)\n\t\t} else if (relationship === 'safe') {\n\t\t\tif (startShapeInfo && !startShapeInfo.didIntersect) {\n\t\t\t\ttempA.setTo(a)\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t(endShapeInfo && !endShapeInfo.didIntersect) ||\n\t\t\t\tdistFn(handle_aCA, aCA) > distFn(handle_aCA, aCB)\n\t\t\t) {\n\t\t\t\ttempB\n\t\t\t\t\t.setTo(handleArc.center)\n\t\t\t\t\t.add(\n\t\t\t\t\t\tVec.FromAngle(\n\t\t\t\t\t\t\taCA +\n\t\t\t\t\t\t\t\tdAB *\n\t\t\t\t\t\t\t\t\t(Math.min(0.9, (MIN_ARROW_LENGTH * shape.props.scale) / lAB) *\n\t\t\t\t\t\t\t\t\t\t(isClockwise ? 1 : -1))\n\t\t\t\t\t\t).mul(handleArc.radius)\n\t\t\t\t\t)\n\t\t\t}\n\t\t}\n\t}\n\n\tplaceCenterHandle(\n\t\thandleArc.center,\n\t\thandleArc.radius,\n\t\ttempA,\n\t\ttempB,\n\t\ttempC,\n\t\thandle_dAB,\n\t\tisClockwise\n\t)\n\n\tif (tempA.equals(tempB)) {\n\t\ttempA.setTo(tempC.clone().addXY(1, 1))\n\t\ttempB.setTo(tempC.clone().subXY(1, 1))\n\t}\n\n\ta.setTo(tempA)\n\tb.setTo(tempB)\n\tc.setTo(tempC)\n\tconst bodyArc = getArcInfo(a, b, c)\n\n\treturn {\n\t\tbindings,\n\t\ttype: 'arc',\n\t\tstart: {\n\t\t\tpoint: a,\n\t\t\thandle: terminalsInArrowSpace.start,\n\t\t\tarrowhead: shape.props.arrowheadStart,\n\t\t},\n\t\tend: {\n\t\t\tpoint: b,\n\t\t\thandle: terminalsInArrowSpace.end,\n\t\t\tarrowhead: shape.props.arrowheadEnd,\n\t\t},\n\t\tmiddle: c,\n\t\thandleArc,\n\t\tbodyArc,\n\t\tisValid: bodyArc.length !== 0 && isFinite(bodyArc.center.x) && isFinite(bodyArc.center.y),\n\t}\n}\n\n/**\n * Get info about an arc formed by three points.\n *\n * @param a - The start of the arc\n * @param b - The end of the arc\n * @param c - A point on the arc\n */\nfunction getArcInfo(a: VecLike, b: VecLike, c: VecLike): TLArcInfo {\n\t// find a circle from the three points\n\tconst center = centerOfCircleFromThreePoints(a, b, c) ?? Vec.Med(a, b)\n\n\tconst radius = Vec.Dist(center, a)\n\n\t// Whether to draw the arc clockwise or counter-clockwise (are the points clockwise?)\n\tconst sweepFlag = +Vec.Clockwise(a, c, b)\n\n\t// The base angle of the arc in radians\n\tconst ab = ((a.y - b.y) ** 2 + (a.x - b.x) ** 2) ** 0.5\n\tconst bc = ((b.y - c.y) ** 2 + (b.x - c.x) ** 2) ** 0.5\n\tconst ca = ((c.y - a.y) ** 2 + (c.x - a.x) ** 2) ** 0.5\n\n\tconst theta = Math.acos((bc * bc + ca * ca - ab * ab) / (2 * bc * ca)) * 2\n\n\t// Whether to draw the long arc or short arc\n\tconst largeArcFlag = +(PI > theta)\n\n\t// The size of the arc to draw in radians\n\tconst size = (PI2 - theta) * (sweepFlag ? 1 : -1)\n\n\t// The length of the arc to draw in distance units\n\tconst length = size * radius\n\n\treturn {\n\t\tcenter,\n\t\tradius,\n\t\tsize,\n\t\tlength,\n\t\tlargeArcFlag,\n\t\tsweepFlag,\n\t}\n}\n\nfunction placeCenterHandle(\n\tcenter: VecLike,\n\tradius: number,\n\ttempA: Vec,\n\ttempB: Vec,\n\ttempC: Vec,\n\toriginalArcLength: number,\n\tisClockwise: boolean\n) {\n\tconst aCA = Vec.Angle(center, tempA) // angle center -> a\n\tconst aCB = Vec.Angle(center, tempB) // angle center -> b\n\tlet dAB = clockwiseAngleDist(aCA, aCB) // angle distance between a and b\n\tif (!isClockwise) dAB = PI2 - dAB\n\n\ttempC.setTo(center).add(Vec.FromAngle(aCA + dAB * (0.5 * (isClockwise ? 1 : -1))).mul(radius))\n\n\tif (dAB > originalArcLength) {\n\t\ttempC.rotWith(center, PI)\n\t\tconst t = tempB.clone()\n\t\ttempB.setTo(tempA)\n\t\ttempA.setTo(t)\n\t}\n}\n"],"names":["dAB"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1204, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/arrow/elbow/definitions.ts"],"sourcesContent":["import { Box, ElbowArrowSnap, Geometry2d, TLShapeId, Vec, VecLike, VecModel } from '@tldraw/editor'\n\n/**\n * The side of a box that an elbow arrow could enter/exit from.\n * @public\n */\nexport type ElbowArrowSide = 'top' | 'right' | 'bottom' | 'left'\n\n/**\n * The reason a particular side of a shape was chosen for an elbow arrow to enter / exit. Used only\n * for debugging information.\n *\n * - `manual`: The side was chosen because the user indicated this was the desired side\n * - `auto`: The side was chosen automatically based on heuristics for nice-looking arrows\n * - `fallback`: We couldn't draw a route to the edge the user indicated, so fell back to our\n *   heuristics\n *\n * @internal\n */\nexport type ElbowArrowSideReason = 'manual' | 'auto' | 'fallback'\n\n/**\n * A route for an elbow arrow.\n *\n * @public\n */\nexport interface ElbowArrowRoute {\n\t/**\n\t * The name of the route - this is used only for debugging.\n\t * @internal\n\t */\n\tname: string\n\t/** The vertices of the route. Draw a line through them to see the route. */\n\tpoints: Vec[]\n\t/** The total distance of the route, in arrow-space pixels. */\n\tdistance: number\n\t/**\n\t * Why did we pick edge A?\n\t * @internal\n\t */\n\taEdgePicking: ElbowArrowSideReason\n\t/**\n\t * Why did we pick edge B?\n\t * @internal\n\t */\n\tbEdgePicking: ElbowArrowSideReason\n\t/**\n\t * Some points on the line are there for more informative than display reasons - e.g. where the\n\t * midpoint handle is. If we draw these in our \"draw\" style, the line will look weird. We still\n\t * need them for some of the calculations we do, but we want to skip them specifically when\n\t * rendering the arrow.\n\t */\n\tskipPointsWhenDrawing: Set<Vec>\n\t/**\n\t * The midpoint handle of the route, if any.\n\t */\n\tmidpointHandle: ElbowArrowMidpointHandle | null\n}\n\n/**\n * Part of an {@link ElbowArrowRoute} that describes a handle for dragging the midpoint line, a line\n * roughly halfway between the two shapes.\n * @public\n */\nexport interface ElbowArrowMidpointHandle {\n\taxis: 'x' | 'y'\n\t/** The start point of the segment in the route that the handle is on. */\n\tsegmentStart: VecLike\n\t/** The end point of the segment in the route that the handle is on. */\n\tsegmentEnd: VecLike\n\t/** The position of the handle, in arrow-space. */\n\tpoint: VecLike\n}\n\nexport const ElbowArrowSides = ['right', 'bottom', 'left', 'top'] as const\n\n/**\n * Extracted from {@link ArrowShapeOptions}. Options for one specific arrow.\n * @public\n */\nexport interface ElbowArrowOptions {\n\texpandElbowLegLength: number\n\tminElbowLegLength: number\n\telbowMidpoint: number\n}\n\n/**\n * Vectors that point out of each side of a box.\n */\nexport const ElbowArrowSideDeltas = {\n\ttop: { x: 0, y: -1 },\n\tright: { x: 1, y: 0 },\n\tbottom: { x: 0, y: 1 },\n\tleft: { x: -1, y: 0 },\n} as const satisfies Record<ElbowArrowSide, VecModel>\n\n/**\n * The axis along when each side of a box lies.\n */\nexport const ElbowArrowSideAxes = {\n\tleft: 'x',\n\tright: 'x',\n\ttop: 'y',\n\tbottom: 'y',\n} as const satisfies Record<ElbowArrowSide, 'x' | 'y'>\n\n/**\n * The opposite of each side of a box.\n */\nexport const ElbowArrowSideOpposites = {\n\ttop: 'bottom',\n\tright: 'left',\n\tbottom: 'top',\n\tleft: 'right',\n} as const satisfies Record<ElbowArrowSide, ElbowArrowSide>\n\nexport const ElbowArrowAxes = {\n\tx: {\n\t\tv: (x: number, y: number) => new Vec(x, y),\n\t\tloEdge: 'left',\n\t\thiEdge: 'right',\n\t\tcrossMid: 'midY',\n\t\tgap: 'gapX',\n\t\tmidRange: 'midXRange',\n\t\tself: 'x',\n\t\tcross: 'y',\n\t\tsize: 'width',\n\t},\n\ty: {\n\t\tv: (y: number, x: number) => new Vec(x, y),\n\t\tloEdge: 'top',\n\t\thiEdge: 'bottom',\n\t\tcrossMid: 'midX',\n\t\tgap: 'gapY',\n\t\tmidRange: 'midYRange',\n\t\tself: 'y',\n\t\tcross: 'x',\n\t\tsize: 'height',\n\t},\n} as const\n\nexport type ElbowArrowAxis = (typeof ElbowArrowAxes)[keyof typeof ElbowArrowAxes]\n\nexport type ElbowArrowSideWithAxis = ElbowArrowSide | 'x' | 'y'\n\n/** @public */\nexport interface ElbowArrowBoxes {\n\t/** The starting bounding box */\n\tA: Box\n\t/** The ending bounding box */\n\tB: Box\n\t/** The common bounding box of A and B */\n\tcommon: Box\n}\n\n/** @public */\nexport interface ElbowArrowRange {\n\tmin: number\n\tmax: number\n}\n\n/**\n * An edge on a box.\n * @public\n */\nexport interface ElbowArrowEdge {\n\t/**\n\t * The co-ordinate of the edge. An x-coordinate if left/right, a y-coordinate if top/bottom.\n\t */\n\tvalue: number\n\t/**\n\t * The co-ordinate of the edge, expanded by {@link ArrowShapeOptions.expandElbowLegLength}. May\n\t * be null if the target is a point.\n\t */\n\texpanded: number | null\n\t/**\n\t * The usable range of the edge along its cross-axis. Y-coordinates if left/right, x-coordinated\n\t * if top/bottom.\n\t */\n\tcross: ElbowArrowRange\n\t/**\n\t * The point of the target along the edge, constrained to within {@link ElbowArrowEdge.cross}.\n\t */\n\tcrossTarget: number\n\t/**\n\t * Whether the cross-axis range is shrunk from the original range to make space for the other shape.\n\t */\n\tisPartial: boolean\n}\n\n/**\n * The usable range of the edges of a box. Each edge might be null if the edge is not usable for\n * entry/exit.\n * @public\n */\nexport interface ElbowArrowBoxEdges {\n\ttop: ElbowArrowEdge | null\n\tright: ElbowArrowEdge | null\n\tbottom: ElbowArrowEdge | null\n\tleft: ElbowArrowEdge | null\n}\n\n/**\n * @public\n */\nexport interface ElbowArrowBox {\n\t/** The original bounding box */\n\toriginal: Box\n\t/**\n\t * The bounding box, expanded by {@link ArrowShapeOptions.expandElbowLegLength}.\n\t */\n\texpanded: Box\n}\n\n/**\n * @public\n */\nexport interface ElbowArrowTargetBox extends ElbowArrowBox {\n\t/** What specific point in the box are we aiming for? */\n\ttarget: Vec\n\t/**\n\t * If true, the arrow should end at `target`. If false, the arrow should end at the edge of the\n\t * shape, pointing at `target`.\n\t */\n\tisExact: boolean\n\t/**\n\t * How far away from this box should the arrow terminate to leave space for the arrowhead?\n\t */\n\tarrowheadOffset: number\n\t/**\n\t * The minimum length of the segment of the arrow that actually reaches the target - and has the\n\t * arrowhead on it.\n\t */\n\tminEndSegmentLength: number\n\t/**\n\t * The usable edges of the box.\n\t */\n\tedges: ElbowArrowBoxEdges\n\t/**\n\t * The geometry of the bound shape, in arrow space.\n\t */\n\tgeometry: Geometry2d | null\n\t/**\n\t * Are we treating this target as a single point in space rather than a bounding box?\n\t */\n\tisPoint: boolean\n}\n\n/** @public */\nexport interface ElbowArrowInfoWithoutRoute {\n\t/**\n\t * The options used for this elbow arrow\n\t */\n\toptions: ElbowArrowOptions\n\n\t/**\n\t * If false, A is the start shape and B is the end shape. If true, A is the end shape and B is\n\t * the start shape.\n\t */\n\tswapOrder: boolean\n\n\t/**\n\t * One of the two shapes we're drawing an arrow between. Could be either the start or end\n\t * depending on `swapOrder`.\n\t */\n\tA: ElbowArrowTargetBox\n\t/**\n\t * The other shape we're drawing an arrow between. Could be either the start or end\n\t * depending on `swapOrder`.\n\t */\n\tB: ElbowArrowTargetBox\n\t/**\n\t * The common bounding box of A and B.\n\t */\n\tcommon: ElbowArrowBox\n\n\t/**\n\t * The gap between the right edge of A and the left edge of B.\n\t */\n\tgapX: number\n\t/**\n\t * The gap between the bottom edge of A and the top edge of B.\n\t */\n\tgapY: number\n\t/**\n\t * The X coordinate of the middle line between the two boxes. If the boxes are too close or\n\t * overlap, this may be null.\n\t */\n\tmidX: number | null\n\t/**\n\t * The Y coordinate of the middle line between the two boxes. If the boxes are too close or\n\t * overlap, this may be null.\n\t */\n\tmidY: number | null\n}\n\n/** @public */\nexport interface ElbowArrowInfo extends ElbowArrowInfoWithoutRoute {\n\t/**\n\t * The route of the arrow.\n\t */\n\troute: ElbowArrowRoute | null\n\n\tmidXRange: { lo: number; hi: number } | null\n\tmidYRange: { lo: number; hi: number } | null\n}\n\nexport interface ElbowArrowTerminal {\n\t/**\n\t * The id of the shape we're binding to, if any.\n\t */\n\ttargetShapeId: TLShapeId | null\n\t/**\n\t * The side of the box that the arrow should enter from.\n\t */\n\tside: ElbowArrowSideWithAxis | null\n\t/**\n\t * The bounding box of the shape. May have width/height of 0 if the shape is a point.\n\t */\n\tbounds: Box\n\t/**\n\t * The geometry of the we're binding to, if it exists.\n\t */\n\tgeometry: Geometry2d | null\n\t/**\n\t * The target point of the arrow.\n\t */\n\ttarget: Vec\n\t/**\n\t * How far away from the target should the arrow terminate to leave space for the arrowhead?\n\t */\n\tarrowheadOffset: number\n\t/**\n\t * The minimum length of the segment of the arrow that actually reaches the target - and has the\n\t * arrowhead on it.\n\t */\n\tminEndSegmentLength: number\n\t/**\n\t * Whether the target is an exact point. within a shape's geometry.\n\t */\n\tisExact: boolean\n\t/**\n\t * Whether the target is a point, rather than a bounding box\n\t */\n\tisPoint: boolean\n\t/**\n\t * How did this binding get snapped to the target shape?\n\t */\n\tsnap: ElbowArrowSnap\n}\n"],"names":[],"mappings":";;;;;;;;AAAA,SAAqD,WAA8B;;AA0E5E,MAAM,kBAAkB;IAAC;IAAS;IAAU;IAAQ,KAAK;CAAA;AAezD,MAAM,uBAAuB;IACnC,KAAK;QAAE,GAAG;QAAG,GAAG,CAAA;IAAG;IACnB,OAAO;QAAE,GAAG;QAAG,GAAG;IAAE;IACpB,QAAQ;QAAE,GAAG;QAAG,GAAG;IAAE;IACrB,MAAM;QAAE,GAAG,CAAA;QAAI,GAAG;IAAE;AACrB;AAKO,MAAM,qBAAqB;IACjC,MAAM;IACN,OAAO;IACP,KAAK;IACL,QAAQ;AACT;AAKO,MAAM,0BAA0B;IACtC,KAAK;IACL,OAAO;IACP,QAAQ;IACR,MAAM;AACP;AAEO,MAAM,iBAAiB;IAC7B,GAAG;QACF,GAAG,CAAC,GAAW,IAAc,sLAAI,MAAA,CAAI,GAAG,CAAC;QACzC,QAAQ;QACR,QAAQ;QACR,UAAU;QACV,KAAK;QACL,UAAU;QACV,MAAM;QACN,OAAO;QACP,MAAM;IACP;IACA,GAAG;QACF,GAAG,CAAC,GAAW,IAAc,sLAAI,MAAA,CAAI,GAAG,CAAC;QACzC,QAAQ;QACR,QAAQ;QACR,UAAU;QACV,KAAK;QACL,UAAU;QACV,MAAM;QACN,OAAO;QACP,MAAM;IACP;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1282, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/arrow/elbow/range.tsx"],"sourcesContent":["import { assert, clamp } from '@tldraw/editor'\n\nexport interface Range {\n\tmin: number\n\tmax: number\n}\n\nexport function expandRange(range: Range, amount: number) {\n\tconst newRange: Range = {\n\t\tmin: range.min - amount,\n\t\tmax: range.max + amount,\n\t}\n\tif (newRange.min > newRange.max) {\n\t\treturn null\n\t}\n\treturn newRange\n}\n\nexport function clampToRange(value: number, range: Range) {\n\treturn clamp(value, range.min, range.max)\n}\n\n/**\n * Subtract the range b from the range a. If b is completely inside a, return the two ranges of a\n * that are outside of b. If b contains a, return []. Otherwise, return the range of a that is\n * outside of b.\n */\nexport function subtractRange(a: Range, b: Range): [] | [Range] | [Range, Range] {\n\tassert(a.min <= a.max && b.min <= b.max)\n\n\t// if b is completely inside a:\n\tif (a.min <= b.min && b.max <= a.max) {\n\t\treturn [\n\t\t\t{ min: a.min, max: b.min },\n\t\t\t{ min: b.max, max: a.max },\n\t\t]\n\t}\n\n\t// if b is completely outside of a:\n\tif (b.max <= a.min || b.min >= a.max) {\n\t\treturn [a]\n\t}\n\n\t// if b fully contains a:\n\tif (b.min <= a.min && a.max <= b.max) {\n\t\treturn []\n\t}\n\n\t// if b overlaps a on the low side:\n\tif (isWithinRange(a.min, b)) {\n\t\treturn [{ min: b.max, max: a.max }]\n\t}\n\n\t// if b overlaps a on the high side:\n\tif (isWithinRange(a.max, b)) {\n\t\treturn [{ min: a.min, max: b.min }]\n\t}\n\n\t// unreachable (?)\n\treturn []\n}\n\nexport function createRange(a: number, b: number) {\n\treturn { min: Math.min(a, b), max: Math.max(a, b) }\n}\n\nexport function doRangesOverlap(a: Range, b: Range) {\n\treturn a.min <= b.max && a.max >= b.min\n}\n\nexport function isWithinRange(value: number, range: Range) {\n\treturn value >= range.min && value <= range.max\n}\n\nexport function rangeSize(range: Range) {\n\treturn range.max - range.min\n}\n\nexport function rangeCenter(range: Range) {\n\treturn (range.min + range.max) / 2\n}\n"],"names":[],"mappings":";;;;;;;;;;AAAA,SAAS,QAAQ,aAAa;;;;AAOvB,SAAS,YAAY,KAAA,EAAc,MAAA,EAAgB;IACzD,MAAM,WAAkB;QACvB,KAAK,MAAM,GAAA,GAAM;QACjB,KAAK,MAAM,GAAA,GAAM;IAClB;IACA,IAAI,SAAS,GAAA,GAAM,SAAS,GAAA,EAAK;QAChC,OAAO;IACR;IACA,OAAO;AACR;AAEO,SAAS,aAAa,KAAA,EAAe,KAAA,EAAc;IACzD,+LAAO,QAAA,EAAM,OAAO,MAAM,GAAA,EAAK,MAAM,GAAG;AACzC;AAOO,SAAS,cAAc,CAAA,EAAU,CAAA,EAAyC;IAChF,CAAA,GAAA,sKAAA,CAAA,SAAA,EAAO,EAAE,GAAA,IAAO,EAAE,GAAA,IAAO,EAAE,GAAA,IAAO,EAAE,GAAG;IAGvC,IAAI,EAAE,GAAA,IAAO,EAAE,GAAA,IAAO,EAAE,GAAA,IAAO,EAAE,GAAA,EAAK;QACrC,OAAO;YACN;gBAAE,KAAK,EAAE,GAAA;gBAAK,KAAK,EAAE,GAAA;YAAI;YACzB;gBAAE,KAAK,EAAE,GAAA;gBAAK,KAAK,EAAE,GAAA;YAAI;SAC1B;IACD;IAGA,IAAI,EAAE,GAAA,IAAO,EAAE,GAAA,IAAO,EAAE,GAAA,IAAO,EAAE,GAAA,EAAK;QACrC,OAAO;YAAC,CAAC;SAAA;IACV;IAGA,IAAI,EAAE,GAAA,IAAO,EAAE,GAAA,IAAO,EAAE,GAAA,IAAO,EAAE,GAAA,EAAK;QACrC,OAAO,CAAC,CAAA;IACT;IAGA,IAAI,cAAc,EAAE,GAAA,EAAK,CAAC,GAAG;QAC5B,OAAO;YAAC;gBAAE,KAAK,EAAE,GAAA;gBAAK,KAAK,EAAE,GAAA;YAAI,CAAC;SAAA;IACnC;IAGA,IAAI,cAAc,EAAE,GAAA,EAAK,CAAC,GAAG;QAC5B,OAAO;YAAC;gBAAE,KAAK,EAAE,GAAA;gBAAK,KAAK,EAAE,GAAA;YAAI,CAAC;SAAA;IACnC;IAGA,OAAO,CAAC,CAAA;AACT;AAEO,SAAS,YAAY,CAAA,EAAW,CAAA,EAAW;IACjD,OAAO;QAAE,KAAK,KAAK,GAAA,CAAI,GAAG,CAAC;QAAG,KAAK,KAAK,GAAA,CAAI,GAAG,CAAC;IAAE;AACnD;AAEO,SAAS,gBAAgB,CAAA,EAAU,CAAA,EAAU;IACnD,OAAO,EAAE,GAAA,IAAO,EAAE,GAAA,IAAO,EAAE,GAAA,IAAO,EAAE,GAAA;AACrC;AAEO,SAAS,cAAc,KAAA,EAAe,KAAA,EAAc;IAC1D,OAAO,SAAS,MAAM,GAAA,IAAO,SAAS,MAAM,GAAA;AAC7C;AAEO,SAAS,UAAU,KAAA,EAAc;IACvC,OAAO,MAAM,GAAA,GAAM,MAAM,GAAA;AAC1B;AAEO,SAAS,YAAY,KAAA,EAAc;IACzC,OAAA,CAAQ,MAAM,GAAA,GAAM,MAAM,GAAA,IAAO;AAClC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1375, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/arrow/elbow/routes/ElbowArrowWorkingInfo.ts"],"sourcesContent":["import { Box, Vec, VecLike } from '@tldraw/editor'\nimport {\n\tElbowArrowBoxEdges,\n\tElbowArrowEdge,\n\tElbowArrowInfoWithoutRoute,\n\tElbowArrowOptions,\n} from '../definitions'\n\n/**\n * A transform that can be applied when working on elbow arrows. This only models flipping x/y or\n * transposing x/y (for 90 degree rotations).\n */\nexport interface ElbowArrowTransform {\n\treadonly x: 1 | -1\n\treadonly y: 1 | -1\n\treadonly transpose: boolean\n}\n\nfunction flipEdgeCrossInPlace(edge: ElbowArrowEdge | null) {\n\tif (!edge) return\n\tconst tmp = edge.cross.min\n\tedge.cross.min = -edge.cross.max\n\tedge.cross.max = -tmp\n\tedge.crossTarget = -edge.crossTarget\n}\n\nfunction flipEdgeValueInPlace(edge: ElbowArrowEdge | null) {\n\tif (!edge) return\n\tedge.value = -edge.value\n\tedge.expanded = edge.expanded === null ? null : -edge.expanded\n}\n\nexport const ElbowArrowTransform = {\n\tIdentity: { x: 1, y: 1, transpose: false } as const,\n\tRotate90: { x: -1, y: 1, transpose: true } as const,\n\tRotate180: { x: -1, y: -1, transpose: false } as const,\n\tRotate270: { x: 1, y: -1, transpose: true } as const,\n\tFlipX: { x: -1, y: 1, transpose: false } as const,\n\tFlipY: { x: 1, y: -1, transpose: false } as const,\n}\n\nfunction invertElbowArrowTransform(transform: ElbowArrowTransform): ElbowArrowTransform {\n\tif (transform.transpose) {\n\t\treturn {\n\t\t\tx: transform.y,\n\t\t\ty: transform.x,\n\t\t\ttranspose: true,\n\t\t}\n\t}\n\n\treturn transform\n}\n\nexport function transformElbowArrowTransform(a: ElbowArrowTransform, b: ElbowArrowTransform) {\n\t// apply b to a:\n\tconst next = { ...a }\n\n\tif (b.transpose) {\n\t\tswap(next, 'x', 'y')\n\t\tnext.transpose = !next.transpose\n\t}\n\n\tif (b.x === -1) {\n\t\tnext.x = -next.x as 1 | -1\n\t}\n\tif (b.y === -1) {\n\t\tnext.y = -next.y as 1 | -1\n\t}\n\n\treturn next\n}\n\nfunction swap<const A extends string, const B extends string>(\n\tobject: { [key in A | B]: any },\n\ta: A,\n\tb: B\n) {\n\tconst temp = object[a]\n\tobject[a] = object[b]\n\tobject[b] = temp\n}\n\nfunction transformVecInPlace(transform: ElbowArrowTransform, point: VecLike) {\n\tpoint.x = transform.x * point.x\n\tpoint.y = transform.y * point.y\n\n\tif (transform.transpose) {\n\t\tswap(point, 'x', 'y')\n\t}\n}\n\nfunction transformBoxInPlace(transform: ElbowArrowTransform, box: Box) {\n\tif (transform.x === -1) {\n\t\tbox.x = -(box.x + box.width)\n\t}\n\tif (transform.y === -1) {\n\t\tbox.y = -(box.y + box.height)\n\t}\n\tif (transform.transpose) {\n\t\tswap(box, 'x', 'y')\n\t\tswap(box, 'width', 'height')\n\t}\n}\n\nfunction transformEdgesInPlace(transform: ElbowArrowTransform, edges: ElbowArrowBoxEdges) {\n\tif (transform.x === -1) {\n\t\tswap(edges, 'left', 'right')\n\t\tflipEdgeCrossInPlace(edges.top)\n\t\tflipEdgeCrossInPlace(edges.bottom)\n\t\tflipEdgeValueInPlace(edges.left)\n\t\tflipEdgeValueInPlace(edges.right)\n\t}\n\tif (transform.y === -1) {\n\t\tswap(edges, 'top', 'bottom')\n\t\tflipEdgeCrossInPlace(edges.left)\n\t\tflipEdgeCrossInPlace(edges.right)\n\t\tflipEdgeValueInPlace(edges.top)\n\t\tflipEdgeValueInPlace(edges.bottom)\n\t}\n\tif (transform.transpose) {\n\t\tswap(edges, 'left', 'top')\n\t\tswap(edges, 'right', 'bottom')\n\t}\n}\n\nexport function debugElbowArrowTransform(transform: ElbowArrowTransform) {\n\tswitch (\n\t\t`${transform.transpose ? 't' : ''}${transform.x === -1 ? 'x' : ''}${transform.y === -1 ? 'y' : ''}`\n\t) {\n\t\tcase '':\n\t\t\treturn 'Identity'\n\t\tcase 't':\n\t\t\treturn 'Transpose'\n\t\tcase 'x':\n\t\t\treturn 'FlipX'\n\t\tcase 'y':\n\t\t\treturn 'FlipY'\n\t\tcase 'tx':\n\t\t\treturn 'Rotate90'\n\t\tcase 'ty':\n\t\t\treturn 'Rotate270'\n\t\tcase 'xy':\n\t\t\treturn 'Rotate180'\n\t\tcase 'txy':\n\t\t\treturn 'spooky (transpose + flip both)'\n\t\tdefault:\n\t\t\tthrow new Error('Unknown transform')\n\t}\n}\n\nexport interface ElbowArrowWorkingBox {\n\toriginal: Box\n\texpanded: Box\n\tedges: ElbowArrowBoxEdges\n\tisPoint: boolean\n}\n\nexport class ElbowArrowWorkingInfo {\n\toptions: ElbowArrowOptions\n\tA: ElbowArrowWorkingBox\n\tB: ElbowArrowWorkingBox\n\tcommon: {\n\t\toriginal: Box\n\t\texpanded: Box\n\t}\n\tgapX: number\n\tgapY: number\n\tmidX: number | null\n\tmidY: number | null\n\tbias: Vec\n\n\tconstructor(info: ElbowArrowInfoWithoutRoute) {\n\t\tthis.options = info.options\n\t\tthis.A = info.A\n\t\tthis.B = info.B\n\t\tthis.common = info.common\n\t\tthis.midX = info.midX\n\t\tthis.midY = info.midY\n\t\tthis.gapX = info.gapX\n\t\tthis.gapY = info.gapY\n\t\t// prefer down/right when routing arrows\n\t\tthis.bias = new Vec(1, 1)\n\t}\n\n\ttransform: ElbowArrowTransform = ElbowArrowTransform.Identity\n\tinverse: ElbowArrowTransform = ElbowArrowTransform.Identity\n\n\tapply(transform: ElbowArrowTransform) {\n\t\tthis.transform = transformElbowArrowTransform(transform, this.transform)\n\t\tthis.inverse = invertElbowArrowTransform(this.transform)\n\n\t\ttransformBoxInPlace(transform, this.A.original)\n\t\ttransformBoxInPlace(transform, this.B.original)\n\t\ttransformBoxInPlace(transform, this.common.original)\n\n\t\ttransformBoxInPlace(transform, this.A.expanded)\n\t\ttransformBoxInPlace(transform, this.B.expanded)\n\t\ttransformBoxInPlace(transform, this.common.expanded)\n\n\t\ttransformEdgesInPlace(transform, this.A.edges)\n\t\ttransformEdgesInPlace(transform, this.B.edges)\n\n\t\ttransformVecInPlace(transform, this.bias)\n\n\t\tif (transform.x === -1) {\n\t\t\tthis.gapX = -this.gapX\n\t\t\tthis.midX = this.midX === null ? null : -this.midX\n\t\t}\n\t\tif (transform.y === -1) {\n\t\t\tthis.gapY = -this.gapY\n\t\t\tthis.midY = this.midY === null ? null : -this.midY\n\t\t}\n\n\t\tif (transform.transpose) {\n\t\t\tlet temp = this.midX\n\t\t\tthis.midX = this.midY\n\t\t\tthis.midY = temp\n\t\t\ttemp = this.gapX\n\t\t\tthis.gapX = this.gapY\n\t\t\tthis.gapY = temp\n\t\t}\n\t}\n\n\treset() {\n\t\tthis.apply(this.inverse)\n\t}\n\n\tvec(x: number, y: number) {\n\t\tconst point = new Vec(x, y)\n\t\ttransformVecInPlace(this.inverse, point)\n\t\treturn point\n\t}\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1589, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/arrow/elbow/routes/ElbowArrowRouteBuilder.ts"],"sourcesContent":["import { assert, Vec, VecLike } from '@tldraw/editor'\nimport { ElbowArrowMidpointHandle, ElbowArrowRoute } from '../definitions'\nimport { ElbowArrowWorkingInfo } from './ElbowArrowWorkingInfo'\n\nconst MIN_DISTANCE = 0.01\n\nexport class ElbowArrowRouteBuilder {\n\tpoints: Vec[] = []\n\n\tconstructor(\n\t\tprivate readonly info: ElbowArrowWorkingInfo,\n\t\tpublic readonly name: string\n\t) {}\n\n\tadd(x: number, y: number): this {\n\t\tthis.points.push(this.info.vec(x, y))\n\n\t\treturn this\n\t}\n\n\tprivate _midpointHandle: ElbowArrowMidpointHandle | null = null\n\tmidpointHandle(axis: 'x' | 'y'): this {\n\t\tassert(this._midpointHandle === null, 'midX/midY called multiple times')\n\n\t\tconst point = Vec.Lrp(\n\t\t\tthis.points[this.points.length - 2],\n\t\t\tthis.points[this.points.length - 1],\n\t\t\t0.5\n\t\t)\n\n\t\tthis._midpointHandle = {\n\t\t\taxis: this.info.transform.transpose ? (axis === 'x' ? 'y' : 'x') : axis,\n\t\t\tpoint,\n\t\t\tsegmentStart: this.points[this.points.length - 2].clone(),\n\t\t\tsegmentEnd: this.points[this.points.length - 1].clone(),\n\t\t}\n\n\t\treturn this\n\t}\n\n\tbuild(): ElbowArrowRoute {\n\t\tconst finalPoints = []\n\t\tfor (let i = 0; i < this.points.length; i++) {\n\t\t\tconst p0 = this.points[i]\n\t\t\tconst p1 = finalPoints[finalPoints.length - 1]\n\t\t\tconst p2 = finalPoints[finalPoints.length - 2]\n\n\t\t\tif (!p1 || !p2) {\n\t\t\t\tfinalPoints.push(p0)\n\t\t\t} else {\n\t\t\t\tconst d1x = Math.abs(p0.x - p1.x)\n\t\t\t\tconst d1y = Math.abs(p0.y - p1.y)\n\t\t\t\tconst d2x = Math.abs(p0.x - p2.x)\n\t\t\t\tconst d2y = Math.abs(p0.y - p2.y)\n\n\t\t\t\tif (d1x < MIN_DISTANCE && d1y < MIN_DISTANCE) {\n\t\t\t\t\t// this point is basically in the same place as the last one, so ignore it\n\t\t\t\t} else if (d1x < MIN_DISTANCE && d2x < MIN_DISTANCE) {\n\t\t\t\t\t// this coord is extending the same vertical line as the last two, so update the\n\t\t\t\t\t// last point to this one.\n\t\t\t\t\tp1.y = p0.y\n\t\t\t\t} else if (d1y < MIN_DISTANCE && d2y < MIN_DISTANCE) {\n\t\t\t\t\t// this coord is extending the same horizontal line as the last two, so update the\n\t\t\t\t\t// last point to this one.\n\t\t\t\t\tp1.x = p0.x\n\t\t\t\t} else {\n\t\t\t\t\t// this coord is changing direction, so add it to the points\n\t\t\t\t\tfinalPoints.push(p0)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tname: this.name,\n\t\t\tpoints: finalPoints,\n\t\t\tdistance: measureRouteManhattanDistance(finalPoints),\n\t\t\taEdgePicking: 'manual',\n\t\t\tbEdgePicking: 'manual',\n\t\t\tskipPointsWhenDrawing: new Set(),\n\t\t\tmidpointHandle: this._midpointHandle,\n\t\t}\n\t}\n}\n\nfunction measureRouteManhattanDistance(path: VecLike[]): number {\n\tlet distance = 0\n\tfor (let i = 0; i < path.length - 1; i++) {\n\t\tconst start = path[i]\n\t\tconst end = path[i + 1]\n\t\tdistance += Math.abs(end.x - start.x) + Math.abs(end.y - start.y)\n\t}\n\treturn distance\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1669, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/arrow/elbow/routes/elbowArrowRoutes.tsx"],"sourcesContent":["import { ElbowArrowRoute, ElbowArrowSide } from '../definitions'\nimport { ElbowArrowRouteBuilder } from './ElbowArrowRouteBuilder'\nimport { ElbowArrowTransform, ElbowArrowWorkingInfo } from './ElbowArrowWorkingInfo'\n\n/**\n * Draw one of these arrows:\n *\n * ```\n * 1:              2:         3:          4:          5:\n * âââââ           âââââ      âââââ       âââââââââ   âââââââââ âââââ\n * â A âââ         â A âââ    â A âââââ   â âââââ â   â âââââ â â A âââ\n * âââââ â âââââ   âââââ â    âââââ   â   â â A âââ   âââº B â â âââââ â\n *       âââº B â    ââââââ      âââââ â   â âââââ       âââââ âââââââââ\n *         âââââ    â âââââ   ââºâ B â â   â   âââââ\n *                  âââº B â   â âââââ â   âââââº B â\n *                    âââââ   âââââââââ       âââââ\n * ```\n */\nexport function routeRightToLeft(info: ElbowArrowWorkingInfo): ElbowArrowRoute | null {\n\tconst aEdge = info.A.edges.right\n\tconst bEdge = info.B.edges.left\n\n\t// we can't draw this arrow if we don't have the proper edge we want:\n\tif (!aEdge || !bEdge) return null\n\n\t// just so we get to handle less edge cases, flip the boxes if A is below B:\n\tif (aEdge.crossTarget > bEdge.crossTarget) {\n\t\tinfo.apply(ElbowArrowTransform.FlipY)\n\t}\n\n\tif (info.gapX > 0 && info.midX !== null) {\n\t\t// Arrow 1:\n\t\treturn new ElbowArrowRouteBuilder(info, 'to left 1')\n\t\t\t.add(aEdge.value, aEdge.crossTarget)\n\t\t\t.add(info.midX, aEdge.crossTarget)\n\t\t\t.add(info.midX, bEdge.crossTarget)\n\t\t\t.midpointHandle('x')\n\t\t\t.add(bEdge.value, bEdge.crossTarget)\n\t\t\t.build()\n\t}\n\n\tif (aEdge.expanded === null || bEdge.expanded === null) return null\n\n\tif (info.midY !== null) {\n\t\t// Arrow 2:\n\t\treturn new ElbowArrowRouteBuilder(info, 'to left 2')\n\t\t\t.add(aEdge.value, aEdge.crossTarget)\n\t\t\t.add(aEdge.expanded, aEdge.crossTarget)\n\t\t\t.add(aEdge.expanded, info.midY)\n\t\t\t.add(bEdge.expanded, info.midY)\n\t\t\t.midpointHandle('y')\n\t\t\t.add(bEdge.expanded, bEdge.crossTarget)\n\t\t\t.add(bEdge.value, bEdge.crossTarget)\n\t\t\t.build()\n\t}\n\n\tconst arrow3Distance =\n\t\tMath.abs(aEdge.value - info.common.expanded.right) +\n\t\tMath.abs(aEdge.crossTarget - info.common.expanded.bottom) +\n\t\tMath.abs(info.common.expanded.right - bEdge.expanded) +\n\t\tMath.abs(info.common.expanded.bottom - bEdge.crossTarget) +\n\t\tinfo.options.expandElbowLegLength +\n\t\t6 // 6 points in this arrow\n\n\tconst arrow4Distance =\n\t\tinfo.options.expandElbowLegLength +\n\t\tMath.abs(aEdge.crossTarget - info.common.expanded.top) +\n\t\tMath.abs(aEdge.expanded - info.common.expanded.left) +\n\t\tMath.abs(info.common.expanded.top - bEdge.crossTarget) +\n\t\tMath.abs(info.common.expanded.left - bEdge.value) +\n\t\t// 6 points in this arrow, plus bias towards down/right:\n\t\t6 +\n\t\tinfo.bias.y\n\n\tconst arrow5Distance =\n\t\tinfo.gapX < 0 && info.midX !== null\n\t\t\t? info.options.expandElbowLegLength +\n\t\t\t\tMath.abs(aEdge.crossTarget - info.A.expanded.bottom) +\n\t\t\t\tinfo.common.expanded.width +\n\t\t\t\tMath.abs(info.A.expanded.bottom - info.B.expanded.top) +\n\t\t\t\tMath.abs(info.B.expanded.top - bEdge.crossTarget) +\n\t\t\t\tinfo.options.expandElbowLegLength +\n\t\t\t\t// 8 points in this arrow\n\t\t\t\t8\n\t\t\t: Infinity\n\n\tif (arrow3Distance < arrow4Distance && arrow3Distance < arrow5Distance) {\n\t\t// Arrow 3:\n\t\treturn new ElbowArrowRouteBuilder(info, 'to left 3')\n\t\t\t.add(aEdge.value, aEdge.crossTarget)\n\t\t\t.add(info.common.expanded.right, aEdge.crossTarget)\n\t\t\t.add(info.common.expanded.right, info.common.expanded.bottom)\n\t\t\t.add(bEdge.expanded, info.common.expanded.bottom)\n\t\t\t.add(bEdge.expanded, bEdge.crossTarget)\n\t\t\t.add(bEdge.value, bEdge.crossTarget)\n\t\t\t.build()\n\t}\n\n\tif (arrow4Distance < arrow5Distance) {\n\t\t// Arrow 4:\n\t\treturn new ElbowArrowRouteBuilder(info, 'to left 4')\n\t\t\t.add(aEdge.value, aEdge.crossTarget)\n\t\t\t.add(aEdge.expanded, aEdge.crossTarget)\n\t\t\t.add(aEdge.expanded, info.common.expanded.top)\n\t\t\t.add(info.common.expanded.left, info.common.expanded.top)\n\t\t\t.add(info.common.expanded.left, bEdge.crossTarget)\n\t\t\t.add(bEdge.value, bEdge.crossTarget)\n\t\t\t.build()\n\t}\n\n\tif (info.midX !== null) {\n\t\t// Arrow 5:\n\t\treturn new ElbowArrowRouteBuilder(info, 'to left 5')\n\t\t\t.add(aEdge.value, aEdge.crossTarget)\n\t\t\t.add(aEdge.expanded, aEdge.crossTarget)\n\t\t\t.add(aEdge.expanded, info.A.expanded.bottom)\n\t\t\t.add(info.midX, info.A.expanded.bottom)\n\t\t\t.add(info.midX, info.B.expanded.top)\n\t\t\t.midpointHandle('y')\n\t\t\t.add(bEdge.expanded, info.B.expanded.top)\n\t\t\t.add(bEdge.expanded, bEdge.crossTarget)\n\t\t\t.add(bEdge.value, bEdge.crossTarget)\n\t\t\t.build()\n\t}\n\n\treturn null\n}\n\n/**\n * Draw one of these arrows:\n * ```\n * 1:              2:              3:\n * âââââ                 âââââ     âââââ\n * â A âââââââ     âââââ â âââ¼ââ   â A âââ\n * âââââ     â     â A âââ â B â   âââââ â\n *         âââ¼ââ   âââââ   âââââ     âââââ\n *         â B â                   âââ¼ââ\n *         âââââ                   â B â\n *                                 âââââ\n * 4:        5:          6:\n *   âââââ     âââââ       âââââ âââââ\n * âââ¼ââ â     â âââ¼ââ   âââ¼ââ â â A âââ\n * â B â â     â â B â   â B â â âââââ â\n * âââââ â     â âââââ   âââââ âââââââââ\n * âââââ â     âââââ\n * â A âââ   âââââ â\n * âââââ     â A âââ\n *           âââââ\n * ```\n */\nexport function routeRightToTop(info: ElbowArrowWorkingInfo): ElbowArrowRoute | null {\n\tconst aEdge = info.A.edges.right\n\tconst bEdge = info.B.edges.top\n\n\tif (!aEdge || !bEdge) return null\n\n\tif (\n\t\t(aEdge.crossTarget < (bEdge.expanded ?? bEdge.value) &&\n\t\t\tbEdge.crossTarget > (aEdge.expanded ?? aEdge.value)) ||\n\t\t(info.A.isPoint && info.B.expanded.containsPoint(info.A.original.center))\n\t) {\n\t\t// Arrow 1:\n\t\treturn new ElbowArrowRouteBuilder(info, 'to top 1')\n\t\t\t.add(aEdge.value, aEdge.crossTarget)\n\t\t\t.add(bEdge.crossTarget, aEdge.crossTarget)\n\t\t\t.add(bEdge.crossTarget, bEdge.value)\n\t\t\t.build()\n\t}\n\n\tif (info.gapX > 0 && info.midX !== null && bEdge.expanded !== null) {\n\t\t// Arrow 2:\n\t\treturn new ElbowArrowRouteBuilder(info, 'to top 2')\n\t\t\t.add(aEdge.value, aEdge.crossTarget)\n\t\t\t.add(info.midX, aEdge.crossTarget)\n\t\t\t.add(info.midX, bEdge.expanded)\n\t\t\t.midpointHandle('x')\n\t\t\t.add(bEdge.crossTarget, bEdge.expanded)\n\t\t\t.add(bEdge.crossTarget, bEdge.value)\n\t\t\t.build()\n\t}\n\n\tif (\n\t\tinfo.gapY > 0 &&\n\t\taEdge.expanded !== null &&\n\t\tbEdge.crossTarget < aEdge.expanded &&\n\t\tinfo.midY !== null\n\t) {\n\t\t// Arrow 3:\n\t\treturn new ElbowArrowRouteBuilder(info, 'to top 3')\n\t\t\t.add(aEdge.value, aEdge.crossTarget)\n\t\t\t.add(aEdge.expanded, aEdge.crossTarget)\n\t\t\t.add(aEdge.expanded, info.midY)\n\t\t\t.add(bEdge.crossTarget, info.midY)\n\t\t\t.midpointHandle('y')\n\t\t\t.add(bEdge.crossTarget, bEdge.value)\n\t\t\t.build()\n\t}\n\n\tconst arrow4Length =\n\t\tMath.abs(aEdge.value - info.common.expanded.right) +\n\t\tMath.abs(aEdge.crossTarget - info.common.expanded.top) +\n\t\tMath.abs(bEdge.crossTarget - info.common.expanded.right) +\n\t\tMath.abs(bEdge.value - info.common.expanded.top)\n\n\tconst arrow5Length =\n\t\taEdge.expanded !== null && info.midY !== null && bEdge.expanded !== null\n\t\t\t? Math.abs(aEdge.value - aEdge.expanded) +\n\t\t\t\tMath.abs(info.B.expanded.left - aEdge.expanded) +\n\t\t\t\tMath.abs(info.B.expanded.left - bEdge.crossTarget) +\n\t\t\t\tMath.abs(aEdge.crossTarget - info.B.expanded.top) +\n\t\t\t\tMath.abs(bEdge.value - bEdge.expanded)\n\t\t\t: Infinity\n\n\tconst arrow6Length =\n\t\taEdge.expanded !== null && info.midX !== null && bEdge.expanded !== null\n\t\t\t? Math.abs(aEdge.value - info.common.expanded.right) +\n\t\t\t\tMath.abs(aEdge.crossTarget - info.A.expanded.bottom) +\n\t\t\t\tMath.abs(aEdge.expanded - bEdge.crossTarget) +\n\t\t\t\tMath.abs(info.A.expanded.bottom - bEdge.expanded) +\n\t\t\t\tMath.abs(bEdge.expanded - bEdge.value)\n\t\t\t: Infinity\n\n\tif (arrow4Length < arrow5Length && arrow4Length < arrow6Length) {\n\t\t// Arrow 4:\n\t\treturn new ElbowArrowRouteBuilder(info, 'to top 4')\n\t\t\t.add(aEdge.value, aEdge.crossTarget)\n\t\t\t.add(info.common.expanded.right, aEdge.crossTarget)\n\t\t\t.add(info.common.expanded.right, info.common.expanded.top)\n\t\t\t.add(bEdge.crossTarget, info.common.expanded.top)\n\t\t\t.add(bEdge.crossTarget, bEdge.value)\n\t\t\t.build()\n\t}\n\n\tif (\n\t\tbEdge.expanded !== null &&\n\t\taEdge.expanded !== null &&\n\t\tinfo.midY !== null &&\n\t\tarrow5Length < arrow6Length\n\t) {\n\t\t// Arrow 5:\n\t\treturn new ElbowArrowRouteBuilder(info, 'to top 5')\n\t\t\t.add(aEdge.value, aEdge.crossTarget)\n\t\t\t.add(aEdge.expanded, aEdge.crossTarget)\n\t\t\t.add(aEdge.expanded, info.midY)\n\t\t\t.add(info.B.expanded.left, info.midY)\n\t\t\t.midpointHandle('y')\n\t\t\t.add(info.B.expanded.left, bEdge.expanded)\n\t\t\t.add(bEdge.crossTarget, bEdge.expanded)\n\t\t\t.add(bEdge.crossTarget, bEdge.value)\n\t\t\t.build()\n\t}\n\n\tif (bEdge.expanded !== null && aEdge.expanded !== null && info.midX !== null) {\n\t\t// Arrow 6:\n\t\treturn new ElbowArrowRouteBuilder(info, 'to top 6')\n\t\t\t.add(aEdge.value, aEdge.crossTarget)\n\t\t\t.add(aEdge.expanded, aEdge.crossTarget)\n\t\t\t.add(aEdge.expanded, info.A.expanded.bottom)\n\t\t\t.add(info.midX, info.A.expanded.bottom)\n\t\t\t.add(info.midX, bEdge.expanded)\n\t\t\t.midpointHandle('x')\n\t\t\t.add(bEdge.crossTarget, bEdge.expanded)\n\t\t\t.add(bEdge.crossTarget, bEdge.value)\n\t\t\t.build()\n\t}\n\n\treturn null\n}\n\n/**\n * See `routeRightToTop`.\n */\nexport function routeRightToBottom(info: ElbowArrowWorkingInfo): ElbowArrowRoute | null {\n\tinfo.apply(ElbowArrowTransform.FlipY)\n\treturn routeRightToTop(info)\n}\n\n/**\n * Arrows may be mirrored - Y flipped\n * ```\n * 1:        2:                3:\n * âââââ     âââââ âââââââââ           âââââ\n * â A âââ   â A âââ âââââ â   âââââ   â A âââ\n * âââââ â   âââââ   â B âââ   â B âââ âââââ â\n * âââââ â           âââââ     âââââ âââââââââ\n * â B âââ\n * âââââ\n * ```\n */\nexport function routeRightToRight(info: ElbowArrowWorkingInfo): ElbowArrowRoute | null {\n\tconst aEdge = info.A.edges.right\n\tconst bEdge = info.B.edges.right\n\n\tif (!aEdge || !bEdge) return null\n\n\tif (\n\t\t(info.gapX <= 0 ||\n\t\t\taEdge.crossTarget > info.B.expanded.bottom ||\n\t\t\taEdge.crossTarget < info.B.expanded.top) &&\n\t\t(bEdge.value > info.A.original.left ||\n\t\t\tbEdge.crossTarget > info.A.expanded.bottom ||\n\t\t\tbEdge.crossTarget < info.A.expanded.top)\n\t) {\n\t\t// Arrow 1\n\t\treturn new ElbowArrowRouteBuilder(info, 'to right 1')\n\t\t\t.add(aEdge.value, aEdge.crossTarget)\n\t\t\t.add(info.common.expanded.right, aEdge.crossTarget)\n\t\t\t.add(info.common.expanded.right, bEdge.crossTarget)\n\t\t\t.add(bEdge.value, bEdge.crossTarget)\n\t\t\t.build()\n\t}\n\n\tif (info.midX === null) return null\n\n\tif (bEdge.expanded !== null && info.gapX >= 0) {\n\t\tconst viaBottomLength =\n\t\t\tMath.abs(bEdge.crossTarget - info.B.expanded.bottom) +\n\t\t\tMath.abs(aEdge.crossTarget - info.B.expanded.bottom)\n\t\tconst viaTopLength =\n\t\t\tMath.abs(bEdge.crossTarget - info.B.expanded.top) +\n\t\t\tMath.abs(aEdge.crossTarget - info.B.expanded.top)\n\n\t\tconst topOrBottom = viaBottomLength < viaTopLength ? 'bottom' : 'top'\n\t\t// Arrow 2:\n\t\treturn new ElbowArrowRouteBuilder(info, `to right 2 via ${topOrBottom}`)\n\t\t\t.add(aEdge.value, aEdge.crossTarget)\n\t\t\t.add(info.midX, aEdge.crossTarget)\n\t\t\t.add(info.midX, info.B.expanded[topOrBottom])\n\t\t\t.midpointHandle('x')\n\t\t\t.add(bEdge.expanded, info.B.expanded[topOrBottom])\n\t\t\t.add(bEdge.expanded, bEdge.crossTarget)\n\t\t\t.add(bEdge.value, bEdge.crossTarget)\n\t\t\t.build()\n\t}\n\n\tif (aEdge.expanded !== null && info.gapX <= 0) {\n\t\tconst viaBottomLength =\n\t\t\tMath.abs(bEdge.crossTarget - info.A.expanded.bottom) +\n\t\t\tMath.abs(aEdge.crossTarget - info.A.expanded.bottom)\n\t\tconst viaTopLength =\n\t\t\tMath.abs(bEdge.crossTarget - info.A.expanded.top) +\n\t\t\tMath.abs(aEdge.crossTarget - info.A.expanded.top)\n\n\t\tconst topOrBottom = viaBottomLength < viaTopLength ? 'bottom' : 'top'\n\t\t// Arrow 3:\n\t\treturn new ElbowArrowRouteBuilder(info, `to right 3 via ${topOrBottom}`)\n\t\t\t.add(aEdge.value, aEdge.crossTarget)\n\t\t\t.add(aEdge.expanded, aEdge.crossTarget)\n\t\t\t.add(aEdge.expanded, info.A.expanded[topOrBottom])\n\t\t\t.add(info.midX, info.A.expanded[topOrBottom])\n\t\t\t.add(info.midX, bEdge.crossTarget)\n\t\t\t.midpointHandle('x')\n\t\t\t.add(bEdge.value, bEdge.crossTarget)\n\t\t\t.build()\n\t}\n\n\treturn null\n}\n\nconst routes = {\n\ttop: {\n\t\ttop: [ElbowArrowTransform.Rotate270, routeRightToRight],\n\t\tleft: [ElbowArrowTransform.Rotate270, routeRightToTop],\n\t\tbottom: [ElbowArrowTransform.Rotate270, routeRightToLeft],\n\t\tright: [ElbowArrowTransform.Rotate270, routeRightToBottom],\n\t},\n\tright: {\n\t\ttop: [ElbowArrowTransform.Identity, routeRightToTop],\n\t\tright: [ElbowArrowTransform.Identity, routeRightToRight],\n\t\tbottom: [ElbowArrowTransform.Identity, routeRightToBottom],\n\t\tleft: [ElbowArrowTransform.Identity, routeRightToLeft],\n\t},\n\tbottom: {\n\t\ttop: [ElbowArrowTransform.Rotate90, routeRightToLeft],\n\t\tleft: [ElbowArrowTransform.Rotate90, routeRightToBottom],\n\t\tbottom: [ElbowArrowTransform.Rotate90, routeRightToRight],\n\t\tright: [ElbowArrowTransform.Rotate90, routeRightToTop],\n\t},\n\tleft: {\n\t\ttop: [ElbowArrowTransform.Rotate180, routeRightToBottom],\n\t\tleft: [ElbowArrowTransform.Rotate180, routeRightToRight],\n\t\tbottom: [ElbowArrowTransform.Rotate180, routeRightToTop],\n\t\tright: [ElbowArrowTransform.Rotate180, routeRightToLeft],\n\t},\n} satisfies Record<\n\tElbowArrowSide,\n\tRecord<\n\t\tElbowArrowSide,\n\t\t[ElbowArrowTransform, (info: ElbowArrowWorkingInfo) => ElbowArrowRoute | null]\n\t>\n>\n\nexport function tryRouteArrow(\n\tinfo: ElbowArrowWorkingInfo,\n\taEdge: ElbowArrowSide,\n\tbEdge: ElbowArrowSide\n): ElbowArrowRoute | null {\n\tconst [transform, routeFn] = routes[aEdge][bEdge]\n\tinfo.apply(transform)\n\tconst route = routeFn(info)\n\tinfo.reset()\n\treturn route\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1852, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/arrow/elbow/routes/routeArrowWithAutoEdgePicking.tsx"],"sourcesContent":["import { exhaustiveSwitchError } from '@tldraw/editor'\nimport {\n\tElbowArrowRoute,\n\tElbowArrowSide,\n\tElbowArrowSideOpposites,\n\tElbowArrowSideReason,\n\tElbowArrowSides,\n} from '../definitions'\nimport { ElbowArrowWorkingInfo } from './ElbowArrowWorkingInfo'\nimport { tryRouteArrow } from './elbowArrowRoutes'\n\nexport function routeArrowWithAutoEdgePicking(\n\tinfo: ElbowArrowWorkingInfo,\n\treason: ElbowArrowSideReason\n): ElbowArrowRoute | null {\n\tlet idealRoute = null\n\tif (\n\t\t// +1 to bias us towards the x-axis. without this, we get flicker as we move an arrow locket\n\t\t// to 45 deg (as gapx/gapy are almost equal and the result depends on floating point\n\t\t// precision)\n\t\tMath.abs(info.gapX) + 1 > Math.abs(info.gapY) &&\n\t\tinfo.midX !== null\n\t) {\n\t\tif (info.gapX > 0) {\n\t\t\tidealRoute = tryRouteArrow(info, 'right', 'left')\n\t\t} else {\n\t\t\tidealRoute = tryRouteArrow(info, 'left', 'right')\n\t\t}\n\t} else {\n\t\tconst aRight = info.A.edges.right\n\t\tconst aLeft = info.A.edges.left\n\t\tconst bTop = info.B.edges.top\n\t\tconst bBottom = info.B.edges.bottom\n\n\t\tif (info.A.isPoint && info.B.isPoint) {\n\t\t\tif (info.gapY > 0) {\n\t\t\t\tidealRoute = tryRouteArrow(info, 'bottom', 'top')\n\t\t\t} else {\n\t\t\t\tidealRoute = tryRouteArrow(info, 'top', 'bottom')\n\t\t\t}\n\t\t} else if (\n\t\t\taRight &&\n\t\t\tbTop &&\n\t\t\t(aRight.expanded ?? aRight.value) <= bTop.crossTarget &&\n\t\t\taRight.crossTarget <= (bTop.expanded ?? bTop.value)\n\t\t) {\n\t\t\tidealRoute = tryRouteArrow(info, 'right', 'top')\n\t\t} else if (\n\t\t\taRight &&\n\t\t\tbBottom &&\n\t\t\t(aRight.expanded ?? aRight.value) <= bBottom.crossTarget &&\n\t\t\taRight.crossTarget >= (bBottom.expanded ?? bBottom.value)\n\t\t) {\n\t\t\tidealRoute = tryRouteArrow(info, 'right', 'bottom')\n\t\t} else if (\n\t\t\taLeft &&\n\t\t\tbTop &&\n\t\t\t(aLeft.expanded ?? aLeft.value) >= bTop.crossTarget &&\n\t\t\taLeft.crossTarget <= (bTop.expanded ?? bTop.value)\n\t\t) {\n\t\t\tidealRoute = tryRouteArrow(info, 'left', 'top')\n\t\t} else if (\n\t\t\taLeft &&\n\t\t\tbBottom &&\n\t\t\t(aLeft.expanded ?? aLeft.value) >= bBottom.crossTarget &&\n\t\t\taLeft.crossTarget >= (bBottom.expanded ?? bBottom.value)\n\t\t) {\n\t\t\tidealRoute = tryRouteArrow(info, 'left', 'bottom')\n\t\t} else if (info.gapY > 0 && info.midY !== null) {\n\t\t\tidealRoute = tryRouteArrow(info, 'bottom', 'top')\n\t\t} else if (info.gapY < 0 && info.midY !== null) {\n\t\t\tidealRoute = tryRouteArrow(info, 'top', 'bottom')\n\t\t}\n\t}\n\n\tif (idealRoute) {\n\t\tidealRoute.aEdgePicking = reason\n\t\tidealRoute.bEdgePicking = reason\n\t\treturn idealRoute\n\t}\n\n\tconst aAvailableSide = ElbowArrowSides.filter((side) => info.A.edges[side])\n\tconst bAvailableSides = ElbowArrowSides.filter((side) => info.B.edges[side])\n\n\tconst nonPartialRouteCandidates = aAvailableSide.flatMap((aSide) =>\n\t\tbAvailableSides.map((bSide) => [aSide, bSide, reason, reason] as const)\n\t)\n\n\treturn pickBest(info, nonPartialRouteCandidates)\n}\n\nexport function routeArrowWithPartialEdgePicking(\n\tinfo: ElbowArrowWorkingInfo,\n\taSide: ElbowArrowSide\n) {\n\tlet idealRoute = null\n\n\tconst aRight = info.A.edges.right\n\tconst aLeft = info.A.edges.left\n\tconst bTop = info.B.edges.top\n\tconst bBottom = info.B.edges.bottom\n\n\tswitch (aSide) {\n\t\tcase 'right':\n\t\t\tif (info.gapX > 0 && info.gapX > Math.abs(info.gapY) && info.midX !== null) {\n\t\t\t\tidealRoute = tryRouteArrow(info, 'right', 'left')\n\t\t\t} else if (\n\t\t\t\taRight &&\n\t\t\t\tbTop &&\n\t\t\t\t(aRight.expanded ?? aRight.value) <= bTop.crossTarget &&\n\t\t\t\taRight.crossTarget <= (bTop.expanded ?? bTop.value)\n\t\t\t) {\n\t\t\t\tidealRoute = tryRouteArrow(info, 'right', 'top')\n\t\t\t} else if (\n\t\t\t\taRight &&\n\t\t\t\tbBottom &&\n\t\t\t\t(aRight.expanded ?? aRight.value) <= bBottom.crossTarget &&\n\t\t\t\taRight.crossTarget >= (bBottom.expanded ?? bBottom.value)\n\t\t\t) {\n\t\t\t\tidealRoute = tryRouteArrow(info, 'right', 'bottom')\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'left':\n\t\t\tif (info.gapX < 0 && Math.abs(info.gapX) > Math.abs(info.gapY) && info.midX !== null) {\n\t\t\t\tidealRoute = tryRouteArrow(info, 'left', 'right')\n\t\t\t} else if (\n\t\t\t\taLeft &&\n\t\t\t\tbTop &&\n\t\t\t\t(aLeft.expanded ?? aLeft.value) >= bTop.crossTarget &&\n\t\t\t\taLeft.crossTarget <= (bTop.expanded ?? bTop.value)\n\t\t\t) {\n\t\t\t\tidealRoute = tryRouteArrow(info, 'left', 'top')\n\t\t\t} else if (\n\t\t\t\taLeft &&\n\t\t\t\tbBottom &&\n\t\t\t\t(aLeft.expanded ?? aLeft.value) >= bBottom.crossTarget &&\n\t\t\t\taLeft.crossTarget >= (bBottom.expanded ?? bBottom.value)\n\t\t\t) {\n\t\t\t\tidealRoute = tryRouteArrow(info, 'left', 'bottom')\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'top':\n\t\tcase 'bottom':\n\t\t\t// top and bottom are handled by the pickShortest approach below - it automatically\n\t\t\t// picks the path we would pick with heuristics anyway.\n\t\t\tbreak\n\t\tdefault:\n\t\t\texhaustiveSwitchError(aSide)\n\t}\n\n\tif (idealRoute) {\n\t\tidealRoute.aEdgePicking = 'manual'\n\t\tidealRoute.bEdgePicking = 'auto'\n\t\treturn idealRoute\n\t}\n\n\tswitch (aSide) {\n\t\tcase 'top':\n\t\t\treturn pickBest(info, [\n\t\t\t\t['top', 'bottom', 'manual', 'auto'],\n\t\t\t\t['top', 'right', 'manual', 'auto'],\n\t\t\t\t['top', 'left', 'manual', 'auto'],\n\t\t\t\t['top', 'top', 'manual', 'auto'],\n\t\t\t])\n\t\tcase 'bottom':\n\t\t\treturn pickBest(info, [\n\t\t\t\t['bottom', 'top', 'manual', 'auto'],\n\t\t\t\t['bottom', 'right', 'manual', 'auto'],\n\t\t\t\t['bottom', 'left', 'manual', 'auto'],\n\t\t\t\t['bottom', 'bottom', 'manual', 'auto'],\n\t\t\t])\n\t\tcase 'left':\n\t\t\treturn pickBest(info, [\n\t\t\t\t['left', 'right', 'manual', 'auto'],\n\t\t\t\t['left', 'bottom', 'manual', 'auto'],\n\t\t\t\t['left', 'left', 'manual', 'auto'],\n\t\t\t\t['left', 'top', 'manual', 'auto'],\n\t\t\t])\n\t\tcase 'right':\n\t\t\treturn pickBest(info, [\n\t\t\t\t['right', 'left', 'manual', 'auto'],\n\t\t\t\t['right', 'bottom', 'manual', 'auto'],\n\t\t\t\t['right', 'right', 'manual', 'auto'],\n\t\t\t\t['right', 'top', 'manual', 'auto'],\n\t\t\t])\n\t}\n}\n\nexport function routeArrowWithManualEdgePicking(\n\tinfo: ElbowArrowWorkingInfo,\n\taSide: ElbowArrowSide,\n\tbSide: ElbowArrowSide\n) {\n\tconst route = tryRouteArrow(info, aSide, bSide)\n\tif (route) return route\n\n\tif (info.A.isPoint && info.B.isPoint) {\n\t\treturn pickBest(info, [\n\t\t\t[ElbowArrowSideOpposites[aSide], ElbowArrowSideOpposites[bSide], 'manual', 'manual'],\n\t\t\t[aSide, ElbowArrowSideOpposites[bSide], 'manual', 'auto'],\n\t\t\t[ElbowArrowSideOpposites[aSide], bSide, 'auto', 'manual'],\n\t\t])\n\t} else if (info.A.isPoint) {\n\t\treturn tryRouteArrow(info, ElbowArrowSideOpposites[aSide], bSide)\n\t} else if (info.B.isPoint) {\n\t\treturn tryRouteArrow(info, aSide, ElbowArrowSideOpposites[bSide])\n\t}\n\n\treturn null\n}\nfunction pickBest(\n\tinfo: ElbowArrowWorkingInfo,\n\tedges: ReadonlyArray<\n\t\treadonly [ElbowArrowSide, ElbowArrowSide, ElbowArrowSideReason, ElbowArrowSideReason]\n\t>\n) {\n\tlet bestRoute: ElbowArrowRoute | null = null\n\tlet bestCornerCount = Infinity\n\tlet bestDistance = Infinity\n\tlet distanceBias = 0\n\tfor (const [aSide, bSide, aEdgePicking, bEdgePicking] of edges) {\n\t\tdistanceBias += 1\n\t\tconst route = tryRouteArrow(info, aSide, bSide)\n\t\tif (route) {\n\t\t\troute.aEdgePicking = aEdgePicking\n\t\t\troute.bEdgePicking = bEdgePicking\n\t\t\tif (route.points.length < bestCornerCount) {\n\t\t\t\tbestCornerCount = route.points.length\n\t\t\t\tbestDistance = route.distance\n\t\t\t\tbestRoute = route\n\t\t\t} else if (\n\t\t\t\troute.points.length === bestCornerCount &&\n\t\t\t\troute.distance + distanceBias < bestDistance\n\t\t\t) {\n\t\t\t\tbestDistance = route.distance\n\t\t\t\tbestRoute = route\n\t\t\t}\n\t\t}\n\t}\n\treturn bestRoute\n}\n"],"names":[],"mappings":";;;;;;AAAA,SAAS,6BAA6B;AACtC;AAQA,SAAS,qBAAqB;;;;AAEvB,SAAS,8BACf,IAAA,EACA,MAAA,EACyB;IACzB,IAAI,aAAa;IACjB,IAAA,4FAAA;IAAA,oFAAA;IAAA,aAAA;IAIC,KAAK,GAAA,CAAI,KAAK,IAAI,IAAI,IAAI,KAAK,GAAA,CAAI,KAAK,IAAI,KAC5C,KAAK,IAAA,KAAS,MACb;QACD,IAAI,KAAK,IAAA,GAAO,GAAG;YAClB,4NAAa,gBAAA,EAAc,MAAM,SAAS,MAAM;QACjD,OAAO;YACN,iBAAa,2NAAA,EAAc,MAAM,QAAQ,OAAO;QACjD;IACD,OAAO;QACN,MAAM,SAAS,KAAK,CAAA,CAAE,KAAA,CAAM,KAAA;QAC5B,MAAM,QAAQ,KAAK,CAAA,CAAE,KAAA,CAAM,IAAA;QAC3B,MAAM,OAAO,KAAK,CAAA,CAAE,KAAA,CAAM,GAAA;QAC1B,MAAM,UAAU,KAAK,CAAA,CAAE,KAAA,CAAM,MAAA;QAE7B,IAAI,KAAK,CAAA,CAAE,OAAA,IAAW,KAAK,CAAA,CAAE,OAAA,EAAS;YACrC,IAAI,KAAK,IAAA,GAAO,GAAG;gBAClB,4NAAa,gBAAA,EAAc,MAAM,UAAU,KAAK;YACjD,OAAO;gBACN,4NAAa,gBAAA,EAAc,MAAM,OAAO,QAAQ;YACjD;QACD,OAAA,IACC,UACA,QAAA,CACC,OAAO,QAAA,IAAY,OAAO,KAAA,KAAU,KAAK,WAAA,IAC1C,OAAO,WAAA,IAAA,CAAgB,KAAK,QAAA,IAAY,KAAK,KAAA,GAC5C;YACD,4NAAa,gBAAA,EAAc,MAAM,SAAS,KAAK;QAChD,OAAA,IACC,UACA,WAAA,CACC,OAAO,QAAA,IAAY,OAAO,KAAA,KAAU,QAAQ,WAAA,IAC7C,OAAO,WAAA,IAAA,CAAgB,QAAQ,QAAA,IAAY,QAAQ,KAAA,GAClD;YACD,4NAAa,gBAAA,EAAc,MAAM,SAAS,QAAQ;QACnD,OAAA,IACC,SACA,QAAA,CACC,MAAM,QAAA,IAAY,MAAM,KAAA,KAAU,KAAK,WAAA,IACxC,MAAM,WAAA,IAAA,CAAgB,KAAK,QAAA,IAAY,KAAK,KAAA,GAC3C;YACD,4NAAa,gBAAA,EAAc,MAAM,QAAQ,KAAK;QAC/C,OAAA,IACC,SACA,WAAA,CACC,MAAM,QAAA,IAAY,MAAM,KAAA,KAAU,QAAQ,WAAA,IAC3C,MAAM,WAAA,IAAA,CAAgB,QAAQ,QAAA,IAAY,QAAQ,KAAA,GACjD;YACD,4NAAa,gBAAA,EAAc,MAAM,QAAQ,QAAQ;QAClD,OAAA,IAAW,KAAK,IAAA,GAAO,KAAK,KAAK,IAAA,KAAS,MAAM;YAC/C,4NAAa,gBAAA,EAAc,MAAM,UAAU,KAAK;QACjD,OAAA,IAAW,KAAK,IAAA,GAAO,KAAK,KAAK,IAAA,KAAS,MAAM;YAC/C,4NAAa,gBAAA,EAAc,MAAM,OAAO,QAAQ;QACjD;IACD;IAEA,IAAI,YAAY;QACf,WAAW,YAAA,GAAe;QAC1B,WAAW,YAAA,GAAe;QAC1B,OAAO;IACR;IAEA,MAAM,6MAAiB,kBAAA,CAAgB,MAAA,CAAO,CAAC,OAAS,KAAK,CAAA,CAAE,KAAA,CAAM,IAAI,CAAC;IAC1E,MAAM,8MAAkB,kBAAA,CAAgB,MAAA,CAAO,CAAC,OAAS,KAAK,CAAA,CAAE,KAAA,CAAM,IAAI,CAAC;IAE3E,MAAM,4BAA4B,eAAe,OAAA,CAAQ,CAAC,QACzD,gBAAgB,GAAA,CAAI,CAAC,QAAU;gBAAC;gBAAO;gBAAO;gBAAQ,MAAM;aAAU;IAGvE,OAAO,SAAS,MAAM,yBAAyB;AAChD;AAEO,SAAS,iCACf,IAAA,EACA,KAAA,EACC;IACD,IAAI,aAAa;IAEjB,MAAM,SAAS,KAAK,CAAA,CAAE,KAAA,CAAM,KAAA;IAC5B,MAAM,QAAQ,KAAK,CAAA,CAAE,KAAA,CAAM,IAAA;IAC3B,MAAM,OAAO,KAAK,CAAA,CAAE,KAAA,CAAM,GAAA;IAC1B,MAAM,UAAU,KAAK,CAAA,CAAE,KAAA,CAAM,MAAA;IAE7B,OAAQ,OAAO;QACd,KAAK;YACJ,IAAI,KAAK,IAAA,GAAO,KAAK,KAAK,IAAA,GAAO,KAAK,GAAA,CAAI,KAAK,IAAI,KAAK,KAAK,IAAA,KAAS,MAAM;gBAC3E,4NAAa,gBAAA,EAAc,MAAM,SAAS,MAAM;YACjD,OAAA,IACC,UACA,QAAA,CACC,OAAO,QAAA,IAAY,OAAO,KAAA,KAAU,KAAK,WAAA,IAC1C,OAAO,WAAA,IAAA,CAAgB,KAAK,QAAA,IAAY,KAAK,KAAA,GAC5C;gBACD,aAAa,+NAAA,EAAc,MAAM,SAAS,KAAK;YAChD,OAAA,IACC,UACA,WAAA,CACC,OAAO,QAAA,IAAY,OAAO,KAAA,KAAU,QAAQ,WAAA,IAC7C,OAAO,WAAA,IAAA,CAAgB,QAAQ,QAAA,IAAY,QAAQ,KAAA,GAClD;gBACD,4NAAa,gBAAA,EAAc,MAAM,SAAS,QAAQ;YACnD;YACA;QACD,KAAK;YACJ,IAAI,KAAK,IAAA,GAAO,KAAK,KAAK,GAAA,CAAI,KAAK,IAAI,IAAI,KAAK,GAAA,CAAI,KAAK,IAAI,KAAK,KAAK,IAAA,KAAS,MAAM;gBACrF,4NAAa,gBAAA,EAAc,MAAM,QAAQ,OAAO;YACjD,OAAA,IACC,SACA,QAAA,CACC,MAAM,QAAA,IAAY,MAAM,KAAA,KAAU,KAAK,WAAA,IACxC,MAAM,WAAA,IAAA,CAAgB,KAAK,QAAA,IAAY,KAAK,KAAA,GAC3C;gBACD,4NAAa,gBAAA,EAAc,MAAM,QAAQ,KAAK;YAC/C,OAAA,IACC,SACA,WAAA,CACC,MAAM,QAAA,IAAY,MAAM,KAAA,KAAU,QAAQ,WAAA,IAC3C,MAAM,WAAA,IAAA,CAAgB,QAAQ,QAAA,IAAY,QAAQ,KAAA,GACjD;gBACD,aAAa,+NAAA,EAAc,MAAM,QAAQ,QAAQ;YAClD;YACA;QACD,KAAK;QACL,KAAK;YAGJ;QACD;YACC,CAAA,GAAA,sKAAA,CAAA,wBAAA,EAAsB,KAAK;IAC7B;IAEA,IAAI,YAAY;QACf,WAAW,YAAA,GAAe;QAC1B,WAAW,YAAA,GAAe;QAC1B,OAAO;IACR;IAEA,OAAQ,OAAO;QACd,KAAK;YACJ,OAAO,SAAS,MAAM;gBACrB;oBAAC;oBAAO;oBAAU;oBAAU,MAAM;iBAAA;gBAClC;oBAAC;oBAAO;oBAAS;oBAAU,MAAM;iBAAA;gBACjC;oBAAC;oBAAO;oBAAQ;oBAAU,MAAM;iBAAA;gBAChC;oBAAC;oBAAO;oBAAO;oBAAU,MAAM;iBAAA;aAC/B;QACF,KAAK;YACJ,OAAO,SAAS,MAAM;gBACrB;oBAAC;oBAAU;oBAAO;oBAAU,MAAM;iBAAA;gBAClC;oBAAC;oBAAU;oBAAS;oBAAU,MAAM;iBAAA;gBACpC;oBAAC;oBAAU;oBAAQ;oBAAU,MAAM;iBAAA;gBACnC;oBAAC;oBAAU;oBAAU;oBAAU,MAAM;iBAAA;aACrC;QACF,KAAK;YACJ,OAAO,SAAS,MAAM;gBACrB;oBAAC;oBAAQ;oBAAS;oBAAU,MAAM;iBAAA;gBAClC;oBAAC;oBAAQ;oBAAU;oBAAU,MAAM;iBAAA;gBACnC;oBAAC;oBAAQ;oBAAQ;oBAAU,MAAM;iBAAA;gBACjC;oBAAC;oBAAQ;oBAAO;oBAAU,MAAM;iBAAA;aAChC;QACF,KAAK;YACJ,OAAO,SAAS,MAAM;gBACrB;oBAAC;oBAAS;oBAAQ;oBAAU,MAAM;iBAAA;gBAClC;oBAAC;oBAAS;oBAAU;oBAAU,MAAM;iBAAA;gBACpC;oBAAC;oBAAS;oBAAS;oBAAU,MAAM;iBAAA;gBACnC;oBAAC;oBAAS;oBAAO;oBAAU,MAAM;iBAAA;aACjC;IACH;AACD;AAEO,SAAS,gCACf,IAAA,EACA,KAAA,EACA,KAAA,EACC;IACD,MAAM,uNAAQ,gBAAA,EAAc,MAAM,OAAO,KAAK;IAC9C,IAAI,MAAO,CAAA,OAAO;IAElB,IAAI,KAAK,CAAA,CAAE,OAAA,IAAW,KAAK,CAAA,CAAE,OAAA,EAAS;QACrC,OAAO,SAAS,MAAM;YACrB;4MAAC,0BAAA,CAAwB,KAAK,CAAA;4MAAG,0BAAA,CAAwB,KAAK,CAAA;gBAAG;gBAAU,QAAQ;aAAA;YACnF;gBAAC;4MAAO,0BAAA,CAAwB,KAAK,CAAA;gBAAG;gBAAU,MAAM;aAAA;YACxD;4MAAC,0BAAA,CAAwB,KAAK,CAAA;gBAAG;gBAAO;gBAAQ,QAAQ;aAAA;SACxD;IACF,OAAA,IAAW,KAAK,CAAA,CAAE,OAAA,EAAS;QAC1B,QAAO,8NAAA,EAAc,kMAAM,0BAAA,CAAwB,KAAK,CAAA,EAAG,KAAK;IACjE,OAAA,IAAW,KAAK,CAAA,CAAE,OAAA,EAAS;QAC1B,QAAO,8NAAA,EAAc,MAAM,mMAAO,0BAAA,CAAwB,KAAK,CAAC;IACjE;IAEA,OAAO;AACR;AACA,SAAS,SACR,IAAA,EACA,KAAA,EAGC;IACD,IAAI,YAAoC;IACxC,IAAI,kBAAkB;IACtB,IAAI,eAAe;IACnB,IAAI,eAAe;IACnB,KAAA,MAAW,CAAC,OAAO,OAAO,cAAc,YAAY,CAAA,IAAK,MAAO;QAC/D,gBAAgB;QAChB,MAAM,SAAQ,8NAAA,EAAc,MAAM,OAAO,KAAK;QAC9C,IAAI,OAAO;YACV,MAAM,YAAA,GAAe;YACrB,MAAM,YAAA,GAAe;YACrB,IAAI,MAAM,MAAA,CAAO,MAAA,GAAS,iBAAiB;gBAC1C,kBAAkB,MAAM,MAAA,CAAO,MAAA;gBAC/B,eAAe,MAAM,QAAA;gBACrB,YAAY;YACb,OAAA,IACC,MAAM,MAAA,CAAO,MAAA,KAAW,mBACxB,MAAM,QAAA,GAAW,eAAe,cAC/B;gBACD,eAAe,MAAM,QAAA;gBACrB,YAAY;YACb;QACD;IACD;IACA,OAAO;AACR","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2124, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/arrow/elbow/getElbowArrowInfo.tsx"],"sourcesContent":["import {\n\tapproximately,\n\tassert,\n\tBox,\n\tEditor,\n\texhaustiveSwitchError,\n\tGeometry2dFilters,\n\tlerp,\n\tMat,\n\tTLArrowBinding,\n\tTLArrowBindingProps,\n\tTLArrowShape,\n\tTLShapeId,\n\tVec,\n\tVecLike,\n\tVecModel,\n} from '@tldraw/editor'\nimport { ArrowShapeUtil } from '../ArrowShapeUtil'\nimport { BOUND_ARROW_OFFSET, STROKE_SIZES, TLArrowBindings } from '../shared'\nimport {\n\tElbowArrowAxes,\n\tElbowArrowBox,\n\tElbowArrowBoxEdges,\n\tElbowArrowEdge,\n\tElbowArrowInfo,\n\tElbowArrowInfoWithoutRoute,\n\tElbowArrowOptions,\n\tElbowArrowRoute,\n\tElbowArrowSide,\n\tElbowArrowSideWithAxis,\n\tElbowArrowTargetBox,\n\tElbowArrowTerminal,\n} from './definitions'\nimport { createRange, expandRange, isWithinRange, rangeSize, subtractRange } from './range'\nimport { ElbowArrowWorkingInfo } from './routes/ElbowArrowWorkingInfo'\nimport {\n\trouteArrowWithAutoEdgePicking,\n\trouteArrowWithManualEdgePicking,\n\trouteArrowWithPartialEdgePicking,\n} from './routes/routeArrowWithAutoEdgePicking'\n\nexport function getElbowArrowInfo(\n\teditor: Editor,\n\tarrow: TLArrowShape,\n\tbindings: TLArrowBindings\n): ElbowArrowInfo {\n\tconst shapeOptions = editor.getShapeUtil<ArrowShapeUtil>(arrow.type).options\n\tconst options: ElbowArrowOptions = {\n\t\telbowMidpoint: arrow.props.elbowMidPoint,\n\t\texpandElbowLegLength: shapeOptions.expandElbowLegLength[arrow.props.size] * arrow.props.scale,\n\t\tminElbowLegLength: shapeOptions.minElbowLegLength[arrow.props.size] * arrow.props.scale,\n\t}\n\n\t// Before we can do anything else, we need to find the start and end terminals of the arrow.\n\t// These contain the binding info, geometry, bounds, etc.\n\tlet startTerminal = getElbowArrowTerminalInfo(editor, arrow, bindings.start, arrow.props.start)\n\tlet endTerminal = getElbowArrowTerminalInfo(editor, arrow, bindings.end, arrow.props.end)\n\t// unclosed paths are weird - we handle them outside of the initial terminal info.\n\tstartTerminal = adjustTerminalForUnclosedPathIfNeeded(startTerminal, endTerminal, options)\n\tendTerminal = adjustTerminalForUnclosedPathIfNeeded(endTerminal, startTerminal, options)\n\n\t// Ther terminal might include a \"side\" if the user has explicitly indicated what side the arrow\n\t// should come from. There are two terminals, and two cases for each terminal (explicit side or\n\t// not), for a total for 4 cases to handle. In order to keep things a bit simpler though, we\n\t// only handle 3 cases: if start no side and end has a side, we flip them around. From here on\n\t// out, we use A and B to refer to the terminals as they may be swapped.\n\tconst swapOrder = !!(!startTerminal.side && endTerminal.side)\n\n\tlet { aTerminal, bTerminal } = swapOrder\n\t\t? { aTerminal: endTerminal, bTerminal: startTerminal }\n\t\t: { aTerminal: startTerminal, bTerminal: endTerminal }\n\n\t// We model each edge that an arrow might enter/exit from separately. If an edge is blocked,\n\t// `getUsableEdge` might return null.\n\tlet edgesA = {\n\t\ttop: getUsableEdge(aTerminal, bTerminal, 'top', options),\n\t\tright: getUsableEdge(aTerminal, bTerminal, 'right', options),\n\t\tbottom: getUsableEdge(aTerminal, bTerminal, 'bottom', options),\n\t\tleft: getUsableEdge(aTerminal, bTerminal, 'left', options),\n\t}\n\n\tlet edgesB = {\n\t\ttop: getUsableEdge(bTerminal, aTerminal, 'top', options),\n\t\tright: getUsableEdge(bTerminal, aTerminal, 'right', options),\n\t\tbottom: getUsableEdge(bTerminal, aTerminal, 'bottom', options),\n\t\tleft: getUsableEdge(bTerminal, aTerminal, 'left', options),\n\t}\n\n\t// We we don't have a usable edge because it's blocked, we can convert some of the terminals to\n\t// points. Point terminals have less strict edge routing rules, but don't look as good\n\t// generally. For example, the arrow might go through the shape instead of around.\n\tconst aIsUsable = hasUsableEdge(edgesA, aTerminal.side)\n\tconst bIsUsable = hasUsableEdge(edgesB, bTerminal.side)\n\tlet needsNewEdges = false\n\tif (!aIsUsable || !bIsUsable) {\n\t\tneedsNewEdges = true\n\t\tif (!aIsUsable) {\n\t\t\tbTerminal = convertTerminalToPoint(bTerminal)\n\t\t}\n\n\t\tif (!bIsUsable) {\n\t\t\taTerminal = convertTerminalToPoint(aTerminal)\n\t\t}\n\n\t\tif (bTerminal.bounds.containsPoint(aTerminal.target, options.expandElbowLegLength)) {\n\t\t\tbTerminal = convertTerminalToPoint(bTerminal)\n\t\t}\n\n\t\tif (aTerminal.bounds.containsPoint(bTerminal.target, options.expandElbowLegLength)) {\n\t\t\taTerminal = convertTerminalToPoint(aTerminal)\n\t\t}\n\t}\n\n\tif (needsNewEdges) {\n\t\tedgesA = {\n\t\t\ttop: getUsableEdge(aTerminal, bTerminal, 'top', options),\n\t\t\tright: getUsableEdge(aTerminal, bTerminal, 'right', options),\n\t\t\tbottom: getUsableEdge(aTerminal, bTerminal, 'bottom', options),\n\t\t\tleft: getUsableEdge(aTerminal, bTerminal, 'left', options),\n\t\t}\n\n\t\tedgesB = {\n\t\t\ttop: getUsableEdge(bTerminal, aTerminal, 'top', options),\n\t\t\tright: getUsableEdge(bTerminal, aTerminal, 'right', options),\n\t\t\tbottom: getUsableEdge(bTerminal, aTerminal, 'bottom', options),\n\t\t\tleft: getUsableEdge(bTerminal, aTerminal, 'left', options),\n\t\t}\n\t}\n\n\t// We expand the bounds of the terminals so we can route arrows around them without the arrows\n\t// being too close to the shapes.\n\tconst expandedA = aTerminal.isPoint\n\t\t? aTerminal.bounds\n\t\t: aTerminal.bounds.clone().expandBy(options.expandElbowLegLength)\n\tconst expandedB = bTerminal.isPoint\n\t\t? bTerminal.bounds\n\t\t: bTerminal.bounds.clone().expandBy(options.expandElbowLegLength)\n\n\tconst common: ElbowArrowBox = {\n\t\toriginal: Box.Common([aTerminal.bounds, bTerminal.bounds]),\n\t\texpanded: Box.Common([expandedA, expandedB]),\n\t}\n\n\t// Calculate the gaps between the two terminals. If gap is positive, B is to the right of A. If\n\t// it's negative, the opposite is true. If it's 0, there's no gap between the shapes in that\n\t// dimension.\n\tlet gapX = bTerminal.bounds.minX - aTerminal.bounds.maxX\n\tif (gapX < 0) {\n\t\tgapX = aTerminal.bounds.minX - bTerminal.bounds.maxX\n\t\tif (gapX < 0) {\n\t\t\tgapX = 0\n\t\t}\n\t\tgapX = -gapX\n\t}\n\tlet gapY = bTerminal.bounds.minY - aTerminal.bounds.maxY\n\tif (gapY < 0) {\n\t\tgapY = aTerminal.bounds.minY - bTerminal.bounds.maxY\n\t\tif (gapY < 0) {\n\t\t\tgapY = 0\n\t\t}\n\t\tgapY = -gapY\n\t}\n\n\t// The midpoint of the gap is a useful point to route arrows through, but the user can also drag\n\t// it to choose a new midpoint. First, we calculate some constraints we'll need to keep in mind\n\t// when figuring out the midpoint...\n\tconst aMinLength = aTerminal.minEndSegmentLength * 3\n\tconst bMinLength = bTerminal.minEndSegmentLength * 3\n\tconst minLegDistanceNeeded =\n\t\t(aTerminal.isPoint ? aMinLength : options.minElbowLegLength) +\n\t\t(bTerminal.isPoint ? bMinLength : options.minElbowLegLength)\n\n\t// ...then, the possible range of the midpoint. This is also used when dragging the midpoint.\n\tlet mxRange: null | { a: number; b: number } = null\n\tif (gapX > minLegDistanceNeeded) {\n\t\tmxRange = {\n\t\t\ta: aTerminal.isPoint ? aTerminal.bounds.maxX + aMinLength : expandedA.maxX,\n\t\t\tb: bTerminal.isPoint ? bTerminal.bounds.minX - bMinLength : expandedB.minX,\n\t\t}\n\t} else if (gapX < -minLegDistanceNeeded) {\n\t\tmxRange = {\n\t\t\ta: aTerminal.isPoint ? aTerminal.bounds.minX - aMinLength : expandedA.minX,\n\t\t\tb: bTerminal.isPoint ? bTerminal.bounds.maxX + bMinLength : expandedB.maxX,\n\t\t}\n\t}\n\n\tlet myRange: null | { a: number; b: number } = null\n\tif (gapY > minLegDistanceNeeded) {\n\t\tmyRange = {\n\t\t\ta: aTerminal.isPoint ? aTerminal.bounds.maxY + aMinLength : expandedA.maxY,\n\t\t\tb: bTerminal.isPoint ? bTerminal.bounds.minY - bMinLength : expandedB.minY,\n\t\t}\n\t} else if (gapY < -minLegDistanceNeeded) {\n\t\tmyRange = {\n\t\t\ta: aTerminal.isPoint ? aTerminal.bounds.minY - aMinLength : expandedA.minY,\n\t\t\tb: bTerminal.isPoint ? bTerminal.bounds.maxY + bMinLength : expandedB.maxY,\n\t\t}\n\t}\n\n\t// and finally we take the range and the midpoint prop and calculate the actual position of the\n\t// midpoint. Note that the midpoint and midpoint range can be null if the gap is too small for a\n\t// midpoint line.\n\tconst midpoint = swapOrder ? 1 - options.elbowMidpoint : options.elbowMidpoint\n\tconst mx = mxRange ? lerp(mxRange.a, mxRange.b, midpoint) : null\n\tconst my = myRange ? lerp(myRange.a, myRange.b, midpoint) : null\n\n\t// The info without route is given to the route-finding functions to route between the two\n\t// terminals.\n\tconst info: ElbowArrowInfoWithoutRoute = {\n\t\toptions,\n\t\tswapOrder,\n\t\tA: {\n\t\t\tisPoint: aTerminal.isPoint,\n\t\t\ttarget: aTerminal.target,\n\t\t\tisExact: aTerminal.isExact,\n\t\t\tarrowheadOffset: aTerminal.arrowheadOffset,\n\t\t\tminEndSegmentLength: aTerminal.minEndSegmentLength,\n\t\t\toriginal: aTerminal.bounds,\n\t\t\texpanded: expandedA,\n\t\t\tedges: edgesA,\n\t\t\tgeometry: aTerminal.geometry,\n\t\t},\n\t\tB: {\n\t\t\tisPoint: bTerminal.isPoint,\n\t\t\ttarget: bTerminal.target,\n\t\t\tisExact: bTerminal.isExact,\n\t\t\tarrowheadOffset: bTerminal.arrowheadOffset,\n\t\t\tminEndSegmentLength: bTerminal.minEndSegmentLength,\n\t\t\toriginal: bTerminal.bounds,\n\t\t\texpanded: expandedB,\n\t\t\tedges: edgesB,\n\t\t\tgeometry: bTerminal.geometry,\n\t\t},\n\t\tcommon,\n\t\tgapX,\n\t\tgapY,\n\t\tmidX: mx,\n\t\tmidY: my,\n\t}\n\n\t// We wrap the info in a working info object that lets us mutate and reset it as needed.\n\tconst workingInfo = new ElbowArrowWorkingInfo(info)\n\n\t// Figure out the final sides to use for each terminal.\n\tconst aSide = getSideToUse(aTerminal, bTerminal, info.A.edges)\n\tconst bSide = getSideToUse(bTerminal, aTerminal, info.B.edges)\n\n\t// try to find a route with the specification we have:\n\tlet route\n\tif (aSide && bSide) {\n\t\troute = routeArrowWithManualEdgePicking(workingInfo, aSide, bSide)\n\t} else if (aSide && !bSide) {\n\t\troute = routeArrowWithPartialEdgePicking(workingInfo, aSide)\n\t}\n\tif (!route) {\n\t\troute = routeArrowWithAutoEdgePicking(workingInfo, aSide || bSide ? 'fallback' : 'auto')\n\t}\n\n\tif (route) {\n\t\t// If we found a route, we need to fix it up. The route will only go to the bounding box of\n\t\t// the shape, so we need to cast the final segments into the actual geometry of the shape.\n\t\tcastPathSegmentIntoGeometry('first', info.A, info.B, route)\n\t\tcastPathSegmentIntoGeometry('last', info.B, info.A, route)\n\t\t// If we have tiny L-shaped arrows, the arrowheads look super janky. We fix those up by just\n\t\t// drawing a straight line instead.\n\t\tfixTinyEndNubs(route, aTerminal, bTerminal)\n\n\t\t// If we swapped the order way back of the start of things, we need to reverse the route so\n\t\t// it flows start -> end instead of A -> B.\n\t\tif (swapOrder) route.points.reverse()\n\t}\n\n\treturn {\n\t\t...info,\n\t\troute,\n\t\tmidXRange: mxRange\n\t\t\t? swapOrder\n\t\t\t\t? { lo: mxRange.b, hi: mxRange.a }\n\t\t\t\t: { lo: mxRange.a, hi: mxRange.b }\n\t\t\t: null,\n\t\tmidYRange: myRange\n\t\t\t? swapOrder\n\t\t\t\t? { lo: myRange.b, hi: myRange.a }\n\t\t\t\t: { lo: myRange.a, hi: myRange.b }\n\t\t\t: null,\n\t}\n}\n\n/**\n * Take the route from `getElbowArrowInfo` (which represents the visible body of the arrow) and\n * convert it into a path we can use to show that paths to the handles, which may extend further\n * into the target shape geometries.\n * @returns\n */\nexport function getRouteHandlePath(info: ElbowArrowInfo, route: ElbowArrowRoute): ElbowArrowRoute {\n\tconst startTarget = info.swapOrder ? info.B.target : info.A.target\n\tconst endTarget = info.swapOrder ? info.A.target : info.B.target\n\n\tconst firstSegmentLength = Vec.ManhattanDist(route.points[0], route.points[1])\n\tconst lastSegmentLength = Vec.ManhattanDist(\n\t\troute.points[route.points.length - 2],\n\t\troute.points[route.points.length - 1]\n\t)\n\n\tconst newFirstSegmentLength = Vec.ManhattanDist(startTarget, route.points[1])\n\tconst newLastSegmentLength = Vec.ManhattanDist(route.points[route.points.length - 2], endTarget)\n\n\tconst firstSegmentLengthChange = firstSegmentLength - newFirstSegmentLength\n\tconst lastSegmentLengthChange = lastSegmentLength - newLastSegmentLength\n\n\tconst newPoints = [startTarget, ...route.points, endTarget]\n\n\treturn {\n\t\tname: route.name,\n\t\tdistance: route.distance + firstSegmentLengthChange + lastSegmentLengthChange,\n\t\tpoints: newPoints.filter((p) => !route.skipPointsWhenDrawing.has(p)),\n\t\taEdgePicking: route.aEdgePicking,\n\t\tbEdgePicking: route.bEdgePicking,\n\t\tskipPointsWhenDrawing: route.skipPointsWhenDrawing,\n\t\tmidpointHandle: route.midpointHandle,\n\t}\n}\n\n/**\n * Take a normalizes anchor and return the side we think it's closest to.\n */\nexport function getEdgeFromNormalizedAnchor(normalizedAnchor: VecLike) {\n\tif (approximately(normalizedAnchor.x, 0.5) && approximately(normalizedAnchor.y, 0.5)) {\n\t\treturn null\n\t}\n\n\tif (\n\t\tMath.abs(normalizedAnchor.x - 0.5) >\n\t\t// slightly bias towards x arrows to prevent flickering when the anchor is right on the line\n\t\t// between the two directions\n\t\tMath.abs(normalizedAnchor.y - 0.5) - 0.0001\n\t) {\n\t\treturn normalizedAnchor.x < 0.5 ? 'left' : 'right'\n\t}\n\n\treturn normalizedAnchor.y < 0.5 ? 'top' : 'bottom'\n}\n\nfunction getElbowArrowTerminalInfo(\n\teditor: Editor,\n\tarrow: TLArrowShape,\n\tbinding: TLArrowBinding | undefined,\n\tpoint: VecModel\n): ElbowArrowTerminal {\n\tconst arrowStrokeSize = (STROKE_SIZES[arrow.props.size] * arrow.props.scale) / 2\n\tconst minEndSegmentLength = arrowStrokeSize * arrow.props.scale * 3\n\n\tif (binding) {\n\t\tconst target = editor.getShape(binding.toId)\n\t\tconst geometry = getBindingGeometryInArrowSpace(editor, arrow, binding.toId, binding.props)\n\t\tif (geometry && target) {\n\t\t\tlet arrowheadOffset = 0\n\t\t\tconst arrowheadProp = binding.props.terminal === 'start' ? 'arrowheadStart' : 'arrowheadEnd'\n\t\t\tif (arrow.props[arrowheadProp] !== 'none') {\n\t\t\t\tconst targetScale = 'scale' in target.props ? target.props.scale : 1\n\t\t\t\tconst targetStrokeSize =\n\t\t\t\t\t'size' in target.props ? ((STROKE_SIZES[target.props.size] ?? 0) * targetScale) / 2 : 0\n\n\t\t\t\tarrowheadOffset =\n\t\t\t\t\tarrowStrokeSize + targetStrokeSize + BOUND_ARROW_OFFSET * arrow.props.scale\n\t\t\t}\n\n\t\t\tlet side: ElbowArrowSideWithAxis | null = null\n\t\t\tconst targetPoint = geometry.target\n\t\t\tif (binding.props.isPrecise) {\n\t\t\t\tside = getEdgeFromNormalizedAnchor(\n\t\t\t\t\tVec.RotWith(\n\t\t\t\t\t\tbinding.props.normalizedAnchor,\n\t\t\t\t\t\t{ x: 0.5, y: 0.5 },\n\t\t\t\t\t\tgeometry.shapeToArrowTransform.rotation()\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\ttargetShapeId: binding.toId,\n\t\t\t\tisPoint: false,\n\t\t\t\tisExact: binding.props.isExact,\n\t\t\t\tbounds: geometry.bounds,\n\t\t\t\tgeometry: geometry.geometry,\n\t\t\t\ttarget: targetPoint,\n\t\t\t\tarrowheadOffset,\n\t\t\t\tminEndSegmentLength,\n\t\t\t\tside,\n\t\t\t\tsnap: binding.props.snap,\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\ttargetShapeId: null,\n\t\tbounds: Box.FromCenter(point, { x: 0, y: 0 }),\n\t\tgeometry: null,\n\t\tisExact: false,\n\t\tisPoint: true,\n\t\ttarget: Vec.From(point),\n\t\tarrowheadOffset: 0,\n\t\tminEndSegmentLength,\n\t\tside: null,\n\t\tsnap: 'none',\n\t}\n}\n\nfunction getBindingGeometryInArrowSpace(\n\teditor: Editor,\n\tarrow: TLArrowShape,\n\ttargetId: TLShapeId,\n\tbindingProps: TLArrowBindingProps\n) {\n\tconst hasArrowhead =\n\t\tbindingProps.terminal === 'start'\n\t\t\t? arrow.props.arrowheadStart !== 'none'\n\t\t\t: arrow.props.arrowheadEnd !== 'none'\n\n\tconst targetGeometryInTargetSpace = editor.getShapeGeometry(\n\t\ttargetId,\n\t\thasArrowhead ? undefined : { context: '@tldraw/arrow-without-arrowhead' }\n\t)\n\n\tif (!targetGeometryInTargetSpace) {\n\t\treturn null\n\t}\n\n\tconst arrowTransform = editor.getShapePageTransform(arrow.id)\n\tconst shapeTransform = editor.getShapePageTransform(targetId)\n\tconst shapeToArrowTransform = arrowTransform.clone().invert().multiply(shapeTransform)\n\n\tconst targetGeometryInArrowSpace = targetGeometryInTargetSpace.transform(shapeToArrowTransform)\n\n\tconst center = { x: 0.5, y: 0.5 }\n\tconst normalizedAnchor = bindingProps.isPrecise ? bindingProps.normalizedAnchor : center\n\n\tconst targetInShapeSpace = {\n\t\tx: lerp(\n\t\t\ttargetGeometryInTargetSpace.bounds.minX,\n\t\t\ttargetGeometryInTargetSpace.bounds.maxX,\n\t\t\tnormalizedAnchor.x\n\t\t),\n\t\ty: lerp(\n\t\t\ttargetGeometryInTargetSpace.bounds.minY,\n\t\t\ttargetGeometryInTargetSpace.bounds.maxY,\n\t\t\tnormalizedAnchor.y\n\t\t),\n\t}\n\tconst centerInShapeSpace = {\n\t\tx: lerp(\n\t\t\ttargetGeometryInTargetSpace.bounds.minX,\n\t\t\ttargetGeometryInTargetSpace.bounds.maxX,\n\t\t\tcenter.x\n\t\t),\n\t\ty: lerp(\n\t\t\ttargetGeometryInTargetSpace.bounds.minY,\n\t\t\ttargetGeometryInTargetSpace.bounds.maxY,\n\t\t\tcenter.y\n\t\t),\n\t}\n\n\tconst targetInArrowSpace = Mat.applyToPoint(shapeToArrowTransform, targetInShapeSpace)\n\tconst centerInArrowSpace = Mat.applyToPoint(shapeToArrowTransform, centerInShapeSpace)\n\n\treturn {\n\t\tbounds: targetGeometryInArrowSpace.bounds,\n\t\tgeometry: targetGeometryInArrowSpace,\n\t\ttarget: targetInArrowSpace,\n\t\tcenter: centerInArrowSpace,\n\t\tshapeToArrowTransform,\n\t}\n}\n\nconst sideProps = {\n\ttop: {\n\t\texpand: -1,\n\t\tmain: 'minY',\n\t\topposite: 'maxY',\n\t\tcrossMid: 'midX',\n\t\tcrossMin: 'minX',\n\t\tcrossMax: 'maxX',\n\t\tbRangeExpand: 'max',\n\t\tcrossAxis: 'x',\n\t},\n\tbottom: {\n\t\texpand: 1,\n\t\tmain: 'maxY',\n\t\topposite: 'minY',\n\t\tcrossMid: 'midX',\n\t\tcrossMin: 'minX',\n\t\tcrossMax: 'maxX',\n\t\tbRangeExpand: 'min',\n\t\tcrossAxis: 'x',\n\t},\n\tleft: {\n\t\texpand: -1,\n\t\tmain: 'minX',\n\t\topposite: 'maxX',\n\t\tcrossMid: 'midY',\n\t\tcrossMin: 'minY',\n\t\tcrossMax: 'maxY',\n\t\tbRangeExpand: 'max',\n\t\tcrossAxis: 'y',\n\t},\n\tright: {\n\t\texpand: 1,\n\t\tmain: 'maxX',\n\t\topposite: 'minX',\n\t\tcrossMid: 'midY',\n\t\tcrossMin: 'minY',\n\t\tcrossMax: 'maxY',\n\t\tbRangeExpand: 'min',\n\t\tcrossAxis: 'y',\n\t},\n} as const\n\nexport function getUsableEdge(\n\ta: ElbowArrowTerminal,\n\tb: ElbowArrowTerminal,\n\tside: 'top' | 'right' | 'bottom' | 'left',\n\toptions: ElbowArrowOptions\n): ElbowArrowEdge | null {\n\tconst props = sideProps[side]\n\n\t// if a shape is bound to itself, by default we'd end up routing the arrow _within_ the shape -\n\t// as if it were a point-to-point arrow. if one of the bindings is specifically to the edge\n\t// though, we route it externally instead.\n\tconst isSelfBoundAndShouldRouteExternal =\n\t\ta.targetShapeId === b.targetShapeId &&\n\t\ta.targetShapeId !== null &&\n\t\t(a.snap === 'edge' || a.snap === 'edge-point') &&\n\t\t(b.snap === 'edge' || b.snap === 'edge-point')\n\n\tconst aValue = a.bounds[props.main]\n\tconst aExpanded = a.isPoint ? null : aValue + props.expand * options.expandElbowLegLength\n\n\tconst originalACrossRange = createRange(a.bounds[props.crossMin], a.bounds[props.crossMax])\n\tlet aCrossRange = originalACrossRange\n\n\t// this edge is too small to be useful:\n\tif (!aCrossRange) {\n\t\treturn null\n\t}\n\n\tassert(originalACrossRange)\n\tconst bRange = createRange(b.bounds[props.main], b.bounds[props.opposite])\n\tif (!b.isPoint) {\n\t\tbRange[props.bRangeExpand] -= options.minElbowLegLength * 2 * props.expand\n\t}\n\n\tconst bCrossRange = expandRange(\n\t\tcreateRange(b.bounds[props.crossMin], b.bounds[props.crossMax]),\n\t\toptions.expandElbowLegLength\n\t)\n\tassert(bRange && bCrossRange)\n\n\tlet isPartial = false\n\tif (\n\t\tisWithinRange(aValue, bRange) &&\n\t\t!a.isPoint &&\n\t\t!b.isPoint &&\n\t\t!isSelfBoundAndShouldRouteExternal\n\t) {\n\t\tconst subtracted = subtractRange(aCrossRange, bCrossRange)\n\t\tswitch (subtracted.length) {\n\t\t\tcase 0:\n\t\t\t\treturn null\n\t\t\tcase 1:\n\t\t\t\tisPartial = subtracted[0] !== aCrossRange\n\t\t\t\taCrossRange = subtracted[0]\n\t\t\t\tbreak\n\t\t\tcase 2:\n\t\t\t\tisPartial = true\n\t\t\t\taCrossRange =\n\t\t\t\t\trangeSize(subtracted[0]) > rangeSize(subtracted[1]) ? subtracted[0] : subtracted[1]\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\texhaustiveSwitchError(subtracted)\n\t\t}\n\t}\n\n\tif (!isWithinRange(a.target[props.crossAxis], aCrossRange)) {\n\t\treturn null\n\t}\n\tconst crossTarget = a.target[props.crossAxis]\n\n\treturn {\n\t\tvalue: aValue,\n\t\texpanded: aExpanded,\n\t\tcross: aCrossRange,\n\t\tcrossTarget,\n\t\tisPartial,\n\t}\n}\n\nfunction hasUsableEdge(edges: ElbowArrowBoxEdges, side: ElbowArrowSideWithAxis | null) {\n\tif (side === null) {\n\t\treturn !!(edges.bottom || edges.left || edges.right || edges.top)\n\t}\n\n\tif (side === 'x') {\n\t\treturn !!edges.left || !!edges.right\n\t}\n\n\tif (side === 'y') {\n\t\treturn !!edges.top || !!edges.bottom\n\t}\n\n\treturn !!edges[side]\n}\n\nfunction getSideToUse(\n\tbinding: ElbowArrowTerminal,\n\tother: ElbowArrowTerminal,\n\tedges: ElbowArrowBoxEdges | null\n): ElbowArrowSide | null {\n\tswitch (binding.side) {\n\t\tcase null:\n\t\t\treturn null\n\t\tcase 'x':\n\t\t\tif (binding.bounds.center.x > other.bounds.center.x && edges?.left) {\n\t\t\t\treturn 'left'\n\t\t\t} else if (edges?.right) {\n\t\t\t\treturn 'right'\n\t\t\t}\n\t\t\treturn null\n\t\tcase 'y':\n\t\t\tif (binding.bounds.center.y > other.bounds.center.y && edges?.top) {\n\t\t\t\treturn 'top'\n\t\t\t} else if (edges?.bottom) {\n\t\t\t\treturn 'bottom'\n\t\t\t}\n\t\t\treturn null\n\t\tdefault:\n\t\t\treturn binding.side\n\t}\n}\n\nfunction convertTerminalToPoint(terminal: ElbowArrowTerminal): ElbowArrowTerminal {\n\tif (terminal.isPoint) return terminal\n\n\tlet side: ElbowArrowSideWithAxis | null = null\n\tlet arrowheadOffset = 0\n\tif (terminal.snap === 'edge' || terminal.snap === 'edge-point') {\n\t\tarrowheadOffset = terminal.arrowheadOffset\n\t\tif (terminal.side === 'x' || terminal.side === 'left' || terminal.side === 'right') {\n\t\t\tside = 'x'\n\t\t}\n\t\tif (terminal.side === 'y' || terminal.side === 'top' || terminal.side === 'bottom') {\n\t\t\tside = 'y'\n\t\t}\n\t}\n\n\treturn {\n\t\ttargetShapeId: terminal.targetShapeId,\n\t\tside,\n\t\tbounds: new Box(terminal.target.x, terminal.target.y, 0, 0),\n\t\tgeometry: terminal.geometry,\n\t\ttarget: terminal.target,\n\t\tarrowheadOffset,\n\t\tminEndSegmentLength: terminal.minEndSegmentLength,\n\t\tisExact: terminal.isExact,\n\t\tisPoint: true,\n\t\tsnap: terminal.snap,\n\t}\n}\n\n/**\n * Make sure the first path segments goes fully into the target, and doesn't just point to its\n * bounding box. This modifies the route in-place.\n */\nfunction castPathSegmentIntoGeometry(\n\tsegment: 'first' | 'last',\n\ttarget: ElbowArrowTargetBox,\n\tother: ElbowArrowTargetBox,\n\troute: ElbowArrowRoute\n) {\n\tif (!target.geometry) return\n\n\tconst point1 = segment === 'first' ? route.points[0] : route.points[route.points.length - 1]\n\tconst point2 = segment === 'first' ? route.points[1] : route.points[route.points.length - 2]\n\n\tconst pointToFindClosestIntersectionTo = target.geometry.isClosed ? point2 : target.target\n\n\tconst initialDistance = Vec.ManhattanDist(point1, pointToFindClosestIntersectionTo)\n\n\tlet nearestIntersectionToPoint2: VecLike | null = null\n\tlet nearestDistanceToPoint2 = Infinity\n\n\tif (target.isExact) {\n\t\tnearestIntersectionToPoint2 = target.target\n\t} else if (target.geometry) {\n\t\tconst intersections = target.geometry.intersectLineSegment(point2, target.target, {\n\t\t\tincludeLabels: false,\n\t\t\tincludeInternal: false,\n\t\t})\n\t\tif (\n\t\t\ttarget.geometry.hitTestPoint(\n\t\t\t\ttarget.target,\n\t\t\t\tMath.max(1, target.arrowheadOffset),\n\t\t\t\ttrue,\n\t\t\t\tGeometry2dFilters.EXCLUDE_NON_STANDARD\n\t\t\t)\n\t\t) {\n\t\t\tintersections.push(target.target)\n\t\t}\n\t\tfor (const intersection of intersections) {\n\t\t\tconst point2Distance = Vec.ManhattanDist(pointToFindClosestIntersectionTo, intersection)\n\t\t\tif (point2Distance < nearestDistanceToPoint2) {\n\t\t\t\tnearestDistanceToPoint2 = point2Distance\n\t\t\t\tnearestIntersectionToPoint2 = intersection\n\t\t\t}\n\t\t}\n\t}\n\n\tif (nearestIntersectionToPoint2) {\n\t\tlet offset = target.arrowheadOffset\n\n\t\tconst currentFinalSegmentLength = Vec.ManhattanDist(point2, nearestIntersectionToPoint2)\n\t\tconst minLength = target.arrowheadOffset * 2\n\t\tif (currentFinalSegmentLength < minLength) {\n\t\t\tconst targetLength = minLength - target.arrowheadOffset\n\t\t\toffset = currentFinalSegmentLength - targetLength\n\t\t}\n\t\tif (offset < target.minEndSegmentLength) {\n\t\t\tif (target.geometry.bounds.containsPoint(other.target)) {\n\t\t\t\toffset = Math.max(0, offset)\n\t\t\t} else {\n\t\t\t\toffset = -target.arrowheadOffset\n\t\t\t}\n\t\t}\n\n\t\tlet nudgedPoint = nearestIntersectionToPoint2\n\t\tlet shouldAddExtraPointForNudge = false\n\t\tif (!target.isExact && offset !== 0) {\n\t\t\tconst nudged = Vec.Nudge(nearestIntersectionToPoint2, point2, offset)\n\t\t\tnudgedPoint = nudged\n\t\t\tif (\n\t\t\t\toffset < 0 &&\n\t\t\t\t!target.geometry.hitTestPoint(nudged, 0, true, Geometry2dFilters.EXCLUDE_NON_STANDARD)\n\t\t\t) {\n\t\t\t\t// point has been nudged _out_ of the shape so lets not actually apply the nudge\n\t\t\t\tnudgedPoint = nearestIntersectionToPoint2\n\t\t\t} else {\n\t\t\t\tif (offset < 0) {\n\t\t\t\t\tshouldAddExtraPointForNudge = true\n\t\t\t\t}\n\t\t\t\tnudgedPoint = nudged\n\t\t\t}\n\t\t}\n\n\t\tconst newDistance = Vec.ManhattanDist(point2, nudgedPoint)\n\t\troute.distance += newDistance - initialDistance\n\t\tpoint1.x = nudgedPoint.x\n\t\tpoint1.y = nudgedPoint.y\n\n\t\tif (shouldAddExtraPointForNudge) {\n\t\t\tconst midPoint = Vec.Lrp(point2, point1, 0.5)\n\t\t\troute.skipPointsWhenDrawing.add(midPoint)\n\t\t\troute.points.splice(segment === 'first' ? 1 : route.points.length - 1, 0, midPoint)\n\t\t}\n\t}\n}\n\nfunction fixTinyEndNubs(\n\troute: ElbowArrowRoute,\n\taTerminal: ElbowArrowTerminal,\n\tbTerminal: ElbowArrowTerminal\n) {\n\tif (!route) return\n\n\tif (route.points.length >= 3) {\n\t\tconst a = route.points[0]\n\t\tconst b = route.points[1]\n\t\tconst firstSegmentLength = Vec.ManhattanDist(a, b)\n\t\tif (firstSegmentLength < aTerminal.minEndSegmentLength) {\n\t\t\troute.points.splice(1, 1)\n\t\t\tif (route.points.length >= 3) {\n\t\t\t\tconst matchAxis = approximately(a.x, b.x) ? 'y' : 'x'\n\t\t\t\troute.points[1][matchAxis] = a[matchAxis]\n\t\t\t}\n\t\t}\n\t}\n\n\tif (route.points.length >= 3) {\n\t\tconst a = route.points[route.points.length - 1]\n\t\tconst b = route.points[route.points.length - 2]\n\t\tconst lastSegmentLength = Vec.ManhattanDist(a, b)\n\t\tif (lastSegmentLength < bTerminal.minEndSegmentLength) {\n\t\t\troute.points.splice(route.points.length - 2, 1)\n\t\t\tif (route.points.length >= 3) {\n\t\t\t\tconst matchAxis = approximately(a.x, b.x) ? 'y' : 'x'\n\t\t\t\troute.points[route.points.length - 2][matchAxis] = a[matchAxis]\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction adjustTerminalForUnclosedPathIfNeeded(\n\tterminal: ElbowArrowTerminal,\n\totherTerminal: ElbowArrowTerminal,\n\toptions: ElbowArrowOptions\n): ElbowArrowTerminal {\n\tif (!terminal.geometry || terminal.geometry.isClosed) return terminal\n\tconst normalizedPointAlongPath = terminal.geometry.uninterpolateAlongEdge(\n\t\tterminal.target,\n\t\tGeometry2dFilters.EXCLUDE_NON_STANDARD\n\t)\n\n\tconst prev = terminal.geometry.interpolateAlongEdge(\n\t\tnormalizedPointAlongPath - 0.01 / terminal.geometry.length\n\t)\n\tconst next = terminal.geometry.interpolateAlongEdge(\n\t\tnormalizedPointAlongPath + 0.01 / terminal.geometry.length\n\t)\n\n\tconst normal = next.sub(prev).per().uni()\n\tconst axis = Math.abs(normal.x) > Math.abs(normal.y) ? ElbowArrowAxes.x : ElbowArrowAxes.y\n\n\tif (terminal.geometry.bounds.containsPoint(otherTerminal.target, options.expandElbowLegLength)) {\n\t\tterminal.side = axis.self\n\t\treturn convertTerminalToPoint(terminal)\n\t}\n\n\tconst min = axis.v(\n\t\tterminal.target[axis.self] - terminal.bounds[axis.size] * 2,\n\t\tterminal.target[axis.cross]\n\t)\n\tconst max = axis.v(\n\t\tterminal.target[axis.self] + terminal.bounds[axis.size] * 2,\n\t\tterminal.target[axis.cross]\n\t)\n\n\tlet furthestIntersectionTowardsMin: VecLike | null = null\n\tlet furthestIntersectionTowardsMinDistance = 0\n\tlet furthestIntersectionTowardsMax: VecLike | null = null\n\tlet furthestIntersectionTowardsMaxDistance = 0\n\tlet side: ElbowArrowSideWithAxis = axis.self\n\n\tfor (const intersection of terminal.geometry.intersectLineSegment(\n\t\tmin,\n\t\tmax,\n\t\tGeometry2dFilters.EXCLUDE_NON_STANDARD\n\t)) {\n\t\tif (Math.abs(intersection[axis.self] - terminal.target[axis.self]) < 1) {\n\t\t\tcontinue\n\t\t}\n\t\tif (intersection[axis.self] < terminal.target[axis.self]) {\n\t\t\tif (\n\t\t\t\tVec.ManhattanDist(intersection, terminal.target) > furthestIntersectionTowardsMinDistance\n\t\t\t) {\n\t\t\t\tfurthestIntersectionTowardsMinDistance = Vec.ManhattanDist(intersection, terminal.target)\n\t\t\t\tfurthestIntersectionTowardsMin = intersection\n\t\t\t}\n\t\t} else {\n\t\t\tif (\n\t\t\t\tVec.ManhattanDist(intersection, terminal.target) > furthestIntersectionTowardsMaxDistance\n\t\t\t) {\n\t\t\t\tfurthestIntersectionTowardsMaxDistance = Vec.ManhattanDist(intersection, terminal.target)\n\t\t\t\tfurthestIntersectionTowardsMax = intersection\n\t\t\t}\n\t\t}\n\t}\n\n\tif (furthestIntersectionTowardsMin && furthestIntersectionTowardsMax) {\n\t\tif (furthestIntersectionTowardsMinDistance > furthestIntersectionTowardsMaxDistance) {\n\t\t\tside = axis.hiEdge\n\t\t} else {\n\t\t\tside = axis.loEdge\n\t\t}\n\t} else if (furthestIntersectionTowardsMin && !furthestIntersectionTowardsMax) {\n\t\tside = axis.hiEdge\n\t} else if (!furthestIntersectionTowardsMin && furthestIntersectionTowardsMax) {\n\t\tside = axis.loEdge\n\t}\n\n\tterminal.side = side\n\treturn terminal\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2758, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/arrow/shared.ts"],"sourcesContent":["import {\n\tEditor,\n\tGeometry2d,\n\tisEqualAllowingForFloatingPointErrors,\n\tMat,\n\tTLArrowBinding,\n\tTLArrowBindingProps,\n\tTLArrowShape,\n\tTLShape,\n\tTLShapeId,\n\tVec,\n} from '@tldraw/editor'\nimport { createComputedCache } from '@tldraw/store'\nimport { TLArrowInfo } from './arrow-types'\nimport { getCurvedArrowInfo } from './curved-arrow'\nimport { getElbowArrowInfo } from './elbow/getElbowArrowInfo'\nimport { getStraightArrowInfo } from './straight-arrow'\n\nconst MIN_ARROW_BEND = 8\n\nexport function getIsArrowStraight(shape: TLArrowShape) {\n\tif (shape.props.kind !== 'arc') return false\n\treturn Math.abs(shape.props.bend) < MIN_ARROW_BEND * shape.props.scale // snap to +-8px\n}\n\nexport interface BoundShapeInfo<T extends TLShape = TLShape> {\n\tshape: T\n\tdidIntersect: boolean\n\tisExact: boolean\n\tisClosed: boolean\n\ttransform: Mat\n\tgeometry: Geometry2d\n}\n\nexport function getBoundShapeInfoForTerminal(\n\teditor: Editor,\n\tarrow: TLArrowShape,\n\tterminalName: 'start' | 'end'\n): BoundShapeInfo | undefined {\n\tconst binding = editor\n\t\t.getBindingsFromShape<TLArrowBinding>(arrow, 'arrow')\n\t\t.find((b) => b.props.terminal === terminalName)\n\tif (!binding) return\n\n\tconst boundShape = editor.getShape(binding.toId)!\n\tif (!boundShape) return\n\tconst transform = editor.getShapePageTransform(boundShape)!\n\tconst hasArrowhead =\n\t\tterminalName === 'start'\n\t\t\t? arrow.props.arrowheadStart !== 'none'\n\t\t\t: arrow.props.arrowheadEnd !== 'none'\n\tconst geometry = editor.getShapeGeometry(\n\t\tboundShape,\n\t\thasArrowhead ? undefined : { context: '@tldraw/arrow-without-arrowhead' }\n\t)\n\n\treturn {\n\t\tshape: boundShape,\n\t\ttransform,\n\t\tisClosed: geometry.isClosed,\n\t\tisExact: binding.props.isExact,\n\t\tdidIntersect: false,\n\t\tgeometry,\n\t}\n}\n\nexport function getArrowTerminalInArrowSpace(\n\teditor: Editor,\n\tarrowPageTransform: Mat,\n\tbinding: TLArrowBinding,\n\tforceImprecise: boolean\n) {\n\tconst boundShape = editor.getShape(binding.toId)\n\n\tif (!boundShape) {\n\t\t// this can happen in multiplayer contexts where the shape is being deleted\n\t\treturn new Vec(0, 0)\n\t} else {\n\t\t// Find the actual local point of the normalized terminal on\n\t\t// the bound shape and transform it to page space, then transform\n\t\t// it to arrow space\n\t\tconst { point, size } = editor.getShapeGeometry(boundShape).bounds\n\t\tconst shapePoint = Vec.Add(\n\t\t\tpoint,\n\t\t\tVec.MulV(\n\t\t\t\t// if the parent is the bound shape, then it's ALWAYS precise\n\t\t\t\tbinding.props.isPrecise || forceImprecise\n\t\t\t\t\t? binding.props.normalizedAnchor\n\t\t\t\t\t: { x: 0.5, y: 0.5 },\n\t\t\t\tsize\n\t\t\t)\n\t\t)\n\t\tconst pagePoint = Mat.applyToPoint(editor.getShapePageTransform(boundShape)!, shapePoint)\n\t\tconst arrowPoint = Mat.applyToPoint(Mat.Inverse(arrowPageTransform), pagePoint)\n\t\treturn arrowPoint\n\t}\n}\n\n/** @public */\nexport interface TLArrowBindings {\n\tstart: TLArrowBinding | undefined\n\tend: TLArrowBinding | undefined\n}\n\nconst arrowBindingsCache = createComputedCache(\n\t'arrow bindings',\n\t(editor: Editor, arrow: TLArrowShape) => {\n\t\tconst bindings = editor.getBindingsFromShape<TLArrowBinding>(arrow.id, 'arrow')\n\t\treturn {\n\t\t\tstart: bindings.find((b) => b.props.terminal === 'start'),\n\t\t\tend: bindings.find((b) => b.props.terminal === 'end'),\n\t\t}\n\t},\n\t{\n\t\t// we only look at the arrow IDs:\n\t\tareRecordsEqual: (a, b) => a.id === b.id,\n\t\t// the records should stay the same:\n\t\tareResultsEqual: (a, b) => a.start === b.start && a.end === b.end,\n\t}\n)\n\n/** @public */\nexport function getArrowBindings(editor: Editor, shape: TLArrowShape): TLArrowBindings {\n\treturn arrowBindingsCache.get(editor, shape.id)!\n}\n\nconst arrowInfoCache = createComputedCache<Editor, TLArrowInfo, TLArrowShape>(\n\t'arrow info',\n\t(editor: Editor, shape: TLArrowShape): TLArrowInfo => {\n\t\tconst bindings = getArrowBindings(editor, shape)\n\t\tif (shape.props.kind === 'elbow') {\n\t\t\tconst elbowInfo = getElbowArrowInfo(editor, shape, bindings)\n\t\t\tif (!elbowInfo?.route) return getStraightArrowInfo(editor, shape, bindings)\n\n\t\t\tconst start = elbowInfo.swapOrder ? elbowInfo.B : elbowInfo.A\n\t\t\tconst end = elbowInfo.swapOrder ? elbowInfo.A : elbowInfo.B\n\n\t\t\treturn {\n\t\t\t\ttype: 'elbow',\n\t\t\t\tbindings,\n\t\t\t\tstart: {\n\t\t\t\t\thandle: start.target,\n\t\t\t\t\tpoint: elbowInfo.route.points[0],\n\t\t\t\t\tarrowhead: shape.props.arrowheadStart,\n\t\t\t\t},\n\t\t\t\tend: {\n\t\t\t\t\thandle: end.target,\n\t\t\t\t\tpoint: elbowInfo.route.points[elbowInfo.route.points.length - 1],\n\t\t\t\t\tarrowhead: shape.props.arrowheadEnd,\n\t\t\t\t},\n\t\t\t\telbow: elbowInfo,\n\t\t\t\troute: elbowInfo.route,\n\t\t\t\tisValid: true,\n\t\t\t}\n\t\t}\n\n\t\tif (getIsArrowStraight(shape)) {\n\t\t\treturn getStraightArrowInfo(editor, shape, bindings)\n\t\t} else {\n\t\t\treturn getCurvedArrowInfo(editor, shape, bindings)\n\t\t}\n\t},\n\t{\n\t\tareRecordsEqual: (a, b) => a.props === b.props,\n\t\tareResultsEqual: isEqualAllowingForFloatingPointErrors,\n\t}\n)\n\n/** @public */\nexport function getArrowInfo(editor: Editor, shape: TLArrowShape | TLShapeId) {\n\tconst id = typeof shape === 'string' ? shape : shape.id\n\treturn arrowInfoCache.get(editor, id)\n}\n\n/** @public */\nexport function getArrowTerminalsInArrowSpace(\n\teditor: Editor,\n\tshape: TLArrowShape,\n\tbindings: TLArrowBindings\n) {\n\tconst arrowPageTransform = editor.getShapePageTransform(shape)!\n\n\tconst boundShapeRelationships = getBoundShapeRelationships(\n\t\teditor,\n\t\tbindings.start?.toId,\n\t\tbindings.end?.toId\n\t)\n\n\tconst start = bindings.start\n\t\t? getArrowTerminalInArrowSpace(\n\t\t\t\teditor,\n\t\t\t\tarrowPageTransform,\n\t\t\t\tbindings.start,\n\t\t\t\tboundShapeRelationships === 'double-bound' ||\n\t\t\t\t\tboundShapeRelationships === 'start-contains-end'\n\t\t\t)\n\t\t: Vec.From(shape.props.start)\n\n\tconst end = bindings.end\n\t\t? getArrowTerminalInArrowSpace(\n\t\t\t\teditor,\n\t\t\t\tarrowPageTransform,\n\t\t\t\tbindings.end,\n\t\t\t\tboundShapeRelationships === 'double-bound' ||\n\t\t\t\t\tboundShapeRelationships === 'end-contains-start'\n\t\t\t)\n\t\t: Vec.From(shape.props.end)\n\n\treturn { start, end }\n}\n\n/**\n * Create or update the arrow binding for a particular arrow terminal. Will clear up if needed.\n * @internal\n */\nexport function createOrUpdateArrowBinding(\n\teditor: Editor,\n\tarrow: TLArrowShape | TLShapeId,\n\ttarget: TLShape | TLShapeId,\n\tprops: TLArrowBindingProps\n) {\n\tconst arrowId = typeof arrow === 'string' ? arrow : arrow.id\n\tconst targetId = typeof target === 'string' ? target : target.id\n\n\tconst existingMany = editor\n\t\t.getBindingsFromShape<TLArrowBinding>(arrowId, 'arrow')\n\t\t.filter((b) => b.props.terminal === props.terminal)\n\n\t// if we've somehow ended up with too many bindings, delete the extras\n\tif (existingMany.length > 1) {\n\t\teditor.deleteBindings(existingMany.slice(1))\n\t}\n\n\tconst existing = existingMany[0]\n\tif (existing) {\n\t\teditor.updateBinding({\n\t\t\t...existing,\n\t\t\ttoId: targetId,\n\t\t\tprops,\n\t\t})\n\t} else {\n\t\teditor.createBinding({\n\t\t\ttype: 'arrow',\n\t\t\tfromId: arrowId,\n\t\t\ttoId: targetId,\n\t\t\tprops,\n\t\t})\n\t}\n}\n\n/**\n * Remove any arrow bindings for a particular terminal.\n * @internal\n */\nexport function removeArrowBinding(editor: Editor, arrow: TLArrowShape, terminal: 'start' | 'end') {\n\tconst existing = editor\n\t\t.getBindingsFromShape<TLArrowBinding>(arrow, 'arrow')\n\t\t.filter((b) => b.props.terminal === terminal)\n\n\teditor.deleteBindings(existing)\n}\n\n/** @internal */\nexport const MIN_ARROW_LENGTH = 10\n/** @internal */\nexport const BOUND_ARROW_OFFSET = 10\n/** @internal */\nexport const WAY_TOO_BIG_ARROW_BEND_FACTOR = 10\n\n/** @public */\nexport const STROKE_SIZES: Record<string, number> = {\n\ts: 2,\n\tm: 3.5,\n\tl: 5,\n\txl: 10,\n}\n\n/**\n * Get the relationships for an arrow that has two bound shape terminals.\n * If the arrow has only one bound shape, then it is always \"safe\" to apply\n * standard offsets and precision behavior. If the shape is bound to the same\n * shape on both ends, then that is an exception. If one of the shape's\n * terminals is bound to a shape that contains / is contained by the shape that\n * is bound to the other terminal, then that is also an exception.\n *\n * @param editor - the editor instance\n * @param startShapeId - the bound shape from the arrow's start\n * @param endShapeId - the bound shape from the arrow's end\n *\n *  @internal */\nexport function getBoundShapeRelationships(\n\teditor: Editor,\n\tstartShapeId?: TLShapeId,\n\tendShapeId?: TLShapeId\n) {\n\tif (!startShapeId || !endShapeId) return 'safe'\n\tif (startShapeId === endShapeId) return 'double-bound'\n\tconst startBounds = editor.getShapePageBounds(startShapeId)\n\tconst endBounds = editor.getShapePageBounds(endShapeId)\n\tif (startBounds && endBounds) {\n\t\tif (startBounds.contains(endBounds)) return 'start-contains-end'\n\t\tif (endBounds.contains(startBounds)) return 'end-contains-start'\n\t}\n\treturn 'safe'\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2945, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/arrow/arrowTargetState.ts"],"sourcesContent":["import {\n\tArrowShapeKindStyle,\n\tatom,\n\tAtom,\n\tBox,\n\tclamp,\n\tEditor,\n\tElbowArrowSnap,\n\tGeometry2dFilters,\n\tinvLerp,\n\tmapObjectMapValues,\n\tobjectMapEntries,\n\tobjectMapKeys,\n\tTLArrowBinding,\n\tTLArrowShape,\n\tTLArrowShapeKind,\n\tTLShape,\n\tVec,\n\tVecLike,\n\tWeakCache,\n} from '@tldraw/editor'\nimport { ArrowShapeUtil } from './ArrowShapeUtil'\nimport {\n\tElbowArrowAxes,\n\tElbowArrowSide,\n\tElbowArrowSideAxes,\n\tElbowArrowSideDeltas,\n} from './elbow/definitions'\n\nexport interface UpdateArrowTargetStateOpts {\n\teditor: Editor\n\tpointInPageSpace: VecLike\n\tarrow: TLArrowShape | undefined\n\tisPrecise: boolean\n\tcurrentBinding: TLArrowBinding | undefined\n\t/** The binding from the opposite end of the arrow, if one exists. */\n\toppositeBinding: TLArrowBinding | undefined\n}\n\nexport interface ArrowTargetState {\n\ttarget: TLShape\n\tarrowKind: TLArrowShapeKind\n\n\thandlesInPageSpace: {\n\t\ttop: { point: VecLike; isEnabled: boolean }\n\t\tbottom: { point: VecLike; isEnabled: boolean }\n\t\tleft: { point: VecLike; isEnabled: boolean }\n\t\tright: { point: VecLike; isEnabled: boolean }\n\t}\n\n\tisExact: boolean\n\tisPrecise: boolean\n\n\tcenterInPageSpace: VecLike\n\tanchorInPageSpace: VecLike\n\tsnap: ElbowArrowSnap\n\tnormalizedAnchor: VecLike\n}\n\nconst arrowTargetStore = new WeakCache<Editor, Atom<ArrowTargetState | null>>()\n\nfunction getArrowTargetAtom(editor: Editor) {\n\treturn arrowTargetStore.get(editor, () => atom('arrowTarget', null))\n}\n\nexport function getArrowTargetState(editor: Editor) {\n\treturn getArrowTargetAtom(editor).get()\n}\n\nexport function clearArrowTargetState(editor: Editor) {\n\tgetArrowTargetAtom(editor).set(null)\n}\n\nexport function updateArrowTargetState({\n\teditor,\n\tpointInPageSpace,\n\tarrow,\n\tisPrecise,\n\tcurrentBinding,\n\toppositeBinding,\n}: UpdateArrowTargetStateOpts): ArrowTargetState | null {\n\tconst util = editor.getShapeUtil<ArrowShapeUtil>('arrow')\n\n\t// no target picking when ctrl is held:\n\tif (util.options.shouldIgnoreTargets(editor)) {\n\t\tgetArrowTargetAtom(editor).set(null)\n\t\treturn null\n\t}\n\n\tconst isExact = util.options.shouldBeExact(editor)\n\n\tconst arrowKind = arrow ? arrow.props.kind : editor.getStyleForNextShape(ArrowShapeKindStyle)\n\n\tconst target = editor.getShapeAtPoint(pointInPageSpace, {\n\t\thitInside: true,\n\t\thitFrameInside: true,\n\t\tmargin: arrowKind === 'elbow' ? 8 : 0,\n\t\tfilter: (targetShape) => {\n\t\t\treturn (\n\t\t\t\t!targetShape.isLocked &&\n\t\t\t\teditor.canBindShapes({\n\t\t\t\t\tfromShape: arrow ?? targetFilterFallback,\n\t\t\t\t\ttoShape: targetShape,\n\t\t\t\t\tbinding: 'arrow',\n\t\t\t\t})\n\t\t\t)\n\t\t},\n\t})\n\n\tif (!target) {\n\t\tgetArrowTargetAtom(editor).set(null)\n\t\treturn null\n\t}\n\n\tconst targetGeometryInTargetSpace = editor.getShapeGeometry(target)\n\tconst targetBoundsInTargetSpace = Box.ZeroFix(targetGeometryInTargetSpace.bounds)\n\tconst targetCenterInTargetSpace = targetGeometryInTargetSpace.center\n\tconst targetTransform = editor.getShapePageTransform(target)\n\tconst pointInTargetSpace = editor.getPointInShapeSpace(target, pointInPageSpace)\n\n\tconst castDistance = Math.max(\n\t\ttargetGeometryInTargetSpace.bounds.width,\n\t\ttargetGeometryInTargetSpace.bounds.height\n\t)\n\n\tconst handlesInPageSpace = mapObjectMapValues(ElbowArrowSideDeltas, (side, delta) => {\n\t\tconst axis = ElbowArrowAxes[ElbowArrowSideAxes[side]]\n\n\t\tconst farPoint = Vec.Mul(delta, castDistance).add(targetCenterInTargetSpace)\n\n\t\tlet isEnabled = false\n\t\tlet handlePointInTargetSpace: VecLike = axis.v(\n\t\t\ttargetBoundsInTargetSpace[side],\n\t\t\ttargetBoundsInTargetSpace[axis.crossMid]\n\t\t)\n\t\tlet furthestDistance = 0\n\n\t\tconst intersections = targetGeometryInTargetSpace.intersectLineSegment(\n\t\t\ttargetCenterInTargetSpace,\n\t\t\tfarPoint,\n\t\t\tGeometry2dFilters.EXCLUDE_NON_STANDARD\n\t\t)\n\t\tfor (const intersection of intersections) {\n\t\t\tconst distance = Vec.Dist2(intersection, targetCenterInTargetSpace)\n\t\t\tif (distance > furthestDistance) {\n\t\t\t\tfurthestDistance = distance\n\t\t\t\thandlePointInTargetSpace = intersection\n\t\t\t\tisEnabled = targetGeometryInTargetSpace.isClosed\n\t\t\t}\n\t\t}\n\n\t\tconst handlePointInPageSpace = targetTransform.applyToPoint(handlePointInTargetSpace)\n\n\t\treturn { point: handlePointInPageSpace, isEnabled, far: targetTransform.applyToPoint(farPoint) }\n\t})\n\n\tconst zoomLevel = editor.getZoomLevel()\n\tconst minDistScaled = util.options.minElbowHandleDistance / zoomLevel\n\n\tconst targetCenterInPageSpace = targetTransform.applyToPoint(targetCenterInTargetSpace)\n\tfor (const side of objectMapKeys(handlesInPageSpace)) {\n\t\tconst handle = handlesInPageSpace[side]\n\t\tif (Vec.DistMin(handle.point, targetCenterInPageSpace, minDistScaled)) {\n\t\t\thandle.isEnabled = false\n\t\t}\n\t}\n\n\tlet precise = isPrecise || isExact\n\n\tif (!precise) {\n\t\t// If we're switching to a new bound shape, then precise only if moving slowly\n\t\tif (!currentBinding || (currentBinding && target.id !== currentBinding.toId)) {\n\t\t\tprecise = editor.inputs.pointerVelocity.len() < 0.5\n\t\t}\n\t}\n\n\tif (!isPrecise) {\n\t\tif (!targetGeometryInTargetSpace.isClosed) {\n\t\t\tprecise = true\n\t\t}\n\n\t\t// Double check that we're not going to be doing an imprecise snap on\n\t\t// the same shape twice, as this would result in a zero length line\n\t\tif (oppositeBinding && target.id === oppositeBinding.toId && oppositeBinding.props.isPrecise) {\n\t\t\tprecise = true\n\t\t}\n\t}\n\n\tconst shouldSnapCenter = !isExact && precise && targetGeometryInTargetSpace.isClosed\n\tconst shouldSnapEdges =\n\t\t!isExact && ((precise && arrowKind === 'elbow') || !targetGeometryInTargetSpace.isClosed)\n\tconst shouldSnapEdgePoints =\n\t\t!isExact && precise && arrowKind === 'elbow' && targetGeometryInTargetSpace.isClosed\n\tconst shouldSnapNone = precise && (targetGeometryInTargetSpace.isClosed || isExact)\n\tconst shouldSnapCenterAxis =\n\t\t!isExact && precise && arrowKind === 'elbow' && targetGeometryInTargetSpace.isClosed\n\n\t// we run through all the snapping options from least to most specific:\n\tlet snap: ElbowArrowSnap = 'none'\n\tlet anchorInPageSpace: VecLike = pointInPageSpace\n\n\tif (!shouldSnapNone) {\n\t\tsnap = 'center'\n\t\tanchorInPageSpace = targetCenterInPageSpace\n\t}\n\n\tif (shouldSnapEdges) {\n\t\tconst snapDistance = shouldSnapNone\n\t\t\t? calculateSnapDistance(\n\t\t\t\t\teditor,\n\t\t\t\t\ttargetBoundsInTargetSpace,\n\t\t\t\t\tutil.options.elbowArrowEdgeSnapDistance\n\t\t\t\t)\n\t\t\t: Infinity\n\n\t\tconst nearestPointOnEdgeInTargetSpace = targetGeometryInTargetSpace.nearestPoint(\n\t\t\tpointInTargetSpace,\n\t\t\t{\n\t\t\t\tincludeLabels: false,\n\t\t\t\tincludeInternal: false,\n\t\t\t}\n\t\t)\n\n\t\tconst nearestPointOnEdgeInPageSpace = targetTransform.applyToPoint(\n\t\t\tnearestPointOnEdgeInTargetSpace\n\t\t)\n\n\t\tconst distance = Vec.Dist(nearestPointOnEdgeInPageSpace, pointInPageSpace)\n\n\t\tif (distance < snapDistance) {\n\t\t\tsnap = 'edge'\n\t\t\tanchorInPageSpace = nearestPointOnEdgeInPageSpace\n\t\t}\n\t}\n\n\tif (shouldSnapCenterAxis) {\n\t\tconst snapDistance = calculateSnapDistance(\n\t\t\teditor,\n\t\t\ttargetBoundsInTargetSpace,\n\t\t\tutil.options.elbowArrowAxisSnapDistance\n\t\t)\n\n\t\tconst distanceFromXAxis = Vec.DistanceToLineSegment(\n\t\t\thandlesInPageSpace.left.far,\n\t\t\thandlesInPageSpace.right.far,\n\t\t\tpointInPageSpace\n\t\t)\n\t\tconst distanceFromYAxis = Vec.DistanceToLineSegment(\n\t\t\thandlesInPageSpace.top.far,\n\t\t\thandlesInPageSpace.bottom.far,\n\t\t\tpointInPageSpace\n\t\t)\n\n\t\tconst snapAxis =\n\t\t\tdistanceFromXAxis < distanceFromYAxis && distanceFromXAxis < snapDistance\n\t\t\t\t? 'x'\n\t\t\t\t: distanceFromYAxis < snapDistance\n\t\t\t\t\t? 'y'\n\t\t\t\t\t: null\n\n\t\tif (snapAxis) {\n\t\t\tconst axis = ElbowArrowAxes[snapAxis]\n\n\t\t\tconst loDist2 = Vec.Dist2(handlesInPageSpace[axis.loEdge].far, pointInPageSpace)\n\t\t\tconst hiDist2 = Vec.Dist2(handlesInPageSpace[axis.hiEdge].far, pointInPageSpace)\n\n\t\t\tconst side = loDist2 < hiDist2 ? axis.loEdge : axis.hiEdge\n\n\t\t\tif (handlesInPageSpace[side].isEnabled) {\n\t\t\t\tsnap = 'edge-point'\n\t\t\t\tanchorInPageSpace = handlesInPageSpace[side].point\n\t\t\t}\n\t\t}\n\t}\n\n\tif (shouldSnapEdgePoints) {\n\t\tconst snapDistance = calculateSnapDistance(\n\t\t\teditor,\n\t\t\ttargetBoundsInTargetSpace,\n\t\t\tutil.options.elbowArrowPointSnapDistance\n\t\t)\n\n\t\tlet closestSide: ElbowArrowSide | null = null\n\t\tlet closestDistance = Infinity\n\n\t\tfor (const [side, handle] of objectMapEntries(handlesInPageSpace)) {\n\t\t\tif (!handle.isEnabled) continue\n\t\t\tconst distance = Vec.Dist(handle.point, pointInPageSpace)\n\t\t\tif (distance < snapDistance && distance < closestDistance) {\n\t\t\t\tclosestDistance = distance\n\t\t\t\tclosestSide = side\n\t\t\t}\n\t\t}\n\n\t\tif (closestSide) {\n\t\t\tsnap = 'edge-point'\n\t\t\tanchorInPageSpace = handlesInPageSpace[closestSide].point\n\t\t}\n\t}\n\n\tif (shouldSnapCenter) {\n\t\tconst snapDistance = calculateSnapDistance(\n\t\t\teditor,\n\t\t\ttargetBoundsInTargetSpace,\n\t\t\tarrowKind === 'elbow'\n\t\t\t\t? util.options.elbowArrowCenterSnapDistance\n\t\t\t\t: util.options.arcArrowCenterSnapDistance\n\t\t)\n\n\t\tif (Vec.Dist(pointInTargetSpace, targetBoundsInTargetSpace.center) < snapDistance) {\n\t\t\tsnap = 'center'\n\t\t\tanchorInPageSpace = targetCenterInPageSpace\n\t\t}\n\t}\n\n\tconst snapPointInTargetSpace = editor.getPointInShapeSpace(target, anchorInPageSpace)\n\n\tconst normalizedAnchor = {\n\t\tx: invLerp(\n\t\t\ttargetBoundsInTargetSpace.minX,\n\t\t\ttargetBoundsInTargetSpace.maxX,\n\t\t\tsnapPointInTargetSpace.x\n\t\t),\n\t\ty: invLerp(\n\t\t\ttargetBoundsInTargetSpace.minY,\n\t\t\ttargetBoundsInTargetSpace.maxY,\n\t\t\tsnapPointInTargetSpace.y\n\t\t),\n\t}\n\n\tconst result: ArrowTargetState = {\n\t\ttarget,\n\t\tarrowKind,\n\t\thandlesInPageSpace,\n\t\tcenterInPageSpace: targetCenterInPageSpace,\n\t\tanchorInPageSpace,\n\t\tisExact,\n\t\tisPrecise: precise,\n\t\tsnap,\n\t\tnormalizedAnchor,\n\t}\n\n\tgetArrowTargetAtom(editor).set(result)\n\n\treturn result\n}\n\nconst targetFilterFallback = { type: 'arrow' }\n\n/**\n * Funky math but we want the snap distance to be 4 at the minimum and either 16 or 15% of the\n * smaller dimension of the target shape, whichever is smaller\n */\nfunction calculateSnapDistance(\n\teditor: Editor,\n\ttargetBoundsInTargetSpace: Box,\n\tidealSnapDistance: number\n) {\n\treturn (\n\t\tclamp(\n\t\t\tMath.min(targetBoundsInTargetSpace.width, targetBoundsInTargetSpace.height) * 0.15,\n\t\t\t4,\n\t\t\tidealSnapDistance\n\t\t) / editor.getZoomLevel()\n\t)\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3145, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/shared/freehand/getStrokeOutlinePoints.ts"],"sourcesContent":["import { Vec } from '@tldraw/editor'\nimport type { StrokeOptions, StrokePoint } from './types'\n\nconst { PI } = Math\n\n// Browser strokes seem to be off if PI is regular, a tiny offset seems to fix it\nconst FIXED_PI = PI + 0.0001\n\n/**\n * @internal\n */\nexport function getStrokeOutlineTracks(\n\tstrokePoints: StrokePoint[],\n\toptions: StrokeOptions = {}\n): { left: Vec[]; right: Vec[] } {\n\tconst { size = 16, smoothing = 0.5 } = options\n\n\t// We can't do anything with an empty array or a stroke with negative size.\n\tif (strokePoints.length === 0 || size <= 0) {\n\t\treturn { left: [], right: [] }\n\t}\n\n\tconst firstStrokePoint = strokePoints[0]\n\tconst lastStrokePoint = strokePoints[strokePoints.length - 1]\n\n\t// The total length of the line\n\tconst totalLength = lastStrokePoint.runningLength\n\n\t// The minimum allowed distance between points (squared)\n\tconst minDistance = Math.pow(size * smoothing, 2)\n\n\t// Our collected left and right points\n\tconst leftPts: Vec[] = []\n\tconst rightPts: Vec[] = []\n\n\t// Previous vector\n\tlet prevVector = strokePoints[0].vector\n\n\t// Previous left and right points\n\tlet pl = strokePoints[0].point\n\tlet pr = pl\n\n\t// Temporary left and right points\n\tlet tl = pl\n\tlet tr = pr\n\n\t// Keep track of whether the previous point is a sharp corner\n\t// ... so that we don't detect the same corner twice\n\tlet isPrevPointSharpCorner = false\n\n\t/*\n    Find the outline's left and right points\n\n    Iterating through the points and populate the rightPts and leftPts arrays,\n    skipping the first and last pointsm, which will get caps later on.\n  */\n\n\tlet strokePoint: StrokePoint\n\n\tfor (let i = 0; i < strokePoints.length; i++) {\n\t\tstrokePoint = strokePoints[i]\n\t\tconst { point, vector } = strokePoints[i]\n\n\t\t/*\n      Handle sharp corners\n\n      Find the difference (dot product) between the current and next vector.\n      If the next vector is at more than a right angle to the current vector,\n      draw a cap at the current point.\n    */\n\n\t\tconst prevDpr = strokePoint.vector.dpr(prevVector)\n\t\tconst nextVector = (i < strokePoints.length - 1 ? strokePoints[i + 1] : strokePoints[i]).vector\n\t\tconst nextDpr = i < strokePoints.length - 1 ? nextVector.dpr(strokePoint.vector) : 1\n\n\t\tconst isPointSharpCorner = prevDpr < 0 && !isPrevPointSharpCorner\n\t\tconst isNextPointSharpCorner = nextDpr !== null && nextDpr < 0.2\n\n\t\tif (isPointSharpCorner || isNextPointSharpCorner) {\n\t\t\t// It's a sharp corner. Draw a rounded cap and move on to the next point\n\t\t\t// Considering saving these and drawing them later? So that we can avoid\n\t\t\t// crossing future points.\n\n\t\t\tif (nextDpr > -0.62 && totalLength - strokePoint.runningLength > strokePoint.radius) {\n\t\t\t\t// Draw a \"soft\" corner\n\t\t\t\tconst offset = prevVector.clone().mul(strokePoint.radius)\n\t\t\t\tconst cpr = prevVector.clone().cpr(nextVector)\n\n\t\t\t\tif (cpr < 0) {\n\t\t\t\t\ttl = Vec.Add(point, offset)\n\t\t\t\t\ttr = Vec.Sub(point, offset)\n\t\t\t\t} else {\n\t\t\t\t\ttl = Vec.Sub(point, offset)\n\t\t\t\t\ttr = Vec.Add(point, offset)\n\t\t\t\t}\n\n\t\t\t\tleftPts.push(tl)\n\t\t\t\trightPts.push(tr)\n\t\t\t} else {\n\t\t\t\t// Draw a \"sharp\" corner\n\t\t\t\tconst offset = prevVector.clone().mul(strokePoint.radius).per()\n\t\t\t\tconst start = Vec.Sub(strokePoint.input, offset)\n\n\t\t\t\tfor (let step = 1 / 13, t = 0; t < 1; t += step) {\n\t\t\t\t\ttl = Vec.RotWith(start, strokePoint.input, FIXED_PI * t)\n\t\t\t\t\tleftPts.push(tl)\n\n\t\t\t\t\ttr = Vec.RotWith(start, strokePoint.input, FIXED_PI + FIXED_PI * -t)\n\t\t\t\t\trightPts.push(tr)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpl = tl\n\t\t\tpr = tr\n\n\t\t\tif (isNextPointSharpCorner) {\n\t\t\t\tisPrevPointSharpCorner = true\n\t\t\t}\n\n\t\t\tcontinue\n\t\t}\n\n\t\tisPrevPointSharpCorner = false\n\n\t\tif (strokePoint === firstStrokePoint || strokePoint === lastStrokePoint) {\n\t\t\tconst offset = Vec.Per(vector).mul(strokePoint.radius)\n\t\t\tleftPts.push(Vec.Sub(point, offset))\n\t\t\trightPts.push(Vec.Add(point, offset))\n\n\t\t\tcontinue\n\t\t}\n\n\t\t/* \n      Add regular points\n\n      Project points to either side of the current point, using the\n      calculated size as a distance. If a point's distance to the \n      previous point on that side greater than the minimum distance\n      (or if the corner is kinda sharp), add the points to the side's\n      points array.\n    */\n\n\t\tconst offset = Vec.Lrp(nextVector, vector, nextDpr).per().mul(strokePoint.radius)\n\n\t\ttl = Vec.Sub(point, offset)\n\n\t\tif (i <= 1 || Vec.Dist2(pl, tl) > minDistance) {\n\t\t\tleftPts.push(tl)\n\t\t\tpl = tl\n\t\t}\n\n\t\ttr = Vec.Add(point, offset)\n\n\t\tif (i <= 1 || Vec.Dist2(pr, tr) > minDistance) {\n\t\t\trightPts.push(tr)\n\t\t\tpr = tr\n\t\t}\n\n\t\t// Set variables for next iteration\n\t\tprevVector = vector\n\n\t\tcontinue\n\t}\n\n\t/*\n    Return the points in the correct winding order: begin on the left side, then \n    continue around the end cap, then come back along the right side, and finally \n    complete the start cap.\n  */\n\n\treturn {\n\t\tleft: leftPts,\n\t\tright: rightPts,\n\t}\n}\n\n/**\n * ## getStrokeOutlinePoints\n *\n * Get an array of points (as `[x, y]`) representing the outline of a stroke.\n *\n * @param points - An array of StrokePoints as returned from `getStrokePoints`.\n * @param options - An object with options.\n * @public\n */\nexport function getStrokeOutlinePoints(\n\tstrokePoints: StrokePoint[],\n\toptions: StrokeOptions = {}\n): Vec[] {\n\tconst { size = 16, start = {}, end = {}, last: isComplete = false } = options\n\n\tconst { cap: capStart = true } = start\n\tconst { cap: capEnd = true } = end\n\n\t// We can't do anything with an empty array or a stroke with negative size.\n\tif (strokePoints.length === 0 || size <= 0) {\n\t\treturn []\n\t}\n\n\tconst firstStrokePoint = strokePoints[0]\n\tconst lastStrokePoint = strokePoints[strokePoints.length - 1]\n\n\t// The total length of the line\n\tconst totalLength = lastStrokePoint.runningLength\n\n\tconst taperStart =\n\t\tstart.taper === false\n\t\t\t? 0\n\t\t\t: start.taper === true\n\t\t\t\t? Math.max(size, totalLength)\n\t\t\t\t: (start.taper as number)\n\n\tconst taperEnd =\n\t\tend.taper === false\n\t\t\t? 0\n\t\t\t: end.taper === true\n\t\t\t\t? Math.max(size, totalLength)\n\t\t\t\t: (end.taper as number)\n\n\t// The minimum allowed distance between points (squared)\n\t// Our collected left and right points\n\tconst { left: leftPts, right: rightPts } = getStrokeOutlineTracks(strokePoints, options)\n\n\t/*\n    Drawing caps\n    \n    Now that we have our points on either side of the line, we need to\n    draw caps at the start and end. Tapered lines don't have caps, but\n    may have dots for very short lines.\n  */\n\n\tconst firstPoint = firstStrokePoint.point\n\n\tconst lastPoint =\n\t\tstrokePoints.length > 1\n\t\t\t? strokePoints[strokePoints.length - 1].point\n\t\t\t: Vec.AddXY(firstStrokePoint.point, 1, 1)\n\n\t/* \n    Draw a dot for very short or completed strokes\n    \n    If the line is too short to gather left or right points and if the line is\n    not tapered on either side, draw a dot. If the line is tapered, then only\n    draw a dot if the line is both very short and complete. If we draw a dot,\n    we can just return those points.\n  */\n\n\tif (strokePoints.length === 1) {\n\t\tif (!(taperStart || taperEnd) || isComplete) {\n\t\t\tconst start = Vec.Add(\n\t\t\t\tfirstPoint,\n\t\t\t\tVec.Sub(firstPoint, lastPoint).uni().per().mul(-firstStrokePoint.radius)\n\t\t\t)\n\t\t\tconst dotPts: Vec[] = []\n\t\t\tfor (let step = 1 / 13, t = step; t <= 1; t += step) {\n\t\t\t\tdotPts.push(Vec.RotWith(start, firstPoint, FIXED_PI * 2 * t))\n\t\t\t}\n\t\t\treturn dotPts\n\t\t}\n\t}\n\n\t/*\n    Draw a start cap\n\n    Unless the line has a tapered start, or unless the line has a tapered end\n    and the line is very short, draw a start cap around the first point. Use\n    the distance between the second left and right point for the cap's radius.\n    Finally remove the first left and right points. :psyduck:\n  */\n\n\tconst startCap: Vec[] = []\n\tif (taperStart || (taperEnd && strokePoints.length === 1)) {\n\t\t// The start point is tapered, noop\n\t} else if (capStart) {\n\t\t// Draw the round cap - add thirteen points rotating the right point around the start point to the left point\n\t\tfor (let step = 1 / 8, t = step; t <= 1; t += step) {\n\t\t\tconst pt = Vec.RotWith(rightPts[0], firstPoint, FIXED_PI * t)\n\t\t\tstartCap.push(pt)\n\t\t}\n\t} else {\n\t\t// Draw the flat cap - add a point to the left and right of the start point\n\t\tconst cornersVector = Vec.Sub(leftPts[0], rightPts[0])\n\t\tconst offsetA = Vec.Mul(cornersVector, 0.5)\n\t\tconst offsetB = Vec.Mul(cornersVector, 0.51)\n\n\t\tstartCap.push(\n\t\t\tVec.Sub(firstPoint, offsetA),\n\t\t\tVec.Sub(firstPoint, offsetB),\n\t\t\tVec.Add(firstPoint, offsetB),\n\t\t\tVec.Add(firstPoint, offsetA)\n\t\t)\n\t}\n\n\t/*\n    Draw an end cap\n\n    If the line does not have a tapered end, and unless the line has a tapered\n    start and the line is very short, draw a cap around the last point. Finally,\n    remove the last left and right points. Otherwise, add the last point. Note\n    that This cap is a full-turn-and-a-half: this prevents incorrect caps on\n    sharp end turns.\n  */\n\n\tconst endCap: Vec[] = []\n\tconst direction = lastStrokePoint.vector.clone().per().neg()\n\n\tif (taperEnd || (taperStart && strokePoints.length === 1)) {\n\t\t// Tapered end - push the last point to the line\n\t\tendCap.push(lastPoint)\n\t} else if (capEnd) {\n\t\t// Draw the round end cap\n\t\tconst start = Vec.Add(lastPoint, Vec.Mul(direction, lastStrokePoint.radius))\n\t\tfor (let step = 1 / 29, t = step; t < 1; t += step) {\n\t\t\tendCap.push(Vec.RotWith(start, lastPoint, FIXED_PI * 3 * t))\n\t\t}\n\t} else {\n\t\t// Draw the flat end cap\n\t\tendCap.push(\n\t\t\tVec.Add(lastPoint, Vec.Mul(direction, lastStrokePoint.radius)),\n\t\t\tVec.Add(lastPoint, Vec.Mul(direction, lastStrokePoint.radius * 0.99)),\n\t\t\tVec.Sub(lastPoint, Vec.Mul(direction, lastStrokePoint.radius * 0.99)),\n\t\t\tVec.Sub(lastPoint, Vec.Mul(direction, lastStrokePoint.radius))\n\t\t)\n\t}\n\n\t/*\n    Return the points in the correct winding order: begin on the left side, then \n    continue around the end cap, then come back along the right side, and finally \n    complete the start cap.\n  */\n\n\treturn leftPts.concat(endCap, rightPts.reverse(), startCap)\n}\n"],"names":["offset","start"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3298, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/shared/freehand/getStrokePoints.ts"],"sourcesContent":["import { Vec, VecLike } from '@tldraw/editor'\nimport type { StrokeOptions, StrokePoint } from './types'\n\nconst MIN_START_PRESSURE = 0.025\nconst MIN_END_PRESSURE = 0.01\n\n/**\n * ## getStrokePoints\n *\n * Get an array of points as objects with an adjusted point, pressure, vector, distance, and\n * runningLength.\n *\n * @param points - An array of points (as `[x, y, pressure]` or `{x, y, pressure}`). Pressure is\n *   optional in both cases.\n * @param options - An object with options.\n * @public\n */\nexport function getStrokePoints(\n\trawInputPoints: VecLike[],\n\toptions: StrokeOptions = {}\n): StrokePoint[] {\n\tconst { streamline = 0.5, size = 16, simulatePressure = false } = options\n\n\t// If we don't have any points, return an empty array.\n\tif (rawInputPoints.length === 0) return []\n\n\t// Find the interpolation level between points.\n\tconst t = 0.15 + (1 - streamline) * 0.85\n\n\t// Whatever the input is, make sure that the points are in number[][].\n\tlet pts = rawInputPoints.map(Vec.From)\n\n\tlet pointsRemovedFromNearEnd = 0\n\n\tif (!simulatePressure) {\n\t\t// Strip low pressure points from the start of the array.\n\t\tlet pt = pts[0]\n\t\twhile (pt) {\n\t\t\tif (pt.z >= MIN_START_PRESSURE) break\n\t\t\tpts.shift()\n\t\t\tpt = pts[0]\n\t\t}\n\t}\n\n\tif (!simulatePressure) {\n\t\t// Strip low pressure points from the end of the array.\n\t\tlet pt = pts[pts.length - 1]\n\t\twhile (pt) {\n\t\t\tif (pt.z >= MIN_END_PRESSURE) break\n\t\t\tpts.pop()\n\t\t\tpt = pts[pts.length - 1]\n\t\t}\n\t}\n\n\tif (pts.length === 0)\n\t\treturn [\n\t\t\t{\n\t\t\t\tpoint: Vec.From(rawInputPoints[0]),\n\t\t\t\tinput: Vec.From(rawInputPoints[0]),\n\t\t\t\tpressure: simulatePressure ? 0.5 : 0.15,\n\t\t\t\tvector: new Vec(1, 1),\n\t\t\t\tdistance: 0,\n\t\t\t\trunningLength: 0,\n\t\t\t\tradius: 1,\n\t\t\t},\n\t\t]\n\n\t// Strip points that are too close to the first point.\n\tlet pt = pts[1]\n\twhile (pt) {\n\t\tif (Vec.Dist2(pt, pts[0]) > (size / 3) ** 2) break\n\t\tpts[0].z = Math.max(pts[0].z, pt.z) // Use maximum pressure\n\t\tpts.splice(1, 1)\n\t\tpt = pts[1]\n\t}\n\n\t// Strip points that are too close to the last point.\n\tconst last = pts.pop()!\n\tpt = pts[pts.length - 1]\n\twhile (pt) {\n\t\tif (Vec.Dist2(pt, last) > (size / 3) ** 2) break\n\t\tpts.pop()\n\t\tpt = pts[pts.length - 1]\n\t\tpointsRemovedFromNearEnd++\n\t}\n\tpts.push(last)\n\n\tconst isComplete =\n\t\toptions.last ||\n\t\t!options.simulatePressure ||\n\t\t(pts.length > 1 && Vec.Dist2(pts[pts.length - 1], pts[pts.length - 2]) < size ** 2) ||\n\t\tpointsRemovedFromNearEnd > 0\n\n\t// Add extra points between the two, to help avoid \"dash\" lines\n\t// for strokes with tapered start and ends. Don't mutate the\n\t// input array!\n\tif (pts.length === 2 && options.simulatePressure) {\n\t\tconst last = pts[1]\n\t\tpts = pts.slice(0, -1)\n\t\tfor (let i = 1; i < 5; i++) {\n\t\t\tconst next = Vec.Lrp(pts[0], last, i / 4)\n\t\t\tnext.z = ((pts[0].z + (last.z - pts[0].z)) * i) / 4\n\t\t\tpts.push(next)\n\t\t}\n\t}\n\n\t// The strokePoints array will hold the points for the stroke.\n\t// Start it out with the first point, which needs no adjustment.\n\tconst strokePoints: StrokePoint[] = [\n\t\t{\n\t\t\tpoint: pts[0],\n\t\t\tinput: pts[0],\n\t\t\tpressure: simulatePressure ? 0.5 : pts[0].z,\n\t\t\tvector: new Vec(1, 1),\n\t\t\tdistance: 0,\n\t\t\trunningLength: 0,\n\t\t\tradius: 1,\n\t\t},\n\t]\n\n\t// We use the totalLength to keep track of the total distance\n\tlet totalLength = 0\n\n\t// We're set this to the latest point, so we can use it to calculate\n\t// the distance and vector of the next point.\n\tlet prev = strokePoints[0]\n\n\t// Iterate through all of the points, creating StrokePoints.\n\tlet point: Vec, distance: number\n\n\tif (isComplete && streamline > 0) {\n\t\tpts.push(pts[pts.length - 1].clone())\n\t}\n\n\tfor (let i = 1, n = pts.length; i < n; i++) {\n\t\tpoint =\n\t\t\t!t || (options.last && i === n - 1) ? pts[i].clone() : pts[i].clone().lrp(prev.point, 1 - t)\n\n\t\t// If the new point is the same as the previous point, skip ahead.\n\t\tif (prev.point.equals(point)) continue\n\n\t\t// How far is the new point from the previous point?\n\t\tdistance = Vec.Dist(point, prev.point)\n\n\t\t// Add this distance to the total \"running length\" of the line.\n\t\ttotalLength += distance\n\n\t\t// At the start of the line, we wait until the new point is a\n\t\t// certain distance away from the original point, to avoid noise\n\n\t\tif (i < 4 && totalLength < size) {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Create a new strokepoint (it will be the new \"previous\" one).\n\t\tprev = {\n\t\t\tinput: pts[i],\n\t\t\t// The adjusted point\n\t\t\tpoint,\n\t\t\t// The input pressure (or .5 if not specified)\n\t\t\tpressure: simulatePressure ? 0.5 : pts[i].z,\n\t\t\t// The vector from the current point to the previous point\n\t\t\tvector: Vec.Sub(prev.point, point).uni(),\n\t\t\t// The distance between the current point and the previous point\n\t\t\tdistance,\n\t\t\t// The total distance so far\n\t\t\trunningLength: totalLength,\n\t\t\t// The stroke point's radius\n\t\t\tradius: 1,\n\t\t}\n\n\t\t// Push it to the strokePoints array.\n\t\tstrokePoints.push(prev)\n\t}\n\n\t// Set the vector of the first point to be the same as the second point.\n\tif (strokePoints[1]?.vector) {\n\t\tstrokePoints[0].vector = strokePoints[1].vector.clone()\n\t}\n\n\tif (totalLength < 1) {\n\t\tconst maxPressureAmongPoints = Math.max(0.5, ...strokePoints.map((s) => s.pressure))\n\t\tstrokePoints.forEach((s) => (s.pressure = maxPressureAmongPoints))\n\t}\n\n\treturn strokePoints\n}\n"],"names":["pt","last"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3424, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/shared/freehand/setStrokePointRadii.ts"],"sourcesContent":["import { EASINGS } from '@tldraw/editor'\nimport { StrokeOptions, StrokePoint } from './types'\n\nconst { min } = Math\n\n// This is the rate of change for simulated pressure. It could be an option.\nconst RATE_OF_PRESSURE_CHANGE = 0.275\n\n/** @public */\nexport function setStrokePointRadii(strokePoints: StrokePoint[], options: StrokeOptions) {\n\tconst {\n\t\tsize = 16,\n\t\tthinning = 0.5,\n\t\tsimulatePressure = true,\n\t\teasing = (t) => t,\n\t\tstart = {},\n\t\tend = {},\n\t} = options\n\n\tconst { easing: taperStartEase = EASINGS.easeOutQuad } = start\n\tconst { easing: taperEndEase = EASINGS.easeOutCubic } = end\n\n\tconst totalLength = strokePoints[strokePoints.length - 1].runningLength\n\n\tlet firstRadius: number | undefined\n\tlet prevPressure = strokePoints[0].pressure\n\tlet strokePoint: StrokePoint\n\n\tif (!simulatePressure && totalLength < size) {\n\t\tconst max = strokePoints.reduce((max, curr) => Math.max(max, curr.pressure), 0.5)\n\t\tstrokePoints.forEach((sp) => {\n\t\t\tsp.pressure = max\n\t\t\tsp.radius = size * easing(0.5 - thinning * (0.5 - sp.pressure))\n\t\t})\n\t\treturn strokePoints\n\t} else {\n\t\t// Calculate initial pressure based on the average of the first\n\t\t// n number of points. This prevents \"dots\" at the start of the\n\t\t// line. Drawn lines almost always start slow!\n\t\tlet p: number\n\t\tfor (let i = 0, n = strokePoints.length; i < n; i++) {\n\t\t\tstrokePoint = strokePoints[i]\n\t\t\tif (strokePoint.runningLength > size * 5) break\n\t\t\tconst sp = min(1, strokePoint.distance / size)\n\t\t\tif (simulatePressure) {\n\t\t\t\tconst rp = min(1, 1 - sp)\n\t\t\t\tp = min(1, prevPressure + (rp - prevPressure) * (sp * RATE_OF_PRESSURE_CHANGE))\n\t\t\t} else {\n\t\t\t\tp = min(1, prevPressure + (strokePoint.pressure - prevPressure) * 0.5)\n\t\t\t}\n\t\t\tprevPressure = prevPressure + (p - prevPressure) * 0.5\n\t\t}\n\n\t\t// Now calculate pressure and radius for each point\n\t\tfor (let i = 0; i < strokePoints.length; i++) {\n\t\t\tstrokePoint = strokePoints[i]\n\t\t\tif (thinning) {\n\t\t\t\tlet { pressure } = strokePoint\n\t\t\t\tconst sp = min(1, strokePoint.distance / size)\n\t\t\t\tif (simulatePressure) {\n\t\t\t\t\t// If we're simulating pressure, then do so based on the distance\n\t\t\t\t\t// between the current point and the previous point, and the size\n\t\t\t\t\t// of the stroke.\n\t\t\t\t\tconst rp = min(1, 1 - sp)\n\t\t\t\t\tpressure = min(1, prevPressure + (rp - prevPressure) * (sp * RATE_OF_PRESSURE_CHANGE))\n\t\t\t\t} else {\n\t\t\t\t\t// Otherwise, use the input pressure slightly smoothed based on the\n\t\t\t\t\t// distance between the current point and the previous point.\n\t\t\t\t\tpressure = min(\n\t\t\t\t\t\t1,\n\t\t\t\t\t\tprevPressure + (pressure - prevPressure) * (sp * RATE_OF_PRESSURE_CHANGE)\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tstrokePoint.radius = size * easing(0.5 - thinning * (0.5 - pressure))\n\n\t\t\t\tprevPressure = pressure\n\t\t\t} else {\n\t\t\t\tstrokePoint.radius = size / 2\n\t\t\t}\n\n\t\t\tif (firstRadius === undefined) {\n\t\t\t\tfirstRadius = strokePoint.radius\n\t\t\t}\n\t\t}\n\t}\n\n\tconst taperStart =\n\t\tstart.taper === false\n\t\t\t? 0\n\t\t\t: start.taper === true\n\t\t\t\t? Math.max(size, totalLength)\n\t\t\t\t: (start.taper as number)\n\n\tconst taperEnd =\n\t\tend.taper === false\n\t\t\t? 0\n\t\t\t: end.taper === true\n\t\t\t\t? Math.max(size, totalLength)\n\t\t\t\t: (end.taper as number)\n\n\tif (taperStart || taperEnd) {\n\t\tfor (let i = 0; i < strokePoints.length; i++) {\n\t\t\tstrokePoint = strokePoints[i]\n\t\t\t/*\n\t\t\t\tApply tapering\n\n\t\t\t\tIf the current length is within the taper distance at either the\n\t\t\t\tstart or the end, calculate the taper strengths. Apply the smaller \n\t\t\t\tof the two taper strengths to the radius.\n\t\t\t*/\n\n\t\t\tconst { runningLength } = strokePoint\n\n\t\t\tconst ts = runningLength < taperStart ? taperStartEase(runningLength / taperStart) : 1\n\n\t\t\tconst te =\n\t\t\t\ttotalLength - runningLength < taperEnd\n\t\t\t\t\t? taperEndEase((totalLength - runningLength) / taperEnd)\n\t\t\t\t\t: 1\n\n\t\t\tstrokePoint.radius = Math.max(0.01, strokePoint.radius * Math.min(ts, te))\n\t\t}\n\t}\n\n\treturn strokePoints\n}\n"],"names":["max"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3503, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/shared/freehand/getStroke.ts"],"sourcesContent":["import { Vec, VecLike } from '@tldraw/editor'\nimport { getStrokeOutlinePoints } from './getStrokeOutlinePoints'\nimport { getStrokePoints } from './getStrokePoints'\nimport { setStrokePointRadii } from './setStrokePointRadii'\nimport type { StrokeOptions } from './types'\n\n/**\n * ## getStroke\n *\n * Get an array of points describing a polygon that surrounds the input points.\n *\n * @param points - An array of points (as `[x, y, pressure]` or `{x, y, pressure}`). Pressure is\n *   optional in both cases.\n * @param options - An object with options.\n * @public\n */\n\nexport function getStroke(points: VecLike[], options: StrokeOptions = {}): Vec[] {\n\treturn getStrokeOutlinePoints(\n\t\tsetStrokePointRadii(getStrokePoints(points, options), options),\n\t\toptions\n\t)\n}\n"],"names":[],"mappings":";;;AACA,SAAS,8BAA8B;AACvC,SAAS,uBAAuB;AAChC,SAAS,2BAA2B;;;;AAc7B,SAAS,UAAU,MAAA,EAAmB,UAAyB,CAAC,CAAA,EAAU;IAChF,sNAAO,yBAAA,8MACN,sBAAA,0MAAoB,kBAAA,EAAgB,QAAQ,OAAO,GAAG,OAAO,GAC7D;AAEF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3523, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/shared/crop.ts"],"sourcesContent":["import {\n\tBox,\n\tShapeWithCrop,\n\tTLCropInfo,\n\tTLImageShape,\n\tTLShapeCrop,\n\tTLShapeId,\n\tVec,\n\tclamp,\n\tisEqual,\n} from '@tldraw/editor'\n\n/** @internal */\nexport const MIN_CROP_SIZE = 8\n\n/** @public */\nexport interface CropBoxOptions {\n\tminWidth?: number\n\tminHeight?: number\n}\n\n/** @public */\nexport function getDefaultCrop(): TLShapeCrop {\n\treturn {\n\t\ttopLeft: { x: 0, y: 0 },\n\t\tbottomRight: { x: 1, y: 1 },\n\t}\n}\n\n/** @public */\nexport type ASPECT_RATIO_OPTION =\n\t| 'original'\n\t| 'square'\n\t| 'circle'\n\t| 'landscape'\n\t| 'portrait'\n\t| 'wide'\n\n/** @public */\nexport const ASPECT_RATIO_OPTIONS: ASPECT_RATIO_OPTION[] = [\n\t'original',\n\t'square',\n\t'circle',\n\t'landscape',\n\t'portrait',\n\t'wide',\n]\n\n/** @public */\nexport const ASPECT_RATIO_TO_VALUE: Record<ASPECT_RATIO_OPTION, number> = {\n\toriginal: 0,\n\tsquare: 1,\n\tcircle: 1,\n\tlandscape: 4 / 3,\n\tportrait: 3 / 4,\n\twide: 16 / 9,\n}\n\n/**\n * Original (uncropped) width and height of shape.\n *\n * @public\n */\nexport function getUncroppedSize(\n\tshapeSize: { w: number; h: number },\n\tcrop: TLShapeCrop | null\n): { w: number; h: number } {\n\tif (!crop) return { w: shapeSize.w, h: shapeSize.h }\n\tconst w = shapeSize.w / (crop.bottomRight.x - crop.topLeft.x)\n\tconst h = shapeSize.h / (crop.bottomRight.y - crop.topLeft.y)\n\treturn { w, h }\n}\n\n// Utility function to get crop dimensions\nfunction getCropDimensions(crop: TLShapeCrop) {\n\treturn {\n\t\twidth: crop.bottomRight.x - crop.topLeft.x,\n\t\theight: crop.bottomRight.y - crop.topLeft.y,\n\t}\n}\n\n// Utility function to get crop center\nfunction getCropCenter(crop: TLShapeCrop) {\n\tconst { width, height } = getCropDimensions(crop)\n\treturn {\n\t\tx: crop.topLeft.x + width / 2,\n\t\ty: crop.topLeft.y + height / 2,\n\t}\n}\n\n// Utility function to create crop with specified dimensions centered on given point\nfunction createCropAroundCenter(\n\tcenterX: number,\n\tcenterY: number,\n\twidth: number,\n\theight: number,\n\tisCircle?: boolean\n) {\n\tconst topLeftX = Math.max(0, Math.min(1 - width, centerX - width / 2))\n\tconst topLeftY = Math.max(0, Math.min(1 - height, centerY - height / 2))\n\n\treturn {\n\t\ttopLeft: { x: topLeftX, y: topLeftY },\n\t\tbottomRight: { x: topLeftX + width, y: topLeftY + height },\n\t\tisCircle,\n\t}\n}\n\n/** @public */\nexport function getCropBox<T extends ShapeWithCrop>(\n\tshape: T,\n\tinfo: TLCropInfo<T>,\n\topts = {} as CropBoxOptions\n):\n\t| {\n\t\t\tid: TLShapeId\n\t\t\ttype: T['type']\n\t\t\tx: number\n\t\t\ty: number\n\t\t\tprops: ShapeWithCrop['props']\n\t  }\n\t| undefined {\n\tconst { handle, change, crop, aspectRatioLocked } = info\n\tconst { w, h } = info.uncroppedSize\n\tconst { minWidth = MIN_CROP_SIZE, minHeight = MIN_CROP_SIZE } = opts\n\n\tif (w < minWidth || h < minHeight || (change.x === 0 && change.y === 0)) {\n\t\treturn\n\t}\n\n\t// Lets get a box here in pixel space. For simplicity, we'll do all the math in\n\t// pixel space, then convert to normalized space at the end.\n\tconst prevCropBox = new Box(\n\t\tcrop.topLeft.x * w,\n\t\tcrop.topLeft.y * h,\n\t\t(crop.bottomRight.x - crop.topLeft.x) * w,\n\t\t(crop.bottomRight.y - crop.topLeft.y) * h\n\t)\n\n\tconst targetRatio = prevCropBox.aspectRatio\n\tconst tempBox = prevCropBox.clone()\n\n\t// Basic resizing logic based on the handles\n\n\tif (handle === 'top_left' || handle === 'bottom_left' || handle === 'left') {\n\t\ttempBox.x = clamp(tempBox.x + change.x, 0, prevCropBox.maxX - minWidth)\n\t\ttempBox.w = prevCropBox.maxX - tempBox.x\n\t} else if (handle === 'top_right' || handle === 'bottom_right' || handle === 'right') {\n\t\tconst tempRight = clamp(tempBox.maxX + change.x, prevCropBox.x + minWidth, w)\n\t\ttempBox.w = tempRight - tempBox.x\n\t}\n\n\tif (handle === 'top_left' || handle === 'top_right' || handle === 'top') {\n\t\ttempBox.y = clamp(tempBox.y + change.y, 0, prevCropBox.maxY - minHeight)\n\t\ttempBox.h = prevCropBox.maxY - tempBox.y\n\t} else if (handle === 'bottom_left' || handle === 'bottom_right' || handle === 'bottom') {\n\t\tconst tempBottom = clamp(tempBox.maxY + change.y, prevCropBox.y + minHeight, h)\n\t\ttempBox.h = tempBottom - tempBox.y\n\t}\n\n\t// Aspect ratio locked resizing logic\n\n\tif (aspectRatioLocked) {\n\t\tconst isXLimiting = tempBox.aspectRatio > targetRatio\n\n\t\tif (isXLimiting) {\n\t\t\ttempBox.h = tempBox.w / targetRatio\n\t\t} else {\n\t\t\ttempBox.w = tempBox.h * targetRatio\n\t\t}\n\n\t\tswitch (handle) {\n\t\t\tcase 'top_left': {\n\t\t\t\t// preserve the bottom right corner\n\t\t\t\ttempBox.x = prevCropBox.maxX - tempBox.w\n\t\t\t\ttempBox.y = prevCropBox.maxY - tempBox.h\n\n\t\t\t\tif (tempBox.x <= 0) {\n\t\t\t\t\ttempBox.x = 0\n\t\t\t\t\ttempBox.w = prevCropBox.maxX - tempBox.x\n\t\t\t\t\ttempBox.h = tempBox.w / targetRatio\n\t\t\t\t\ttempBox.y = prevCropBox.maxY - tempBox.h\n\t\t\t\t}\n\n\t\t\t\tif (tempBox.y <= 0) {\n\t\t\t\t\ttempBox.y = 0\n\t\t\t\t\ttempBox.h = prevCropBox.maxY - tempBox.y\n\t\t\t\t\ttempBox.w = tempBox.h * targetRatio\n\t\t\t\t\ttempBox.x = prevCropBox.maxX - tempBox.w\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'top_right': {\n\t\t\t\t// preserve the bottom left corner\n\t\t\t\ttempBox.x = prevCropBox.x\n\t\t\t\ttempBox.y = prevCropBox.maxY - tempBox.h\n\n\t\t\t\tif (tempBox.maxX >= w) {\n\t\t\t\t\ttempBox.w = w - prevCropBox.x\n\t\t\t\t\ttempBox.h = tempBox.w / targetRatio\n\t\t\t\t\ttempBox.y = prevCropBox.maxY - tempBox.h\n\t\t\t\t}\n\n\t\t\t\tif (tempBox.y <= 0) {\n\t\t\t\t\ttempBox.y = 0\n\t\t\t\t\ttempBox.h = prevCropBox.maxY - tempBox.y\n\t\t\t\t\ttempBox.w = tempBox.h * targetRatio\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'bottom_left': {\n\t\t\t\t// preserve the top right corner\n\t\t\t\ttempBox.x = prevCropBox.maxX - tempBox.w\n\t\t\t\ttempBox.y = prevCropBox.y\n\n\t\t\t\tif (tempBox.x <= 0) {\n\t\t\t\t\ttempBox.x = 0\n\t\t\t\t\ttempBox.w = prevCropBox.maxX - tempBox.x\n\t\t\t\t\ttempBox.h = tempBox.w / targetRatio\n\t\t\t\t}\n\n\t\t\t\tif (tempBox.maxY >= h) {\n\t\t\t\t\ttempBox.h = h - prevCropBox.y\n\t\t\t\t\ttempBox.w = tempBox.h * targetRatio\n\t\t\t\t\ttempBox.x = prevCropBox.maxX - tempBox.w\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'bottom_right': {\n\t\t\t\t// preserve the top left corner\n\t\t\t\ttempBox.x = prevCropBox.x\n\t\t\t\ttempBox.y = prevCropBox.y\n\n\t\t\t\tif (tempBox.maxX >= w) {\n\t\t\t\t\ttempBox.w = w - prevCropBox.x\n\t\t\t\t\ttempBox.h = tempBox.w / targetRatio\n\t\t\t\t}\n\n\t\t\t\tif (tempBox.maxY >= h) {\n\t\t\t\t\ttempBox.h = h - prevCropBox.y\n\t\t\t\t\ttempBox.w = tempBox.h * targetRatio\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'top': {\n\t\t\t\t// preserve the bottom edge center\n\t\t\t\ttempBox.h = prevCropBox.maxY - tempBox.y\n\t\t\t\ttempBox.w = tempBox.h * targetRatio\n\t\t\t\ttempBox.x -= (tempBox.w - prevCropBox.w) / 2\n\n\t\t\t\tif (tempBox.x <= 0) {\n\t\t\t\t\tconst leftSide = prevCropBox.midX\n\t\t\t\t\ttempBox.w = leftSide * 2\n\t\t\t\t\ttempBox.h = tempBox.w / targetRatio\n\t\t\t\t\ttempBox.x = 0\n\t\t\t\t}\n\n\t\t\t\tif (tempBox.maxX >= w) {\n\t\t\t\t\tconst rightSide = w - prevCropBox.midX\n\t\t\t\t\ttempBox.w = rightSide * 2\n\t\t\t\t\ttempBox.h = tempBox.w / targetRatio\n\t\t\t\t\ttempBox.x = w - tempBox.w\n\t\t\t\t}\n\n\t\t\t\ttempBox.y = prevCropBox.maxY - tempBox.h\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'right': {\n\t\t\t\t// preserve the left edge center\n\t\t\t\ttempBox.w = tempBox.maxX - prevCropBox.x\n\t\t\t\ttempBox.h = tempBox.w / targetRatio\n\t\t\t\ttempBox.y -= (tempBox.h - prevCropBox.h) / 2\n\n\t\t\t\tif (tempBox.y <= 0) {\n\t\t\t\t\tconst topSide = prevCropBox.midY\n\t\t\t\t\ttempBox.h = topSide * 2\n\t\t\t\t\ttempBox.w = tempBox.h * targetRatio\n\t\t\t\t\ttempBox.y = 0\n\t\t\t\t}\n\n\t\t\t\tif (tempBox.maxY >= h) {\n\t\t\t\t\tconst bottomSide = h - prevCropBox.midY\n\t\t\t\t\ttempBox.h = bottomSide * 2\n\t\t\t\t\ttempBox.w = tempBox.h * targetRatio\n\t\t\t\t\ttempBox.y = h - tempBox.h\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'bottom': {\n\t\t\t\t// preserve the top edge center\n\t\t\t\ttempBox.h = tempBox.maxY - prevCropBox.y\n\t\t\t\ttempBox.w = tempBox.h * targetRatio\n\t\t\t\ttempBox.x -= (tempBox.w - prevCropBox.w) / 2\n\n\t\t\t\tif (tempBox.x <= 0) {\n\t\t\t\t\tconst leftSide = prevCropBox.midX\n\t\t\t\t\ttempBox.w = leftSide * 2\n\t\t\t\t\ttempBox.h = tempBox.w / targetRatio\n\t\t\t\t\ttempBox.x = 0\n\t\t\t\t}\n\n\t\t\t\tif (tempBox.maxX >= w) {\n\t\t\t\t\tconst rightSide = w - prevCropBox.midX\n\t\t\t\t\ttempBox.w = rightSide * 2\n\t\t\t\t\ttempBox.h = tempBox.w / targetRatio\n\t\t\t\t\ttempBox.x = w - tempBox.w\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'left': {\n\t\t\t\t// preserve the right edge center\n\t\t\t\ttempBox.w = prevCropBox.maxX - tempBox.x\n\t\t\t\ttempBox.h = tempBox.w / targetRatio\n\t\t\t\ttempBox.y -= (tempBox.h - prevCropBox.h) / 2\n\n\t\t\t\tif (tempBox.y <= 0) {\n\t\t\t\t\tconst topSide = prevCropBox.midY\n\t\t\t\t\ttempBox.h = topSide * 2\n\t\t\t\t\ttempBox.w = tempBox.h * targetRatio\n\t\t\t\t\ttempBox.y = 0\n\t\t\t\t}\n\n\t\t\t\tif (tempBox.maxY >= h) {\n\t\t\t\t\tconst bottomSide = h - prevCropBox.midY\n\t\t\t\t\ttempBox.h = bottomSide * 2\n\t\t\t\t\ttempBox.w = tempBox.h * targetRatio\n\t\t\t\t\ttempBox.y = h - tempBox.h\n\t\t\t\t}\n\n\t\t\t\ttempBox.x = prevCropBox.maxX - tempBox.w\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// Convert the box back to normalized space\n\tconst newCrop: TLShapeCrop = {\n\t\ttopLeft: { x: tempBox.x / w, y: tempBox.y / h },\n\t\tbottomRight: { x: tempBox.maxX / w, y: tempBox.maxY / h },\n\t\tisCircle: crop.isCircle,\n\t}\n\n\t// If the crop hasn't changed, we can return early\n\tif (\n\t\tnewCrop.topLeft.x === crop.topLeft.x &&\n\t\tnewCrop.topLeft.y === crop.topLeft.y &&\n\t\tnewCrop.bottomRight.x === crop.bottomRight.x &&\n\t\tnewCrop.bottomRight.y === crop.bottomRight.y\n\t) {\n\t\treturn\n\t}\n\n\t// Adjust the shape's position to keep the crop's absolute coordinates correct\n\tconst newPoint = new Vec(tempBox.x - crop.topLeft.x * w, tempBox.y - crop.topLeft.y * h)\n\t\t.rot(shape.rotation)\n\t\t.add(shape)\n\n\treturn {\n\t\tid: shape.id,\n\t\ttype: shape.type,\n\t\tx: newPoint.x,\n\t\ty: newPoint.y,\n\t\tprops: {\n\t\t\tw: tempBox.w,\n\t\t\th: tempBox.h,\n\t\t\tcrop: newCrop,\n\t\t},\n\t}\n}\n\ninterface CropChange {\n\tcrop: {\n\t\ttopLeft: { x: number; y: number }\n\t\tbottomRight: { x: number; y: number }\n\t\tisCircle?: boolean\n\t}\n\tw: number\n\th: number\n\tx: number\n\ty: number\n}\n\n// Base function for calculating crop changes\nfunction calculateCropChange(\n\timageShape: TLImageShape,\n\tnewCropWidth: number,\n\tnewCropHeight: number,\n\tcenterOnCurrentCrop: boolean = true,\n\tisCircle: boolean = false\n): CropChange {\n\tconst { w, h } = getUncroppedSize(imageShape.props, imageShape.props.crop ?? getDefaultCrop())\n\tconst currentCrop = imageShape.props.crop || getDefaultCrop()\n\n\t// Calculate image and crop centers\n\tconst imageCenterX = imageShape.x + imageShape.props.w / 2\n\tconst imageCenterY = imageShape.y + imageShape.props.h / 2\n\n\tlet cropCenterX, cropCenterY\n\tif (centerOnCurrentCrop) {\n\t\tconst { x, y } = getCropCenter(currentCrop)\n\t\tcropCenterX = x\n\t\tcropCenterY = y\n\t} else {\n\t\tcropCenterX = 0.5\n\t\tcropCenterY = 0.5\n\t}\n\n\t// Create new crop\n\tconst newCrop = createCropAroundCenter(\n\t\tcropCenterX,\n\t\tcropCenterY,\n\t\tnewCropWidth,\n\t\tnewCropHeight,\n\t\tisCircle\n\t)\n\n\t// Calculate new dimensions\n\tconst croppedW = newCropWidth * w\n\tconst croppedH = newCropHeight * h\n\n\treturn {\n\t\tcrop: newCrop,\n\t\tw: croppedW,\n\t\th: croppedH,\n\t\tx: imageCenterX - croppedW / 2,\n\t\ty: imageCenterY - croppedH / 2,\n\t}\n}\n\n/** @internal */\nexport const MAX_ZOOM = 3\n\n/**\n * Calculate new crop dimensions and position when zooming\n */\nexport function getCroppedImageDataWhenZooming(\n\tzoom: number,\n\timageShape: TLImageShape,\n\tmaxZoom?: number\n): CropChange {\n\tconst oldCrop = imageShape.props.crop || getDefaultCrop()\n\tconst { width: oldWidth, height: oldHeight } = getCropDimensions(oldCrop)\n\tconst aspectRatio = oldWidth / oldHeight\n\n\t// Calculate new crop size with zoom scale\n\tconst derivedMaxZoom = maxZoom ? 1 / (1 - maxZoom) : MAX_ZOOM\n\tconst zoomScale = 1 + zoom * (derivedMaxZoom - 1)\n\tlet newWidth, newHeight\n\n\tif (aspectRatio > 1) {\n\t\tnewWidth = Math.min(1, 1 / zoomScale)\n\t\tnewHeight = newWidth / aspectRatio\n\t} else {\n\t\tnewHeight = Math.min(1, 1 / zoomScale)\n\t\tnewWidth = newHeight * aspectRatio\n\t}\n\n\t// Calculate result with base function\n\tconst result = calculateCropChange(imageShape, newWidth, newHeight, true, oldCrop.isCircle)\n\n\t// Apply zoom factor to display dimensions\n\tconst scaleFactor = Math.min(MAX_ZOOM, oldWidth / newWidth)\n\tresult.w *= scaleFactor\n\tresult.h *= scaleFactor\n\n\t// Recenter\n\tconst imageCenterX = imageShape.x + imageShape.props.w / 2\n\tconst imageCenterY = imageShape.y + imageShape.props.h / 2\n\tresult.x = imageCenterX - result.w / 2\n\tresult.y = imageCenterY - result.h / 2\n\n\treturn result\n}\n\n/**\n * Calculate new crop dimensions and position when replacing an image\n */\nexport function getCroppedImageDataForReplacedImage(\n\timageShape: TLImageShape,\n\tnewImageWidth: number,\n\tnewImageHeight: number\n): CropChange {\n\tconst defaultCrop = getDefaultCrop()\n\tconst currentCrop = imageShape.props.crop || defaultCrop\n\tconst origDisplayW = imageShape.props.w\n\tconst origDisplayH = imageShape.props.h\n\tconst newImageAspectRatio = newImageWidth / newImageHeight\n\n\tlet crop = defaultCrop\n\tlet newDisplayW = origDisplayW\n\tlet newDisplayH = origDisplayH\n\tconst isOriginalCrop = isEqual(imageShape.props.crop, defaultCrop)\n\n\tif (isOriginalCrop) {\n\t\tnewDisplayW = origDisplayW\n\t\tnewDisplayH = (origDisplayW * newImageHeight) / newImageWidth\n\t} else {\n\t\tconst { w: uncroppedW, h: uncroppedH } = getUncroppedSize(\n\t\t\timageShape.props,\n\t\t\timageShape.props.crop || getDefaultCrop() // Use the ACTUAL current crop to correctly infer uncropped size\n\t\t)\n\t\tconst { width: cropW, height: cropH } = getCropDimensions(currentCrop)\n\t\tconst targetRatio = cropW / cropH\n\t\tconst oldImageAspectRatio = uncroppedW / uncroppedH\n\t\tlet newRelativeWidth: number\n\t\tlet newRelativeHeight: number\n\n\t\tconst currentCropCenter = getCropCenter(currentCrop)\n\n\t\t// Adjust the new crop dimensions to match the current crop zoom\n\t\tnewRelativeWidth = cropW\n\t\tconst ratioConversion = newImageAspectRatio / oldImageAspectRatio / targetRatio\n\t\tnewRelativeHeight = newRelativeWidth * ratioConversion\n\n\t\t// Check that our new crop dimensions are within the MAX_ZOOM bounds\n\t\tconst maxRatioConversion = MAX_ZOOM / (MAX_ZOOM - 1)\n\t\tif (ratioConversion > maxRatioConversion) {\n\t\t\tconst minDimension = 1 / MAX_ZOOM\n\t\t\tif (1 / newRelativeHeight < 1 / newRelativeWidth) {\n\t\t\t\tconst scale = newRelativeHeight / minDimension\n\t\t\t\tnewRelativeHeight = newRelativeHeight / scale\n\t\t\t\tnewRelativeWidth = newRelativeWidth / scale\n\t\t\t} else {\n\t\t\t\tconst scale = newRelativeWidth / minDimension\n\t\t\t\tnewRelativeWidth = newRelativeWidth / scale\n\t\t\t\tnewRelativeHeight = newRelativeHeight / scale\n\t\t\t}\n\t\t}\n\n\t\t// Ensure dimensions are within [0, 1] bounds after adjustment\n\t\tnewRelativeWidth = Math.max(0, Math.min(1, newRelativeWidth))\n\t\tnewRelativeHeight = Math.max(0, Math.min(1, newRelativeHeight))\n\n\t\t// Create the new crop object, centered around the CURRENT crop's center\n\t\tcrop = createCropAroundCenter(\n\t\t\tcurrentCropCenter.x,\n\t\t\tcurrentCropCenter.y,\n\t\t\tnewRelativeWidth,\n\t\t\tnewRelativeHeight,\n\t\t\tcurrentCrop.isCircle\n\t\t)\n\t}\n\n\t// Position so visual center stays put\n\tconst pageCenterX = imageShape.x + origDisplayW / 2\n\tconst pageCenterY = imageShape.y + origDisplayH / 2\n\n\tconst newX = pageCenterX - newDisplayW / 2\n\tconst newY = pageCenterY - newDisplayH / 2\n\n\treturn {\n\t\tcrop,\n\t\tw: newDisplayW,\n\t\th: newDisplayH,\n\t\tx: newX,\n\t\ty: newY,\n\t}\n}\n\n/**\n * Calculate new crop dimensions and position when changing aspect ratio\n */\nexport function getCroppedImageDataForAspectRatio(\n\taspectRatioOption: ASPECT_RATIO_OPTION,\n\timageShape: TLImageShape\n): CropChange {\n\t// If original aspect ratio is requested, use default crop\n\tif (aspectRatioOption === 'original') {\n\t\tconst { w, h } = getUncroppedSize(imageShape.props, imageShape.props.crop ?? getDefaultCrop())\n\t\tconst imageCenterX = imageShape.x + imageShape.props.w / 2\n\t\tconst imageCenterY = imageShape.y + imageShape.props.h / 2\n\n\t\treturn {\n\t\t\tcrop: getDefaultCrop(),\n\t\t\tw,\n\t\t\th,\n\t\t\tx: imageCenterX - w / 2,\n\t\t\ty: imageCenterY - h / 2,\n\t\t}\n\t}\n\n\t// Get target ratio and uncropped image properties\n\tconst targetRatio = ASPECT_RATIO_TO_VALUE[aspectRatioOption] // Assume valid option\n\tconst isCircle = aspectRatioOption === 'circle'\n\t// Use default crop to get uncropped size relative to the *original* image bounds\n\tconst { w: uncroppedW, h: uncroppedH } = getUncroppedSize(\n\t\timageShape.props,\n\t\timageShape.props.crop || getDefaultCrop() // Use the ACTUAL current crop to correctly infer uncropped size\n\t)\n\t// Calculate the original image aspect ratio\n\tconst imageAspectRatio = uncroppedW / uncroppedH\n\n\t// Get the current crop and its relative dimensions\n\tconst currentCrop = imageShape.props.crop || getDefaultCrop()\n\tconst { width: cropW, height: cropH } = getCropDimensions(currentCrop)\n\tconst currentCropCenter = getCropCenter(currentCrop)\n\n\t// Calculate the current crop zoom level\n\tconst currentCropZoom = Math.min(1 / cropW, 1 / cropH)\n\n\t// Calculate the relative width and height of the crop rectangle (0-1 scale)\n\t// Try to preserve the longest dimension of the current crop when changing aspect ratios\n\tlet newRelativeWidth: number\n\tlet newRelativeHeight: number\n\n\tif (imageAspectRatio === 0 || !Number.isFinite(imageAspectRatio) || targetRatio === 0) {\n\t\t// Avoid division by zero or NaN issues if image dimensions are invalid or target ratio is 0\n\t\tnewRelativeWidth = 1\n\t\tnewRelativeHeight = 1\n\t} else {\n\t\t// Get current crop dimensions in absolute units\n\t\tconst currentAbsoluteWidth = cropW * uncroppedW\n\t\tconst currentAbsoluteHeight = cropH * uncroppedH\n\n\t\t// Find the longest current dimension to preserve\n\t\tconst longestCurrentDimension = Math.max(currentAbsoluteWidth, currentAbsoluteHeight)\n\t\tconst isWidthLongest = currentAbsoluteWidth >= currentAbsoluteHeight\n\n\t\t// Calculate new dimensions preserving the longest dimension\n\t\tlet newAbsoluteWidth: number\n\t\tlet newAbsoluteHeight: number\n\n\t\tif (isWidthLongest) {\n\t\t\t// Preserve width, calculate height based on target ratio\n\t\t\tnewAbsoluteWidth = longestCurrentDimension\n\t\t\tnewAbsoluteHeight = newAbsoluteWidth / targetRatio\n\t\t} else {\n\t\t\t// Preserve height, calculate width based on target ratio\n\t\t\tnewAbsoluteHeight = longestCurrentDimension\n\t\t\tnewAbsoluteWidth = newAbsoluteHeight * targetRatio\n\t\t}\n\n\t\t// Convert back to relative coordinates\n\t\tnewRelativeWidth = newAbsoluteWidth / uncroppedW\n\t\tnewRelativeHeight = newAbsoluteHeight / uncroppedH\n\n\t\t// Clamp to image bounds and adjust if necessary\n\t\tif (newRelativeWidth > 1) {\n\t\t\t// Width exceeds bounds, clamp and recalculate height\n\t\t\tnewRelativeWidth = 1\n\t\t\tnewRelativeHeight = imageAspectRatio / targetRatio\n\t\t}\n\t\tif (newRelativeHeight > 1) {\n\t\t\t// Height exceeds bounds, clamp and recalculate width\n\t\t\tnewRelativeHeight = 1\n\t\t\tnewRelativeWidth = targetRatio / imageAspectRatio\n\t\t}\n\n\t\t// Final clamp to ensure we stay within bounds\n\t\tnewRelativeWidth = Math.max(0, Math.min(1, newRelativeWidth))\n\t\tnewRelativeHeight = Math.max(0, Math.min(1, newRelativeHeight))\n\t}\n\n\tconst newCropZoom = Math.min(1 / newRelativeWidth, 1 / newRelativeHeight)\n\t// Adjust the new crop dimensions to match the current crop zoom\n\tnewRelativeWidth *= newCropZoom / currentCropZoom\n\tnewRelativeHeight *= newCropZoom / currentCropZoom\n\n\t// Ensure dimensions are within [0, 1] bounds after adjustment\n\tnewRelativeWidth = Math.max(0, Math.min(1, newRelativeWidth))\n\tnewRelativeHeight = Math.max(0, Math.min(1, newRelativeHeight))\n\n\t// Create the new crop object, centered around the CURRENT crop's center\n\tconst newCrop = createCropAroundCenter(\n\t\tcurrentCropCenter.x,\n\t\tcurrentCropCenter.y,\n\t\tnewRelativeWidth,\n\t\tnewRelativeHeight,\n\t\tisCircle\n\t)\n\n\t// Get the actual relative dimensions from the new crop (after potential clamping)\n\tconst finalRelativeWidth = newCrop.bottomRight.x - newCrop.topLeft.x\n\tconst finalRelativeHeight = newCrop.bottomRight.y - newCrop.topLeft.y\n\n\t// Calculate the base dimensions (as if applying the new crop to the uncropped image at scale 1)\n\tconst baseW = finalRelativeWidth * uncroppedW\n\tconst baseH = finalRelativeHeight * uncroppedH\n\n\t// Determine the current effective scale of the shape\n\t// This preserves the visual size when the crop changes\n\tlet currentScale = 1.0\n\tif (cropW > 0) {\n\t\tcurrentScale = imageShape.props.w / (cropW * uncroppedW)\n\t} else if (cropH > 0) {\n\t\t// Fallback to height if width relative dimension is zero\n\t\tcurrentScale = imageShape.props.h / (cropH * uncroppedH)\n\t}\n\n\t// Apply the current scale to the base dimensions to get the final dimensions\n\tconst newW = baseW * currentScale\n\tconst newH = baseH * currentScale\n\n\t// Calculate the new top-left position (x, y) for the shape\n\t// to keep the visual center of the cropped area fixed on the page.\n\tconst currentCenterXPage = imageShape.x + imageShape.props.w / 2\n\tconst currentCenterYPage = imageShape.y + imageShape.props.h / 2\n\tconst newX = currentCenterXPage - newW / 2\n\tconst newY = currentCenterYPage - newH / 2\n\n\treturn {\n\t\tcrop: newCrop,\n\t\tw: newW,\n\t\th: newH,\n\t\tx: newX,\n\t\ty: newY,\n\t}\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;;;;;;AAaO,MAAM,gBAAgB;AAStB,SAAS,iBAA8B;IAC7C,OAAO;QACN,SAAS;YAAE,GAAG;YAAG,GAAG;QAAE;QACtB,aAAa;YAAE,GAAG;YAAG,GAAG;QAAE;IAC3B;AACD;AAYO,MAAM,uBAA8C;IAC1D;IACA;IACA;IACA;IACA;IACA;CACD;AAGO,MAAM,wBAA6D;IACzE,UAAU;IACV,QAAQ;IACR,QAAQ;IACR,WAAW,IAAI;IACf,UAAU,IAAI;IACd,MAAM,KAAK;AACZ;AAOO,SAAS,iBACf,SAAA,EACA,IAAA,EAC2B;IAC3B,IAAI,CAAC,KAAM,CAAA,OAAO;QAAE,GAAG,UAAU,CAAA;QAAG,GAAG,UAAU,CAAA;IAAE;IACnD,MAAM,IAAI,UAAU,CAAA,GAAA,CAAK,KAAK,WAAA,CAAY,CAAA,GAAI,KAAK,OAAA,CAAQ,CAAA;IAC3D,MAAM,IAAI,UAAU,CAAA,GAAA,CAAK,KAAK,WAAA,CAAY,CAAA,GAAI,KAAK,OAAA,CAAQ,CAAA;IAC3D,OAAO;QAAE;QAAG;IAAE;AACf;AAGA,SAAS,kBAAkB,IAAA,EAAmB;IAC7C,OAAO;QACN,OAAO,KAAK,WAAA,CAAY,CAAA,GAAI,KAAK,OAAA,CAAQ,CAAA;QACzC,QAAQ,KAAK,WAAA,CAAY,CAAA,GAAI,KAAK,OAAA,CAAQ,CAAA;IAC3C;AACD;AAGA,SAAS,cAAc,IAAA,EAAmB;IACzC,MAAM,EAAE,KAAA,EAAO,MAAA,CAAO,CAAA,GAAI,kBAAkB,IAAI;IAChD,OAAO;QACN,GAAG,KAAK,OAAA,CAAQ,CAAA,GAAI,QAAQ;QAC5B,GAAG,KAAK,OAAA,CAAQ,CAAA,GAAI,SAAS;IAC9B;AACD;AAGA,SAAS,uBACR,OAAA,EACA,OAAA,EACA,KAAA,EACA,MAAA,EACA,QAAA,EACC;IACD,MAAM,WAAW,KAAK,GAAA,CAAI,GAAG,KAAK,GAAA,CAAI,IAAI,OAAO,UAAU,QAAQ,CAAC,CAAC;IACrE,MAAM,WAAW,KAAK,GAAA,CAAI,GAAG,KAAK,GAAA,CAAI,IAAI,QAAQ,UAAU,SAAS,CAAC,CAAC;IAEvE,OAAO;QACN,SAAS;YAAE,GAAG;YAAU,GAAG;QAAS;QACpC,aAAa;YAAE,GAAG,WAAW;YAAO,GAAG,WAAW;QAAO;QACzD;IACD;AACD;AAGO,SAAS,WACf,KAAA,EACA,IAAA,EACA,OAAO,CAAC,CAAA,EASI;IACZ,MAAM,EAAE,MAAA,EAAQ,MAAA,EAAQ,IAAA,EAAM,iBAAA,CAAkB,CAAA,GAAI;IACpD,MAAM,EAAE,CAAA,EAAG,CAAA,CAAE,CAAA,GAAI,KAAK,aAAA;IACtB,MAAM,EAAE,WAAW,aAAA,EAAe,YAAY,aAAA,CAAc,CAAA,GAAI;IAEhE,IAAI,IAAI,YAAY,IAAI,aAAc,OAAO,CAAA,KAAM,KAAK,OAAO,CAAA,KAAM,GAAI;QACxE;IACD;IAIA,MAAM,cAAc,sLAAI,MAAA,CACvB,KAAK,OAAA,CAAQ,CAAA,GAAI,GACjB,KAAK,OAAA,CAAQ,CAAA,GAAI,GAAA,CAChB,KAAK,WAAA,CAAY,CAAA,GAAI,KAAK,OAAA,CAAQ,CAAA,IAAK,GAAA,CACvC,KAAK,WAAA,CAAY,CAAA,GAAI,KAAK,OAAA,CAAQ,CAAA,IAAK;IAGzC,MAAM,cAAc,YAAY,WAAA;IAChC,MAAM,UAAU,YAAY,KAAA,CAAM;IAIlC,IAAI,WAAW,cAAc,WAAW,iBAAiB,WAAW,QAAQ;QAC3E,QAAQ,CAAA,0LAAI,SAAA,EAAM,QAAQ,CAAA,GAAI,OAAO,CAAA,EAAG,GAAG,YAAY,IAAA,GAAO,QAAQ;QACtE,QAAQ,CAAA,GAAI,YAAY,IAAA,GAAO,QAAQ,CAAA;IACxC,OAAA,IAAW,WAAW,eAAe,WAAW,kBAAkB,WAAW,SAAS;QACrF,MAAM,mMAAY,SAAA,EAAM,QAAQ,IAAA,GAAO,OAAO,CAAA,EAAG,YAAY,CAAA,GAAI,UAAU,CAAC;QAC5E,QAAQ,CAAA,GAAI,YAAY,QAAQ,CAAA;IACjC;IAEA,IAAI,WAAW,cAAc,WAAW,eAAe,WAAW,OAAO;QACxE,QAAQ,CAAA,2LAAI,QAAA,EAAM,QAAQ,CAAA,GAAI,OAAO,CAAA,EAAG,GAAG,YAAY,IAAA,GAAO,SAAS;QACvE,QAAQ,CAAA,GAAI,YAAY,IAAA,GAAO,QAAQ,CAAA;IACxC,OAAA,IAAW,WAAW,iBAAiB,WAAW,kBAAkB,WAAW,UAAU;QACxF,MAAM,cAAa,+LAAA,EAAM,QAAQ,IAAA,GAAO,OAAO,CAAA,EAAG,YAAY,CAAA,GAAI,WAAW,CAAC;QAC9E,QAAQ,CAAA,GAAI,aAAa,QAAQ,CAAA;IAClC;IAIA,IAAI,mBAAmB;QACtB,MAAM,cAAc,QAAQ,WAAA,GAAc;QAE1C,IAAI,aAAa;YAChB,QAAQ,CAAA,GAAI,QAAQ,CAAA,GAAI;QACzB,OAAO;YACN,QAAQ,CAAA,GAAI,QAAQ,CAAA,GAAI;QACzB;QAEA,OAAQ,QAAQ;YACf,KAAK;gBAAY;oBAEhB,QAAQ,CAAA,GAAI,YAAY,IAAA,GAAO,QAAQ,CAAA;oBACvC,QAAQ,CAAA,GAAI,YAAY,IAAA,GAAO,QAAQ,CAAA;oBAEvC,IAAI,QAAQ,CAAA,IAAK,GAAG;wBACnB,QAAQ,CAAA,GAAI;wBACZ,QAAQ,CAAA,GAAI,YAAY,IAAA,GAAO,QAAQ,CAAA;wBACvC,QAAQ,CAAA,GAAI,QAAQ,CAAA,GAAI;wBACxB,QAAQ,CAAA,GAAI,YAAY,IAAA,GAAO,QAAQ,CAAA;oBACxC;oBAEA,IAAI,QAAQ,CAAA,IAAK,GAAG;wBACnB,QAAQ,CAAA,GAAI;wBACZ,QAAQ,CAAA,GAAI,YAAY,IAAA,GAAO,QAAQ,CAAA;wBACvC,QAAQ,CAAA,GAAI,QAAQ,CAAA,GAAI;wBACxB,QAAQ,CAAA,GAAI,YAAY,IAAA,GAAO,QAAQ,CAAA;oBACxC;oBACA;gBACD;YACA,KAAK;gBAAa;oBAEjB,QAAQ,CAAA,GAAI,YAAY,CAAA;oBACxB,QAAQ,CAAA,GAAI,YAAY,IAAA,GAAO,QAAQ,CAAA;oBAEvC,IAAI,QAAQ,IAAA,IAAQ,GAAG;wBACtB,QAAQ,CAAA,GAAI,IAAI,YAAY,CAAA;wBAC5B,QAAQ,CAAA,GAAI,QAAQ,CAAA,GAAI;wBACxB,QAAQ,CAAA,GAAI,YAAY,IAAA,GAAO,QAAQ,CAAA;oBACxC;oBAEA,IAAI,QAAQ,CAAA,IAAK,GAAG;wBACnB,QAAQ,CAAA,GAAI;wBACZ,QAAQ,CAAA,GAAI,YAAY,IAAA,GAAO,QAAQ,CAAA;wBACvC,QAAQ,CAAA,GAAI,QAAQ,CAAA,GAAI;oBACzB;oBACA;gBACD;YACA,KAAK;gBAAe;oBAEnB,QAAQ,CAAA,GAAI,YAAY,IAAA,GAAO,QAAQ,CAAA;oBACvC,QAAQ,CAAA,GAAI,YAAY,CAAA;oBAExB,IAAI,QAAQ,CAAA,IAAK,GAAG;wBACnB,QAAQ,CAAA,GAAI;wBACZ,QAAQ,CAAA,GAAI,YAAY,IAAA,GAAO,QAAQ,CAAA;wBACvC,QAAQ,CAAA,GAAI,QAAQ,CAAA,GAAI;oBACzB;oBAEA,IAAI,QAAQ,IAAA,IAAQ,GAAG;wBACtB,QAAQ,CAAA,GAAI,IAAI,YAAY,CAAA;wBAC5B,QAAQ,CAAA,GAAI,QAAQ,CAAA,GAAI;wBACxB,QAAQ,CAAA,GAAI,YAAY,IAAA,GAAO,QAAQ,CAAA;oBACxC;oBACA;gBACD;YACA,KAAK;gBAAgB;oBAEpB,QAAQ,CAAA,GAAI,YAAY,CAAA;oBACxB,QAAQ,CAAA,GAAI,YAAY,CAAA;oBAExB,IAAI,QAAQ,IAAA,IAAQ,GAAG;wBACtB,QAAQ,CAAA,GAAI,IAAI,YAAY,CAAA;wBAC5B,QAAQ,CAAA,GAAI,QAAQ,CAAA,GAAI;oBACzB;oBAEA,IAAI,QAAQ,IAAA,IAAQ,GAAG;wBACtB,QAAQ,CAAA,GAAI,IAAI,YAAY,CAAA;wBAC5B,QAAQ,CAAA,GAAI,QAAQ,CAAA,GAAI;oBACzB;oBACA;gBACD;YACA,KAAK;gBAAO;oBAEX,QAAQ,CAAA,GAAI,YAAY,IAAA,GAAO,QAAQ,CAAA;oBACvC,QAAQ,CAAA,GAAI,QAAQ,CAAA,GAAI;oBACxB,QAAQ,CAAA,IAAA,CAAM,QAAQ,CAAA,GAAI,YAAY,CAAA,IAAK;oBAE3C,IAAI,QAAQ,CAAA,IAAK,GAAG;wBACnB,MAAM,WAAW,YAAY,IAAA;wBAC7B,QAAQ,CAAA,GAAI,WAAW;wBACvB,QAAQ,CAAA,GAAI,QAAQ,CAAA,GAAI;wBACxB,QAAQ,CAAA,GAAI;oBACb;oBAEA,IAAI,QAAQ,IAAA,IAAQ,GAAG;wBACtB,MAAM,YAAY,IAAI,YAAY,IAAA;wBAClC,QAAQ,CAAA,GAAI,YAAY;wBACxB,QAAQ,CAAA,GAAI,QAAQ,CAAA,GAAI;wBACxB,QAAQ,CAAA,GAAI,IAAI,QAAQ,CAAA;oBACzB;oBAEA,QAAQ,CAAA,GAAI,YAAY,IAAA,GAAO,QAAQ,CAAA;oBACvC;gBACD;YACA,KAAK;gBAAS;oBAEb,QAAQ,CAAA,GAAI,QAAQ,IAAA,GAAO,YAAY,CAAA;oBACvC,QAAQ,CAAA,GAAI,QAAQ,CAAA,GAAI;oBACxB,QAAQ,CAAA,IAAA,CAAM,QAAQ,CAAA,GAAI,YAAY,CAAA,IAAK;oBAE3C,IAAI,QAAQ,CAAA,IAAK,GAAG;wBACnB,MAAM,UAAU,YAAY,IAAA;wBAC5B,QAAQ,CAAA,GAAI,UAAU;wBACtB,QAAQ,CAAA,GAAI,QAAQ,CAAA,GAAI;wBACxB,QAAQ,CAAA,GAAI;oBACb;oBAEA,IAAI,QAAQ,IAAA,IAAQ,GAAG;wBACtB,MAAM,aAAa,IAAI,YAAY,IAAA;wBACnC,QAAQ,CAAA,GAAI,aAAa;wBACzB,QAAQ,CAAA,GAAI,QAAQ,CAAA,GAAI;wBACxB,QAAQ,CAAA,GAAI,IAAI,QAAQ,CAAA;oBACzB;oBACA;gBACD;YACA,KAAK;gBAAU;oBAEd,QAAQ,CAAA,GAAI,QAAQ,IAAA,GAAO,YAAY,CAAA;oBACvC,QAAQ,CAAA,GAAI,QAAQ,CAAA,GAAI;oBACxB,QAAQ,CAAA,IAAA,CAAM,QAAQ,CAAA,GAAI,YAAY,CAAA,IAAK;oBAE3C,IAAI,QAAQ,CAAA,IAAK,GAAG;wBACnB,MAAM,WAAW,YAAY,IAAA;wBAC7B,QAAQ,CAAA,GAAI,WAAW;wBACvB,QAAQ,CAAA,GAAI,QAAQ,CAAA,GAAI;wBACxB,QAAQ,CAAA,GAAI;oBACb;oBAEA,IAAI,QAAQ,IAAA,IAAQ,GAAG;wBACtB,MAAM,YAAY,IAAI,YAAY,IAAA;wBAClC,QAAQ,CAAA,GAAI,YAAY;wBACxB,QAAQ,CAAA,GAAI,QAAQ,CAAA,GAAI;wBACxB,QAAQ,CAAA,GAAI,IAAI,QAAQ,CAAA;oBACzB;oBACA;gBACD;YACA,KAAK;gBAAQ;oBAEZ,QAAQ,CAAA,GAAI,YAAY,IAAA,GAAO,QAAQ,CAAA;oBACvC,QAAQ,CAAA,GAAI,QAAQ,CAAA,GAAI;oBACxB,QAAQ,CAAA,IAAA,CAAM,QAAQ,CAAA,GAAI,YAAY,CAAA,IAAK;oBAE3C,IAAI,QAAQ,CAAA,IAAK,GAAG;wBACnB,MAAM,UAAU,YAAY,IAAA;wBAC5B,QAAQ,CAAA,GAAI,UAAU;wBACtB,QAAQ,CAAA,GAAI,QAAQ,CAAA,GAAI;wBACxB,QAAQ,CAAA,GAAI;oBACb;oBAEA,IAAI,QAAQ,IAAA,IAAQ,GAAG;wBACtB,MAAM,aAAa,IAAI,YAAY,IAAA;wBACnC,QAAQ,CAAA,GAAI,aAAa;wBACzB,QAAQ,CAAA,GAAI,QAAQ,CAAA,GAAI;wBACxB,QAAQ,CAAA,GAAI,IAAI,QAAQ,CAAA;oBACzB;oBAEA,QAAQ,CAAA,GAAI,YAAY,IAAA,GAAO,QAAQ,CAAA;oBACvC;gBACD;QACD;IACD;IAGA,MAAM,UAAuB;QAC5B,SAAS;YAAE,GAAG,QAAQ,CAAA,GAAI;YAAG,GAAG,QAAQ,CAAA,GAAI;QAAE;QAC9C,aAAa;YAAE,GAAG,QAAQ,IAAA,GAAO;YAAG,GAAG,QAAQ,IAAA,GAAO;QAAE;QACxD,UAAU,KAAK,QAAA;IAChB;IAGA,IACC,QAAQ,OAAA,CAAQ,CAAA,KAAM,KAAK,OAAA,CAAQ,CAAA,IACnC,QAAQ,OAAA,CAAQ,CAAA,KAAM,KAAK,OAAA,CAAQ,CAAA,IACnC,QAAQ,WAAA,CAAY,CAAA,KAAM,KAAK,WAAA,CAAY,CAAA,IAC3C,QAAQ,WAAA,CAAY,CAAA,KAAM,KAAK,WAAA,CAAY,CAAA,EAC1C;QACD;IACD;IAGA,MAAM,WAAW,sLAAI,MAAA,CAAI,QAAQ,CAAA,GAAI,KAAK,OAAA,CAAQ,CAAA,GAAI,GAAG,QAAQ,CAAA,GAAI,KAAK,OAAA,CAAQ,CAAA,GAAI,CAAC,EACrF,GAAA,CAAI,MAAM,QAAQ,EAClB,GAAA,CAAI,KAAK;IAEX,OAAO;QACN,IAAI,MAAM,EAAA;QACV,MAAM,MAAM,IAAA;QACZ,GAAG,SAAS,CAAA;QACZ,GAAG,SAAS,CAAA;QACZ,OAAO;YACN,GAAG,QAAQ,CAAA;YACX,GAAG,QAAQ,CAAA;YACX,MAAM;QACP;IACD;AACD;AAeA,SAAS,oBACR,UAAA,EACA,YAAA,EACA,aAAA,EACA,sBAA+B,IAAA,EAC/B,WAAoB,KAAA,EACP;IACb,MAAM,EAAE,CAAA,EAAG,CAAA,CAAE,CAAA,GAAI,iBAAiB,WAAW,KAAA,EAAO,WAAW,KAAA,CAAM,IAAA,IAAQ,eAAe,CAAC;IAC7F,MAAM,cAAc,WAAW,KAAA,CAAM,IAAA,IAAQ,eAAe;IAG5D,MAAM,eAAe,WAAW,CAAA,GAAI,WAAW,KAAA,CAAM,CAAA,GAAI;IACzD,MAAM,eAAe,WAAW,CAAA,GAAI,WAAW,KAAA,CAAM,CAAA,GAAI;IAEzD,IAAI,aAAa;IACjB,IAAI,qBAAqB;QACxB,MAAM,EAAE,CAAA,EAAG,CAAA,CAAE,CAAA,GAAI,cAAc,WAAW;QAC1C,cAAc;QACd,cAAc;IACf,OAAO;QACN,cAAc;QACd,cAAc;IACf;IAGA,MAAM,UAAU,uBACf,aACA,aACA,cACA,eACA;IAID,MAAM,WAAW,eAAe;IAChC,MAAM,WAAW,gBAAgB;IAEjC,OAAO;QACN,MAAM;QACN,GAAG;QACH,GAAG;QACH,GAAG,eAAe,WAAW;QAC7B,GAAG,eAAe,WAAW;IAC9B;AACD;AAGO,MAAM,WAAW;AAKjB,SAAS,+BACf,IAAA,EACA,UAAA,EACA,OAAA,EACa;IACb,MAAM,UAAU,WAAW,KAAA,CAAM,IAAA,IAAQ,eAAe;IACxD,MAAM,EAAE,OAAO,QAAA,EAAU,QAAQ,SAAA,CAAU,CAAA,GAAI,kBAAkB,OAAO;IACxE,MAAM,cAAc,WAAW;IAG/B,MAAM,iBAAiB,UAAU,IAAA,CAAK,IAAI,OAAA,IAAW;IACrD,MAAM,YAAY,IAAI,OAAA,CAAQ,iBAAiB,CAAA;IAC/C,IAAI,UAAU;IAEd,IAAI,cAAc,GAAG;QACpB,WAAW,KAAK,GAAA,CAAI,GAAG,IAAI,SAAS;QACpC,YAAY,WAAW;IACxB,OAAO;QACN,YAAY,KAAK,GAAA,CAAI,GAAG,IAAI,SAAS;QACrC,WAAW,YAAY;IACxB;IAGA,MAAM,SAAS,oBAAoB,YAAY,UAAU,WAAW,MAAM,QAAQ,QAAQ;IAG1F,MAAM,cAAc,KAAK,GAAA,CAAI,UAAU,WAAW,QAAQ;IAC1D,OAAO,CAAA,IAAK;IACZ,OAAO,CAAA,IAAK;IAGZ,MAAM,eAAe,WAAW,CAAA,GAAI,WAAW,KAAA,CAAM,CAAA,GAAI;IACzD,MAAM,eAAe,WAAW,CAAA,GAAI,WAAW,KAAA,CAAM,CAAA,GAAI;IACzD,OAAO,CAAA,GAAI,eAAe,OAAO,CAAA,GAAI;IACrC,OAAO,CAAA,GAAI,eAAe,OAAO,CAAA,GAAI;IAErC,OAAO;AACR;AAKO,SAAS,oCACf,UAAA,EACA,aAAA,EACA,cAAA,EACa;IACb,MAAM,cAAc,eAAe;IACnC,MAAM,cAAc,WAAW,KAAA,CAAM,IAAA,IAAQ;IAC7C,MAAM,eAAe,WAAW,KAAA,CAAM,CAAA;IACtC,MAAM,eAAe,WAAW,KAAA,CAAM,CAAA;IACtC,MAAM,sBAAsB,gBAAgB;IAE5C,IAAI,OAAO;IACX,IAAI,cAAc;IAClB,IAAI,cAAc;IAClB,MAAM,qBAAiB,8LAAA,EAAQ,WAAW,KAAA,CAAM,IAAA,EAAM,WAAW;IAEjE,IAAI,gBAAgB;QACnB,cAAc;QACd,cAAe,eAAe,iBAAkB;IACjD,OAAO;QACN,MAAM,EAAE,GAAG,UAAA,EAAY,GAAG,UAAA,CAAW,CAAA,GAAI,iBACxC,WAAW,KAAA,EACX,WAAW,KAAA,CAAM,IAAA,IAAQ,eAAe;QAEzC,MAAM,EAAE,OAAO,KAAA,EAAO,QAAQ,KAAA,CAAM,CAAA,GAAI,kBAAkB,WAAW;QACrE,MAAM,cAAc,QAAQ;QAC5B,MAAM,sBAAsB,aAAa;QACzC,IAAI;QACJ,IAAI;QAEJ,MAAM,oBAAoB,cAAc,WAAW;QAGnD,mBAAmB;QACnB,MAAM,kBAAkB,sBAAsB,sBAAsB;QACpE,oBAAoB,mBAAmB;QAGvC,MAAM,qBAAqB,WAAA,CAAY,WAAW,CAAA;QAClD,IAAI,kBAAkB,oBAAoB;YACzC,MAAM,eAAe,IAAI;YACzB,IAAI,IAAI,oBAAoB,IAAI,kBAAkB;gBACjD,MAAM,QAAQ,oBAAoB;gBAClC,oBAAoB,oBAAoB;gBACxC,mBAAmB,mBAAmB;YACvC,OAAO;gBACN,MAAM,QAAQ,mBAAmB;gBACjC,mBAAmB,mBAAmB;gBACtC,oBAAoB,oBAAoB;YACzC;QACD;QAGA,mBAAmB,KAAK,GAAA,CAAI,GAAG,KAAK,GAAA,CAAI,GAAG,gBAAgB,CAAC;QAC5D,oBAAoB,KAAK,GAAA,CAAI,GAAG,KAAK,GAAA,CAAI,GAAG,iBAAiB,CAAC;QAG9D,OAAO,uBACN,kBAAkB,CAAA,EAClB,kBAAkB,CAAA,EAClB,kBACA,mBACA,YAAY,QAAA;IAEd;IAGA,MAAM,cAAc,WAAW,CAAA,GAAI,eAAe;IAClD,MAAM,cAAc,WAAW,CAAA,GAAI,eAAe;IAElD,MAAM,OAAO,cAAc,cAAc;IACzC,MAAM,OAAO,cAAc,cAAc;IAEzC,OAAO;QACN;QACA,GAAG;QACH,GAAG;QACH,GAAG;QACH,GAAG;IACJ;AACD;AAKO,SAAS,kCACf,iBAAA,EACA,UAAA,EACa;IAEb,IAAI,sBAAsB,YAAY;QACrC,MAAM,EAAE,CAAA,EAAG,CAAA,CAAE,CAAA,GAAI,iBAAiB,WAAW,KAAA,EAAO,WAAW,KAAA,CAAM,IAAA,IAAQ,eAAe,CAAC;QAC7F,MAAM,eAAe,WAAW,CAAA,GAAI,WAAW,KAAA,CAAM,CAAA,GAAI;QACzD,MAAM,eAAe,WAAW,CAAA,GAAI,WAAW,KAAA,CAAM,CAAA,GAAI;QAEzD,OAAO;YACN,MAAM,eAAe;YACrB;YACA;YACA,GAAG,eAAe,IAAI;YACtB,GAAG,eAAe,IAAI;QACvB;IACD;IAGA,MAAM,cAAc,qBAAA,CAAsB,iBAAiB,CAAA;IAC3D,MAAM,WAAW,sBAAsB;IAEvC,MAAM,EAAE,GAAG,UAAA,EAAY,GAAG,UAAA,CAAW,CAAA,GAAI,iBACxC,WAAW,KAAA,EACX,WAAW,KAAA,CAAM,IAAA,IAAQ,eAAe;IAGzC,MAAM,mBAAmB,aAAa;IAGtC,MAAM,cAAc,WAAW,KAAA,CAAM,IAAA,IAAQ,eAAe;IAC5D,MAAM,EAAE,OAAO,KAAA,EAAO,QAAQ,KAAA,CAAM,CAAA,GAAI,kBAAkB,WAAW;IACrE,MAAM,oBAAoB,cAAc,WAAW;IAGnD,MAAM,kBAAkB,KAAK,GAAA,CAAI,IAAI,OAAO,IAAI,KAAK;IAIrD,IAAI;IACJ,IAAI;IAEJ,IAAI,qBAAqB,KAAK,CAAC,OAAO,QAAA,CAAS,gBAAgB,KAAK,gBAAgB,GAAG;QAEtF,mBAAmB;QACnB,oBAAoB;IACrB,OAAO;QAEN,MAAM,uBAAuB,QAAQ;QACrC,MAAM,wBAAwB,QAAQ;QAGtC,MAAM,0BAA0B,KAAK,GAAA,CAAI,sBAAsB,qBAAqB;QACpF,MAAM,iBAAiB,wBAAwB;QAG/C,IAAI;QACJ,IAAI;QAEJ,IAAI,gBAAgB;YAEnB,mBAAmB;YACnB,oBAAoB,mBAAmB;QACxC,OAAO;YAEN,oBAAoB;YACpB,mBAAmB,oBAAoB;QACxC;QAGA,mBAAmB,mBAAmB;QACtC,oBAAoB,oBAAoB;QAGxC,IAAI,mBAAmB,GAAG;YAEzB,mBAAmB;YACnB,oBAAoB,mBAAmB;QACxC;QACA,IAAI,oBAAoB,GAAG;YAE1B,oBAAoB;YACpB,mBAAmB,cAAc;QAClC;QAGA,mBAAmB,KAAK,GAAA,CAAI,GAAG,KAAK,GAAA,CAAI,GAAG,gBAAgB,CAAC;QAC5D,oBAAoB,KAAK,GAAA,CAAI,GAAG,KAAK,GAAA,CAAI,GAAG,iBAAiB,CAAC;IAC/D;IAEA,MAAM,cAAc,KAAK,GAAA,CAAI,IAAI,kBAAkB,IAAI,iBAAiB;IAExE,oBAAoB,cAAc;IAClC,qBAAqB,cAAc;IAGnC,mBAAmB,KAAK,GAAA,CAAI,GAAG,KAAK,GAAA,CAAI,GAAG,gBAAgB,CAAC;IAC5D,oBAAoB,KAAK,GAAA,CAAI,GAAG,KAAK,GAAA,CAAI,GAAG,iBAAiB,CAAC;IAG9D,MAAM,UAAU,uBACf,kBAAkB,CAAA,EAClB,kBAAkB,CAAA,EAClB,kBACA,mBACA;IAID,MAAM,qBAAqB,QAAQ,WAAA,CAAY,CAAA,GAAI,QAAQ,OAAA,CAAQ,CAAA;IACnE,MAAM,sBAAsB,QAAQ,WAAA,CAAY,CAAA,GAAI,QAAQ,OAAA,CAAQ,CAAA;IAGpE,MAAM,QAAQ,qBAAqB;IACnC,MAAM,QAAQ,sBAAsB;IAIpC,IAAI,eAAe;IACnB,IAAI,QAAQ,GAAG;QACd,eAAe,WAAW,KAAA,CAAM,CAAA,GAAA,CAAK,QAAQ,UAAA;IAC9C,OAAA,IAAW,QAAQ,GAAG;QAErB,eAAe,WAAW,KAAA,CAAM,CAAA,GAAA,CAAK,QAAQ,UAAA;IAC9C;IAGA,MAAM,OAAO,QAAQ;IACrB,MAAM,OAAO,QAAQ;IAIrB,MAAM,qBAAqB,WAAW,CAAA,GAAI,WAAW,KAAA,CAAM,CAAA,GAAI;IAC/D,MAAM,qBAAqB,WAAW,CAAA,GAAI,WAAW,KAAA,CAAM,CAAA,GAAI;IAC/D,MAAM,OAAO,qBAAqB,OAAO;IACzC,MAAM,OAAO,qBAAqB,OAAO;IAEzC,OAAO;QACN,MAAM;QACN,GAAG;QACH,GAAG;QACH,GAAG;QACH,GAAG;IACJ;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4007, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/shared/default-shape-constants.ts"],"sourcesContent":["import { TLDefaultFontStyle, TLDefaultSizeStyle } from '@tldraw/editor'\n\n/** @public */\nexport const TEXT_PROPS = {\n\tlineHeight: 1.35,\n\tfontWeight: 'normal',\n\tfontVariant: 'normal',\n\tfontStyle: 'normal',\n\tpadding: '0px',\n}\n\n/** @public */\nexport const STROKE_SIZES: Record<TLDefaultSizeStyle, number> = {\n\ts: 2,\n\tm: 3.5,\n\tl: 5,\n\txl: 10,\n}\n\n/** @public */\nexport const FONT_SIZES: Record<TLDefaultSizeStyle, number> = {\n\ts: 18,\n\tm: 24,\n\tl: 36,\n\txl: 44,\n}\n\n/** @public */\nexport const LABEL_FONT_SIZES: Record<TLDefaultSizeStyle, number> = {\n\ts: 18,\n\tm: 22,\n\tl: 26,\n\txl: 32,\n}\n\n/** @public */\nexport const ARROW_LABEL_FONT_SIZES: Record<TLDefaultSizeStyle, number> = {\n\ts: 18,\n\tm: 20,\n\tl: 24,\n\txl: 28,\n}\n\n/** @public */\nexport const FONT_FAMILIES: Record<TLDefaultFontStyle, string> = {\n\tdraw: 'var(--tl-font-draw)',\n\tsans: 'var(--tl-font-sans)',\n\tserif: 'var(--tl-font-serif)',\n\tmono: 'var(--tl-font-mono)',\n}\n\n/** @internal */\nexport const LABEL_TO_ARROW_PADDING = 20\n/** @internal */\nexport const ARROW_LABEL_PADDING = 4.25\n/** @internal */\nexport const LABEL_PADDING = 16\n"],"names":[],"mappings":";;;;;;;;;;;AAGO,MAAM,aAAa;IACzB,YAAY;IACZ,YAAY;IACZ,aAAa;IACb,WAAW;IACX,SAAS;AACV;AAGO,MAAM,eAAmD;IAC/D,GAAG;IACH,GAAG;IACH,GAAG;IACH,IAAI;AACL;AAGO,MAAM,aAAiD;IAC7D,GAAG;IACH,GAAG;IACH,GAAG;IACH,IAAI;AACL;AAGO,MAAM,mBAAuD;IACnE,GAAG;IACH,GAAG;IACH,GAAG;IACH,IAAI;AACL;AAGO,MAAM,yBAA6D;IACzE,GAAG;IACH,GAAG;IACH,GAAG;IACH,IAAI;AACL;AAGO,MAAM,gBAAoD;IAChE,MAAM;IACN,MAAM;IACN,OAAO;IACP,MAAM;AACP;AAGO,MAAM,yBAAyB;AAE/B,MAAM,sBAAsB;AAE5B,MAAM,gBAAgB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4066, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/shared/defaultFonts.tsx"],"sourcesContent":["import { objectMapValues, TLFontFace } from '@tldraw/editor'\n\n/** @public */\nexport interface TLDefaultFont {\n\tnormal: {\n\t\tnormal: TLFontFace\n\t\tbold: TLFontFace\n\t}\n\titalic: {\n\t\tnormal: TLFontFace\n\t\tbold: TLFontFace\n\t}\n}\n/** @public */\nexport interface TLDefaultFonts {\n\ttldraw_draw: TLDefaultFont\n\ttldraw_sans: TLDefaultFont\n\ttldraw_serif: TLDefaultFont\n\ttldraw_mono: TLDefaultFont\n}\n\n/** @public */\nexport const DefaultFontFaces: TLDefaultFonts = {\n\ttldraw_draw: {\n\t\tnormal: {\n\t\t\tnormal: {\n\t\t\t\tfamily: 'tldraw_draw',\n\t\t\t\tsrc: { url: 'tldraw_draw', format: 'woff2' },\n\t\t\t\tweight: 'normal',\n\t\t\t},\n\t\t\tbold: {\n\t\t\t\tfamily: 'tldraw_draw',\n\t\t\t\tsrc: { url: 'tldraw_draw_bold', format: 'woff2' },\n\t\t\t\tweight: 'bold',\n\t\t\t},\n\t\t},\n\t\titalic: {\n\t\t\tnormal: {\n\t\t\t\tfamily: 'tldraw_draw',\n\t\t\t\tsrc: { url: 'tldraw_draw_italic', format: 'woff2' },\n\t\t\t\tweight: 'normal',\n\t\t\t\tstyle: 'italic',\n\t\t\t},\n\t\t\tbold: {\n\t\t\t\tfamily: 'tldraw_draw',\n\t\t\t\tsrc: { url: 'tldraw_draw_italic_bold', format: 'woff2' },\n\t\t\t\tweight: 'bold',\n\t\t\t\tstyle: 'italic',\n\t\t\t},\n\t\t},\n\t},\n\ttldraw_sans: {\n\t\tnormal: {\n\t\t\tnormal: {\n\t\t\t\tfamily: 'tldraw_sans',\n\t\t\t\tsrc: { url: 'tldraw_sans', format: 'woff2' },\n\t\t\t\tweight: 'normal',\n\t\t\t\tstyle: 'normal',\n\t\t\t},\n\t\t\tbold: {\n\t\t\t\tfamily: 'tldraw_sans',\n\t\t\t\tsrc: { url: 'tldraw_sans_bold', format: 'woff2' },\n\t\t\t\tweight: 'bold',\n\t\t\t\tstyle: 'normal',\n\t\t\t},\n\t\t},\n\t\titalic: {\n\t\t\tnormal: {\n\t\t\t\tfamily: 'tldraw_sans',\n\t\t\t\tsrc: { url: 'tldraw_sans_italic', format: 'woff2' },\n\t\t\t\tweight: 'normal',\n\t\t\t\tstyle: 'italic',\n\t\t\t},\n\t\t\tbold: {\n\t\t\t\tfamily: 'tldraw_sans',\n\t\t\t\tsrc: { url: 'tldraw_sans_italic_bold', format: 'woff2' },\n\t\t\t\tweight: 'bold',\n\t\t\t\tstyle: 'italic',\n\t\t\t},\n\t\t},\n\t},\n\ttldraw_serif: {\n\t\tnormal: {\n\t\t\tnormal: {\n\t\t\t\tfamily: 'tldraw_serif',\n\t\t\t\tsrc: { url: 'tldraw_serif', format: 'woff2' },\n\t\t\t\tweight: 'normal',\n\t\t\t\tstyle: 'normal',\n\t\t\t},\n\t\t\tbold: {\n\t\t\t\tfamily: 'tldraw_serif',\n\t\t\t\tsrc: { url: 'tldraw_serif_bold', format: 'woff2' },\n\t\t\t\tweight: 'bold',\n\t\t\t\tstyle: 'normal',\n\t\t\t},\n\t\t},\n\t\titalic: {\n\t\t\tnormal: {\n\t\t\t\tfamily: 'tldraw_serif',\n\t\t\t\tsrc: { url: 'tldraw_serif_italic', format: 'woff2' },\n\t\t\t\tweight: 'normal',\n\t\t\t\tstyle: 'italic',\n\t\t\t},\n\t\t\tbold: {\n\t\t\t\tfamily: 'tldraw_serif',\n\t\t\t\tsrc: { url: 'tldraw_serif_italic_bold', format: 'woff2' },\n\t\t\t\tweight: 'bold',\n\t\t\t\tstyle: 'italic',\n\t\t\t},\n\t\t},\n\t},\n\ttldraw_mono: {\n\t\tnormal: {\n\t\t\tnormal: {\n\t\t\t\tfamily: 'tldraw_mono',\n\t\t\t\tsrc: { url: 'tldraw_mono', format: 'woff2' },\n\t\t\t\tweight: 'normal',\n\t\t\t\tstyle: 'normal',\n\t\t\t},\n\t\t\tbold: {\n\t\t\t\tfamily: 'tldraw_mono',\n\t\t\t\tsrc: { url: 'tldraw_mono_bold', format: 'woff2' },\n\t\t\t\tweight: 'bold',\n\t\t\t\tstyle: 'normal',\n\t\t\t},\n\t\t},\n\t\titalic: {\n\t\t\tnormal: {\n\t\t\t\tfamily: 'tldraw_mono',\n\t\t\t\tsrc: { url: 'tldraw_mono_italic', format: 'woff2' },\n\t\t\t\tweight: 'normal',\n\t\t\t\tstyle: 'italic',\n\t\t\t},\n\t\t\tbold: {\n\t\t\t\tfamily: 'tldraw_mono',\n\t\t\t\tsrc: { url: 'tldraw_mono_italic_bold', format: 'woff2' },\n\t\t\t\tweight: 'bold',\n\t\t\t\tstyle: 'italic',\n\t\t\t},\n\t\t},\n\t},\n}\n\n/** @public */\nexport const allDefaultFontFaces = objectMapValues(DefaultFontFaces).flatMap((font) =>\n\tobjectMapValues(font).flatMap((fontFace) => Object.values(fontFace))\n)\n"],"names":[],"mappings":";;;;AAAA,SAAS,uBAAmC;;;AAsBrC,MAAM,mBAAmC;IAC/C,aAAa;QACZ,QAAQ;YACP,QAAQ;gBACP,QAAQ;gBACR,KAAK;oBAAE,KAAK;oBAAe,QAAQ;gBAAQ;gBAC3C,QAAQ;YACT;YACA,MAAM;gBACL,QAAQ;gBACR,KAAK;oBAAE,KAAK;oBAAoB,QAAQ;gBAAQ;gBAChD,QAAQ;YACT;QACD;QACA,QAAQ;YACP,QAAQ;gBACP,QAAQ;gBACR,KAAK;oBAAE,KAAK;oBAAsB,QAAQ;gBAAQ;gBAClD,QAAQ;gBACR,OAAO;YACR;YACA,MAAM;gBACL,QAAQ;gBACR,KAAK;oBAAE,KAAK;oBAA2B,QAAQ;gBAAQ;gBACvD,QAAQ;gBACR,OAAO;YACR;QACD;IACD;IACA,aAAa;QACZ,QAAQ;YACP,QAAQ;gBACP,QAAQ;gBACR,KAAK;oBAAE,KAAK;oBAAe,QAAQ;gBAAQ;gBAC3C,QAAQ;gBACR,OAAO;YACR;YACA,MAAM;gBACL,QAAQ;gBACR,KAAK;oBAAE,KAAK;oBAAoB,QAAQ;gBAAQ;gBAChD,QAAQ;gBACR,OAAO;YACR;QACD;QACA,QAAQ;YACP,QAAQ;gBACP,QAAQ;gBACR,KAAK;oBAAE,KAAK;oBAAsB,QAAQ;gBAAQ;gBAClD,QAAQ;gBACR,OAAO;YACR;YACA,MAAM;gBACL,QAAQ;gBACR,KAAK;oBAAE,KAAK;oBAA2B,QAAQ;gBAAQ;gBACvD,QAAQ;gBACR,OAAO;YACR;QACD;IACD;IACA,cAAc;QACb,QAAQ;YACP,QAAQ;gBACP,QAAQ;gBACR,KAAK;oBAAE,KAAK;oBAAgB,QAAQ;gBAAQ;gBAC5C,QAAQ;gBACR,OAAO;YACR;YACA,MAAM;gBACL,QAAQ;gBACR,KAAK;oBAAE,KAAK;oBAAqB,QAAQ;gBAAQ;gBACjD,QAAQ;gBACR,OAAO;YACR;QACD;QACA,QAAQ;YACP,QAAQ;gBACP,QAAQ;gBACR,KAAK;oBAAE,KAAK;oBAAuB,QAAQ;gBAAQ;gBACnD,QAAQ;gBACR,OAAO;YACR;YACA,MAAM;gBACL,QAAQ;gBACR,KAAK;oBAAE,KAAK;oBAA4B,QAAQ;gBAAQ;gBACxD,QAAQ;gBACR,OAAO;YACR;QACD;IACD;IACA,aAAa;QACZ,QAAQ;YACP,QAAQ;gBACP,QAAQ;gBACR,KAAK;oBAAE,KAAK;oBAAe,QAAQ;gBAAQ;gBAC3C,QAAQ;gBACR,OAAO;YACR;YACA,MAAM;gBACL,QAAQ;gBACR,KAAK;oBAAE,KAAK;oBAAoB,QAAQ;gBAAQ;gBAChD,QAAQ;gBACR,OAAO;YACR;QACD;QACA,QAAQ;YACP,QAAQ;gBACP,QAAQ;gBACR,KAAK;oBAAE,KAAK;oBAAsB,QAAQ;gBAAQ;gBAClD,QAAQ;gBACR,OAAO;YACR;YACA,MAAM;gBACL,QAAQ;gBACR,KAAK;oBAAE,KAAK;oBAA2B,QAAQ;gBAAQ;gBACvD,QAAQ;gBACR,OAAO;YACR;QACD;IACD;AACD;AAGO,MAAM,gMAAsB,kBAAA,EAAgB,gBAAgB,EAAE,OAAA,CAAQ,CAAC,iLAC7E,kBAAA,EAAgB,IAAI,EAAE,OAAA,CAAQ,CAAC,WAAa,OAAO,MAAA,CAAO,QAAQ,CAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4250, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/shared/TextHelpers.ts"],"sourcesContent":["/**\t@public */\nexport const INDENT = '  '\n\n/** @internal */\nexport class TextHelpers {\n\tstatic fixNewLines = /\\r?\\n|\\r/g\n\n\tstatic normalizeText(text: string) {\n\t\treturn text.replace(TextHelpers.fixNewLines, '\\n')\n\t}\n\n\tstatic normalizeTextForDom(text: string) {\n\t\treturn text\n\t\t\t.replace(TextHelpers.fixNewLines, '\\n')\n\t\t\t.split('\\n')\n\t\t\t.map((x) => x || ' ')\n\t\t\t.join('\\n')\n\t}\n}\n"],"names":[],"mappings":";;;;AACO,MAAM,SAAS;AAGf,MAAM,YAAY;IACxB,OAAO,cAAc,YAAA;IAErB,OAAO,cAAc,IAAA,EAAc;QAClC,OAAO,KAAK,OAAA,CAAQ,YAAY,WAAA,EAAa,IAAI;IAClD;IAEA,OAAO,oBAAoB,IAAA,EAAc;QACxC,OAAO,KACL,OAAA,CAAQ,YAAY,WAAA,EAAa,IAAI,EACrC,KAAA,CAAM,IAAI,EACV,GAAA,CAAI,CAAC,IAAM,KAAK,GAAG,EACnB,IAAA,CAAK,IAAI;IACZ;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4272, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/arrow/toolStates/Idle.tsx"],"sourcesContent":["import { StateNode, TLKeyboardEventInfo, TLPointerEventInfo, TLShapeId } from '@tldraw/editor'\nimport { ArrowShapeUtil } from '../ArrowShapeUtil'\nimport { clearArrowTargetState, updateArrowTargetState } from '../arrowTargetState'\n\nexport class Idle extends StateNode {\n\tstatic override id = 'idle'\n\n\tisPrecise = false\n\tisPreciseTimerId: number | null = null\n\tpreciseTargetId: TLShapeId | null = null\n\n\toverride onPointerMove() {\n\t\tthis.update()\n\t}\n\n\toverride onPointerDown(info: TLPointerEventInfo) {\n\t\tthis.parent.transition('pointing', { ...info, isPrecise: this.isPrecise })\n\t}\n\n\toverride onEnter() {\n\t\tthis.editor.setCursor({ type: 'cross', rotation: 0 })\n\t\tthis.update()\n\t}\n\n\toverride onCancel() {\n\t\tthis.editor.setCurrentTool('select')\n\t}\n\n\toverride onExit() {\n\t\tclearArrowTargetState(this.editor)\n\t\tif (this.isPreciseTimerId !== null) {\n\t\t\tclearTimeout(this.isPreciseTimerId)\n\t\t}\n\t}\n\n\toverride onKeyDown() {\n\t\tthis.update()\n\t}\n\n\toverride onKeyUp(info: TLKeyboardEventInfo) {\n\t\tthis.update()\n\t\tif (info.key === 'Enter') {\n\t\t\tif (this.editor.getIsReadonly()) return null\n\t\t\tconst onlySelectedShape = this.editor.getOnlySelectedShape()\n\t\t\t// If the only selected shape is editable, start editing it\n\t\t\tif (\n\t\t\t\tonlySelectedShape &&\n\t\t\t\tthis.editor.getShapeUtil(onlySelectedShape).canEdit(onlySelectedShape)\n\t\t\t) {\n\t\t\t\tthis.editor.setCurrentTool('select')\n\t\t\t\tthis.editor.setEditingShape(onlySelectedShape.id)\n\t\t\t\tthis.editor.root.getCurrent()?.transition('editing_shape', {\n\t\t\t\t\t...info,\n\t\t\t\t\ttarget: 'shape',\n\t\t\t\t\tshape: onlySelectedShape,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\tupdate() {\n\t\tconst arrowUtil = this.editor.getShapeUtil<ArrowShapeUtil>('arrow')\n\n\t\tconst targetState = updateArrowTargetState({\n\t\t\teditor: this.editor,\n\t\t\tpointInPageSpace: this.editor.inputs.currentPagePoint,\n\t\t\tarrow: undefined,\n\t\t\tisPrecise: this.isPrecise,\n\t\t\tcurrentBinding: undefined,\n\t\t\toppositeBinding: undefined,\n\t\t})\n\n\t\tif (targetState && targetState.target.id !== this.preciseTargetId) {\n\t\t\tif (this.isPreciseTimerId !== null) {\n\t\t\t\tclearTimeout(this.isPreciseTimerId)\n\t\t\t}\n\n\t\t\tthis.preciseTargetId = targetState.target.id\n\t\t\tthis.isPreciseTimerId = this.editor.timers.setTimeout(() => {\n\t\t\t\tthis.isPrecise = true\n\t\t\t\tthis.update()\n\t\t\t}, arrowUtil.options.hoverPreciseTimeout)\n\t\t} else if (!targetState && this.preciseTargetId) {\n\t\t\tthis.isPrecise = false\n\t\t\tthis.preciseTargetId = null\n\t\t\tif (this.isPreciseTimerId !== null) {\n\t\t\t\tclearTimeout(this.isPreciseTimerId)\n\t\t\t}\n\t\t}\n\t}\n}\n"],"names":[],"mappings":";;;AAAA,SAAS,iBAAqE;;AAE9E,SAAS,uBAAuB,8BAA8B;;;AAEvD,MAAM,0MAAa,YAAA,CAAU;IACnC,OAAgB,KAAK,OAAA;IAErB,YAAY,MAAA;IACZ,mBAAkC,KAAA;IAClC,kBAAoC,KAAA;IAE3B,gBAAgB;QACxB,IAAA,CAAK,MAAA,CAAO;IACb;IAES,cAAc,IAAA,EAA0B;QAChD,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,YAAY;YAAE,GAAG,IAAA;YAAM,WAAW,IAAA,CAAK,SAAA;QAAU,CAAC;IAC1E;IAES,UAAU;QAClB,IAAA,CAAK,MAAA,CAAO,SAAA,CAAU;YAAE,MAAM;YAAS,UAAU;QAAE,CAAC;QACpD,IAAA,CAAK,MAAA,CAAO;IACb;IAES,WAAW;QACnB,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,QAAQ;IACpC;IAES,SAAS;QACjB,CAAA,GAAA,uLAAA,CAAA,wBAAA,EAAsB,IAAA,CAAK,MAAM;QACjC,IAAI,IAAA,CAAK,gBAAA,KAAqB,MAAM;YACnC,aAAa,IAAA,CAAK,gBAAgB;QACnC;IACD;IAES,YAAY;QACpB,IAAA,CAAK,MAAA,CAAO;IACb;IAES,QAAQ,IAAA,EAA2B;QAC3C,IAAA,CAAK,MAAA,CAAO;QACZ,IAAI,KAAK,GAAA,KAAQ,SAAS;YACzB,IAAI,IAAA,CAAK,MAAA,CAAO,aAAA,CAAc,EAAG,CAAA,OAAO;YACxC,MAAM,oBAAoB,IAAA,CAAK,MAAA,CAAO,oBAAA,CAAqB;YAE3D,IACC,qBACA,IAAA,CAAK,MAAA,CAAO,YAAA,CAAa,iBAAiB,EAAE,OAAA,CAAQ,iBAAiB,GACpE;gBACD,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,QAAQ;gBACnC,IAAA,CAAK,MAAA,CAAO,eAAA,CAAgB,kBAAkB,EAAE;gBAChD,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,UAAA,CAAW,GAAG,WAAW,iBAAiB;oBAC1D,GAAG,IAAA;oBACH,QAAQ;oBACR,OAAO;gBACR,CAAC;YACF;QACD;IACD;IAEA,SAAS;QACR,MAAM,YAAY,IAAA,CAAK,MAAA,CAAO,YAAA,CAA6B,OAAO;QAElE,MAAM,0MAAc,yBAAA,EAAuB;YAC1C,QAAQ,IAAA,CAAK,MAAA;YACb,kBAAkB,IAAA,CAAK,MAAA,CAAO,MAAA,CAAO,gBAAA;YACrC,OAAO,KAAA;YACP,WAAW,IAAA,CAAK,SAAA;YAChB,gBAAgB,KAAA;YAChB,iBAAiB,KAAA;QAClB,CAAC;QAED,IAAI,eAAe,YAAY,MAAA,CAAO,EAAA,KAAO,IAAA,CAAK,eAAA,EAAiB;YAClE,IAAI,IAAA,CAAK,gBAAA,KAAqB,MAAM;gBACnC,aAAa,IAAA,CAAK,gBAAgB;YACnC;YAEA,IAAA,CAAK,eAAA,GAAkB,YAAY,MAAA,CAAO,EAAA;YAC1C,IAAA,CAAK,gBAAA,GAAmB,IAAA,CAAK,MAAA,CAAO,MAAA,CAAO,UAAA,CAAW,MAAM;gBAC3D,IAAA,CAAK,SAAA,GAAY;gBACjB,IAAA,CAAK,MAAA,CAAO;YACb,GAAG,UAAU,OAAA,CAAQ,mBAAmB;QACzC,OAAA,IAAW,CAAC,eAAe,IAAA,CAAK,eAAA,EAAiB;YAChD,IAAA,CAAK,SAAA,GAAY;YACjB,IAAA,CAAK,eAAA,GAAkB;YACvB,IAAI,IAAA,CAAK,gBAAA,KAAqB,MAAM;gBACnC,aAAa,IAAA,CAAK,gBAAgB;YACnC;QACD;IACD;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4365, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/arrow/toolStates/Pointing.tsx"],"sourcesContent":["import { StateNode, TLArrowShape, createShapeId, maybeSnapToGrid } from '@tldraw/editor'\nimport { ArrowShapeUtil } from '../ArrowShapeUtil'\nimport { clearArrowTargetState, updateArrowTargetState } from '../arrowTargetState'\n\nexport class Pointing extends StateNode {\n\tstatic override id = 'pointing'\n\n\tshape?: TLArrowShape\n\n\tisPrecise = false\n\tisPreciseTimerId: number | null = null\n\n\tmarkId = ''\n\n\toverride onEnter(info: { isPrecise?: boolean }) {\n\t\tthis.markId = ''\n\t\tthis.isPrecise = !!info.isPrecise\n\n\t\tconst targetState = updateArrowTargetState({\n\t\t\teditor: this.editor,\n\t\t\tpointInPageSpace: this.editor.inputs.currentPagePoint,\n\t\t\tarrow: undefined,\n\t\t\tisPrecise: this.isPrecise,\n\t\t\tcurrentBinding: undefined,\n\t\t\toppositeBinding: undefined,\n\t\t})\n\n\t\tif (!targetState) {\n\t\t\tthis.createArrowShape()\n\t\t\tif (!this.shape) {\n\t\t\t\tthis.cancel()\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tthis.startPreciseTimeout()\n\t}\n\n\toverride onExit() {\n\t\tthis.shape = undefined\n\t\tclearArrowTargetState(this.editor)\n\t\tthis.clearPreciseTimeout()\n\t}\n\n\toverride onPointerMove() {\n\t\tif (this.editor.inputs.isDragging) {\n\t\t\tif (!this.shape) {\n\t\t\t\tthis.createArrowShape()\n\t\t\t}\n\n\t\t\tif (!this.shape) {\n\t\t\t\tthis.cancel()\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tthis.updateArrowShapeEndHandle()\n\n\t\t\tthis.editor.setCurrentTool('select.dragging_handle', {\n\t\t\t\tshape: this.shape,\n\t\t\t\thandle: { id: 'end', type: 'vertex', index: 'a3', x: 0, y: 0 },\n\t\t\t\tisCreating: true,\n\t\t\t\tcreatingMarkId: this.markId || undefined,\n\t\t\t\tonInteractionEnd: 'arrow',\n\t\t\t})\n\t\t}\n\t}\n\n\toverride onPointerUp() {\n\t\tthis.cancel()\n\t}\n\n\toverride onCancel() {\n\t\tthis.cancel()\n\t}\n\n\toverride onComplete() {\n\t\tthis.cancel()\n\t}\n\n\toverride onInterrupt() {\n\t\tthis.cancel()\n\t}\n\n\tcancel() {\n\t\tif (this.shape) {\n\t\t\t// the arrow might not have been created yet!\n\t\t\tthis.editor.bailToMark(this.markId)\n\t\t}\n\t\tthis.parent.transition('idle')\n\t}\n\n\tcreateArrowShape() {\n\t\tconst { originPagePoint } = this.editor.inputs\n\n\t\tconst id = createShapeId()\n\n\t\tthis.markId = this.editor.markHistoryStoppingPoint(`creating_arrow:${id}`)\n\t\tconst newPoint = maybeSnapToGrid(originPagePoint, this.editor)\n\t\tthis.editor.createShape<TLArrowShape>({\n\t\t\tid,\n\t\t\ttype: 'arrow',\n\t\t\tx: newPoint.x,\n\t\t\ty: newPoint.y,\n\t\t\tprops: {\n\t\t\t\tscale: this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1,\n\t\t\t},\n\t\t})\n\n\t\tconst shape = this.editor.getShape<TLArrowShape>(id)\n\t\tif (!shape) return\n\n\t\tconst handles = this.editor.getShapeHandles(shape)\n\t\tif (!handles) throw Error(`expected handles for arrow`)\n\n\t\tconst util = this.editor.getShapeUtil<TLArrowShape>('arrow')\n\t\tconst initial = this.shape\n\t\tconst startHandle = handles.find((h) => h.id === 'start')!\n\t\tconst change = util.onHandleDrag?.(shape, {\n\t\t\thandle: { ...startHandle, x: 0, y: 0 },\n\t\t\tisPrecise: true,\n\t\t\tinitial: initial,\n\t\t})\n\n\t\tif (change) {\n\t\t\tthis.editor.updateShapes([change])\n\t\t}\n\n\t\t// Cache the current shape after those changes\n\t\tthis.shape = this.editor.getShape(id)\n\t\tthis.editor.select(id)\n\t}\n\n\tupdateArrowShapeEndHandle() {\n\t\tconst shape = this.shape\n\t\tif (!shape) throw Error(`expected shape`)\n\n\t\tconst handles = this.editor.getShapeHandles(shape)\n\t\tif (!handles) throw Error(`expected handles for arrow`)\n\n\t\t// start update\n\t\t{\n\t\t\tconst util = this.editor.getShapeUtil<TLArrowShape>('arrow')\n\t\t\tconst initial = this.shape\n\t\t\tconst startHandle = handles.find((h) => h.id === 'start')!\n\t\t\tconst change = util.onHandleDrag?.(shape, {\n\t\t\t\thandle: { ...startHandle, x: 0, y: 0 },\n\t\t\t\tisPrecise: this.isPrecise,\n\t\t\t\tinitial: initial,\n\t\t\t})\n\n\t\t\tif (change) {\n\t\t\t\tthis.editor.updateShapes([change])\n\t\t\t}\n\t\t}\n\n\t\t// end update\n\t\t{\n\t\t\tconst util = this.editor.getShapeUtil<TLArrowShape>('arrow')\n\t\t\tconst initial = this.shape\n\t\t\tconst point = this.editor.getPointInShapeSpace(shape, this.editor.inputs.currentPagePoint)\n\t\t\tconst endHandle = handles.find((h) => h.id === 'end')!\n\t\t\tconst change = util.onHandleDrag?.(this.editor.getShape(shape)!, {\n\t\t\t\thandle: { ...endHandle, x: point.x, y: point.y },\n\t\t\t\tisPrecise: false,\n\t\t\t\tinitial: initial,\n\t\t\t})\n\n\t\t\tif (change) {\n\t\t\t\tthis.editor.updateShapes([change])\n\t\t\t}\n\t\t}\n\n\t\t// Cache the current shape after those changes\n\t\tthis.shape = this.editor.getShape(shape.id)\n\t}\n\n\tprivate startPreciseTimeout() {\n\t\tconst arrowUtil = this.editor.getShapeUtil<ArrowShapeUtil>('arrow')\n\n\t\tthis.isPreciseTimerId = this.editor.timers.setTimeout(() => {\n\t\t\tif (!this.getIsActive()) return\n\t\t\tthis.isPrecise = true\n\t\t}, arrowUtil.options.pointingPreciseTimeout)\n\t}\n\n\tprivate clearPreciseTimeout() {\n\t\tif (this.isPreciseTimerId !== null) {\n\t\t\tclearTimeout(this.isPreciseTimerId)\n\t\t}\n\t}\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4554, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/arrow/ArrowShapeTool.ts"],"sourcesContent":["import { StateNode, TLStateNodeConstructor } from '@tldraw/editor'\nimport { Idle } from './toolStates/Idle'\nimport { Pointing } from './toolStates/Pointing'\n\n/** @public */\nexport class ArrowShapeTool extends StateNode {\n\tstatic override id = 'arrow'\n\tstatic override initial = 'idle'\n\tstatic override children(): TLStateNodeConstructor[] {\n\t\treturn [Idle, Pointing]\n\t}\n\n\toverride shapeType = 'arrow'\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,iBAAyC;AAClD,SAAS,YAAY;AACrB,SAAS,gBAAgB;;;;AAGlB,MAAM,oNAAuB,YAAA,CAAU;IAC7C,OAAgB,KAAK,QAAA;IACrB,OAAgB,UAAU,OAAA;IAC1B,OAAgB,WAAqC;QACpD,OAAO;sMAAC,OAAA;0MAAM,WAAQ;SAAA;IACvB;IAES,YAAY,QAAA;AACtB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4583, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/draw/toolStates/Drawing.ts"],"sourcesContent":["import {\n\tMat,\n\tStateNode,\n\tTLDefaultSizeStyle,\n\tTLDrawShape,\n\tTLDrawShapeSegment,\n\tTLHighlightShape,\n\tTLKeyboardEventInfo,\n\tTLPointerEventInfo,\n\tTLShapePartial,\n\tVec,\n\tVecModel,\n\tcreateShapeId,\n\tlast,\n\tsnapAngle,\n\tstructuredClone,\n\ttoFixed,\n\tuniqueId,\n} from '@tldraw/editor'\nimport { HighlightShapeUtil } from '../../highlight/HighlightShapeUtil'\nimport { STROKE_SIZES } from '../../shared/default-shape-constants'\nimport { DrawShapeUtil } from '../DrawShapeUtil'\n\ntype DrawableShape = TLDrawShape | TLHighlightShape\n\nexport class Drawing extends StateNode {\n\tstatic override id = 'drawing'\n\n\tinfo = {} as TLPointerEventInfo\n\n\tinitialShape?: DrawableShape\n\n\toverride shapeType = this.parent.id === 'highlight' ? ('highlight' as const) : ('draw' as const)\n\n\tutil = this.editor.getShapeUtil(this.shapeType) as DrawShapeUtil | HighlightShapeUtil\n\n\tisPen = false\n\tisPenOrStylus = false\n\n\tsegmentMode = 'free' as 'free' | 'straight' | 'starting_straight' | 'starting_free'\n\n\tdidJustShiftClickToExtendPreviousShapeLine = false\n\n\tpagePointWhereCurrentSegmentChanged = {} as Vec\n\n\tpagePointWhereNextSegmentChanged = null as Vec | null\n\n\tlastRecordedPoint = {} as Vec\n\tmergeNextPoint = false\n\tcurrentLineLength = 0\n\n\tmarkId = null as null | string\n\n\toverride onEnter(info: TLPointerEventInfo) {\n\t\tthis.markId = null\n\t\tthis.info = info\n\t\tthis.lastRecordedPoint = this.editor.inputs.currentPagePoint.clone()\n\t\tthis.startShape()\n\t}\n\n\toverride onPointerMove() {\n\t\tconst { inputs } = this.editor\n\n\t\tif (this.isPen && !inputs.isPen) {\n\t\t\t// The user made a palm gesture before starting a pen gesture;\n\t\t\t// ideally we'd start the new shape here but we could also just bail\n\t\t\t// as the next interaction will work correctly\n\t\t\tif (this.markId) {\n\t\t\t\tthis.editor.bailToMark(this.markId)\n\t\t\t\tthis.startShape()\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif (this.isPenOrStylus) {\n\t\t\t// Don't update the shape if we haven't moved far enough from the last time we recorded a point\n\t\t\tif (\n\t\t\t\tVec.Dist(inputs.currentPagePoint, this.lastRecordedPoint) >=\n\t\t\t\t1 / this.editor.getZoomLevel()\n\t\t\t) {\n\t\t\t\tthis.lastRecordedPoint = inputs.currentPagePoint.clone()\n\t\t\t\tthis.mergeNextPoint = false\n\t\t\t} else {\n\t\t\t\tthis.mergeNextPoint = true\n\t\t\t}\n\t\t} else {\n\t\t\tthis.mergeNextPoint = false\n\t\t}\n\n\t\tthis.updateDrawingShape()\n\t}\n\n\toverride onKeyDown(info: TLKeyboardEventInfo) {\n\t\tif (info.key === 'Shift') {\n\t\t\tswitch (this.segmentMode) {\n\t\t\t\tcase 'free': {\n\t\t\t\t\t// We've just entered straight mode, go to straight mode\n\t\t\t\t\tthis.segmentMode = 'starting_straight'\n\t\t\t\t\tthis.pagePointWhereNextSegmentChanged = this.editor.inputs.currentPagePoint.clone()\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'starting_free': {\n\t\t\t\t\tthis.segmentMode = 'starting_straight'\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.updateDrawingShape()\n\t}\n\n\toverride onKeyUp(info: TLKeyboardEventInfo) {\n\t\tif (info.key === 'Shift') {\n\t\t\tthis.editor.snaps.clearIndicators()\n\n\t\t\tswitch (this.segmentMode) {\n\t\t\t\tcase 'straight': {\n\t\t\t\t\t// We've just exited straight mode, go back to free mode\n\t\t\t\t\tthis.segmentMode = 'starting_free'\n\t\t\t\t\tthis.pagePointWhereNextSegmentChanged = this.editor.inputs.currentPagePoint.clone()\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'starting_straight': {\n\t\t\t\t\tthis.pagePointWhereNextSegmentChanged = null\n\t\t\t\t\tthis.segmentMode = 'free'\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.updateDrawingShape()\n\t}\n\n\toverride onExit() {\n\t\tthis.editor.snaps.clearIndicators()\n\t\tthis.pagePointWhereCurrentSegmentChanged = this.editor.inputs.currentPagePoint.clone()\n\t}\n\n\tcanClose() {\n\t\treturn this.shapeType !== 'highlight'\n\t}\n\n\tgetIsClosed(segments: TLDrawShapeSegment[], size: TLDefaultSizeStyle, scale: number) {\n\t\tif (!this.canClose()) return false\n\n\t\tconst strokeWidth = STROKE_SIZES[size]\n\t\tconst firstPoint = segments[0].points[0]\n\t\tconst lastSegment = segments[segments.length - 1]\n\t\tconst lastPoint = lastSegment.points[lastSegment.points.length - 1]\n\n\t\treturn (\n\t\t\tfirstPoint !== lastPoint &&\n\t\t\tthis.currentLineLength > strokeWidth * 4 * scale &&\n\t\t\tVec.DistMin(firstPoint, lastPoint, strokeWidth * 2 * scale)\n\t\t)\n\t}\n\n\tprivate startShape() {\n\t\tconst {\n\t\t\tinputs: { originPagePoint, isPen },\n\t\t} = this.editor\n\n\t\tthis.markId = this.editor.markHistoryStoppingPoint('draw start')\n\n\t\t// If the pressure is weird, then it's probably a stylus reporting as a mouse\n\t\t// We treat pen/stylus inputs differently in the drawing tool, so we need to\n\t\t// have our own value for this. The inputs.isPen is only if the input is a regular\n\t\t// pen, like an iPad pen, which needs to trigger \"pen mode\" in order to avoid\n\t\t// accidental palm touches. We don't have to worry about that with styluses though.\n\t\tconst { z = 0.5 } = this.info.point\n\n\t\tthis.isPen = isPen\n\t\tthis.isPenOrStylus = isPen || (z > 0 && z < 0.5) || (z > 0.5 && z < 1)\n\n\t\tconst pressure = this.isPenOrStylus ? z * 1.25 : 0.5\n\n\t\tthis.segmentMode = this.editor.inputs.shiftKey ? 'straight' : 'free'\n\n\t\tthis.didJustShiftClickToExtendPreviousShapeLine = false\n\n\t\tthis.lastRecordedPoint = originPagePoint.clone()\n\n\t\tif (this.initialShape) {\n\t\t\tconst shape = this.editor.getShape<DrawableShape>(this.initialShape.id)\n\n\t\t\tif (shape && this.segmentMode === 'straight') {\n\t\t\t\t// Connect dots\n\n\t\t\t\tthis.didJustShiftClickToExtendPreviousShapeLine = true\n\n\t\t\t\tconst prevSegment = last(shape.props.segments)\n\t\t\t\tif (!prevSegment) throw Error('Expected a previous segment!')\n\t\t\t\tconst prevPoint = last(prevSegment.points)\n\t\t\t\tif (!prevPoint) throw Error('Expected a previous point!')\n\n\t\t\t\tconst { x, y } = this.editor.getPointInShapeSpace(shape, originPagePoint).toFixed()\n\n\t\t\t\tconst newSegment: TLDrawShapeSegment = {\n\t\t\t\t\ttype: this.segmentMode,\n\t\t\t\t\tpoints: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tx: prevPoint.x,\n\t\t\t\t\t\t\ty: prevPoint.y,\n\t\t\t\t\t\t\tz: +pressure.toFixed(2),\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tx,\n\t\t\t\t\t\t\ty,\n\t\t\t\t\t\t\tz: +pressure.toFixed(2),\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t}\n\n\t\t\t\t// Convert prevPoint to page space\n\t\t\t\tconst prevPointPageSpace = Mat.applyToPoint(\n\t\t\t\t\tthis.editor.getShapePageTransform(shape.id)!,\n\t\t\t\t\tprevPoint\n\t\t\t\t)\n\t\t\t\tthis.pagePointWhereCurrentSegmentChanged = prevPointPageSpace\n\t\t\t\tthis.pagePointWhereNextSegmentChanged = null\n\t\t\t\tconst segments = [...shape.props.segments, newSegment]\n\n\t\t\t\tif (this.currentLineLength < STROKE_SIZES[shape.props.size] * 4) {\n\t\t\t\t\tthis.currentLineLength = this.getLineLength(segments)\n\t\t\t\t}\n\n\t\t\t\tconst shapePartial: TLShapePartial<DrawableShape> = {\n\t\t\t\t\tid: shape.id,\n\t\t\t\t\ttype: this.shapeType,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\tsegments,\n\t\t\t\t\t},\n\t\t\t\t}\n\n\t\t\t\tif (this.canClose()) {\n\t\t\t\t\t;(shapePartial as TLShapePartial<TLDrawShape>).props!.isClosed = this.getIsClosed(\n\t\t\t\t\t\tsegments,\n\t\t\t\t\t\tshape.props.size,\n\t\t\t\t\t\tshape.props.scale\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tthis.editor.updateShapes<TLDrawShape | TLHighlightShape>([shapePartial])\n\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\t// Create a new shape\n\n\t\tthis.pagePointWhereCurrentSegmentChanged = originPagePoint.clone()\n\t\tconst id = createShapeId()\n\n\t\t// Allow this to trigger the max shapes reached alert\n\t\tthis.editor.createShape<DrawableShape>({\n\t\t\tid,\n\t\t\ttype: this.shapeType,\n\t\t\tx: originPagePoint.x,\n\t\t\ty: originPagePoint.y,\n\t\t\tprops: {\n\t\t\t\tisPen: this.isPenOrStylus,\n\t\t\t\tscale: this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1,\n\t\t\t\tsegments: [\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: this.segmentMode,\n\t\t\t\t\t\tpoints: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tx: 0,\n\t\t\t\t\t\t\t\ty: 0,\n\t\t\t\t\t\t\t\tz: +pressure.toFixed(2),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t})\n\t\tconst shape = this.editor.getShape<DrawableShape>(id)\n\t\tif (!shape) {\n\t\t\tthis.cancel()\n\t\t\treturn\n\t\t}\n\t\tthis.currentLineLength = 0\n\t\tthis.initialShape = this.editor.getShape<DrawableShape>(id)\n\t}\n\n\tprivate updateDrawingShape() {\n\t\tconst { initialShape } = this\n\t\tconst { inputs } = this.editor\n\n\t\tif (!initialShape) return\n\n\t\tconst {\n\t\t\tid,\n\t\t\tprops: { size, scale },\n\t\t} = initialShape\n\n\t\tconst shape = this.editor.getShape<DrawableShape>(id)!\n\n\t\tif (!shape) return\n\n\t\tconst { segments } = shape.props\n\n\t\tconst { x, y, z } = this.editor.getPointInShapeSpace(shape, inputs.currentPagePoint).toFixed()\n\t\tconst pressure = this.isPenOrStylus ? +(inputs.currentPagePoint.z! * 1.25).toFixed(2) : 0.5\n\t\tconst newPoint = { x, y, z: pressure }\n\n\t\tswitch (this.segmentMode) {\n\t\t\tcase 'starting_straight': {\n\t\t\t\tconst { pagePointWhereNextSegmentChanged } = this\n\n\t\t\t\tif (pagePointWhereNextSegmentChanged === null) {\n\t\t\t\t\tthrow Error('We should have a point where the segment changed')\n\t\t\t\t}\n\n\t\t\t\tconst hasMovedFarEnough =\n\t\t\t\t\tVec.Dist2(pagePointWhereNextSegmentChanged, inputs.currentPagePoint) >\n\t\t\t\t\tthis.editor.options.dragDistanceSquared\n\n\t\t\t\t// Find the distance from where the pointer was when shift was released and\n\t\t\t\t// where it is now; if it's far enough away, then update the page point where\n\t\t\t\t// the current segment changed (to match the pagepoint where next segment changed)\n\t\t\t\t// and set the pagepoint where next segment changed to null.\n\t\t\t\tif (hasMovedFarEnough) {\n\t\t\t\t\tthis.pagePointWhereCurrentSegmentChanged = this.pagePointWhereNextSegmentChanged!.clone()\n\t\t\t\t\tthis.pagePointWhereNextSegmentChanged = null\n\n\t\t\t\t\t// Set the new mode\n\t\t\t\t\tthis.segmentMode = 'straight'\n\n\t\t\t\t\tconst prevSegment = last(segments)\n\t\t\t\t\tif (!prevSegment) throw Error('Expected a previous segment!')\n\n\t\t\t\t\tconst prevLastPoint = last(prevSegment.points)\n\t\t\t\t\tif (!prevLastPoint) throw Error('Expected a previous last point!')\n\n\t\t\t\t\tlet newSegment: TLDrawShapeSegment\n\n\t\t\t\t\tconst newLastPoint = this.editor\n\t\t\t\t\t\t.getPointInShapeSpace(shape, this.pagePointWhereCurrentSegmentChanged)\n\t\t\t\t\t\t.toFixed()\n\t\t\t\t\t\t.toJson()\n\n\t\t\t\t\tif (prevSegment.type === 'straight') {\n\t\t\t\t\t\tthis.currentLineLength += Vec.Dist(prevLastPoint, newLastPoint)\n\n\t\t\t\t\t\tnewSegment = {\n\t\t\t\t\t\t\ttype: 'straight',\n\t\t\t\t\t\t\tpoints: [{ ...prevLastPoint }, newLastPoint],\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst transform = this.editor.getShapePageTransform(shape)!\n\n\t\t\t\t\t\tthis.pagePointWhereCurrentSegmentChanged = Mat.applyToPoint(transform, prevLastPoint)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewSegment = {\n\t\t\t\t\t\t\ttype: 'straight',\n\t\t\t\t\t\t\tpoints: [newLastPoint, newPoint],\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst shapePartial: TLShapePartial<DrawableShape> = {\n\t\t\t\t\t\tid,\n\t\t\t\t\t\ttype: this.shapeType,\n\t\t\t\t\t\tprops: {\n\t\t\t\t\t\t\tsegments: [...segments, newSegment],\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.canClose()) {\n\t\t\t\t\t\t;(shapePartial as TLShapePartial<TLDrawShape>).props!.isClosed = this.getIsClosed(\n\t\t\t\t\t\t\tsegments,\n\t\t\t\t\t\t\tsize,\n\t\t\t\t\t\t\tscale\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.editor.updateShapes<TLDrawShape | TLHighlightShape>([shapePartial])\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'starting_free': {\n\t\t\t\tconst { pagePointWhereNextSegmentChanged } = this\n\n\t\t\t\tif (pagePointWhereNextSegmentChanged === null) {\n\t\t\t\t\tthrow Error('We should have a point where the segment changed')\n\t\t\t\t}\n\n\t\t\t\tconst hasMovedFarEnough =\n\t\t\t\t\tVec.Dist2(pagePointWhereNextSegmentChanged, inputs.currentPagePoint) >\n\t\t\t\t\tthis.editor.options.dragDistanceSquared\n\n\t\t\t\t// Find the distance from where the pointer was when shift was released and\n\t\t\t\t// where it is now; if it's far enough away, then update the page point where\n\t\t\t\t// the current segment changed (to match the pagepoint where next segment changed)\n\t\t\t\t// and set the pagepoint where next segment changed to null.\n\t\t\t\tif (hasMovedFarEnough) {\n\t\t\t\t\tthis.pagePointWhereCurrentSegmentChanged = this.pagePointWhereNextSegmentChanged!.clone()\n\t\t\t\t\tthis.pagePointWhereNextSegmentChanged = null\n\n\t\t\t\t\t// Set the new mode\n\t\t\t\t\tthis.segmentMode = 'free'\n\n\t\t\t\t\tconst newSegments = segments.slice()\n\t\t\t\t\tconst prevStraightSegment = newSegments[newSegments.length - 1]\n\t\t\t\t\tconst prevPoint = last(prevStraightSegment.points)\n\n\t\t\t\t\tif (!prevPoint) {\n\t\t\t\t\t\tthrow Error('No previous point!')\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create the new free segment and interpolate the points between where the last line\n\t\t\t\t\t// ended and where the pointer is now\n\t\t\t\t\tconst newFreeSegment: TLDrawShapeSegment = {\n\t\t\t\t\t\ttype: 'free',\n\t\t\t\t\t\tpoints: [\n\t\t\t\t\t\t\t...Vec.PointsBetween(prevPoint, newPoint, 6).map((p) => ({\n\t\t\t\t\t\t\t\tx: toFixed(p.x),\n\t\t\t\t\t\t\t\ty: toFixed(p.y),\n\t\t\t\t\t\t\t\tz: toFixed(p.z),\n\t\t\t\t\t\t\t})),\n\t\t\t\t\t\t],\n\t\t\t\t\t}\n\n\t\t\t\t\tconst finalSegments = [...newSegments, newFreeSegment]\n\n\t\t\t\t\tif (this.currentLineLength < STROKE_SIZES[shape.props.size] * 4) {\n\t\t\t\t\t\tthis.currentLineLength = this.getLineLength(finalSegments)\n\t\t\t\t\t}\n\n\t\t\t\t\tconst shapePartial: TLShapePartial<DrawableShape> = {\n\t\t\t\t\t\tid,\n\t\t\t\t\t\ttype: this.shapeType,\n\t\t\t\t\t\tprops: {\n\t\t\t\t\t\t\tsegments: finalSegments,\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.canClose()) {\n\t\t\t\t\t\t;(shapePartial as TLShapePartial<TLDrawShape>).props!.isClosed = this.getIsClosed(\n\t\t\t\t\t\t\tfinalSegments,\n\t\t\t\t\t\t\tsize,\n\t\t\t\t\t\t\tscale\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.editor.updateShapes([shapePartial])\n\t\t\t\t}\n\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'straight': {\n\t\t\t\tconst newSegments = segments.slice()\n\t\t\t\tconst newSegment = newSegments[newSegments.length - 1]\n\n\t\t\t\tconst { pagePointWhereCurrentSegmentChanged } = this\n\t\t\t\tconst { ctrlKey, currentPagePoint } = this.editor.inputs\n\n\t\t\t\tif (!pagePointWhereCurrentSegmentChanged)\n\t\t\t\t\tthrow Error('We should have a point where the segment changed')\n\n\t\t\t\tlet pagePoint: VecModel\n\t\t\t\tlet shouldSnapToAngle = false\n\n\t\t\t\tif (this.didJustShiftClickToExtendPreviousShapeLine) {\n\t\t\t\t\tif (this.editor.inputs.isDragging) {\n\t\t\t\t\t\t// If we've just shift clicked to extend a line, only snap once we've started dragging\n\t\t\t\t\t\tshouldSnapToAngle = !ctrlKey\n\t\t\t\t\t\tthis.didJustShiftClickToExtendPreviousShapeLine = false\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// noop\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// If we're not shift clicking to extend a line, but we're holding shift, then we should snap\n\t\t\t\t\tshouldSnapToAngle = !ctrlKey // don't snap angle while snapping line\n\t\t\t\t}\n\n\t\t\t\tlet newPoint = this.editor.getPointInShapeSpace(shape, currentPagePoint).toFixed().toJson()\n\t\t\t\tlet didSnap = false\n\t\t\t\tlet snapSegment: TLDrawShapeSegment | undefined = undefined\n\n\t\t\t\tconst shouldSnap = this.editor.user.getIsSnapMode() ? !ctrlKey : ctrlKey\n\n\t\t\t\tif (shouldSnap) {\n\t\t\t\t\tif (newSegments.length > 2) {\n\t\t\t\t\t\tlet nearestPoint: VecModel | undefined = undefined\n\t\t\t\t\t\tlet minDistance = 8 / this.editor.getZoomLevel()\n\n\t\t\t\t\t\t// Don't try to snap to the last two segments\n\t\t\t\t\t\tfor (let i = 0, n = segments.length - 2; i < n; i++) {\n\t\t\t\t\t\t\tconst segment = segments[i]\n\t\t\t\t\t\t\tif (!segment) break\n\t\t\t\t\t\t\tif (segment.type === 'free') continue\n\n\t\t\t\t\t\t\tconst first = segment.points[0]\n\t\t\t\t\t\t\tconst lastPoint = last(segment.points)\n\t\t\t\t\t\t\tif (!(first && lastPoint)) continue\n\n\t\t\t\t\t\t\t// Snap to the nearest point on the segment, if it's closer than the previous snapped point\n\t\t\t\t\t\t\tconst nearestPointOnSegment = Vec.NearestPointOnLineSegment(\n\t\t\t\t\t\t\t\tfirst,\n\t\t\t\t\t\t\t\tlastPoint,\n\t\t\t\t\t\t\t\tnewPoint\n\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\tif (Vec.DistMin(nearestPointOnSegment, newPoint, minDistance)) {\n\t\t\t\t\t\t\t\tnearestPoint = nearestPointOnSegment.toFixed().toJson()\n\t\t\t\t\t\t\t\tminDistance = Vec.Dist(nearestPointOnSegment, newPoint)\n\t\t\t\t\t\t\t\tsnapSegment = segment\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (nearestPoint) {\n\t\t\t\t\t\t\tdidSnap = true\n\t\t\t\t\t\t\tnewPoint = nearestPoint\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (didSnap && snapSegment) {\n\t\t\t\t\tconst transform = this.editor.getShapePageTransform(shape)!\n\t\t\t\t\tconst first = snapSegment.points[0]\n\t\t\t\t\tconst lastPoint = last(snapSegment.points)\n\t\t\t\t\tif (!lastPoint) throw Error('Expected a last point!')\n\n\t\t\t\t\tconst A = Mat.applyToPoint(transform, first)\n\n\t\t\t\t\tconst B = Mat.applyToPoint(transform, lastPoint)\n\n\t\t\t\t\tconst snappedPoint = Mat.applyToPoint(transform, newPoint)\n\n\t\t\t\t\tthis.editor.snaps.setIndicators([\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tid: uniqueId(),\n\t\t\t\t\t\t\ttype: 'points',\n\t\t\t\t\t\t\tpoints: [A, snappedPoint, B],\n\t\t\t\t\t\t},\n\t\t\t\t\t])\n\t\t\t\t} else {\n\t\t\t\t\tthis.editor.snaps.clearIndicators()\n\n\t\t\t\t\tif (shouldSnapToAngle) {\n\t\t\t\t\t\t// Snap line angle to nearest 15 degrees\n\t\t\t\t\t\tconst currentAngle = Vec.Angle(pagePointWhereCurrentSegmentChanged, currentPagePoint)\n\t\t\t\t\t\tconst snappedAngle = snapAngle(currentAngle, 24)\n\t\t\t\t\t\tconst angleDiff = snappedAngle - currentAngle\n\n\t\t\t\t\t\tpagePoint = Vec.RotWith(\n\t\t\t\t\t\t\tcurrentPagePoint,\n\t\t\t\t\t\t\tpagePointWhereCurrentSegmentChanged,\n\t\t\t\t\t\t\tangleDiff\n\t\t\t\t\t\t)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpagePoint = currentPagePoint\n\t\t\t\t\t}\n\n\t\t\t\t\tnewPoint = this.editor.getPointInShapeSpace(shape, pagePoint).toFixed().toJson()\n\t\t\t\t}\n\n\t\t\t\t// If the previous segment is a one point free shape and is the first segment of the line,\n\t\t\t\t// then the user just did a click-and-immediately-press-shift to create a new straight line\n\t\t\t\t// without continuing the previous line. In this case, we want to remove the previous segment.\n\n\t\t\t\tthis.currentLineLength += Vec.Dist(newSegment.points[0], newPoint)\n\n\t\t\t\tnewSegments[newSegments.length - 1] = {\n\t\t\t\t\t...newSegment,\n\t\t\t\t\ttype: 'straight',\n\t\t\t\t\tpoints: [newSegment.points[0], newPoint],\n\t\t\t\t}\n\n\t\t\t\tconst shapePartial: TLShapePartial<DrawableShape> = {\n\t\t\t\t\tid,\n\t\t\t\t\ttype: this.shapeType,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\tsegments: newSegments,\n\t\t\t\t\t},\n\t\t\t\t}\n\n\t\t\t\tif (this.canClose()) {\n\t\t\t\t\t;(shapePartial as TLShapePartial<TLDrawShape>).props!.isClosed = this.getIsClosed(\n\t\t\t\t\t\tsegments,\n\t\t\t\t\t\tsize,\n\t\t\t\t\t\tscale\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tthis.editor.updateShapes([shapePartial])\n\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'free': {\n\t\t\t\tconst newSegments = segments.slice()\n\t\t\t\tconst newSegment = newSegments[newSegments.length - 1]\n\t\t\t\tconst newPoints = [...newSegment.points]\n\n\t\t\t\tif (newPoints.length && this.mergeNextPoint) {\n\t\t\t\t\tconst { z } = newPoints[newPoints.length - 1]\n\t\t\t\t\tnewPoints[newPoints.length - 1] = {\n\t\t\t\t\t\tx: newPoint.x,\n\t\t\t\t\t\ty: newPoint.y,\n\t\t\t\t\t\tz: z ? Math.max(z, newPoint.z) : newPoint.z,\n\t\t\t\t\t}\n\t\t\t\t\t// Note: we could recompute the line length here, but it's not really necessary\n\t\t\t\t\t// this.currentLineLength = this.getLineLength(newSegments)\n\t\t\t\t} else {\n\t\t\t\t\tthis.currentLineLength += Vec.Dist(newPoints[newPoints.length - 1], newPoint)\n\t\t\t\t\tnewPoints.push(newPoint)\n\t\t\t\t}\n\n\t\t\t\tnewSegments[newSegments.length - 1] = {\n\t\t\t\t\t...newSegment,\n\t\t\t\t\tpoints: newPoints,\n\t\t\t\t}\n\n\t\t\t\tif (this.currentLineLength < STROKE_SIZES[shape.props.size] * 4) {\n\t\t\t\t\tthis.currentLineLength = this.getLineLength(newSegments)\n\t\t\t\t}\n\n\t\t\t\tconst shapePartial: TLShapePartial<DrawableShape> = {\n\t\t\t\t\tid,\n\t\t\t\t\ttype: this.shapeType,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\tsegments: newSegments,\n\t\t\t\t\t},\n\t\t\t\t}\n\n\t\t\t\tif (this.canClose()) {\n\t\t\t\t\t;(shapePartial as TLShapePartial<TLDrawShape>).props!.isClosed = this.getIsClosed(\n\t\t\t\t\t\tnewSegments,\n\t\t\t\t\t\tsize,\n\t\t\t\t\t\tscale\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tthis.editor.updateShapes([shapePartial])\n\n\t\t\t\t// Set a maximum length for the lines array; after 200 points, complete the line.\n\t\t\t\tif (newPoints.length > this.util.options.maxPointsPerShape) {\n\t\t\t\t\tthis.editor.updateShapes([{ id, type: this.shapeType, props: { isComplete: true } }])\n\n\t\t\t\t\tconst newShapeId = createShapeId()\n\n\t\t\t\t\tconst props = this.editor.getShape<DrawableShape>(id)!.props\n\n\t\t\t\t\tif (!this.editor.canCreateShapes([newShapeId])) return this.cancel()\n\t\t\t\t\tthis.editor.createShape<DrawableShape>({\n\t\t\t\t\t\tid: newShapeId,\n\t\t\t\t\t\ttype: this.shapeType,\n\t\t\t\t\t\tx: toFixed(inputs.currentPagePoint.x),\n\t\t\t\t\t\ty: toFixed(inputs.currentPagePoint.y),\n\t\t\t\t\t\tprops: {\n\t\t\t\t\t\t\tisPen: this.isPenOrStylus,\n\t\t\t\t\t\t\tscale: props.scale,\n\t\t\t\t\t\t\tsegments: [\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttype: 'free',\n\t\t\t\t\t\t\t\t\tpoints: [{ x: 0, y: 0, z: this.isPenOrStylus ? +(z! * 1.25).toFixed() : 0.5 }],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t},\n\t\t\t\t\t})\n\n\t\t\t\t\tconst shape = this.editor.getShape<DrawableShape>(newShapeId)\n\n\t\t\t\t\tif (!shape) {\n\t\t\t\t\t\t// This would only happen if the page is full and no more shapes can be created. The bug would manifest as a crash when we try to clone the shape.\n\t\t\t\t\t\t// todo: handle this type of thing better\n\t\t\t\t\t\treturn this.cancel()\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.initialShape = structuredClone(shape)\n\t\t\t\t\tthis.mergeNextPoint = false\n\t\t\t\t\tthis.lastRecordedPoint = inputs.currentPagePoint.clone()\n\t\t\t\t\tthis.currentLineLength = 0\n\t\t\t\t}\n\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate getLineLength(segments: TLDrawShapeSegment[]) {\n\t\tlet length = 0\n\n\t\tfor (const segment of segments) {\n\t\t\tfor (let i = 0; i < segment.points.length - 1; i++) {\n\t\t\t\tconst A = segment.points[i]\n\t\t\t\tconst B = segment.points[i + 1]\n\t\t\t\tlength += Vec.Dist2(B, A)\n\t\t\t}\n\t\t}\n\n\t\treturn Math.sqrt(length)\n\t}\n\n\toverride onPointerUp() {\n\t\tthis.complete()\n\t}\n\n\toverride onCancel() {\n\t\tthis.cancel()\n\t}\n\n\toverride onComplete() {\n\t\tthis.complete()\n\t}\n\n\toverride onInterrupt() {\n\t\tif (this.editor.inputs.isDragging) {\n\t\t\treturn\n\t\t}\n\n\t\tif (this.markId) {\n\t\t\tthis.editor.bailToMark(this.markId)\n\t\t}\n\t\tthis.cancel()\n\t}\n\n\tcomplete() {\n\t\tconst { initialShape } = this\n\t\tif (!initialShape) return\n\t\tthis.editor.updateShapes([\n\t\t\t{ id: initialShape.id, type: initialShape.type, props: { isComplete: true } },\n\t\t])\n\n\t\tthis.parent.transition('idle')\n\t}\n\n\tcancel() {\n\t\tthis.parent.transition('idle', this.info)\n\t}\n}\n"],"names":["shape","newPoint","z"],"mappings":";;;AAAA;;;;;;;;;AAoBA,SAAS,oBAAoB;;;AAKtB,MAAM,6MAAgB,YAAA,CAAU;IACtC,OAAgB,KAAK,UAAA;IAErB,OAAO,CAAC,EAAA;IAER,aAAA;IAES,YAAY,IAAA,CAAK,MAAA,CAAO,EAAA,KAAO,cAAe,cAAyB,OAAA;IAEhF,OAAO,IAAA,CAAK,MAAA,CAAO,YAAA,CAAa,IAAA,CAAK,SAAS,EAAA;IAE9C,QAAQ,MAAA;IACR,gBAAgB,MAAA;IAEhB,cAAc,OAAA;IAEd,6CAA6C,MAAA;IAE7C,sCAAsC,CAAC,EAAA;IAEvC,mCAAmC,KAAA;IAEnC,oBAAoB,CAAC,EAAA;IACrB,iBAAiB,MAAA;IACjB,oBAAoB,EAAA;IAEpB,SAAS,KAAA;IAEA,QAAQ,IAAA,EAA0B;QAC1C,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,IAAA,GAAO;QACZ,IAAA,CAAK,iBAAA,GAAoB,IAAA,CAAK,MAAA,CAAO,MAAA,CAAO,gBAAA,CAAiB,KAAA,CAAM;QACnE,IAAA,CAAK,UAAA,CAAW;IACjB;IAES,gBAAgB;QACxB,MAAM,EAAE,MAAA,CAAO,CAAA,GAAI,IAAA,CAAK,MAAA;QAExB,IAAI,IAAA,CAAK,KAAA,IAAS,CAAC,OAAO,KAAA,EAAO;YAIhC,IAAI,IAAA,CAAK,MAAA,EAAQ;gBAChB,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,IAAA,CAAK,MAAM;gBAClC,IAAA,CAAK,UAAA,CAAW;gBAChB;YACD;QACD;QAEA,IAAI,IAAA,CAAK,aAAA,EAAe;YAEvB,sLACC,MAAA,CAAI,IAAA,CAAK,OAAO,gBAAA,EAAkB,IAAA,CAAK,iBAAiB,KACxD,IAAI,IAAA,CAAK,MAAA,CAAO,YAAA,CAAa,GAC5B;gBACD,IAAA,CAAK,iBAAA,GAAoB,OAAO,gBAAA,CAAiB,KAAA,CAAM;gBACvD,IAAA,CAAK,cAAA,GAAiB;YACvB,OAAO;gBACN,IAAA,CAAK,cAAA,GAAiB;YACvB;QACD,OAAO;YACN,IAAA,CAAK,cAAA,GAAiB;QACvB;QAEA,IAAA,CAAK,kBAAA,CAAmB;IACzB;IAES,UAAU,IAAA,EAA2B;QAC7C,IAAI,KAAK,GAAA,KAAQ,SAAS;YACzB,OAAQ,IAAA,CAAK,WAAA,EAAa;gBACzB,KAAK;oBAAQ;wBAEZ,IAAA,CAAK,WAAA,GAAc;wBACnB,IAAA,CAAK,gCAAA,GAAmC,IAAA,CAAK,MAAA,CAAO,MAAA,CAAO,gBAAA,CAAiB,KAAA,CAAM;wBAClF;oBACD;gBACA,KAAK;oBAAiB;wBACrB,IAAA,CAAK,WAAA,GAAc;oBACpB;YACD;QACD;QACA,IAAA,CAAK,kBAAA,CAAmB;IACzB;IAES,QAAQ,IAAA,EAA2B;QAC3C,IAAI,KAAK,GAAA,KAAQ,SAAS;YACzB,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,eAAA,CAAgB;YAElC,OAAQ,IAAA,CAAK,WAAA,EAAa;gBACzB,KAAK;oBAAY;wBAEhB,IAAA,CAAK,WAAA,GAAc;wBACnB,IAAA,CAAK,gCAAA,GAAmC,IAAA,CAAK,MAAA,CAAO,MAAA,CAAO,gBAAA,CAAiB,KAAA,CAAM;wBAClF;oBACD;gBACA,KAAK;oBAAqB;wBACzB,IAAA,CAAK,gCAAA,GAAmC;wBACxC,IAAA,CAAK,WAAA,GAAc;wBACnB;oBACD;YACD;QACD;QAEA,IAAA,CAAK,kBAAA,CAAmB;IACzB;IAES,SAAS;QACjB,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,eAAA,CAAgB;QAClC,IAAA,CAAK,mCAAA,GAAsC,IAAA,CAAK,MAAA,CAAO,MAAA,CAAO,gBAAA,CAAiB,KAAA,CAAM;IACtF;IAEA,WAAW;QACV,OAAO,IAAA,CAAK,SAAA,KAAc;IAC3B;IAEA,YAAY,QAAA,EAAgC,IAAA,EAA0B,KAAA,EAAe;QACpF,IAAI,CAAC,IAAA,CAAK,QAAA,CAAS,EAAG,CAAA,OAAO;QAE7B,MAAM,oNAAc,eAAA,CAAa,IAAI,CAAA;QACrC,MAAM,aAAa,QAAA,CAAS,CAAC,CAAA,CAAE,MAAA,CAAO,CAAC,CAAA;QACvC,MAAM,cAAc,QAAA,CAAS,SAAS,MAAA,GAAS,CAAC,CAAA;QAChD,MAAM,YAAY,YAAY,MAAA,CAAO,YAAY,MAAA,CAAO,MAAA,GAAS,CAAC,CAAA;QAElE,OACC,eAAe,aACf,IAAA,CAAK,iBAAA,GAAoB,cAAc,IAAI,2LAC3C,MAAA,CAAI,OAAA,CAAQ,YAAY,WAAW,cAAc,IAAI,KAAK;IAE5D;IAEQ,aAAa;QACpB,MAAM,EACL,QAAQ,EAAE,eAAA,EAAiB,KAAA,CAAM,CAAA,EAClC,GAAI,IAAA,CAAK,MAAA;QAET,IAAA,CAAK,MAAA,GAAS,IAAA,CAAK,MAAA,CAAO,wBAAA,CAAyB,YAAY;QAO/D,MAAM,EAAE,IAAI,GAAA,CAAI,CAAA,GAAI,IAAA,CAAK,IAAA,CAAK,KAAA;QAE9B,IAAA,CAAK,KAAA,GAAQ;QACb,IAAA,CAAK,aAAA,GAAgB,SAAU,IAAI,KAAK,IAAI,OAAS,IAAI,OAAO,IAAI;QAEpE,MAAM,WAAW,IAAA,CAAK,aAAA,GAAgB,IAAI,OAAO;QAEjD,IAAA,CAAK,WAAA,GAAc,IAAA,CAAK,MAAA,CAAO,MAAA,CAAO,QAAA,GAAW,aAAa;QAE9D,IAAA,CAAK,0CAAA,GAA6C;QAElD,IAAA,CAAK,iBAAA,GAAoB,gBAAgB,KAAA,CAAM;QAE/C,IAAI,IAAA,CAAK,YAAA,EAAc;YACtB,MAAMA,SAAQ,IAAA,CAAK,MAAA,CAAO,QAAA,CAAwB,IAAA,CAAK,YAAA,CAAa,EAAE;YAEtE,IAAIA,UAAS,IAAA,CAAK,WAAA,KAAgB,YAAY;gBAG7C,IAAA,CAAK,0CAAA,GAA6C;gBAElD,MAAM,uLAAc,OAAA,EAAKA,OAAM,KAAA,CAAM,QAAQ;gBAC7C,IAAI,CAAC,YAAa,CAAA,MAAM,MAAM,8BAA8B;gBAC5D,MAAM,YAAY,gLAAA,EAAK,YAAY,MAAM;gBACzC,IAAI,CAAC,UAAW,CAAA,MAAM,MAAM,4BAA4B;gBAExD,MAAM,EAAE,CAAA,EAAG,CAAA,CAAE,CAAA,GAAI,IAAA,CAAK,MAAA,CAAO,oBAAA,CAAqBA,QAAO,eAAe,EAAE,OAAA,CAAQ;gBAElF,MAAM,aAAiC;oBACtC,MAAM,IAAA,CAAK,WAAA;oBACX,QAAQ;wBACP;4BACC,GAAG,UAAU,CAAA;4BACb,GAAG,UAAU,CAAA;4BACb,GAAG,CAAC,SAAS,OAAA,CAAQ,CAAC;wBACvB;wBACA;4BACC;4BACA;4BACA,GAAG,CAAC,SAAS,OAAA,CAAQ,CAAC;wBACvB;qBACD;gBACD;gBAGA,MAAM,uMAAqB,MAAA,CAAI,YAAA,CAC9B,IAAA,CAAK,MAAA,CAAO,qBAAA,CAAsBA,OAAM,EAAE,GAC1C;gBAED,IAAA,CAAK,mCAAA,GAAsC;gBAC3C,IAAA,CAAK,gCAAA,GAAmC;gBACxC,MAAM,WAAW,CAAC;uBAAGA,OAAM,KAAA,CAAM,QAAA;oBAAU,UAAU;iBAAA;gBAErD,IAAI,IAAA,CAAK,iBAAA,yMAAoB,eAAA,CAAaA,OAAM,KAAA,CAAM,IAAI,CAAA,GAAI,GAAG;oBAChE,IAAA,CAAK,iBAAA,GAAoB,IAAA,CAAK,aAAA,CAAc,QAAQ;gBACrD;gBAEA,MAAM,eAA8C;oBACnD,IAAIA,OAAM,EAAA;oBACV,MAAM,IAAA,CAAK,SAAA;oBACX,OAAO;wBACN;oBACD;gBACD;gBAEA,IAAI,IAAA,CAAK,QAAA,CAAS,GAAG;;oBAClB,aAA6C,KAAA,CAAO,QAAA,GAAW,IAAA,CAAK,WAAA,CACrE,UACAA,OAAM,KAAA,CAAM,IAAA,EACZA,OAAM,KAAA,CAAM,KAAA;gBAEd;gBAEA,IAAA,CAAK,MAAA,CAAO,YAAA,CAA6C;oBAAC,YAAY;iBAAC;gBAEvE;YACD;QACD;QAIA,IAAA,CAAK,mCAAA,GAAsC,gBAAgB,KAAA,CAAM;QACjE,MAAM,uLAAK,gBAAA,CAAc;QAGzB,IAAA,CAAK,MAAA,CAAO,WAAA,CAA2B;YACtC;YACA,MAAM,IAAA,CAAK,SAAA;YACX,GAAG,gBAAgB,CAAA;YACnB,GAAG,gBAAgB,CAAA;YACnB,OAAO;gBACN,OAAO,IAAA,CAAK,aAAA;gBACZ,OAAO,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,sBAAA,CAAuB,IAAI,IAAI,IAAA,CAAK,MAAA,CAAO,YAAA,CAAa,IAAI;gBACpF,UAAU;oBACT;wBACC,MAAM,IAAA,CAAK,WAAA;wBACX,QAAQ;4BACP;gCACC,GAAG;gCACH,GAAG;gCACH,GAAG,CAAC,SAAS,OAAA,CAAQ,CAAC;4BACvB;yBACD;oBACD;iBACD;YACD;QACD,CAAC;QACD,MAAM,QAAQ,IAAA,CAAK,MAAA,CAAO,QAAA,CAAwB,EAAE;QACpD,IAAI,CAAC,OAAO;YACX,IAAA,CAAK,MAAA,CAAO;YACZ;QACD;QACA,IAAA,CAAK,iBAAA,GAAoB;QACzB,IAAA,CAAK,YAAA,GAAe,IAAA,CAAK,MAAA,CAAO,QAAA,CAAwB,EAAE;IAC3D;IAEQ,qBAAqB;QAC5B,MAAM,EAAE,YAAA,CAAa,CAAA,GAAI,IAAA;QACzB,MAAM,EAAE,MAAA,CAAO,CAAA,GAAI,IAAA,CAAK,MAAA;QAExB,IAAI,CAAC,aAAc,CAAA;QAEnB,MAAM,EACL,EAAA,EACA,OAAO,EAAE,IAAA,EAAM,KAAA,CAAM,CAAA,EACtB,GAAI;QAEJ,MAAM,QAAQ,IAAA,CAAK,MAAA,CAAO,QAAA,CAAwB,EAAE;QAEpD,IAAI,CAAC,MAAO,CAAA;QAEZ,MAAM,EAAE,QAAA,CAAS,CAAA,GAAI,MAAM,KAAA;QAE3B,MAAM,EAAE,CAAA,EAAG,CAAA,EAAG,CAAA,CAAE,CAAA,GAAI,IAAA,CAAK,MAAA,CAAO,oBAAA,CAAqB,OAAO,OAAO,gBAAgB,EAAE,OAAA,CAAQ;QAC7F,MAAM,WAAW,IAAA,CAAK,aAAA,GAAgB,CAAA,CAAE,OAAO,gBAAA,CAAiB,CAAA,GAAK,IAAA,EAAM,OAAA,CAAQ,CAAC,IAAI;QACxF,MAAM,WAAW;YAAE;YAAG;YAAG,GAAG;QAAS;QAErC,OAAQ,IAAA,CAAK,WAAA,EAAa;YACzB,KAAK;gBAAqB;oBACzB,MAAM,EAAE,gCAAA,CAAiC,CAAA,GAAI,IAAA;oBAE7C,IAAI,qCAAqC,MAAM;wBAC9C,MAAM,MAAM,kDAAkD;oBAC/D;oBAEA,MAAM,sMACL,MAAA,CAAI,KAAA,CAAM,kCAAkC,OAAO,gBAAgB,IACnE,IAAA,CAAK,MAAA,CAAO,OAAA,CAAQ,mBAAA;oBAMrB,IAAI,mBAAmB;wBACtB,IAAA,CAAK,mCAAA,GAAsC,IAAA,CAAK,gCAAA,CAAkC,KAAA,CAAM;wBACxF,IAAA,CAAK,gCAAA,GAAmC;wBAGxC,IAAA,CAAK,WAAA,GAAc;wBAEnB,MAAM,uLAAc,OAAA,EAAK,QAAQ;wBACjC,IAAI,CAAC,YAAa,CAAA,MAAM,MAAM,8BAA8B;wBAE5D,MAAM,gBAAgB,gLAAA,EAAK,YAAY,MAAM;wBAC7C,IAAI,CAAC,cAAe,CAAA,MAAM,MAAM,iCAAiC;wBAEjE,IAAI;wBAEJ,MAAM,eAAe,IAAA,CAAK,MAAA,CACxB,oBAAA,CAAqB,OAAO,IAAA,CAAK,mCAAmC,EACpE,OAAA,CAAQ,EACR,MAAA,CAAO;wBAET,IAAI,YAAY,IAAA,KAAS,YAAY;4BACpC,IAAA,CAAK,iBAAA,sLAAqB,MAAA,CAAI,IAAA,CAAK,eAAe,YAAY;4BAE9D,aAAa;gCACZ,MAAM;gCACN,QAAQ;oCAAC;wCAAE,GAAG,aAAA;oCAAc;oCAAG,YAAY;iCAAA;4BAC5C;4BAEA,MAAM,YAAY,IAAA,CAAK,MAAA,CAAO,qBAAA,CAAsB,KAAK;4BAEzD,IAAA,CAAK,mCAAA,qLAAsC,MAAA,CAAI,YAAA,CAAa,WAAW,aAAa;wBACrF,OAAO;4BACN,aAAa;gCACZ,MAAM;gCACN,QAAQ;oCAAC;oCAAc,QAAQ;iCAAA;4BAChC;wBACD;wBAEA,MAAM,eAA8C;4BACnD;4BACA,MAAM,IAAA,CAAK,SAAA;4BACX,OAAO;gCACN,UAAU,CAAC;uCAAG;oCAAU,UAAU;iCAAA;4BACnC;wBACD;wBAEA,IAAI,IAAA,CAAK,QAAA,CAAS,GAAG;;4BAClB,aAA6C,KAAA,CAAO,QAAA,GAAW,IAAA,CAAK,WAAA,CACrE,UACA,MACA;wBAEF;wBAEA,IAAA,CAAK,MAAA,CAAO,YAAA,CAA6C;4BAAC,YAAY;yBAAC;oBACxE;oBACA;gBACD;YACA,KAAK;gBAAiB;oBACrB,MAAM,EAAE,gCAAA,CAAiC,CAAA,GAAI,IAAA;oBAE7C,IAAI,qCAAqC,MAAM;wBAC9C,MAAM,MAAM,kDAAkD;oBAC/D;oBAEA,MAAM,sMACL,MAAA,CAAI,KAAA,CAAM,kCAAkC,OAAO,gBAAgB,IACnE,IAAA,CAAK,MAAA,CAAO,OAAA,CAAQ,mBAAA;oBAMrB,IAAI,mBAAmB;wBACtB,IAAA,CAAK,mCAAA,GAAsC,IAAA,CAAK,gCAAA,CAAkC,KAAA,CAAM;wBACxF,IAAA,CAAK,gCAAA,GAAmC;wBAGxC,IAAA,CAAK,WAAA,GAAc;wBAEnB,MAAM,cAAc,SAAS,KAAA,CAAM;wBACnC,MAAM,sBAAsB,WAAA,CAAY,YAAY,MAAA,GAAS,CAAC,CAAA;wBAC9D,MAAM,qLAAY,OAAA,EAAK,oBAAoB,MAAM;wBAEjD,IAAI,CAAC,WAAW;4BACf,MAAM,MAAM,oBAAoB;wBACjC;wBAIA,MAAM,iBAAqC;4BAC1C,MAAM;4BACN,QAAQ;qNACJ,MAAA,CAAI,aAAA,CAAc,WAAW,UAAU,CAAC,EAAE,GAAA,CAAI,CAAC,IAAA,CAAO;wCACxD,2LAAG,UAAA,EAAQ,EAAE,CAAC;wCACd,IAAG,iMAAA,EAAQ,EAAE,CAAC;wCACd,2LAAG,UAAA,EAAQ,EAAE,CAAC;oCACf,CAAA,CAAE;6BACH;wBACD;wBAEA,MAAM,gBAAgB,CAAC;+BAAG;4BAAa,cAAc;yBAAA;wBAErD,IAAI,IAAA,CAAK,iBAAA,yMAAoB,eAAA,CAAa,MAAM,KAAA,CAAM,IAAI,CAAA,GAAI,GAAG;4BAChE,IAAA,CAAK,iBAAA,GAAoB,IAAA,CAAK,aAAA,CAAc,aAAa;wBAC1D;wBAEA,MAAM,eAA8C;4BACnD;4BACA,MAAM,IAAA,CAAK,SAAA;4BACX,OAAO;gCACN,UAAU;4BACX;wBACD;wBAEA,IAAI,IAAA,CAAK,QAAA,CAAS,GAAG;;4BAClB,aAA6C,KAAA,CAAO,QAAA,GAAW,IAAA,CAAK,WAAA,CACrE,eACA,MACA;wBAEF;wBAEA,IAAA,CAAK,MAAA,CAAO,YAAA,CAAa;4BAAC,YAAY;yBAAC;oBACxC;oBAEA;gBACD;YACA,KAAK;gBAAY;oBAChB,MAAM,cAAc,SAAS,KAAA,CAAM;oBACnC,MAAM,aAAa,WAAA,CAAY,YAAY,MAAA,GAAS,CAAC,CAAA;oBAErD,MAAM,EAAE,mCAAA,CAAoC,CAAA,GAAI,IAAA;oBAChD,MAAM,EAAE,OAAA,EAAS,gBAAA,CAAiB,CAAA,GAAI,IAAA,CAAK,MAAA,CAAO,MAAA;oBAElD,IAAI,CAAC,qCACJ,MAAM,MAAM,kDAAkD;oBAE/D,IAAI;oBACJ,IAAI,oBAAoB;oBAExB,IAAI,IAAA,CAAK,0CAAA,EAA4C;wBACpD,IAAI,IAAA,CAAK,MAAA,CAAO,MAAA,CAAO,UAAA,EAAY;4BAElC,oBAAoB,CAAC;4BACrB,IAAA,CAAK,0CAAA,GAA6C;wBACnD,OAAO,CAEP;oBACD,OAAO;wBAEN,oBAAoB,CAAC;oBACtB;oBAEA,IAAIC,YAAW,IAAA,CAAK,MAAA,CAAO,oBAAA,CAAqB,OAAO,gBAAgB,EAAE,OAAA,CAAQ,EAAE,MAAA,CAAO;oBAC1F,IAAI,UAAU;oBACd,IAAI,cAA8C,KAAA;oBAElD,MAAM,aAAa,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,aAAA,CAAc,IAAI,CAAC,UAAU;oBAEjE,IAAI,YAAY;wBACf,IAAI,YAAY,MAAA,GAAS,GAAG;4BAC3B,IAAI,eAAqC,KAAA;4BACzC,IAAI,cAAc,IAAI,IAAA,CAAK,MAAA,CAAO,YAAA,CAAa;4BAG/C,IAAA,IAAS,IAAI,GAAG,IAAI,SAAS,MAAA,GAAS,GAAG,IAAI,GAAG,IAAK;gCACpD,MAAM,UAAU,QAAA,CAAS,CAAC,CAAA;gCAC1B,IAAI,CAAC,QAAS,CAAA;gCACd,IAAI,QAAQ,IAAA,KAAS,OAAQ,CAAA;gCAE7B,MAAM,QAAQ,QAAQ,MAAA,CAAO,CAAC,CAAA;gCAC9B,MAAM,qLAAY,OAAA,EAAK,QAAQ,MAAM;gCACrC,IAAI,CAAA,CAAE,SAAS,SAAA,EAAY,CAAA;gCAG3B,MAAM,0MAAwB,MAAA,CAAI,yBAAA,CACjC,OACA,WACAA;gCAGD,IAAI,wLAAA,CAAI,OAAA,CAAQ,uBAAuBA,WAAU,WAAW,GAAG;oCAC9D,eAAe,sBAAsB,OAAA,CAAQ,EAAE,MAAA,CAAO;oCACtD,gMAAc,MAAA,CAAI,IAAA,CAAK,uBAAuBA,SAAQ;oCACtD,cAAc;oCACd;gCACD;4BACD;4BAEA,IAAI,cAAc;gCACjB,UAAU;gCACVA,YAAW;4BACZ;wBACD;oBACD;oBAEA,IAAI,WAAW,aAAa;wBAC3B,MAAM,YAAY,IAAA,CAAK,MAAA,CAAO,qBAAA,CAAsB,KAAK;wBACzD,MAAM,QAAQ,YAAY,MAAA,CAAO,CAAC,CAAA;wBAClC,MAAM,qLAAY,OAAA,EAAK,YAAY,MAAM;wBACzC,IAAI,CAAC,UAAW,CAAA,MAAM,MAAM,wBAAwB;wBAEpD,MAAM,sLAAI,MAAA,CAAI,YAAA,CAAa,WAAW,KAAK;wBAE3C,MAAM,sLAAI,MAAA,CAAI,YAAA,CAAa,WAAW,SAAS;wBAE/C,MAAM,iMAAe,MAAA,CAAI,YAAA,CAAa,WAAWA,SAAQ;wBAEzD,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,aAAA,CAAc;4BAC/B;gCACC,0KAAI,WAAA,CAAS;gCACb,MAAM;gCACN,QAAQ;oCAAC;oCAAG;oCAAc,CAAC;iCAAA;4BAC5B;yBACA;oBACF,OAAO;wBACN,IAAA,CAAK,MAAA,CAAO,KAAA,CAAM,eAAA,CAAgB;wBAElC,IAAI,mBAAmB;4BAEtB,MAAM,iMAAe,MAAA,CAAI,KAAA,CAAM,qCAAqC,gBAAgB;4BACpF,MAAM,uMAAe,YAAA,EAAU,cAAc,EAAE;4BAC/C,MAAM,YAAY,eAAe;4BAEjC,8LAAY,MAAA,CAAI,OAAA,CACf,kBACA,qCACA;wBAEF,OAAO;4BACN,YAAY;wBACb;wBAEAA,YAAW,IAAA,CAAK,MAAA,CAAO,oBAAA,CAAqB,OAAO,SAAS,EAAE,OAAA,CAAQ,EAAE,MAAA,CAAO;oBAChF;oBAMA,IAAA,CAAK,iBAAA,sLAAqB,MAAA,CAAI,IAAA,CAAK,WAAW,MAAA,CAAO,CAAC,CAAA,EAAGA,SAAQ;oBAEjE,WAAA,CAAY,YAAY,MAAA,GAAS,CAAC,CAAA,GAAI;wBACrC,GAAG,UAAA;wBACH,MAAM;wBACN,QAAQ;4BAAC,WAAW,MAAA,CAAO,CAAC,CAAA;4BAAGA,SAAQ;yBAAA;oBACxC;oBAEA,MAAM,eAA8C;wBACnD;wBACA,MAAM,IAAA,CAAK,SAAA;wBACX,OAAO;4BACN,UAAU;wBACX;oBACD;oBAEA,IAAI,IAAA,CAAK,QAAA,CAAS,GAAG;;wBAClB,aAA6C,KAAA,CAAO,QAAA,GAAW,IAAA,CAAK,WAAA,CACrE,UACA,MACA;oBAEF;oBAEA,IAAA,CAAK,MAAA,CAAO,YAAA,CAAa;wBAAC,YAAY;qBAAC;oBAEvC;gBACD;YACA,KAAK;gBAAQ;oBACZ,MAAM,cAAc,SAAS,KAAA,CAAM;oBACnC,MAAM,aAAa,WAAA,CAAY,YAAY,MAAA,GAAS,CAAC,CAAA;oBACrD,MAAM,YAAY,CAAC;2BAAG,WAAW,MAAM;qBAAA;oBAEvC,IAAI,UAAU,MAAA,IAAU,IAAA,CAAK,cAAA,EAAgB;wBAC5C,MAAM,EAAE,GAAAC,EAAAA,CAAE,CAAA,GAAI,SAAA,CAAU,UAAU,MAAA,GAAS,CAAC,CAAA;wBAC5C,SAAA,CAAU,UAAU,MAAA,GAAS,CAAC,CAAA,GAAI;4BACjC,GAAG,SAAS,CAAA;4BACZ,GAAG,SAAS,CAAA;4BACZ,GAAGA,KAAI,KAAK,GAAA,CAAIA,IAAG,SAAS,CAAC,IAAI,SAAS,CAAA;wBAC3C;oBAGD,OAAO;wBACN,IAAA,CAAK,iBAAA,sLAAqB,MAAA,CAAI,IAAA,CAAK,SAAA,CAAU,UAAU,MAAA,GAAS,CAAC,CAAA,EAAG,QAAQ;wBAC5E,UAAU,IAAA,CAAK,QAAQ;oBACxB;oBAEA,WAAA,CAAY,YAAY,MAAA,GAAS,CAAC,CAAA,GAAI;wBACrC,GAAG,UAAA;wBACH,QAAQ;oBACT;oBAEA,IAAI,IAAA,CAAK,iBAAA,yMAAoB,eAAA,CAAa,MAAM,KAAA,CAAM,IAAI,CAAA,GAAI,GAAG;wBAChE,IAAA,CAAK,iBAAA,GAAoB,IAAA,CAAK,aAAA,CAAc,WAAW;oBACxD;oBAEA,MAAM,eAA8C;wBACnD;wBACA,MAAM,IAAA,CAAK,SAAA;wBACX,OAAO;4BACN,UAAU;wBACX;oBACD;oBAEA,IAAI,IAAA,CAAK,QAAA,CAAS,GAAG;;wBAClB,aAA6C,KAAA,CAAO,QAAA,GAAW,IAAA,CAAK,WAAA,CACrE,aACA,MACA;oBAEF;oBAEA,IAAA,CAAK,MAAA,CAAO,YAAA,CAAa;wBAAC,YAAY;qBAAC;oBAGvC,IAAI,UAAU,MAAA,GAAS,IAAA,CAAK,IAAA,CAAK,OAAA,CAAQ,iBAAA,EAAmB;wBAC3D,IAAA,CAAK,MAAA,CAAO,YAAA,CAAa;4BAAC;gCAAE;gCAAI,MAAM,IAAA,CAAK,SAAA;gCAAW,OAAO;oCAAE,YAAY;gCAAK;4BAAE,CAAC;yBAAC;wBAEpF,MAAM,+LAAa,gBAAA,CAAc;wBAEjC,MAAM,QAAQ,IAAA,CAAK,MAAA,CAAO,QAAA,CAAwB,EAAE,EAAG,KAAA;wBAEvD,IAAI,CAAC,IAAA,CAAK,MAAA,CAAO,eAAA,CAAgB;4BAAC,UAAU;yBAAC,EAAG,CAAA,OAAO,IAAA,CAAK,MAAA,CAAO;wBACnE,IAAA,CAAK,MAAA,CAAO,WAAA,CAA2B;4BACtC,IAAI;4BACJ,MAAM,IAAA,CAAK,SAAA;4BACX,OAAG,8LAAA,EAAQ,OAAO,gBAAA,CAAiB,CAAC;4BACpC,2LAAG,UAAA,EAAQ,OAAO,gBAAA,CAAiB,CAAC;4BACpC,OAAO;gCACN,OAAO,IAAA,CAAK,aAAA;gCACZ,OAAO,MAAM,KAAA;gCACb,UAAU;oCACT;wCACC,MAAM;wCACN,QAAQ;4CAAC;gDAAE,GAAG;gDAAG,GAAG;gDAAG,GAAG,IAAA,CAAK,aAAA,GAAgB,CAAA,CAAE,IAAK,IAAA,EAAM,OAAA,CAAQ,IAAI;4CAAI,CAAC;yCAAA;oCAC9E;iCACD;4BACD;wBACD,CAAC;wBAED,MAAMF,SAAQ,IAAA,CAAK,MAAA,CAAO,QAAA,CAAwB,UAAU;wBAE5D,IAAI,CAACA,QAAO;4BAGX,OAAO,IAAA,CAAK,MAAA,CAAO;wBACpB;wBAEA,IAAA,CAAK,YAAA,4KAAe,kBAAA,EAAgBA,MAAK;wBACzC,IAAA,CAAK,cAAA,GAAiB;wBACtB,IAAA,CAAK,iBAAA,GAAoB,OAAO,gBAAA,CAAiB,KAAA,CAAM;wBACvD,IAAA,CAAK,iBAAA,GAAoB;oBAC1B;oBAEA;gBACD;QACD;IACD;IAEQ,cAAc,QAAA,EAAgC;QACrD,IAAI,SAAS;QAEb,KAAA,MAAW,WAAW,SAAU;YAC/B,IAAA,IAAS,IAAI,GAAG,IAAI,QAAQ,MAAA,CAAO,MAAA,GAAS,GAAG,IAAK;gBACnD,MAAM,IAAI,QAAQ,MAAA,CAAO,CAAC,CAAA;gBAC1B,MAAM,IAAI,QAAQ,MAAA,CAAO,IAAI,CAAC,CAAA;gBAC9B,4LAAU,MAAA,CAAI,KAAA,CAAM,GAAG,CAAC;YACzB;QACD;QAEA,OAAO,KAAK,IAAA,CAAK,MAAM;IACxB;IAES,cAAc;QACtB,IAAA,CAAK,QAAA,CAAS;IACf;IAES,WAAW;QACnB,IAAA,CAAK,MAAA,CAAO;IACb;IAES,aAAa;QACrB,IAAA,CAAK,QAAA,CAAS;IACf;IAES,cAAc;QACtB,IAAI,IAAA,CAAK,MAAA,CAAO,MAAA,CAAO,UAAA,EAAY;YAClC;QACD;QAEA,IAAI,IAAA,CAAK,MAAA,EAAQ;YAChB,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,IAAA,CAAK,MAAM;QACnC;QACA,IAAA,CAAK,MAAA,CAAO;IACb;IAEA,WAAW;QACV,MAAM,EAAE,YAAA,CAAa,CAAA,GAAI,IAAA;QACzB,IAAI,CAAC,aAAc,CAAA;QACnB,IAAA,CAAK,MAAA,CAAO,YAAA,CAAa;YACxB;gBAAE,IAAI,aAAa,EAAA;gBAAI,MAAM,aAAa,IAAA;gBAAM,OAAO;oBAAE,YAAY;gBAAK;YAAE;SAC5E;QAED,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,MAAM;IAC9B;IAEA,SAAS;QACR,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,QAAQ,IAAA,CAAK,IAAI;IACzC;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5158, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/draw/toolStates/Idle.ts"],"sourcesContent":["import { StateNode, TLPointerEventInfo } from '@tldraw/editor'\n\nexport class Idle extends StateNode {\n\tstatic override id = 'idle'\n\n\toverride onPointerDown(info: TLPointerEventInfo) {\n\t\tthis.parent.transition('drawing', info)\n\t}\n\n\toverride onEnter() {\n\t\tthis.editor.setCursor({ type: 'cross', rotation: 0 })\n\t}\n\n\toverride onCancel() {\n\t\tthis.editor.setCurrentTool('select')\n\t}\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,iBAAqC;;AAEvC,MAAM,0MAAa,YAAA,CAAU;IACnC,OAAgB,KAAK,OAAA;IAEZ,cAAc,IAAA,EAA0B;QAChD,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,WAAW,IAAI;IACvC;IAES,UAAU;QAClB,IAAA,CAAK,MAAA,CAAO,SAAA,CAAU;YAAE,MAAM;YAAS,UAAU;QAAE,CAAC;IACrD;IAES,WAAW;QACnB,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,QAAQ;IACpC;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5187, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/draw/DrawShapeTool.ts"],"sourcesContent":["import { StateNode, TLStateNodeConstructor } from '@tldraw/editor'\nimport { Drawing } from './toolStates/Drawing'\nimport { Idle } from './toolStates/Idle'\n\n/** @public */\nexport class DrawShapeTool extends StateNode {\n\tstatic override id = 'draw'\n\tstatic override initial = 'idle'\n\tstatic override isLockable = false\n\tstatic override useCoalescedEvents = true\n\tstatic override children(): TLStateNodeConstructor[] {\n\t\treturn [Idle, Drawing]\n\t}\n\n\toverride shapeType = 'draw'\n\n\toverride onExit() {\n\t\tconst drawingState = this.children!['drawing'] as Drawing\n\t\tdrawingState.initialShape = undefined\n\t}\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,iBAAyC;AAClD,SAAS,eAAe;AACxB,SAAS,YAAY;;;;AAGd,MAAM,mNAAsB,YAAA,CAAU;IAC5C,OAAgB,KAAK,OAAA;IACrB,OAAgB,UAAU,OAAA;IAC1B,OAAgB,aAAa,MAAA;IAC7B,OAAgB,qBAAqB,KAAA;IACrC,OAAgB,WAAqC;QACpD,OAAO;qMAAC,OAAA;wMAAM,UAAO;SAAA;IACtB;IAES,YAAY,OAAA;IAEZ,SAAS;QACjB,MAAM,eAAe,IAAA,CAAK,QAAA,CAAU,SAAS,CAAA;QAC7C,aAAa,YAAA,GAAe,KAAA;IAC7B;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5222, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/frame/FrameShapeTool.ts"],"sourcesContent":["import { BaseBoxShapeTool, TLShape, TLShapeId } from '@tldraw/editor'\n\n/** @public */\nexport class FrameShapeTool extends BaseBoxShapeTool {\n\tstatic override id = 'frame'\n\tstatic override initial = 'idle'\n\toverride shapeType = 'frame'\n\n\toverride onCreate(shape: TLShape | null): void {\n\t\tif (!shape) return\n\n\t\tconst bounds = this.editor.getShapePageBounds(shape)!\n\t\tconst shapesToAddToFrame: TLShapeId[] = []\n\t\tconst ancestorIds = this.editor.getShapeAncestors(shape).map((shape) => shape.id)\n\n\t\tthis.editor.getSortedChildIdsForParent(shape.parentId).map((siblingShapeId) => {\n\t\t\tconst siblingShape = this.editor.getShape(siblingShapeId)\n\t\t\tif (!siblingShape) return\n\t\t\t// We don't want to frame the frame itself\n\t\t\tif (siblingShape.id === shape.id) return\n\t\t\tif (siblingShape.isLocked) return\n\n\t\t\tconst pageShapeBounds = this.editor.getShapePageBounds(siblingShape)\n\t\t\tif (!pageShapeBounds) return\n\n\t\t\t// Frame shape encloses page shape\n\t\t\tif (bounds.contains(pageShapeBounds)) {\n\t\t\t\tif (canEnclose(siblingShape, ancestorIds, shape)) {\n\t\t\t\t\tshapesToAddToFrame.push(siblingShape.id)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\tthis.editor.reparentShapes(shapesToAddToFrame, shape.id)\n\n\t\tif (this.editor.getInstanceState().isToolLocked) {\n\t\t\tthis.editor.setCurrentTool('frame')\n\t\t} else {\n\t\t\tthis.editor.setCurrentTool('select.idle')\n\t\t}\n\t}\n}\n\n/** @internal */\nfunction canEnclose(shape: TLShape, ancestorIds: TLShapeId[], frame: TLShape): boolean {\n\t// We don't want to pull in shapes that are ancestors of the frame (can create a cycle)\n\tif (ancestorIds.includes(shape.id)) {\n\t\treturn false\n\t}\n\t// We only want to pull in shapes that are siblings of the frame\n\tif (shape.parentId === frame.parentId) {\n\t\treturn true\n\t}\n\treturn false\n}\n"],"names":["shape"],"mappings":";;;;AAAA,SAAS,wBAA4C;;AAG9C,MAAM,+OAAuB,mBAAA,CAAiB;IACpD,OAAgB,KAAK,QAAA;IACrB,OAAgB,UAAU,OAAA;IACjB,YAAY,QAAA;IAEZ,SAAS,KAAA,EAA6B;QAC9C,IAAI,CAAC,MAAO,CAAA;QAEZ,MAAM,SAAS,IAAA,CAAK,MAAA,CAAO,kBAAA,CAAmB,KAAK;QACnD,MAAM,qBAAkC,CAAC,CAAA;QACzC,MAAM,cAAc,IAAA,CAAK,MAAA,CAAO,iBAAA,CAAkB,KAAK,EAAE,GAAA,CAAI,CAACA,SAAUA,OAAM,EAAE;QAEhF,IAAA,CAAK,MAAA,CAAO,0BAAA,CAA2B,MAAM,QAAQ,EAAE,GAAA,CAAI,CAAC,mBAAmB;YAC9E,MAAM,eAAe,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,cAAc;YACxD,IAAI,CAAC,aAAc,CAAA;YAEnB,IAAI,aAAa,EAAA,KAAO,MAAM,EAAA,CAAI,CAAA;YAClC,IAAI,aAAa,QAAA,CAAU,CAAA;YAE3B,MAAM,kBAAkB,IAAA,CAAK,MAAA,CAAO,kBAAA,CAAmB,YAAY;YACnE,IAAI,CAAC,gBAAiB,CAAA;YAGtB,IAAI,OAAO,QAAA,CAAS,eAAe,GAAG;gBACrC,IAAI,WAAW,cAAc,aAAa,KAAK,GAAG;oBACjD,mBAAmB,IAAA,CAAK,aAAa,EAAE;gBACxC;YACD;QACD,CAAC;QAED,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,oBAAoB,MAAM,EAAE;QAEvD,IAAI,IAAA,CAAK,MAAA,CAAO,gBAAA,CAAiB,EAAE,YAAA,EAAc;YAChD,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,OAAO;QACnC,OAAO;YACN,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,aAAa;QACzC;IACD;AACD;AAGA,SAAS,WAAW,KAAA,EAAgB,WAAA,EAA0B,KAAA,EAAyB;IAEtF,IAAI,YAAY,QAAA,CAAS,MAAM,EAAE,GAAG;QACnC,OAAO;IACR;IAEA,IAAI,MAAM,QAAA,KAAa,MAAM,QAAA,EAAU;QACtC,OAAO;IACR;IACA,OAAO;AACR","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5275, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/geo/toolStates/Idle.ts"],"sourcesContent":["import { StateNode, TLKeyboardEventInfo, TLPointerEventInfo } from '@tldraw/editor'\n\nexport class Idle extends StateNode {\n\tstatic override id = 'idle'\n\n\toverride onPointerDown(info: TLPointerEventInfo) {\n\t\tthis.parent.transition('pointing', info)\n\t}\n\n\toverride onEnter() {\n\t\tthis.editor.setCursor({ type: 'cross', rotation: 0 })\n\t}\n\n\toverride onKeyUp(info: TLKeyboardEventInfo) {\n\t\tif (info.key === 'Enter') {\n\t\t\tif (this.editor.getIsReadonly()) return null\n\n\t\t\tconst onlySelectedShape = this.editor.getOnlySelectedShape()\n\t\t\t// If the only selected shape is editable, start editing it\n\t\t\tif (\n\t\t\t\tonlySelectedShape &&\n\t\t\t\tthis.editor.getShapeUtil(onlySelectedShape).canEdit(onlySelectedShape)\n\t\t\t) {\n\t\t\t\tthis.editor.setCurrentTool('select')\n\t\t\t\tthis.editor.setEditingShape(onlySelectedShape.id)\n\t\t\t\tthis.editor.root.getCurrent()?.transition('editing_shape', {\n\t\t\t\t\t...info,\n\t\t\t\t\ttarget: 'shape',\n\t\t\t\t\tshape: onlySelectedShape,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\toverride onCancel() {\n\t\tthis.editor.setCurrentTool('select')\n\t}\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,iBAA0D;;AAE5D,MAAM,0MAAa,YAAA,CAAU;IACnC,OAAgB,KAAK,OAAA;IAEZ,cAAc,IAAA,EAA0B;QAChD,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,YAAY,IAAI;IACxC;IAES,UAAU;QAClB,IAAA,CAAK,MAAA,CAAO,SAAA,CAAU;YAAE,MAAM;YAAS,UAAU;QAAE,CAAC;IACrD;IAES,QAAQ,IAAA,EAA2B;QAC3C,IAAI,KAAK,GAAA,KAAQ,SAAS;YACzB,IAAI,IAAA,CAAK,MAAA,CAAO,aAAA,CAAc,EAAG,CAAA,OAAO;YAExC,MAAM,oBAAoB,IAAA,CAAK,MAAA,CAAO,oBAAA,CAAqB;YAE3D,IACC,qBACA,IAAA,CAAK,MAAA,CAAO,YAAA,CAAa,iBAAiB,EAAE,OAAA,CAAQ,iBAAiB,GACpE;gBACD,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,QAAQ;gBACnC,IAAA,CAAK,MAAA,CAAO,eAAA,CAAgB,kBAAkB,EAAE;gBAChD,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,UAAA,CAAW,GAAG,WAAW,iBAAiB;oBAC1D,GAAG,IAAA;oBACH,QAAQ;oBACR,OAAO;gBACR,CAAC;YACF;QACD;IACD;IAES,WAAW;QACnB,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,QAAQ;IACpC;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5319, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/geo/toolStates/Pointing.ts"],"sourcesContent":["import {\n\tGeoShapeGeoStyle,\n\tStateNode,\n\tTLGeoShape,\n\tTLPointerEventInfo,\n\tVec,\n\tcreateShapeId,\n\tmaybeSnapToGrid,\n} from '@tldraw/editor'\n\nexport class Pointing extends StateNode {\n\tstatic override id = 'pointing'\n\n\toverride onPointerUp() {\n\t\tthis.complete()\n\t}\n\n\toverride onPointerMove(info: TLPointerEventInfo) {\n\t\tif (this.editor.inputs.isDragging) {\n\t\t\tconst { originPagePoint } = this.editor.inputs\n\n\t\t\tconst id = createShapeId()\n\n\t\t\tconst creatingMarkId = this.editor.markHistoryStoppingPoint(`creating_geo:${id}`)\n\t\t\tconst newPoint = maybeSnapToGrid(originPagePoint, this.editor)\n\t\t\tthis.editor\n\t\t\t\t.createShapes<TLGeoShape>([\n\t\t\t\t\t{\n\t\t\t\t\t\tid,\n\t\t\t\t\t\ttype: 'geo',\n\t\t\t\t\t\tx: newPoint.x,\n\t\t\t\t\t\ty: newPoint.y,\n\t\t\t\t\t\tprops: {\n\t\t\t\t\t\t\tw: 1,\n\t\t\t\t\t\t\th: 1,\n\t\t\t\t\t\t\tgeo: this.editor.getStyleForNextShape(GeoShapeGeoStyle),\n\t\t\t\t\t\t\tscale: this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t])\n\t\t\t\t.select(id)\n\n\t\t\tconst shape = this.editor.getShape(id)\n\t\t\tif (!shape) {\n\t\t\t\tthis.cancel()\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tthis.editor.setCurrentTool('select.resizing', {\n\t\t\t\t...info,\n\t\t\t\ttarget: 'selection',\n\t\t\t\thandle: 'bottom_right',\n\t\t\t\tisCreating: true,\n\t\t\t\tcreatingMarkId,\n\t\t\t\tcreationCursorOffset: { x: 1, y: 1 },\n\t\t\t\tonInteractionEnd: 'geo',\n\t\t\t})\n\t\t}\n\t}\n\n\toverride onCancel() {\n\t\tthis.cancel()\n\t}\n\n\toverride onComplete() {\n\t\tthis.complete()\n\t}\n\n\toverride onInterrupt() {\n\t\tthis.cancel()\n\t}\n\n\tprivate complete() {\n\t\tconst { originPagePoint } = this.editor.inputs\n\n\t\tconst id = createShapeId()\n\n\t\tthis.editor.markHistoryStoppingPoint(`creating_geo:${id}`)\n\n\t\tconst scale = this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1\n\n\t\tconst geo = this.editor.getStyleForNextShape(GeoShapeGeoStyle)\n\n\t\tconst size =\n\t\t\tgeo === 'star'\n\t\t\t\t? { w: 200, h: 190 }\n\t\t\t\t: geo === 'cloud'\n\t\t\t\t\t? { w: 300, h: 180 }\n\t\t\t\t\t: { w: 200, h: 200 }\n\n\t\tthis.editor.createShapes<TLGeoShape>([\n\t\t\t{\n\t\t\t\tid,\n\t\t\t\ttype: 'geo',\n\t\t\t\tx: originPagePoint.x,\n\t\t\t\ty: originPagePoint.y,\n\t\t\t\tprops: {\n\t\t\t\t\tgeo: this.editor.getStyleForNextShape(GeoShapeGeoStyle),\n\t\t\t\t\tscale,\n\t\t\t\t\t...size,\n\t\t\t\t},\n\t\t\t},\n\t\t])\n\n\t\tconst shape = this.editor.getShape<TLGeoShape>(id)!\n\t\tif (!shape) {\n\t\t\tthis.cancel()\n\t\t\treturn\n\t\t}\n\n\t\tconst { w, h } = shape.props\n\n\t\tconst delta = new Vec(w / 2, h / 2).mul(scale)\n\t\tconst parentTransform = this.editor.getShapeParentTransform(shape)\n\t\tif (parentTransform) delta.rot(-parentTransform.rotation())\n\t\tconst newPoint = maybeSnapToGrid(new Vec(shape.x - delta.x, shape.y - delta.y), this.editor)\n\t\tthis.editor.select(id)\n\t\tthis.editor.updateShape<TLGeoShape>({\n\t\t\tid: shape.id,\n\t\t\ttype: 'geo',\n\t\t\tx: newPoint.x,\n\t\t\ty: newPoint.y,\n\t\t\tprops: {\n\t\t\t\tgeo: this.editor.getStyleForNextShape(GeoShapeGeoStyle),\n\t\t\t\tw: w * scale,\n\t\t\t\th: h * scale,\n\t\t\t},\n\t\t})\n\n\t\tif (this.editor.getInstanceState().isToolLocked) {\n\t\t\tthis.parent.transition('idle')\n\t\t} else {\n\t\t\tthis.editor.setCurrentTool('select', {})\n\t\t}\n\t}\n\n\tprivate cancel() {\n\t\t// we should not have created any shapes yet, so no need to bail\n\t\tthis.parent.transition('idle')\n\t}\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5451, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/geo/GeoShapeTool.ts"],"sourcesContent":["import { StateNode, TLStateNodeConstructor } from '@tldraw/editor'\nimport { Idle } from './toolStates/Idle'\nimport { Pointing } from './toolStates/Pointing'\n\n/** @public */\nexport class GeoShapeTool extends StateNode {\n\tstatic override id = 'geo'\n\tstatic override initial = 'idle'\n\tstatic override children(): TLStateNodeConstructor[] {\n\t\treturn [Idle, Pointing]\n\t}\n\toverride shapeType = 'geo'\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,iBAAyC;AAClD,SAAS,YAAY;AACrB,SAAS,gBAAgB;;;;AAGlB,MAAM,kNAAqB,YAAA,CAAU;IAC3C,OAAgB,KAAK,MAAA;IACrB,OAAgB,UAAU,OAAA;IAC1B,OAAgB,WAAqC;QACpD,OAAO;oMAAC,OAAA;wMAAM,WAAQ;SAAA;IACvB;IACS,YAAY,MAAA;AACtB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5480, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/highlight/HighlightShapeTool.ts"],"sourcesContent":["// shared custody\nimport { StateNode, TLStateNodeConstructor } from '@tldraw/editor'\nimport { Drawing } from '../draw/toolStates/Drawing'\nimport { Idle } from '../draw/toolStates/Idle'\n\n/** @public */\nexport class HighlightShapeTool extends StateNode {\n\tstatic override id = 'highlight'\n\tstatic override initial = 'idle'\n\tstatic override useCoalescedEvents = true\n\tstatic override children(): TLStateNodeConstructor[] {\n\t\treturn [Idle, Drawing]\n\t}\n\tstatic override isLockable = false\n\toverride shapeType = 'highlight'\n\n\toverride onExit() {\n\t\tconst drawingState = this.children!['drawing'] as Drawing\n\t\tdrawingState.initialShape = undefined\n\t}\n}\n"],"names":[],"mappings":";;;;AACA,SAAS,iBAAyC;AAClD,SAAS,eAAe;AACxB,SAAS,YAAY;;;;AAGd,MAAM,wNAA2B,YAAA,CAAU;IACjD,OAAgB,KAAK,YAAA;IACrB,OAAgB,UAAU,OAAA;IAC1B,OAAgB,qBAAqB,KAAA;IACrC,OAAgB,WAAqC;QACpD,OAAO;qMAAC,OAAA;wMAAM,UAAO;SAAA;IACtB;IACA,OAAgB,aAAa,MAAA;IACpB,YAAY,YAAA;IAEZ,SAAS;QACjB,MAAM,eAAe,IAAA,CAAK,QAAA,CAAU,SAAS,CAAA;QAC7C,aAAa,YAAA,GAAe,KAAA;IAC7B;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5515, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/line/toolStates/Idle.ts"],"sourcesContent":["import { StateNode, TLShapeId } from '@tldraw/editor'\n\nexport class Idle extends StateNode {\n\tstatic override id = 'idle'\n\n\tprivate shapeId = '' as TLShapeId\n\n\toverride onEnter(info: { shapeId: TLShapeId }) {\n\t\tthis.shapeId = info.shapeId\n\t\tthis.editor.setCursor({ type: 'cross', rotation: 0 })\n\t}\n\n\toverride onPointerDown() {\n\t\tthis.parent.transition('pointing', { shapeId: this.shapeId })\n\t}\n\n\toverride onCancel() {\n\t\tthis.editor.setCurrentTool('select')\n\t}\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,iBAA4B;;AAE9B,MAAM,0MAAa,YAAA,CAAU;IACnC,OAAgB,KAAK,OAAA;IAEb,UAAU,GAAA;IAET,QAAQ,IAAA,EAA8B;QAC9C,IAAA,CAAK,OAAA,GAAU,KAAK,OAAA;QACpB,IAAA,CAAK,MAAA,CAAO,SAAA,CAAU;YAAE,MAAM;YAAS,UAAU;QAAE,CAAC;IACrD;IAES,gBAAgB;QACxB,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,YAAY;YAAE,SAAS,IAAA,CAAK,OAAA;QAAQ,CAAC;IAC7D;IAES,WAAW;QACnB,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,QAAQ;IACpC;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5548, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/line/toolStates/Pointing.ts"],"sourcesContent":["import {\n\tMat,\n\tStateNode,\n\tTLLineShape,\n\tTLShapeId,\n\tVec,\n\tcreateShapeId,\n\tgetIndexAbove,\n\tlast,\n\tmaybeSnapToGrid,\n\tsortByIndex,\n\tstructuredClone,\n} from '@tldraw/editor'\n\nconst MINIMUM_DISTANCE_BETWEEN_SHIFT_CLICKED_HANDLES = 2\n\nexport class Pointing extends StateNode {\n\tstatic override id = 'pointing'\n\n\tshape = {} as TLLineShape\n\n\tmarkId: string | undefined\n\n\toverride onEnter(info: { shapeId?: TLShapeId }) {\n\t\tconst { inputs } = this.editor\n\t\tconst { currentPagePoint } = inputs\n\n\t\tthis.markId = undefined\n\n\t\t// Previously created line shape that we might be extending\n\t\tconst shape = info.shapeId && this.editor.getShape<TLLineShape>(info.shapeId)\n\n\t\tif (shape && inputs.shiftKey) {\n\t\t\t// Extending a previous shape\n\t\t\tthis.markId = this.editor.markHistoryStoppingPoint(`creating_line:${shape.id}`)\n\t\t\tthis.shape = shape\n\n\t\t\tconst handles = this.editor.getShapeHandles(this.shape)\n\t\t\tif (!handles) return\n\n\t\t\tconst vertexHandles = handles.filter((h) => h.type === 'vertex').sort(sortByIndex)\n\t\t\tconst endHandle = vertexHandles[vertexHandles.length - 1]\n\t\t\tconst prevEndHandle = vertexHandles[vertexHandles.length - 2]\n\n\t\t\tconst shapePagePoint = Mat.applyToPoint(\n\t\t\t\tthis.editor.getShapeParentTransform(this.shape)!,\n\t\t\t\tnew Vec(this.shape.x, this.shape.y)\n\t\t\t)\n\t\t\t// nudge the point slightly to avoid zero-length lines\n\t\t\tconst nudgedPoint = Vec.Sub(currentPagePoint, shapePagePoint).addXY(0.1, 0.1)\n\t\t\tconst nextPoint = maybeSnapToGrid(nudgedPoint, this.editor)\n\t\t\tconst points = structuredClone(this.shape.props.points)\n\n\t\t\tif (\n\t\t\t\tVec.DistMin(endHandle, prevEndHandle, MINIMUM_DISTANCE_BETWEEN_SHIFT_CLICKED_HANDLES) ||\n\t\t\t\tVec.DistMin(nextPoint, endHandle, MINIMUM_DISTANCE_BETWEEN_SHIFT_CLICKED_HANDLES)\n\t\t\t) {\n\t\t\t\t// Don't add a new point if the distance between the last two points is too small\n\t\t\t\tpoints[endHandle.id] = {\n\t\t\t\t\tid: endHandle.id,\n\t\t\t\t\tindex: endHandle.index,\n\t\t\t\t\tx: nextPoint.x,\n\t\t\t\t\ty: nextPoint.y,\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Add a new point\n\t\t\t\tconst nextIndex = getIndexAbove(endHandle.index)\n\t\t\t\tpoints[nextIndex] = {\n\t\t\t\t\tid: nextIndex,\n\t\t\t\t\tindex: nextIndex,\n\t\t\t\t\tx: nextPoint.x,\n\t\t\t\t\ty: nextPoint.y,\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.editor.updateShapes([\n\t\t\t\t{\n\t\t\t\t\tid: this.shape.id,\n\t\t\t\t\ttype: this.shape.type,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\tpoints,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t])\n\t\t} else {\n\t\t\tconst id = createShapeId()\n\n\t\t\tthis.markId = this.editor.markHistoryStoppingPoint(`creating_line:${id}`)\n\n\t\t\tconst newPoint = maybeSnapToGrid(currentPagePoint, this.editor)\n\n\t\t\tthis.editor.createShapes<TLLineShape>([\n\t\t\t\t{\n\t\t\t\t\tid,\n\t\t\t\t\ttype: 'line',\n\t\t\t\t\tx: newPoint.x,\n\t\t\t\t\ty: newPoint.y,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\tscale: this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t])\n\n\t\t\tif (!this.editor.getShape(id)) {\n\t\t\t\tthis.cancel()\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tthis.editor.select(id)\n\t\t\tthis.shape = this.editor.getShape(id)!\n\t\t}\n\t}\n\n\toverride onPointerMove() {\n\t\tif (!this.shape) return\n\n\t\tif (this.editor.inputs.isDragging) {\n\t\t\tconst handles = this.editor.getShapeHandles(this.shape)\n\t\t\tif (!handles) {\n\t\t\t\tif (this.markId) this.editor.bailToMark(this.markId)\n\t\t\t\tthrow Error('No handles found')\n\t\t\t}\n\t\t\tconst lastHandle = last(handles)!\n\t\t\tthis.editor.setCurrentTool('select.dragging_handle', {\n\t\t\t\tshape: this.shape,\n\t\t\t\tisCreating: true,\n\t\t\t\tcreatingMarkId: this.markId,\n\t\t\t\t// remove the offset that we added to the handle when we created it\n\t\t\t\thandle: { ...lastHandle, x: lastHandle.x - 0.1, y: lastHandle.y - 0.1 },\n\t\t\t\tonInteractionEnd: 'line',\n\t\t\t})\n\t\t}\n\t}\n\n\toverride onPointerUp() {\n\t\tthis.complete()\n\t}\n\n\toverride onCancel() {\n\t\tthis.cancel()\n\t}\n\n\toverride onComplete() {\n\t\tthis.complete()\n\t}\n\n\toverride onInterrupt() {\n\t\tthis.parent.transition('idle')\n\t\tif (this.markId) this.editor.bailToMark(this.markId)\n\t\tthis.editor.snaps.clearIndicators()\n\t}\n\n\tcomplete() {\n\t\tthis.parent.transition('idle', { shapeId: this.shape.id })\n\t\tthis.editor.snaps.clearIndicators()\n\t}\n\n\tcancel() {\n\t\tif (this.markId) this.editor.bailToMark(this.markId)\n\t\tthis.parent.transition('idle', { shapeId: this.shape.id })\n\t\tthis.editor.snaps.clearIndicators()\n\t}\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5690, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/line/LineShapeTool.ts"],"sourcesContent":["import { StateNode, TLStateNodeConstructor } from '@tldraw/editor'\nimport { Idle } from './toolStates/Idle'\nimport { Pointing } from './toolStates/Pointing'\n\n/** @public */\nexport class LineShapeTool extends StateNode {\n\tstatic override id = 'line'\n\tstatic override initial = 'idle'\n\tstatic override children(): TLStateNodeConstructor[] {\n\t\treturn [Idle, Pointing]\n\t}\n\n\toverride shapeType = 'line'\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,iBAAyC;AAClD,SAAS,YAAY;AACrB,SAAS,gBAAgB;;;;AAGlB,MAAM,mNAAsB,YAAA,CAAU;IAC5C,OAAgB,KAAK,OAAA;IACrB,OAAgB,UAAU,OAAA;IAC1B,OAAgB,WAAqC;QACpD,OAAO;qMAAC,OAAA;yMAAM,WAAQ;SAAA;IACvB;IAES,YAAY,OAAA;AACtB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5719, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/note/toolStates/Idle.ts"],"sourcesContent":["import { StateNode, TLPointerEventInfo } from '@tldraw/editor'\n\nexport class Idle extends StateNode {\n\tstatic override id = 'idle'\n\n\toverride onPointerDown(info: TLPointerEventInfo) {\n\t\tthis.parent.transition('pointing', info)\n\t}\n\n\toverride onEnter() {\n\t\tthis.editor.setCursor({ type: 'cross', rotation: 0 })\n\t}\n\n\toverride onCancel() {\n\t\tthis.editor.setCurrentTool('select')\n\t}\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,iBAAqC;;AAEvC,MAAM,0MAAa,YAAA,CAAU;IACnC,OAAgB,KAAK,OAAA;IAEZ,cAAc,IAAA,EAA0B;QAChD,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,YAAY,IAAI;IACxC;IAES,UAAU;QAClB,IAAA,CAAK,MAAA,CAAO,SAAA,CAAU;YAAE,MAAM;YAAS,UAAU;QAAE,CAAC;IACrD;IAES,WAAW;QACnB,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,QAAQ;IACpC;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5748, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/note/noteHelpers.ts"],"sourcesContent":["import {\n\tEditor,\n\tIndexKey,\n\tTLNoteShape,\n\tTLShape,\n\tVec,\n\tcompact,\n\tcreateShapeId,\n\ttoRichText,\n} from '@tldraw/editor'\n\n/** @internal */\nexport const CLONE_HANDLE_MARGIN = 0\n/** @internal */\nexport const NOTE_SIZE = 200\n/** @internal */\nexport const NOTE_CENTER_OFFSET = new Vec(NOTE_SIZE / 2, NOTE_SIZE / 2)\n/** @internal */\nexport const NOTE_ADJACENT_POSITION_SNAP_RADIUS = 10\n\nconst BASE_NOTE_POSITIONS = (editor: Editor) =>\n\t[\n\t\t[\n\t\t\t['a1' as IndexKey],\n\t\t\tnew Vec(NOTE_SIZE * 0.5, NOTE_SIZE * -0.5 - editor.options.adjacentShapeMargin),\n\t\t], // t\n\t\t[\n\t\t\t['a2' as IndexKey],\n\t\t\tnew Vec(NOTE_SIZE * 1.5 + editor.options.adjacentShapeMargin, NOTE_SIZE * 0.5),\n\t\t], // r\n\t\t[\n\t\t\t['a3' as IndexKey],\n\t\t\tnew Vec(NOTE_SIZE * 0.5, NOTE_SIZE * 1.5 + editor.options.adjacentShapeMargin),\n\t\t], // b\n\t\t[\n\t\t\t['a4' as IndexKey],\n\t\t\tnew Vec(NOTE_SIZE * -0.5 - editor.options.adjacentShapeMargin, NOTE_SIZE * 0.5),\n\t\t], // l\n\t] as const\n\nfunction getBaseAdjacentNotePositions(editor: Editor, scale: number) {\n\tif (scale === 1) return BASE_NOTE_POSITIONS(editor)\n\tconst s = NOTE_SIZE * scale\n\tconst m = editor.options.adjacentShapeMargin * scale\n\treturn [\n\t\t[['a1' as IndexKey], new Vec(s * 0.5, s * -0.5 - m)], // t\n\t\t[['a2' as IndexKey], new Vec(s * 1.5 + m, s * 0.5)], // r\n\t\t[['a3' as IndexKey], new Vec(s * 0.5, s * 1.5 + m)], // b\n\t\t[['a4' as IndexKey], new Vec(s * -0.5 - m, s * 0.5)], // l\n\t] as const\n}\n\n/**\n * Get the adjacent positions for a particular note shape.\n *\n * @param pagePoint - The point of the note shape on the page.\n * @param pageRotation - The rotation of the note shape on the page.\n * @param growY - The growY of the note shape.\n * @param extraHeight - The extra height to add to the top position above the note shape (ie the growY of the dragging shape).\n *\n * @internal */\nexport function getNoteAdjacentPositions(\n\teditor: Editor,\n\tpagePoint: Vec,\n\tpageRotation: number,\n\tgrowY: number,\n\textraHeight: number,\n\tscale: number\n): Record<IndexKey, Vec> {\n\treturn Object.fromEntries(\n\t\tgetBaseAdjacentNotePositions(editor, scale).map(([id, v], i) => {\n\t\t\tconst point = v.clone()\n\t\t\tif (i === 0 && extraHeight) {\n\t\t\t\t// apply top margin (the growY of the moving note shape)\n\t\t\t\tpoint.y -= extraHeight\n\t\t\t} else if (i === 2 && growY) {\n\t\t\t\t// apply bottom margin (the growY of this note shape)\n\t\t\t\tpoint.y += growY\n\t\t\t}\n\t\t\treturn [id, point.rot(pageRotation).add(pagePoint)]\n\t\t})\n\t)\n}\n\n/**\n * Get all of the available note adjacent positions, excluding the selected shapes.\n *\n * @param editor - The editor instance.\n * @param rotation - The rotation of the note shape.\n * @param extraHeight - The extra height to add to the top position above the note shape (ie the growY of the dragging shape).\n *\n * @internal */\nexport function getAvailableNoteAdjacentPositions(\n\teditor: Editor,\n\trotation: number,\n\tscale: number,\n\textraHeight: number\n) {\n\tconst selectedShapeIds = new Set(editor.getSelectedShapeIds())\n\tconst minSize = (NOTE_SIZE + editor.options.adjacentShapeMargin + extraHeight) ** 2\n\tconst allCenters = new Map<TLNoteShape, Vec>()\n\tconst positions: (Vec | undefined)[] = []\n\n\t// Get all the positions that are adjacent to the selected note shapes\n\tfor (const shape of editor.getCurrentPageShapes()) {\n\t\tif (\n\t\t\t!editor.isShapeOfType<TLNoteShape>(shape, 'note') ||\n\t\t\tscale !== shape.props.scale ||\n\t\t\tselectedShapeIds.has(shape.id)\n\t\t) {\n\t\t\tcontinue\n\t\t}\n\n\t\tconst transform = editor.getShapePageTransform(shape.id)!\n\n\t\t// If the note has a different rotation, we can't use its adjacent positions\n\t\tif (rotation !== transform.rotation()) continue\n\n\t\t// Save the unselected note shape's center\n\t\tallCenters.set(shape, editor.getShapePageBounds(shape)!.center)\n\n\t\t// And push its position to the positions array\n\t\tpositions.push(\n\t\t\t...Object.values(\n\t\t\t\tgetNoteAdjacentPositions(\n\t\t\t\t\teditor,\n\t\t\t\t\ttransform.point(),\n\t\t\t\t\trotation,\n\t\t\t\t\tshape.props.growY,\n\t\t\t\t\textraHeight,\n\t\t\t\t\tscale\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t}\n\n\t// Remove positions that are inside of another note shape\n\tconst len = positions.length\n\tlet position: Vec | undefined\n\tfor (const [shape, center] of allCenters) {\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tposition = positions[i]\n\t\t\tif (!position) continue\n\t\t\tif (Vec.Dist2(center, position) > minSize) continue\n\t\t\tif (editor.isPointInShape(shape, position)) {\n\t\t\t\tpositions[i] = undefined\n\t\t\t}\n\t\t}\n\t}\n\n\treturn compact(positions)\n}\n\n/**\n * For a particular adjacent note position, get the shape in that position or create a new one.\n *\n * @param editor - The editor instance.\n * @param shape - The note shape to create or select.\n * @param center - The center of the note shape.\n * @param pageRotation - The rotation of the note shape on the page.\n * @param forceNew - Whether to force the creation of a new note shape.\n *\n * @internal */\nexport function getNoteShapeForAdjacentPosition(\n\teditor: Editor,\n\tshape: TLNoteShape,\n\tcenter: Vec,\n\tpageRotation: number,\n\tforceNew = false\n) {\n\t// There might already be a note in that position! If there is, we'll\n\t// select the next note and switch focus to it. If there's not, then\n\t// we'll create a new note in that position.\n\n\tlet nextNote: TLShape | undefined\n\n\t// Check the center of where a new note would be\n\t// Start from the top of the stack, and work our way down\n\tconst allShapesOnPage = editor.getCurrentPageShapesSorted()\n\n\tconst minDistance = (NOTE_SIZE + editor.options.adjacentShapeMargin ** 2) ** shape.props.scale\n\n\tfor (let i = allShapesOnPage.length - 1; i >= 0; i--) {\n\t\tconst otherNote = allShapesOnPage[i]\n\t\tif (otherNote.type === 'note' && otherNote.id !== shape.id) {\n\t\t\tconst otherBounds = editor.getShapePageBounds(otherNote)\n\t\t\tif (\n\t\t\t\totherBounds &&\n\t\t\t\tVec.Dist2(otherBounds.center, center) < minDistance &&\n\t\t\t\teditor.isPointInShape(otherNote, center)\n\t\t\t) {\n\t\t\t\tnextNote = otherNote\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\teditor.complete()\n\n\t// If we didn't find any in that position, then create a new one\n\tif (!nextNote || forceNew) {\n\t\teditor.markHistoryStoppingPoint('creating note shape')\n\t\tconst id = createShapeId()\n\n\t\t// We create it at the center first, so that it becomes\n\t\t// the child of whatever parent was at that center\n\t\teditor.createShape<TLNoteShape>({\n\t\t\tid,\n\t\t\ttype: 'note',\n\t\t\tx: center.x,\n\t\t\ty: center.y,\n\t\t\trotation: pageRotation,\n\t\t\topacity: shape.opacity,\n\t\t\tprops: {\n\t\t\t\t// Use the props of the shape we're cloning\n\t\t\t\t...shape.props,\n\t\t\t\trichText: toRichText(''),\n\t\t\t\tgrowY: 0,\n\t\t\t\tfontSizeAdjustment: 0,\n\t\t\t\turl: '',\n\t\t\t},\n\t\t})\n\n\t\t// Now we need to correct its location within its new parent\n\n\t\tconst createdShape = editor.getShape<TLNoteShape>(id)!\n\t\tif (!createdShape) return // may have hit max shapes\n\n\t\t// We need to put the page point in the same coordinate space as the newly created shape (i.e its parent's space)\n\t\tconst topLeft = editor.getPointInParentSpace(\n\t\t\tcreatedShape,\n\t\t\tVec.Sub(\n\t\t\t\tcenter,\n\t\t\t\tVec.Rot(NOTE_CENTER_OFFSET.clone().mul(createdShape.props.scale), pageRotation)\n\t\t\t)\n\t\t)\n\n\t\teditor.updateShape({\n\t\t\tid,\n\t\t\ttype: 'note',\n\t\t\tx: topLeft.x,\n\t\t\ty: topLeft.y,\n\t\t})\n\n\t\tnextNote = editor.getShape(id)!\n\t}\n\n\teditor.zoomToSelectionIfOffscreen(16, {\n\t\tanimation: {\n\t\t\tduration: editor.options.animationMediumMs,\n\t\t},\n\t\tinset: 0,\n\t})\n\treturn nextNote\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5933, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/note/toolStates/Pointing.ts"],"sourcesContent":["import {\n\tEditor,\n\tStateNode,\n\tTLNoteShape,\n\tTLPointerEventInfo,\n\tTLShapeId,\n\tVec,\n\tcreateShapeId,\n\tmaybeSnapToGrid,\n} from '@tldraw/editor'\n\nimport {\n\tNOTE_ADJACENT_POSITION_SNAP_RADIUS,\n\tgetAvailableNoteAdjacentPositions,\n} from '../noteHelpers'\n\nexport class Pointing extends StateNode {\n\tstatic override id = 'pointing'\n\n\tdragged = false\n\n\tinfo = {} as TLPointerEventInfo\n\n\tmarkId = ''\n\n\tshape = {} as TLNoteShape\n\n\toverride onEnter() {\n\t\tconst { editor } = this\n\n\t\tconst id = createShapeId()\n\t\tthis.markId = editor.markHistoryStoppingPoint(`creating_note:${id}`)\n\n\t\t// Check for note pits; if the pointer is close to one, place the note centered on the pit\n\t\tconst center = this.editor.inputs.originPagePoint.clone()\n\t\tconst offset = getNoteShapeAdjacentPositionOffset(\n\t\t\tthis.editor,\n\t\t\tcenter,\n\t\t\tthis.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1\n\t\t)\n\t\tif (offset) {\n\t\t\tcenter.sub(offset)\n\t\t}\n\n\t\t// Allow this to trigger the max shapes reached alert\n\t\tconst shape = createNoteShape(this.editor, id, center)\n\t\tif (shape) {\n\t\t\tthis.shape = shape\n\t\t} else {\n\t\t\tthis.cancel()\n\t\t}\n\t}\n\n\toverride onPointerMove(info: TLPointerEventInfo) {\n\t\tif (this.editor.inputs.isDragging) {\n\t\t\tthis.editor.setCurrentTool('select.translating', {\n\t\t\t\t...info,\n\t\t\t\ttarget: 'shape',\n\t\t\t\tshape: this.shape,\n\t\t\t\tonInteractionEnd: 'note',\n\t\t\t\tisCreating: true,\n\t\t\t\tcreatingMarkId: this.markId,\n\t\t\t\tonCreate: () => {\n\t\t\t\t\tthis.editor.setEditingShape(this.shape.id)\n\t\t\t\t\tthis.editor.setCurrentTool('select.editing_shape')\n\t\t\t\t},\n\t\t\t})\n\t\t}\n\t}\n\n\toverride onPointerUp() {\n\t\tthis.complete()\n\t}\n\n\toverride onInterrupt() {\n\t\tthis.cancel()\n\t}\n\n\toverride onComplete() {\n\t\tthis.complete()\n\t}\n\n\toverride onCancel() {\n\t\tthis.cancel()\n\t}\n\n\tprivate complete() {\n\t\tif (this.editor.getInstanceState().isToolLocked) {\n\t\t\tthis.parent.transition('idle')\n\t\t} else {\n\t\t\tthis.editor.setEditingShape(this.shape.id)\n\t\t\tthis.editor.setCurrentTool('select.editing_shape', {\n\t\t\t\t...this.info,\n\t\t\t\ttarget: 'shape',\n\t\t\t\tshape: this.shape,\n\t\t\t})\n\t\t}\n\t}\n\n\tprivate cancel() {\n\t\tthis.editor.bailToMark(this.markId)\n\t\tthis.parent.transition('idle', this.info)\n\t}\n}\n\nexport function getNoteShapeAdjacentPositionOffset(editor: Editor, center: Vec, scale: number) {\n\tlet min = NOTE_ADJACENT_POSITION_SNAP_RADIUS / editor.getZoomLevel() // in screen space\n\tlet offset: Vec | undefined\n\tfor (const pit of getAvailableNoteAdjacentPositions(editor, 0, scale, 0)) {\n\t\t// only check page rotations of zero\n\t\tconst deltaToPit = Vec.Sub(center, pit)\n\t\tconst dist = deltaToPit.len()\n\t\tif (dist < min) {\n\t\t\tmin = dist\n\t\t\toffset = deltaToPit\n\t\t}\n\t}\n\treturn offset\n}\n\nexport function createNoteShape(editor: Editor, id: TLShapeId, center: Vec) {\n\teditor.createShape({\n\t\tid,\n\t\ttype: 'note',\n\t\tx: center.x,\n\t\ty: center.y,\n\t\tprops: {\n\t\t\tscale: editor.user.getIsDynamicResizeMode() ? 1 / editor.getZoomLevel() : 1,\n\t\t},\n\t})\n\n\tconst shape = editor.getShape<TLNoteShape>(id)\n\t// Should never happen since we just checked, but just in case\n\tif (!shape) return\n\n\teditor.select(id)\n\tconst bounds = editor.getShapeGeometry(shape).bounds\n\tconst newPoint = maybeSnapToGrid(\n\t\tnew Vec(shape.x - bounds.width / 2, shape.y - bounds.height / 2),\n\t\teditor\n\t)\n\n\t// Center the text around the created point\n\teditor.updateShapes([\n\t\t{\n\t\t\tid,\n\t\t\ttype: 'note',\n\t\t\tx: newPoint.x,\n\t\t\ty: newPoint.y,\n\t\t},\n\t])\n\n\treturn editor.getShape<TLNoteShape>(id)\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6059, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/note/NoteShapeTool.ts"],"sourcesContent":["import { StateNode, TLStateNodeConstructor } from '@tldraw/editor'\nimport { Idle } from './toolStates/Idle'\nimport { Pointing } from './toolStates/Pointing'\n\n/** @public */\nexport class NoteShapeTool extends StateNode {\n\tstatic override id = 'note'\n\tstatic override initial = 'idle'\n\tstatic override children(): TLStateNodeConstructor[] {\n\t\treturn [Idle, Pointing]\n\t}\n\toverride shapeType = 'note'\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,iBAAyC;AAClD,SAAS,YAAY;AACrB,SAAS,gBAAgB;;;;AAGlB,MAAM,mNAAsB,YAAA,CAAU;IAC5C,OAAgB,KAAK,OAAA;IACrB,OAAgB,UAAU,OAAA;IAC1B,OAAgB,WAAqC;QACpD,OAAO;qMAAC,OAAA;yMAAM,WAAQ;SAAA;IACvB;IACS,YAAY,OAAA;AACtB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6088, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/text/toolStates/Idle.ts"],"sourcesContent":["import { StateNode, TLKeyboardEventInfo, TLPointerEventInfo } from '@tldraw/editor'\nimport { updateHoveredShapeId } from '../../../tools/selection-logic/updateHoveredShapeId'\n\nexport class Idle extends StateNode {\n\tstatic override id = 'idle'\n\n\toverride onPointerMove(info: TLPointerEventInfo) {\n\t\tswitch (info.target) {\n\t\t\tcase 'shape':\n\t\t\tcase 'canvas': {\n\t\t\t\tupdateHoveredShapeId(this.editor)\n\t\t\t}\n\t\t}\n\t}\n\n\toverride onPointerDown(info: TLPointerEventInfo) {\n\t\tthis.parent.transition('pointing', info)\n\t}\n\n\toverride onEnter() {\n\t\tthis.editor.setCursor({ type: 'cross', rotation: 0 })\n\t}\n\n\toverride onExit() {\n\t\tupdateHoveredShapeId.cancel()\n\t}\n\n\toverride onKeyDown(info: TLKeyboardEventInfo) {\n\t\tif (info.key === 'Enter') {\n\t\t\tif (this.editor.getIsReadonly()) return null\n\t\t\tconst onlySelectedShape = this.editor.getOnlySelectedShape()\n\t\t\t// If the only selected shape is editable, start editing it\n\t\t\tif (\n\t\t\t\tonlySelectedShape &&\n\t\t\t\tthis.editor.getShapeUtil(onlySelectedShape).canEdit(onlySelectedShape)\n\t\t\t) {\n\t\t\t\tthis.editor.setCurrentTool('select')\n\t\t\t\tthis.editor.setEditingShape(onlySelectedShape.id)\n\t\t\t\tthis.editor.root.getCurrent()?.transition('editing_shape', {\n\t\t\t\t\t...info,\n\t\t\t\t\ttarget: 'shape',\n\t\t\t\t\tshape: onlySelectedShape,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\toverride onCancel() {\n\t\tthis.editor.setCurrentTool('select')\n\t}\n}\n"],"names":[],"mappings":";;;AAAA,SAAS,iBAA0D;;AACnE,SAAS,4BAA4B;;;AAE9B,MAAM,0MAAa,YAAA,CAAU;IACnC,OAAgB,KAAK,OAAA;IAEZ,cAAc,IAAA,EAA0B;QAChD,OAAQ,KAAK,MAAA,EAAQ;YACpB,KAAK;YACL,KAAK;gBAAU;oBACd,CAAA,GAAA,uMAAA,CAAA,uBAAA,EAAqB,IAAA,CAAK,MAAM;gBACjC;QACD;IACD;IAES,cAAc,IAAA,EAA0B;QAChD,IAAA,CAAK,MAAA,CAAO,UAAA,CAAW,YAAY,IAAI;IACxC;IAES,UAAU;QAClB,IAAA,CAAK,MAAA,CAAO,SAAA,CAAU;YAAE,MAAM;YAAS,UAAU;QAAE,CAAC;IACrD;IAES,SAAS;QACjB,uMAAA,CAAA,uBAAA,CAAqB,MAAA,CAAO;IAC7B;IAES,UAAU,IAAA,EAA2B;QAC7C,IAAI,KAAK,GAAA,KAAQ,SAAS;YACzB,IAAI,IAAA,CAAK,MAAA,CAAO,aAAA,CAAc,EAAG,CAAA,OAAO;YACxC,MAAM,oBAAoB,IAAA,CAAK,MAAA,CAAO,oBAAA,CAAqB;YAE3D,IACC,qBACA,IAAA,CAAK,MAAA,CAAO,YAAA,CAAa,iBAAiB,EAAE,OAAA,CAAQ,iBAAiB,GACpE;gBACD,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,QAAQ;gBACnC,IAAA,CAAK,MAAA,CAAO,eAAA,CAAgB,kBAAkB,EAAE;gBAChD,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,UAAA,CAAW,GAAG,WAAW,iBAAiB;oBAC1D,GAAG,IAAA;oBACH,QAAQ;oBACR,OAAO;gBACR,CAAC;YACF;QACD;IACD;IAES,WAAW;QACnB,IAAA,CAAK,MAAA,CAAO,cAAA,CAAe,QAAQ;IACpC;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6146, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/text/toolStates/Pointing.ts"],"sourcesContent":["import {\n\tStateNode,\n\tTLPointerEventInfo,\n\tTLShapeId,\n\tTLTextShape,\n\tVec,\n\tcreateShapeId,\n\tisShapeId,\n\tmaybeSnapToGrid,\n\ttoRichText,\n} from '@tldraw/editor'\n\nexport class Pointing extends StateNode {\n\tstatic override id = 'pointing'\n\n\tshape?: TLTextShape\n\n\tmarkId = ''\n\n\tenterTime = 0\n\toverride onEnter(): void {\n\t\tthis.enterTime = Date.now()\n\t}\n\n\toverride onExit() {\n\t\tthis.editor.setHintingShapes([])\n\t}\n\n\toverride onPointerMove(info: TLPointerEventInfo) {\n\t\t// Create a fixed width shape if the user wants to do that.\n\n\t\t// Don't create a fixed width shape unless the the drag is a little larger,\n\t\t// otherwise you get a vertical column of single characters if you accidentally\n\t\t// drag a bit unintentionally.\n\n\t\t// If the user hasn't been pointing for more than 150ms, don't create a fixed width shape\n\t\tif (Date.now() - this.enterTime < 150) return\n\n\t\tconst { editor } = this\n\t\tconst { isPointing } = editor.inputs\n\n\t\tif (!isPointing) return\n\n\t\tconst { originPagePoint, currentPagePoint } = editor.inputs\n\n\t\tconst currentDragDist = Math.abs(originPagePoint.x - currentPagePoint.x)\n\n\t\tconst baseMinDragDistForFixedWidth = Math.sqrt(\n\t\t\teditor.getInstanceState().isCoarsePointer\n\t\t\t\t? editor.options.coarseDragDistanceSquared\n\t\t\t\t: editor.options.dragDistanceSquared\n\t\t)\n\n\t\t// Ten times the base drag distance for fixed width\n\t\tconst minSquaredDragDist = (baseMinDragDistForFixedWidth * 6) / editor.getZoomLevel()\n\n\t\tif (currentDragDist > minSquaredDragDist) {\n\t\t\tconst id = createShapeId()\n\t\t\tthis.markId = editor.markHistoryStoppingPoint(`creating_text:${id}`)\n\n\t\t\t// create the initial shape with the width that we've dragged\n\t\t\tconst shape = this.createTextShape(id, originPagePoint, false, currentDragDist)\n\n\t\t\tif (!shape) {\n\t\t\t\tthis.cancel()\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Now save the fresh reference\n\t\t\tthis.shape = editor.getShape(shape)\n\n\t\t\teditor.select(id)\n\n\t\t\tconst scale = this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1\n\n\t\t\teditor.setCurrentTool('select.resizing', {\n\t\t\t\t...info,\n\t\t\t\ttarget: 'selection',\n\t\t\t\thandle: 'right',\n\t\t\t\tisCreating: true,\n\t\t\t\tcreatingMarkId: this.markId,\n\t\t\t\t// Make sure the cursor offset takes into account how far we've already dragged\n\t\t\t\tcreationCursorOffset: { x: currentDragDist * scale, y: 1 },\n\t\t\t\tonInteractionEnd: 'text',\n\t\t\t\tonCreate: () => {\n\t\t\t\t\teditor.setEditingShape(shape.id)\n\t\t\t\t\t// this will automatically set the state to 'select.editing_shape'\n\t\t\t\t},\n\t\t\t})\n\t\t}\n\t}\n\n\toverride onPointerUp() {\n\t\tthis.complete()\n\t}\n\n\toverride onComplete() {\n\t\tthis.cancel()\n\t}\n\n\toverride onCancel() {\n\t\tthis.cancel()\n\t}\n\n\toverride onInterrupt() {\n\t\tthis.cancel()\n\t}\n\n\tprivate complete() {\n\t\tthis.editor.markHistoryStoppingPoint('creating text shape')\n\t\tconst id = createShapeId()\n\t\tconst { originPagePoint } = this.editor.inputs\n\t\tconst shape = this.createTextShape(id, originPagePoint, true, 20)\n\t\tif (!shape) return\n\n\t\tthis.editor.select(id)\n\t\tthis.editor.setEditingShape(id)\n\t\t// this will automatically set the state to 'select.editing_shape'\n\t}\n\n\tprivate cancel() {\n\t\tthis.parent.transition('idle')\n\t\tthis.editor.bailToMark(this.markId)\n\t}\n\n\tprivate createTextShape(id: TLShapeId, point: Vec, autoSize: boolean, width: number) {\n\t\tthis.editor.createShape<TLTextShape>({\n\t\t\tid,\n\t\t\ttype: 'text',\n\t\t\tx: point.x,\n\t\t\ty: point.y,\n\t\t\tprops: {\n\t\t\t\trichText: toRichText(''),\n\t\t\t\tautoSize,\n\t\t\t\tw: width,\n\t\t\t\tscale: this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1,\n\t\t\t},\n\t\t})\n\n\t\tconst shape = this.editor.getShape<TLTextShape>(id)\n\t\tif (!shape) {\n\t\t\tthis.cancel()\n\t\t\treturn\n\t\t}\n\n\t\tconst bounds = this.editor.getShapePageBounds(shape)!\n\n\t\tconst delta = new Vec()\n\n\t\tif (autoSize) {\n\t\t\tswitch (shape.props.textAlign) {\n\t\t\t\tcase 'start': {\n\t\t\t\t\tdelta.x = 0\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'middle': {\n\t\t\t\t\tdelta.x = -bounds.width / 2\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'end': {\n\t\t\t\t\tdelta.x = -bounds.width\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tdelta.x = 0\n\t\t}\n\n\t\tdelta.y = -bounds.height / 2\n\n\t\tif (isShapeId(shape.parentId)) {\n\t\t\tconst transform = this.editor.getShapeParentTransform(shape)\n\t\t\tdelta.rot(-transform.rotation())\n\t\t}\n\n\t\tconst shapeX = shape.x + delta.x\n\t\tconst shapeY = shape.y + delta.y\n\t\tif (this.editor.getInstanceState().isGridMode) {\n\t\t\tconst topLeft = new Vec(shapeX, shapeY)\n\t\t\tconst gridSnappedPoint = maybeSnapToGrid(topLeft, this.editor)\n\t\t\tconst gridDelta = Vec.Sub(topLeft, gridSnappedPoint)\n\t\t\tthis.editor.updateShape({\n\t\t\t\t...shape,\n\t\t\t\tx: shapeX - gridDelta.x,\n\t\t\t\ty: shapeY - gridDelta.y,\n\t\t\t})\n\t\t} else {\n\t\t\tthis.editor.updateShape({\n\t\t\t\t...shape,\n\t\t\t\tx: shapeX,\n\t\t\t\ty: shapeY,\n\t\t\t})\n\t\t}\n\n\t\treturn shape\n\t}\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6305, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/text/TextShapeTool.ts"],"sourcesContent":["import { StateNode, TLStateNodeConstructor } from '@tldraw/editor'\nimport { Idle } from './toolStates/Idle'\nimport { Pointing } from './toolStates/Pointing'\n\n/** @public */\nexport class TextShapeTool extends StateNode {\n\tstatic override id = 'text'\n\tstatic override initial = 'idle'\n\tstatic override children(): TLStateNodeConstructor[] {\n\t\treturn [Idle, Pointing]\n\t}\n\toverride shapeType = 'text'\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,iBAAyC;AAClD,SAAS,YAAY;AACrB,SAAS,gBAAgB;;;;AAGlB,MAAM,mNAAsB,YAAA,CAAU;IAC5C,OAAgB,KAAK,OAAA;IACrB,OAAgB,UAAU,OAAA;IAC1B,OAAgB,WAAqC;QACpD,OAAO;qMAAC,OAAA;yMAAM,WAAQ;SAAA;IACvB;IACS,YAAY,OAAA;AACtB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6334, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/text/PlainTextArea.tsx"],"sourcesContent":["import { preventDefault, stopEventPropagation } from '@tldraw/editor'\nimport React from 'react'\nimport { TextAreaProps } from './RichTextArea'\n\n/**\n * A plain text area that can be used for basic editing text.\n *\n * @public @react\n */\nexport const PlainTextArea = React.forwardRef<HTMLTextAreaElement, TextAreaProps>(function TextArea(\n\t{\n\t\tisEditing,\n\t\ttext,\n\t\thandleFocus,\n\t\thandleChange,\n\t\thandleKeyDown,\n\t\thandlePaste,\n\t\thandleBlur,\n\t\thandleInputPointerDown,\n\t\thandleDoubleClick,\n\t},\n\tref\n) {\n\tconst onChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n\t\thandleChange({ plaintext: e.target.value })\n\t}\n\n\treturn (\n\t\t<textarea\n\t\t\tref={ref}\n\t\t\tclassName=\"tl-text tl-text-input\"\n\t\t\tname=\"text\"\n\t\t\ttabIndex={-1}\n\t\t\tdisabled={!isEditing}\n\t\t\treadOnly={!isEditing}\n\t\t\tautoComplete=\"off\"\n\t\t\tautoCapitalize=\"off\"\n\t\t\tautoCorrect=\"off\"\n\t\t\tautoSave=\"off\"\n\t\t\tplaceholder=\"\"\n\t\t\tspellCheck=\"true\"\n\t\t\twrap=\"off\"\n\t\t\tdir=\"auto\"\n\t\t\tdefaultValue={text}\n\t\t\tonFocus={handleFocus}\n\t\t\tonChange={onChange}\n\t\t\tonKeyDown={(e) => handleKeyDown(e.nativeEvent)}\n\t\t\tonBlur={handleBlur}\n\t\t\tonTouchEnd={stopEventPropagation}\n\t\t\tonContextMenu={isEditing ? stopEventPropagation : undefined}\n\t\t\tonPointerDown={handleInputPointerDown}\n\t\t\tonPaste={handlePaste}\n\t\t\tonDoubleClick={handleDoubleClick}\n\t\t\t// On FF, there's a behavior where dragging a selection will grab that selection into\n\t\t\t// the drag event. However, once the drag is over, and you select away from the textarea,\n\t\t\t// starting a drag over the textarea will restart a selection drag instead of a shape drag.\n\t\t\t// This prevents that default behavior in FF.\n\t\t\tonDragStart={preventDefault}\n\t\t/>\n\t)\n})\n"],"names":[],"mappings":";;;AA4BE;AA5BF,SAAS,gBAAgB,4BAA4B;;AACrD,OAAO,WAAW;;;;AAQX,MAAM,8KAAgB,UAAA,CAAM,UAAA,CAA+C,SAAS,SAC1F,EACC,SAAA,EACA,IAAA,EACA,WAAA,EACA,YAAA,EACA,aAAA,EACA,WAAA,EACA,UAAA,EACA,sBAAA,EACA,iBAAA,EACD,EACA,GAAA,EACC;IACD,MAAM,WAAW,CAAC,MAA8C;QAC/D,aAAa;YAAE,WAAW,EAAE,MAAA,CAAO,KAAA;QAAM,CAAC;IAC3C;IAEA,OACC,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,YAAA;QACA;QACA,WAAU;QACV,MAAK;QACL,UAAU,CAAA;QACV,UAAU,CAAC;QACX,UAAU,CAAC;QACX,cAAa;QACb,gBAAe;QACf,aAAY;QACZ,UAAS;QACT,aAAY;QACZ,YAAW;QACX,MAAK;QACL,KAAI;QACJ,cAAc;QACd,SAAS;QACT;QACA,WAAW,CAAC,IAAM,cAAc,EAAE,WAAW;QAC7C,QAAQ;QACR,yLAAY,uBAAA;QACZ,eAAe,yLAAY,uBAAA,GAAuB,KAAA;QAClD,eAAe;QACf,SAAS;QACT,eAAe;QAKf,0LAAa,iBAAA;IAAA;AAGhB,CAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6386, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/shared/legacyProps.ts"],"sourcesContent":["import { Box, BoxModel, TLDefaultHorizontalAlignStyle } from '@tldraw/editor'\n\nexport function getLegacyOffsetX(\n\talign: TLDefaultHorizontalAlignStyle | string,\n\tpadding: number,\n\tspans: { text: string; box: BoxModel }[],\n\ttotalWidth: number\n): number | undefined {\n\tif ((align === 'start-legacy' || align === 'end-legacy') && spans.length !== 0) {\n\t\tconst spansBounds = Box.From(spans[0].box)\n\t\tfor (const { box } of spans) {\n\t\t\tspansBounds.union(box)\n\t\t}\n\t\tif (align === 'start-legacy') {\n\t\t\treturn (totalWidth - 2 * padding - spansBounds.width) / 2\n\t\t} else if (align === 'end-legacy') {\n\t\t\treturn -(totalWidth - 2 * padding - spansBounds.width) / 2\n\t\t}\n\t}\n}\n\n// sneaky TLDefaultHorizontalAlignStyle for legacies\nexport function isLegacyAlign(align: TLDefaultHorizontalAlignStyle | string): boolean {\n\treturn align === 'start-legacy' || align === 'middle-legacy' || align === 'end-legacy'\n}\n"],"names":[],"mappings":";;;;;AAAA,SAAS,WAAoD;;AAEtD,SAAS,iBACf,KAAA,EACA,OAAA,EACA,KAAA,EACA,UAAA,EACqB;IACrB,IAAA,CAAK,UAAU,kBAAkB,UAAU,YAAA,KAAiB,MAAM,MAAA,KAAW,GAAG;QAC/E,MAAM,gMAAc,MAAA,CAAI,IAAA,CAAK,KAAA,CAAM,CAAC,CAAA,CAAE,GAAG;QACzC,KAAA,MAAW,EAAE,GAAA,CAAI,CAAA,IAAK,MAAO;YAC5B,YAAY,KAAA,CAAM,GAAG;QACtB;QACA,IAAI,UAAU,gBAAgB;YAC7B,OAAA,CAAQ,aAAa,IAAI,UAAU,YAAY,KAAA,IAAS;QACzD,OAAA,IAAW,UAAU,cAAc;YAClC,OAAO,CAAA,CAAE,aAAa,IAAI,UAAU,YAAY,KAAA,IAAS;QAC1D;IACD;AACD;AAGO,SAAS,cAAc,KAAA,EAAwD;IACrF,OAAO,UAAU,kBAAkB,UAAU,mBAAmB,UAAU;AAC3E","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6417, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/shared/useEditablePlainText.ts"],"sourcesContent":["import {\n\tEditor,\n\tTLShapeId,\n\tTLUnknownShape,\n\tgetPointerInfo,\n\tnoop,\n\tpreventDefault,\n\tstopEventPropagation,\n\ttlenv,\n\tuseEditor,\n\tuseValue,\n} from '@tldraw/editor'\nimport React, { useCallback, useEffect, useRef } from 'react'\nimport { TextHelpers } from './TextHelpers'\n\n/** @public */\nexport function useEditablePlainText(shapeId: TLShapeId, type: string, text?: string) {\n\tconst commonUseEditableTextHandlers = useEditableTextCommon(shapeId)\n\tconst isEditing = commonUseEditableTextHandlers.isEditing\n\tconst editor = useEditor()\n\tconst rInput = useRef<HTMLTextAreaElement>(null)\n\tconst isEmpty = (text || '').trim().length === 0\n\n\tuseEffect(() => {\n\t\tfunction selectAllIfEditing(event: { shapeId: TLShapeId }) {\n\t\t\tif (event.shapeId === shapeId) {\n\t\t\t\trInput.current?.select?.()\n\t\t\t}\n\t\t}\n\n\t\teditor.on('select-all-text', selectAllIfEditing)\n\t\treturn () => {\n\t\t\teditor.off('select-all-text', selectAllIfEditing)\n\t\t}\n\t}, [editor, shapeId, isEditing])\n\n\tuseEffect(() => {\n\t\tif (!isEditing) return\n\n\t\tif (document.activeElement !== rInput.current) {\n\t\t\trInput.current?.focus()\n\t\t}\n\n\t\tif (editor.getInstanceState().isCoarsePointer) {\n\t\t\trInput.current?.select()\n\t\t}\n\n\t\t// XXX(mime): This fixes iOS not showing the caret sometimes.\n\t\t// This \"shakes\" the caret awake.\n\t\tif (tlenv.isSafari) {\n\t\t\trInput.current?.blur()\n\t\t\trInput.current?.focus()\n\t\t}\n\t}, [editor, isEditing])\n\n\t// When the user presses ctrl / meta enter, complete the editing state.\n\tconst handleKeyDown = useCallback(\n\t\t(e: KeyboardEvent) => {\n\t\t\tif (editor.getEditingShapeId() !== shapeId) return\n\n\t\t\tswitch (e.key) {\n\t\t\t\tcase 'Enter': {\n\t\t\t\t\tif (e.ctrlKey || e.metaKey) {\n\t\t\t\t\t\teditor.complete()\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t[editor, shapeId]\n\t)\n\n\t// When the text changes, update the text value.\n\tconst handleChange = useCallback(\n\t\t({ plaintext }: { plaintext: string }) => {\n\t\t\tif (editor.getEditingShapeId() !== shapeId) return\n\n\t\t\tconst normalizedPlaintext = TextHelpers.normalizeText(plaintext || '')\n\t\t\teditor.updateShape<TLUnknownShape & { props: { text: string } }>({\n\t\t\t\tid: shapeId,\n\t\t\t\ttype,\n\t\t\t\tprops: { text: normalizedPlaintext },\n\t\t\t})\n\t\t},\n\t\t[editor, shapeId, type]\n\t)\n\n\treturn {\n\t\trInput,\n\t\thandleKeyDown,\n\t\thandleChange,\n\t\tisEmpty,\n\t\t...commonUseEditableTextHandlers,\n\t}\n}\n\n/** @internal */\nexport function useIsReadyForEditing(editor: Editor, shapeId: TLShapeId) {\n\treturn useValue(\n\t\t'isReadyForEditing',\n\t\t() => {\n\t\t\tconst editingShapeId = editor.getEditingShapeId()\n\t\t\treturn (\n\t\t\t\t// something's being editing... and either it's this shape OR this shape is hovered\n\t\t\t\teditingShapeId !== null &&\n\t\t\t\t(editingShapeId === shapeId || editor.getHoveredShapeId() === shapeId)\n\t\t\t)\n\t\t},\n\t\t[editor, shapeId]\n\t)\n}\n\n/** @internal */\nexport function useEditableTextCommon(shapeId: TLShapeId) {\n\tconst editor = useEditor()\n\tconst isEditing = useValue('isEditing', () => editor.getEditingShapeId() === shapeId, [editor])\n\tconst isReadyForEditing = useIsReadyForEditing(editor, shapeId)\n\n\tconst handleInputPointerDown = useCallback(\n\t\t(e: React.PointerEvent) => {\n\t\t\t// N.B. We used to only do this only when isEditing to help\n\t\t\t// prevent an issue where you could drag a selected shape\n\t\t\t// behind another shape. That is addressed now by the CSS logic\n\t\t\t// looking at data-isselectinganything.\n\t\t\t//\n\t\t\t// We still need to follow this logic even if not isEditing\n\t\t\t// because otherwise there is some flakiness in selection.\n\t\t\t// When selecting text, it would sometimes select some text\n\t\t\t// partially if we didn't dispatch/stop below.\n\n\t\t\teditor.dispatch({\n\t\t\t\t...getPointerInfo(e),\n\t\t\t\ttype: 'pointer',\n\t\t\t\tname: 'pointer_down',\n\t\t\t\ttarget: 'shape',\n\t\t\t\tshape: editor.getShape(shapeId)!,\n\t\t\t})\n\n\t\t\tstopEventPropagation(e) // we need to prevent blurring the input\n\t\t},\n\t\t[editor, shapeId]\n\t)\n\n\tconst handlePaste = useCallback(\n\t\t(e: ClipboardEvent | React.ClipboardEvent<HTMLTextAreaElement>) => {\n\t\t\tif (editor.getEditingShapeId() !== shapeId) return\n\t\t\tif (e.clipboardData) {\n\t\t\t\t// find html in the clipboard and look for the tldraw data\n\t\t\t\tconst html = e.clipboardData.getData('text/html')\n\t\t\t\tif (html) {\n\t\t\t\t\tif (html.includes('<div data-tldraw')) {\n\t\t\t\t\t\tpreventDefault(e)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t[editor, shapeId]\n\t)\n\n\treturn {\n\t\thandleFocus: noop,\n\t\thandleBlur: noop,\n\t\thandleInputPointerDown,\n\t\thandleDoubleClick: stopEventPropagation,\n\t\thandlePaste,\n\t\tisEditing,\n\t\tisReadyForEditing,\n\t}\n}\n\n/**\n * @deprecated Use `useEditablePlainText` instead.\n * @public\n */\nexport const useEditableText = useEditablePlainText\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6589, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/shared/PlainTextLabel.tsx"],"sourcesContent":["import {\n\tBox,\n\tTLDefaultFillStyle,\n\tTLDefaultFontStyle,\n\tTLDefaultHorizontalAlignStyle,\n\tTLDefaultVerticalAlignStyle,\n\tTLShapeId,\n} from '@tldraw/editor'\nimport React from 'react'\nimport { PlainTextArea } from '../text/PlainTextArea'\nimport { TextHelpers } from './TextHelpers'\nimport { isLegacyAlign } from './legacyProps'\nimport { useEditablePlainText } from './useEditablePlainText'\n\n/** @public */\nexport interface PlainTextLabelProps {\n\tshapeId: TLShapeId\n\ttype: string\n\tfont: TLDefaultFontStyle\n\tfontSize: number\n\tlineHeight: number\n\tfill?: TLDefaultFillStyle\n\talign: TLDefaultHorizontalAlignStyle\n\tverticalAlign: TLDefaultVerticalAlignStyle\n\twrap?: boolean\n\ttext?: string\n\tlabelColor: string\n\tbounds?: Box\n\tisSelected: boolean\n\tonKeyDown?(e: KeyboardEvent): void\n\tclassNamePrefix?: string\n\tstyle?: React.CSSProperties\n\ttextWidth?: number\n\ttextHeight?: number\n\tpadding?: number\n}\n\n/**\n * Renders a text label that can be used inside of shapes.\n * The component has the ability to be edited in place and furthermore\n * supports rich text editing.\n *\n * @public @react\n */\nexport const PlainTextLabel = React.memo(function PlainTextLabel({\n\tshapeId,\n\ttype,\n\ttext: plaintext,\n\tlabelColor,\n\tfont,\n\tfontSize,\n\tlineHeight,\n\talign,\n\tverticalAlign,\n\twrap,\n\tisSelected,\n\tpadding = 0,\n\tonKeyDown: handleKeyDownCustom,\n\tclassNamePrefix,\n\tstyle,\n\ttextWidth,\n\ttextHeight,\n}: PlainTextLabelProps) {\n\tconst { rInput, isEmpty, isEditing, isReadyForEditing, ...editableTextRest } =\n\t\tuseEditablePlainText(shapeId, type, plaintext)\n\n\tconst finalPlainText = TextHelpers.normalizeTextForDom(plaintext || '')\n\tconst hasText = finalPlainText.length > 0\n\n\tconst legacyAlign = isLegacyAlign(align)\n\n\tif (!isEditing && !hasText) {\n\t\treturn null\n\t}\n\n\t// TODO: probably combine tl-text and tl-arrow eventually\n\t// In case you're grepping for this, it breaks down as follows:\n\t// tl-text-label, tl-text-label__inner, tl-text-shape-label, tl-text\n\t// tl-arrow-label, tl-arrow-label__inner, tl-arrow\n\tconst cssPrefix = classNamePrefix || 'tl-text'\n\treturn (\n\t\t<div\n\t\t\tclassName={`${cssPrefix}-label tl-text-wrapper tl-plain-text-wrapper`}\n\t\t\taria-hidden={!isEditing}\n\t\t\tdata-font={font}\n\t\t\tdata-align={align}\n\t\t\tdata-hastext={!isEmpty}\n\t\t\tdata-isediting={isEditing}\n\t\t\tdata-is-ready-for-editing={isReadyForEditing}\n\t\t\tdata-textwrap={!!wrap}\n\t\t\tdata-isselected={isSelected}\n\t\t\tstyle={{\n\t\t\t\tjustifyContent: align === 'middle' || legacyAlign ? 'center' : align,\n\t\t\t\talignItems: verticalAlign === 'middle' ? 'center' : verticalAlign,\n\t\t\t\tpadding,\n\t\t\t\t...style,\n\t\t\t}}\n\t\t>\n\t\t\t<div\n\t\t\t\tclassName={`${cssPrefix}-label__inner tl-text-content__wrapper`}\n\t\t\t\tstyle={{\n\t\t\t\t\tfontSize,\n\t\t\t\t\tlineHeight: lineHeight.toString(),\n\t\t\t\t\tminHeight: Math.floor(fontSize * lineHeight) + 'px',\n\t\t\t\t\tminWidth: Math.ceil(textWidth || 0),\n\t\t\t\t\tcolor: labelColor,\n\t\t\t\t\twidth: textWidth ? Math.ceil(textWidth) : undefined,\n\t\t\t\t\theight: textHeight ? Math.ceil(textHeight) : undefined,\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\t<div className={`${cssPrefix} tl-text tl-text-content`} dir=\"auto\">\n\t\t\t\t\t{finalPlainText.split('\\n').map((lineOfText, index) => (\n\t\t\t\t\t\t<div key={index} dir=\"auto\">\n\t\t\t\t\t\t\t{lineOfText}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t))}\n\t\t\t\t</div>\n\t\t\t\t{(isReadyForEditing || isSelected) && (\n\t\t\t\t\t<PlainTextArea\n\t\t\t\t\t\t// Fudge the ref type because we're using forwardRef and it's not typed correctly.\n\t\t\t\t\t\tref={rInput as any}\n\t\t\t\t\t\ttext={plaintext}\n\t\t\t\t\t\tisEditing={isEditing}\n\t\t\t\t\t\tshapeId={shapeId}\n\t\t\t\t\t\t{...editableTextRest}\n\t\t\t\t\t\thandleKeyDown={handleKeyDownCustom ?? editableTextRest.handleKeyDown}\n\t\t\t\t\t/>\n\t\t\t\t)}\n\t\t\t</div>\n\t\t</div>\n\t)\n})\n\n/**\n * @deprecated Use `PlainTextLabel` instead.\n * @public\n */\nexport const TextLabel = PlainTextLabel\n"],"names":["PlainTextLabel"],"mappings":";;;;AAkGG,SAcG,KAdH;AA1FH,OAAO,WAAW;AAClB,SAAS,qBAAqB;AAC9B,SAAS,mBAAmB;AAC5B,SAAS,qBAAqB;AAC9B,SAAS,4BAA4B;;;;;;;AAgC9B,MAAM,+KAAiB,UAAA,CAAM,IAAA,CAAK,SAASA,gBAAe,EAChE,OAAA,EACA,IAAA,EACA,MAAM,SAAA,EACN,UAAA,EACA,IAAA,EACA,QAAA,EACA,UAAA,EACA,KAAA,EACA,aAAA,EACA,IAAA,EACA,UAAA,EACA,UAAU,CAAA,EACV,WAAW,mBAAA,EACX,eAAA,EACA,KAAA,EACA,SAAA,EACA,UAAA,EACD,EAAwB;IACvB,MAAM,EAAE,MAAA,EAAQ,OAAA,EAAS,SAAA,EAAW,iBAAA,EAAmB,GAAG,iBAAiB,CAAA,oMAC1E,uBAAA,EAAqB,SAAS,MAAM,SAAS;IAE9C,MAAM,qMAAiB,cAAA,CAAY,mBAAA,CAAoB,aAAa,EAAE;IACtE,MAAM,UAAU,eAAe,MAAA,GAAS;IAExC,MAAM,cAAc,wMAAA,EAAc,KAAK;IAEvC,IAAI,CAAC,aAAa,CAAC,SAAS;QAC3B,OAAO;IACR;IAMA,MAAM,YAAY,mBAAmB;IACrC,OACC,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,OAAA;QACA,WAAW,GAAG,SAAS,CAAA,4CAAA,CAAA;QACvB,eAAa,CAAC;QACd,aAAW;QACX,cAAY;QACZ,gBAAc,CAAC;QACf,kBAAgB;QAChB,6BAA2B;QAC3B,iBAAe,CAAC,CAAC;QACjB,mBAAiB;QACjB,OAAO;YACN,gBAAgB,UAAU,YAAY,cAAc,WAAW;YAC/D,YAAY,kBAAkB,WAAW,WAAW;YACpD;YACA,GAAG,KAAA;QACJ;QAEA,UAAA,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,OAAA,EAAC,OAAA;YACA,WAAW,GAAG,SAAS,CAAA,sCAAA,CAAA;YACvB,OAAO;gBACN;gBACA,YAAY,WAAW,QAAA,CAAS;gBAChC,WAAW,KAAK,KAAA,CAAM,WAAW,UAAU,IAAI;gBAC/C,UAAU,KAAK,IAAA,CAAK,aAAa,CAAC;gBAClC,OAAO;gBACP,OAAO,YAAY,KAAK,IAAA,CAAK,SAAS,IAAI,KAAA;gBAC1C,QAAQ,aAAa,KAAK,IAAA,CAAK,UAAU,IAAI,KAAA;YAC9C;YAEA,UAAA;gBAAA,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,OAAA;oBAAI,WAAW,GAAG,SAAS,CAAA,wBAAA,CAAA;oBAA4B,KAAI;oBAC1D,UAAA,eAAe,KAAA,CAAM,IAAI,EAAE,GAAA,CAAI,CAAC,YAAY,QAC5C,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,OAAA;4BAAgB,KAAI;4BACnB,UAAA;wBAAA,GADQ,KAEV,CACA;gBAAA,CACF;gBAAA,CACE,qBAAqB,UAAA,KACtB,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,sLAAC,gBAAA,EAAA;oBAEA,KAAK;oBACL,MAAM;oBACN;oBACA;oBACC,GAAG,gBAAA;oBACJ,eAAe,uBAAuB,iBAAiB,aAAA;gBAAA;aACxD;QAAA;IAEF;AAGH,CAAC;AAMM,MAAM,YAAY","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6671, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/shared/useDefaultColorTheme.ts"],"sourcesContent":["import { getDefaultColorTheme, useIsDarkMode } from '@tldraw/editor'\n\n/** @public */\nexport function useDefaultColorTheme() {\n\treturn getDefaultColorTheme({ isDarkMode: useIsDarkMode() })\n}\n"],"names":[],"mappings":";;;;;AAAA,SAAS,sBAAsB,qBAAqB;;AAG7C,SAAS,uBAAuB;IACtC,6LAAO,uBAAA,EAAqB;QAAE,uMAAY,gBAAA,CAAc;IAAE,CAAC;AAC5D","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6691, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/shared/defaultStyleDefs.tsx"],"sourcesContent":["import {\n\tDefaultColorThemePalette,\n\tDefaultFontStyle,\n\tSvgExportDef,\n\tTLDefaultColorTheme,\n\tTLDefaultFillStyle,\n\tTLShapeUtilCanvasSvgDef,\n\tdebugFlags,\n\tlast,\n\tsuffixSafeId,\n\ttlenv,\n\tuseEditor,\n\tuseSharedSafeId,\n\tuseUniqueSafeId,\n\tuseValue,\n} from '@tldraw/editor'\nimport { useCallback, useEffect, useRef, useState } from 'react'\nimport { useDefaultColorTheme } from './useDefaultColorTheme'\n\n/** @public */\nexport function getFillDefForExport(fill: TLDefaultFillStyle): SvgExportDef {\n\treturn {\n\t\tkey: `${DefaultFontStyle.id}:${fill}`,\n\t\tasync getElement() {\n\t\t\tif (fill !== 'pattern') return null\n\n\t\t\treturn <HashPatternForExport />\n\t\t},\n\t}\n}\n\nfunction HashPatternForExport() {\n\tconst getHashPatternZoomName = useGetHashPatternZoomName()\n\tconst maskId = useUniqueSafeId()\n\tconst theme = useDefaultColorTheme()\n\tconst t = 8 / 12\n\treturn (\n\t\t<>\n\t\t\t<mask id={maskId}>\n\t\t\t\t<rect x=\"0\" y=\"0\" width=\"8\" height=\"8\" fill=\"white\" />\n\t\t\t\t<g strokeLinecap=\"round\" stroke=\"black\">\n\t\t\t\t\t<line x1={t * 1} y1={t * 3} x2={t * 3} y2={t * 1} />\n\t\t\t\t\t<line x1={t * 5} y1={t * 7} x2={t * 7} y2={t * 5} />\n\t\t\t\t\t<line x1={t * 9} y1={t * 11} x2={t * 11} y2={t * 9} />\n\t\t\t\t</g>\n\t\t\t</mask>\n\t\t\t<pattern\n\t\t\t\tid={getHashPatternZoomName(1, theme.id)}\n\t\t\t\twidth=\"8\"\n\t\t\t\theight=\"8\"\n\t\t\t\tpatternUnits=\"userSpaceOnUse\"\n\t\t\t>\n\t\t\t\t<rect x=\"0\" y=\"0\" width=\"8\" height=\"8\" fill={theme.solid} mask={`url(#${maskId})`} />\n\t\t\t</pattern>\n\t\t</>\n\t)\n}\n\nexport function getFillDefForCanvas(): TLShapeUtilCanvasSvgDef {\n\treturn {\n\t\tkey: `${DefaultFontStyle.id}:pattern`,\n\t\tcomponent: PatternFillDefForCanvas,\n\t}\n}\nconst TILE_PATTERN_SIZE = 8\n\nconst generateImage = (dpr: number, currentZoom: number, darkMode: boolean) => {\n\treturn new Promise<Blob>((resolve, reject) => {\n\t\tconst size = TILE_PATTERN_SIZE * currentZoom * dpr\n\n\t\tconst canvasEl = document.createElement('canvas')\n\t\tcanvasEl.width = size\n\t\tcanvasEl.height = size\n\n\t\tconst ctx = canvasEl.getContext('2d')\n\t\tif (!ctx) return\n\n\t\tctx.fillStyle = darkMode\n\t\t\t? DefaultColorThemePalette.darkMode.solid\n\t\t\t: DefaultColorThemePalette.lightMode.solid\n\t\tctx.fillRect(0, 0, size, size)\n\n\t\t// This essentially generates an inverse of the pattern we're drawing.\n\t\tctx.globalCompositeOperation = 'destination-out'\n\n\t\tctx.lineCap = 'round'\n\t\tctx.lineWidth = 1.25 * currentZoom * dpr\n\n\t\tconst t = 8 / 12\n\t\tconst s = (v: number) => v * currentZoom * dpr\n\n\t\tctx.beginPath()\n\t\tctx.moveTo(s(t * 1), s(t * 3))\n\t\tctx.lineTo(s(t * 3), s(t * 1))\n\n\t\tctx.moveTo(s(t * 5), s(t * 7))\n\t\tctx.lineTo(s(t * 7), s(t * 5))\n\n\t\tctx.moveTo(s(t * 9), s(t * 11))\n\t\tctx.lineTo(s(t * 11), s(t * 9))\n\t\tctx.stroke()\n\n\t\tcanvasEl.toBlob((blob) => {\n\t\t\tif (!blob || debugFlags.throwToBlob.get()) {\n\t\t\t\treject()\n\t\t\t} else {\n\t\t\t\tresolve(blob)\n\t\t\t}\n\t\t})\n\t})\n}\n\nconst canvasBlob = (size: [number, number], fn: (ctx: CanvasRenderingContext2D) => void) => {\n\tconst canvas = document.createElement('canvas')\n\tcanvas.width = size[0]\n\tcanvas.height = size[1]\n\tconst ctx = canvas.getContext('2d')\n\tif (!ctx) return ''\n\tfn(ctx)\n\treturn canvas.toDataURL()\n}\ninterface PatternDef {\n\tzoom: number\n\turl: string\n\ttheme: 'light' | 'dark'\n}\n\nlet defaultPixels: { white: string; black: string } | null = null\nfunction getDefaultPixels() {\n\tif (!defaultPixels) {\n\t\tdefaultPixels = {\n\t\t\twhite: canvasBlob([1, 1], (ctx) => {\n\t\t\t\tctx.fillStyle = '#f8f9fa'\n\t\t\t\tctx.fillRect(0, 0, 1, 1)\n\t\t\t}),\n\t\t\tblack: canvasBlob([1, 1], (ctx) => {\n\t\t\t\tctx.fillStyle = '#212529'\n\t\t\t\tctx.fillRect(0, 0, 1, 1)\n\t\t\t}),\n\t\t}\n\t}\n\treturn defaultPixels\n}\n\nfunction getPatternLodForZoomLevel(zoom: number) {\n\treturn Math.ceil(Math.log2(Math.max(1, zoom)))\n}\n\nexport function useGetHashPatternZoomName() {\n\tconst id = useSharedSafeId('hash_pattern')\n\treturn useCallback(\n\t\t(zoom: number, theme: TLDefaultColorTheme['id']) => {\n\t\t\tconst lod = getPatternLodForZoomLevel(zoom)\n\t\t\treturn suffixSafeId(id, `${theme}_${lod}`)\n\t\t},\n\t\t[id]\n\t)\n}\n\nfunction getPatternLodsToGenerate(maxZoom: number) {\n\tconst levels = []\n\tconst minLod = 0\n\tconst maxLod = getPatternLodForZoomLevel(maxZoom)\n\tfor (let i = minLod; i <= maxLod; i++) {\n\t\tlevels.push(Math.pow(2, i))\n\t}\n\treturn levels\n}\n\nfunction getDefaultPatterns(maxZoom: number): PatternDef[] {\n\tconst defaultPixels = getDefaultPixels()\n\treturn getPatternLodsToGenerate(maxZoom).flatMap((zoom) => [\n\t\t{ zoom, url: defaultPixels.white, theme: 'light' },\n\t\t{ zoom, url: defaultPixels.black, theme: 'dark' },\n\t])\n}\n\nfunction usePattern() {\n\tconst editor = useEditor()\n\tconst dpr = useValue('devicePixelRatio', () => editor.getInstanceState().devicePixelRatio, [\n\t\teditor,\n\t])\n\tconst maxZoom = useValue('maxZoom', () => Math.ceil(last(editor.getCameraOptions().zoomSteps)!), [\n\t\teditor,\n\t])\n\tconst [isReady, setIsReady] = useState(false)\n\tconst [backgroundUrls, setBackgroundUrls] = useState<PatternDef[]>(() =>\n\t\tgetDefaultPatterns(maxZoom)\n\t)\n\tconst getHashPatternZoomName = useGetHashPatternZoomName()\n\n\tuseEffect(() => {\n\t\tif (process.env.NODE_ENV === 'test') {\n\t\t\tsetIsReady(true)\n\t\t\treturn\n\t\t}\n\n\t\tconst promise = Promise.all(\n\t\t\tgetPatternLodsToGenerate(maxZoom).flatMap<Promise<PatternDef>>((zoom) => [\n\t\t\t\tgenerateImage(dpr, zoom, false).then((blob) => ({\n\t\t\t\t\tzoom,\n\t\t\t\t\ttheme: 'light',\n\t\t\t\t\turl: URL.createObjectURL(blob),\n\t\t\t\t})),\n\t\t\t\tgenerateImage(dpr, zoom, true).then((blob) => ({\n\t\t\t\t\tzoom,\n\t\t\t\t\ttheme: 'dark',\n\t\t\t\t\turl: URL.createObjectURL(blob),\n\t\t\t\t})),\n\t\t\t])\n\t\t)\n\n\t\tlet isCancelled = false\n\t\tpromise.then((urls) => {\n\t\t\tif (isCancelled) return\n\t\t\tsetBackgroundUrls(urls)\n\t\t\tsetIsReady(true)\n\t\t})\n\t\treturn () => {\n\t\t\tisCancelled = true\n\t\t\tsetIsReady(false)\n\t\t\tpromise.then((patterns) => {\n\t\t\t\tfor (const { url } of patterns) {\n\t\t\t\t\tURL.revokeObjectURL(url)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}, [dpr, maxZoom])\n\n\tconst defs = (\n\t\t<>\n\t\t\t{backgroundUrls.map((item) => {\n\t\t\t\tconst id = getHashPatternZoomName(item.zoom, item.theme)\n\t\t\t\treturn (\n\t\t\t\t\t<pattern\n\t\t\t\t\t\tkey={id}\n\t\t\t\t\t\tid={id}\n\t\t\t\t\t\twidth={TILE_PATTERN_SIZE}\n\t\t\t\t\t\theight={TILE_PATTERN_SIZE}\n\t\t\t\t\t\tpatternUnits=\"userSpaceOnUse\"\n\t\t\t\t\t>\n\t\t\t\t\t\t<image href={item.url} width={TILE_PATTERN_SIZE} height={TILE_PATTERN_SIZE} />\n\t\t\t\t\t</pattern>\n\t\t\t\t)\n\t\t\t})}\n\t\t</>\n\t)\n\n\treturn { defs, isReady }\n}\n\nfunction PatternFillDefForCanvas() {\n\tconst editor = useEditor()\n\tconst containerRef = useRef<SVGGElement>(null)\n\tconst { defs, isReady } = usePattern()\n\n\tuseEffect(() => {\n\t\tif (isReady && tlenv.isSafari) {\n\t\t\tconst htmlLayer = findHtmlLayerParent(containerRef.current!)\n\t\t\tif (htmlLayer) {\n\t\t\t\t// Wait for `patternContext` to be picked up\n\t\t\t\teditor.timers.requestAnimationFrame(() => {\n\t\t\t\t\thtmlLayer.style.display = 'none'\n\n\t\t\t\t\t// Wait for 'display = \"none\"' to take effect\n\t\t\t\t\teditor.timers.requestAnimationFrame(() => {\n\t\t\t\t\t\thtmlLayer.style.display = ''\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}, [editor, isReady])\n\n\treturn (\n\t\t<g ref={containerRef} data-testid={isReady ? 'ready-pattern-fill-defs' : undefined}>\n\t\t\t{defs}\n\t\t</g>\n\t)\n}\n\nfunction findHtmlLayerParent(element: Element): HTMLElement | null {\n\tif (element.classList.contains('tl-html-layer')) return element as HTMLElement\n\tif (element.parentElement) return findHtmlLayerParent(element.parentElement)\n\treturn null\n}\n"],"names":["defaultPixels"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7022, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/shared/ShapeFill.tsx"],"sourcesContent":["import {\n\tTLDefaultColorStyle,\n\tTLDefaultColorTheme,\n\tTLDefaultFillStyle,\n\tuseEditor,\n\tuseSvgExportContext,\n\tuseValue,\n} from '@tldraw/editor'\nimport React from 'react'\nimport { useGetHashPatternZoomName } from './defaultStyleDefs'\n\ninterface ShapeFillProps {\n\td: string\n\tfill: TLDefaultFillStyle\n\tcolor: TLDefaultColorStyle\n\ttheme: TLDefaultColorTheme\n\tscale: number\n}\n\nexport const ShapeFill = React.memo(function ShapeFill({\n\ttheme,\n\td,\n\tcolor,\n\tfill,\n\tscale,\n}: ShapeFillProps) {\n\tswitch (fill) {\n\t\tcase 'none': {\n\t\t\treturn null\n\t\t}\n\t\tcase 'solid': {\n\t\t\treturn <path fill={theme[color].semi} d={d} />\n\t\t}\n\t\tcase 'semi': {\n\t\t\treturn <path fill={theme.solid} d={d} />\n\t\t}\n\t\tcase 'fill': {\n\t\t\treturn <path fill={theme[color].fill} d={d} />\n\t\t}\n\t\tcase 'pattern': {\n\t\t\treturn <PatternFill theme={theme} color={color} fill={fill} d={d} scale={scale} />\n\t\t}\n\t}\n})\n\nexport function PatternFill({ d, color, theme }: ShapeFillProps) {\n\tconst editor = useEditor()\n\tconst svgExport = useSvgExportContext()\n\tconst zoomLevel = useValue('zoomLevel', () => editor.getZoomLevel(), [editor])\n\tconst getHashPatternZoomName = useGetHashPatternZoomName()\n\n\tconst teenyTiny = editor.getZoomLevel() <= 0.18\n\n\treturn (\n\t\t<>\n\t\t\t<path fill={theme[color].pattern} d={d} />\n\t\t\t<path\n\t\t\t\tfill={\n\t\t\t\t\tsvgExport\n\t\t\t\t\t\t? `url(#${getHashPatternZoomName(1, theme.id)})`\n\t\t\t\t\t\t: teenyTiny\n\t\t\t\t\t\t\t? theme[color].semi\n\t\t\t\t\t\t\t: `url(#${getHashPatternZoomName(zoomLevel, theme.id)})`\n\t\t\t\t}\n\t\t\t\td={d}\n\t\t\t/>\n\t\t</>\n\t)\n}\n"],"names":["ShapeFill"],"mappings":";;;;AA+BU,SAuBR,UAvBQ,KAuBR,YAvBQ;AA/BV;;;;AAQA,OAAO,WAAW;AAClB,SAAS,iCAAiC;;;;;AAUnC,MAAM,0KAAY,UAAA,CAAM,IAAA,CAAK,SAASA,WAAU,EACtD,KAAA,EACA,CAAA,EACA,KAAA,EACA,IAAA,EACA,KAAA,EACD,EAAmB;IAClB,OAAQ,MAAM;QACb,KAAK;YAAQ;gBACZ,OAAO;YACR;QACA,KAAK;YAAS;gBACb,OAAO,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,QAAA;oBAAK,MAAM,KAAA,CAAM,KAAK,CAAA,CAAE,IAAA;oBAAM;gBAAA,CAAM;YAC7C;QACA,KAAK;YAAQ;gBACZ,OAAO,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,QAAA;oBAAK,MAAM,MAAM,KAAA;oBAAO;gBAAA,CAAM;YACvC;QACA,KAAK;YAAQ;gBACZ,OAAO,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,QAAA;oBAAK,MAAM,KAAA,CAAM,KAAK,CAAA,CAAE,IAAA;oBAAM;gBAAA,CAAM;YAC7C;QACA,KAAK;YAAW;gBACf,OAAO,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,aAAA;oBAAY;oBAAc;oBAAc;oBAAY;oBAAM;gBAAA,CAAc;YACjF;IACD;AACD,CAAC;AAEM,SAAS,YAAY,EAAE,CAAA,EAAG,KAAA,EAAO,KAAA,CAAM,CAAA,EAAmB;IAChE,MAAM,gMAAS,YAAA,CAAU;IACzB,MAAM,YAAY,8NAAA,CAAoB;IACtC,MAAM,iMAAY,WAAA,EAAS;2CAAa,IAAM,OAAO,YAAA,CAAa;0CAAG;QAAC,MAAM;KAAC;IAC7E,MAAM,sNAAyB,4BAAA,CAA0B;IAEzD,MAAM,YAAY,OAAO,YAAA,CAAa,KAAK;IAE3C,OACC,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,OAAA,EAAA,sKAAA,CAAA,WAAA,EAAA;QACC,UAAA;YAAA,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,QAAA;gBAAK,MAAM,KAAA,CAAM,KAAK,CAAA,CAAE,OAAA;gBAAS;YAAA,CAAM;YACxC,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,QAAA;gBACA,MACC,YACG,CAAA,KAAA,EAAQ,uBAAuB,GAAG,MAAM,EAAE,CAAC,CAAA,CAAA,CAAA,GAC3C,YACC,KAAA,CAAM,KAAK,CAAA,CAAE,IAAA,GACb,CAAA,KAAA,EAAQ,uBAAuB,WAAW,MAAM,EAAE,CAAC,CAAA,CAAA,CAAA;gBAExD;YAAA;SACD;IAAA,CACD;AAEF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7107, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/shared/createTextJsxFromSpans.tsx"],"sourcesContent":["import {\n\tBox,\n\tBoxModel,\n\tEditor,\n\tTLDefaultVerticalAlignStyle,\n\tTLMeasureTextSpanOpts,\n} from '@tldraw/editor'\n\nfunction correctSpacesToNbsp(input: string) {\n\treturn input.replace(/\\s/g, '\\xa0')\n}\n\nexport interface TLCreateTextJsxFromSpansOpts extends TLMeasureTextSpanOpts {\n\tverticalTextAlign: TLDefaultVerticalAlignStyle\n\toffsetX: number\n\toffsetY: number\n\tstroke?: string\n\tstrokeWidth?: number\n\tfill?: string\n}\n\n/** Get an SVG element for a text shape. */\nexport function createTextJsxFromSpans(\n\teditor: Editor,\n\tspans: { text: string; box: BoxModel }[],\n\topts: TLCreateTextJsxFromSpansOpts\n) {\n\tconst { padding = 0 } = opts\n\tif (spans.length === 0) return null\n\n\tconst bounds = Box.From(spans[0].box)\n\tfor (const { box } of spans) {\n\t\tbounds.union(box)\n\t}\n\n\tconst offsetX = padding + (opts.offsetX ?? 0)\n\tconst offsetY =\n\t\t(opts.offsetY ?? 0) +\n\t\topts.fontSize / 2 +\n\t\t(opts.verticalTextAlign === 'start'\n\t\t\t? padding\n\t\t\t: opts.verticalTextAlign === 'end'\n\t\t\t\t? opts.height - padding - bounds.height\n\t\t\t\t: (Math.ceil(opts.height) - bounds.height) / 2)\n\n\t// Create text span elements for each word\n\tlet currentLineTop = null\n\tconst children = []\n\tfor (const { text, box } of spans) {\n\t\t// if we broke a line, add a line break span. This helps tools like\n\t\t// figma import our exported svg correctly\n\t\tconst didBreakLine = currentLineTop !== null && box.y > currentLineTop\n\t\tif (didBreakLine) {\n\t\t\tchildren.push(\n\t\t\t\t<tspan\n\t\t\t\t\tkey={children.length}\n\t\t\t\t\talignmentBaseline=\"mathematical\"\n\t\t\t\t\tx={offsetX}\n\t\t\t\t\ty={box.y + offsetY}\n\t\t\t\t>\n\t\t\t\t\t{'\\n'}\n\t\t\t\t</tspan>\n\t\t\t)\n\t\t}\n\n\t\tchildren.push(\n\t\t\t<tspan\n\t\t\t\tkey={children.length}\n\t\t\t\talignmentBaseline=\"mathematical\"\n\t\t\t\tx={box.x + offsetX}\n\t\t\t\ty={box.y + offsetY}\n\t\t\t\t// N.B. This property, while discouraged (\"intended for Document Type Definition (DTD) designers\")\n\t\t\t\t// is necessary for ensuring correct mixed RTL/LTR behavior when exporting SVGs.\n\t\t\t\tunicodeBidi=\"plaintext\"\n\t\t\t>\n\t\t\t\t{correctSpacesToNbsp(text)}\n\t\t\t</tspan>\n\t\t)\n\n\t\tcurrentLineTop = box.y\n\t}\n\n\treturn (\n\t\t<text\n\t\t\tfontSize={opts.fontSize}\n\t\t\tfontFamily={opts.fontFamily}\n\t\t\tfontStyle={opts.fontStyle}\n\t\t\tfontWeight={opts.fontWeight}\n\t\t\tdominantBaseline=\"mathematical\"\n\t\t\talignmentBaseline=\"mathematical\"\n\t\t\tstroke={opts.stroke}\n\t\t\tstrokeWidth={opts.strokeWidth}\n\t\t\tfill={opts.fill}\n\t\t>\n\t\t\t{children}\n\t\t</text>\n\t)\n}\n"],"names":[],"mappings":";;;AAsDI;AAtDJ;;;;AAQA,SAAS,oBAAoB,KAAA,EAAe;IAC3C,OAAO,MAAM,OAAA,CAAQ,OAAO,MAAM;AACnC;AAYO,SAAS,uBACf,MAAA,EACA,KAAA,EACA,IAAA,EACC;IACD,MAAM,EAAE,UAAU,CAAA,CAAE,CAAA,GAAI;IACxB,IAAI,MAAM,MAAA,KAAW,EAAG,CAAA,OAAO;IAE/B,MAAM,2LAAS,MAAA,CAAI,IAAA,CAAK,KAAA,CAAM,CAAC,CAAA,CAAE,GAAG;IACpC,KAAA,MAAW,EAAE,GAAA,CAAI,CAAA,IAAK,MAAO;QAC5B,OAAO,KAAA,CAAM,GAAG;IACjB;IAEA,MAAM,UAAU,UAAA,CAAW,KAAK,OAAA,IAAW,CAAA;IAC3C,MAAM,UAAA,CACJ,KAAK,OAAA,IAAW,CAAA,IACjB,KAAK,QAAA,GAAW,IAAA,CACf,KAAK,iBAAA,KAAsB,UACzB,UACA,KAAK,iBAAA,KAAsB,QAC1B,KAAK,MAAA,GAAS,UAAU,OAAO,MAAA,GAAA,CAC9B,KAAK,IAAA,CAAK,KAAK,MAAM,IAAI,OAAO,MAAA,IAAU,CAAA;IAGhD,IAAI,iBAAiB;IACrB,MAAM,WAAW,CAAC,CAAA;IAClB,KAAA,MAAW,EAAE,IAAA,EAAM,GAAA,CAAI,CAAA,IAAK,MAAO;QAGlC,MAAM,eAAe,mBAAmB,QAAQ,IAAI,CAAA,GAAI;QACxD,IAAI,cAAc;YACjB,SAAS,IAAA,CACR,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,SAAA;gBAEA,mBAAkB;gBAClB,GAAG;gBACH,GAAG,IAAI,CAAA,GAAI;gBAEV,UAAA;YAAA,GALI,SAAS,MAAA;QAQjB;QAEA,SAAS,IAAA,CACR,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,SAAA;YAEA,mBAAkB;YAClB,GAAG,IAAI,CAAA,GAAI;YACX,GAAG,IAAI,CAAA,GAAI;YAGX,aAAY;YAEX,UAAA,oBAAoB,IAAI;QAAA,GARpB,SAAS,MAAA;QAYhB,iBAAiB,IAAI,CAAA;IACtB;IAEA,OACC,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,QAAA;QACA,UAAU,KAAK,QAAA;QACf,YAAY,KAAK,UAAA;QACjB,WAAW,KAAK,SAAA;QAChB,YAAY,KAAK,UAAA;QACjB,kBAAiB;QACjB,mBAAkB;QAClB,QAAQ,KAAK,MAAA;QACb,aAAa,KAAK,WAAA;QAClB,MAAM,KAAK,IAAA;QAEV;IAAA;AAGJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7169, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/shared/SvgTextLabel.tsx"],"sourcesContent":["import {\n\tBox,\n\tDefaultFontFamilies,\n\tTLDefaultFontStyle,\n\tTLDefaultHorizontalAlignStyle,\n\tTLDefaultVerticalAlignStyle,\n\tuseEditor,\n} from '@tldraw/editor'\nimport { createTextJsxFromSpans } from './createTextJsxFromSpans'\nimport { TEXT_PROPS } from './default-shape-constants'\nimport { getLegacyOffsetX } from './legacyProps'\nimport { useDefaultColorTheme } from './useDefaultColorTheme'\n\nexport function SvgTextLabel({\n\tfontSize,\n\tfont,\n\talign,\n\tverticalAlign,\n\ttext,\n\tlabelColor,\n\tbounds,\n\tpadding = 16,\n\tstroke = true,\n\tshowTextOutline = true,\n}: {\n\tfontSize: number\n\tfont: TLDefaultFontStyle\n\t// fill?: TLDefaultFillStyle\n\talign: TLDefaultHorizontalAlignStyle\n\tverticalAlign: TLDefaultVerticalAlignStyle\n\twrap?: boolean\n\ttext: string\n\tlabelColor: string\n\tbounds: Box\n\tpadding?: number\n\tstroke?: boolean\n\tshowTextOutline?: boolean\n}) {\n\tconst editor = useEditor()\n\tconst theme = useDefaultColorTheme()\n\n\tconst opts = {\n\t\tfontSize,\n\t\tfontFamily: DefaultFontFamilies[font],\n\t\ttextAlign: align,\n\t\tverticalTextAlign: verticalAlign,\n\t\twidth: Math.ceil(bounds.width),\n\t\theight: Math.ceil(bounds.height),\n\t\tpadding,\n\t\tlineHeight: TEXT_PROPS.lineHeight,\n\t\tfontStyle: 'normal',\n\t\tfontWeight: 'normal',\n\t\toverflow: 'wrap' as const,\n\t\toffsetX: 0,\n\t\toffsetY: 0,\n\t\tfill: labelColor,\n\t\tstroke: undefined as string | undefined,\n\t\tstrokeWidth: undefined as number | undefined,\n\t}\n\n\tconst spans = editor.textMeasure.measureTextSpans(text, opts)\n\tconst offsetX = getLegacyOffsetX(align, padding, spans, bounds.width)\n\tif (offsetX) {\n\t\topts.offsetX = offsetX\n\t}\n\n\topts.offsetX += bounds.x\n\topts.offsetY += bounds.y\n\n\tconst mainSpans = createTextJsxFromSpans(editor, spans, opts)\n\n\tlet outlineSpans = null\n\tif (showTextOutline && stroke) {\n\t\topts.fill = theme.background\n\t\topts.stroke = theme.background\n\t\topts.strokeWidth = 3\n\t\toutlineSpans = createTextJsxFromSpans(editor, spans, opts)\n\t}\n\n\treturn (\n\t\t<>\n\t\t\t{outlineSpans}\n\t\t\t{mainSpans}\n\t\t</>\n\t)\n}\n"],"names":[],"mappings":";;;AAgFE;AAhFF;;;AAQA,SAAS,8BAA8B;AACvC,SAAS,kBAAkB;AAC3B,SAAS,wBAAwB;AACjC,SAAS,4BAA4B;;;;;;;AAE9B,SAAS,aAAa,EAC5B,QAAA,EACA,IAAA,EACA,KAAA,EACA,aAAA,EACA,IAAA,EACA,UAAA,EACA,MAAA,EACA,UAAU,EAAA,EACV,SAAS,IAAA,EACT,kBAAkB,IAAA,EACnB,EAaG;IACF,MAAM,aAAS,+LAAA,CAAU;IACzB,MAAM,yMAAQ,uBAAA,CAAqB;IAEnC,MAAM,OAAO;QACZ;QACA,6LAAY,sBAAA,CAAoB,IAAI,CAAA;QACpC,WAAW;QACX,mBAAmB;QACnB,OAAO,KAAK,IAAA,CAAK,OAAO,KAAK;QAC7B,QAAQ,KAAK,IAAA,CAAK,OAAO,MAAM;QAC/B;QACA,kNAAY,aAAA,CAAW,UAAA;QACvB,WAAW;QACX,YAAY;QACZ,UAAU;QACV,SAAS;QACT,SAAS;QACT,MAAM;QACN,QAAQ,KAAA;QACR,aAAa,KAAA;IACd;IAEA,MAAM,QAAQ,OAAO,WAAA,CAAY,gBAAA,CAAiB,MAAM,IAAI;IAC5D,MAAM,WAAU,0MAAA,EAAiB,OAAO,SAAS,OAAO,OAAO,KAAK;IACpE,IAAI,SAAS;QACZ,KAAK,OAAA,GAAU;IAChB;IAEA,KAAK,OAAA,IAAW,OAAO,CAAA;IACvB,KAAK,OAAA,IAAW,OAAO,CAAA;IAEvB,MAAM,+MAAY,yBAAA,EAAuB,QAAQ,OAAO,IAAI;IAE5D,IAAI,eAAe;IACnB,IAAI,mBAAmB,QAAQ;QAC9B,KAAK,IAAA,GAAO,MAAM,UAAA;QAClB,KAAK,MAAA,GAAS,MAAM,UAAA;QACpB,KAAK,WAAA,GAAc;QACnB,kNAAe,yBAAA,EAAuB,QAAQ,OAAO,IAAI;IAC1D;IAEA,OACC,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,OAAA,EAAA,sKAAA,CAAA,WAAA,EAAA;QACE,UAAA;YAAA;YACA;SAAA;IAAA,CACF;AAEF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7237, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/arrow/ArrowPath.tsx"],"sourcesContent":["import { exhaustiveSwitchError, TLArrowShape } from '@tldraw/editor'\nimport { PathBuilder, PathBuilderOpts } from '../shared/PathBuilder'\nimport { TLArrowInfo } from './arrow-types'\nimport { getRouteHandlePath } from './elbow/getElbowArrowInfo'\n\nexport function getArrowBodyPath(shape: TLArrowShape, info: TLArrowInfo, opts: PathBuilderOpts) {\n\tswitch (info.type) {\n\t\tcase 'straight':\n\t\t\treturn new PathBuilder()\n\t\t\t\t.moveTo(info.start.point.x, info.start.point.y, { offset: 0, roundness: 0 })\n\t\t\t\t.lineTo(info.end.point.x, info.end.point.y, { offset: 0, roundness: 0 })\n\t\t\t\t.toSvg(opts)\n\t\tcase 'arc':\n\t\t\treturn new PathBuilder()\n\t\t\t\t.moveTo(info.start.point.x, info.start.point.y, { offset: 0, roundness: 0 })\n\t\t\t\t.circularArcTo(\n\t\t\t\t\tinfo.bodyArc.radius,\n\t\t\t\t\t!!info.bodyArc.largeArcFlag,\n\t\t\t\t\t!!info.bodyArc.sweepFlag,\n\t\t\t\t\tinfo.end.point.x,\n\t\t\t\t\tinfo.end.point.y,\n\t\t\t\t\t{ offset: 0, roundness: 0 }\n\t\t\t\t)\n\t\t\t\t.toSvg(opts)\n\t\tcase 'elbow': {\n\t\t\tconst path = new PathBuilder()\n\t\t\tpath.moveTo(info.start.point.x, info.start.point.y, {\n\t\t\t\toffset: 0,\n\t\t\t})\n\t\t\tfor (let i = 1; i < info.route.points.length; i++) {\n\t\t\t\tconst point = info.route.points[i]\n\t\t\t\tif (info.route.skipPointsWhenDrawing.has(point)) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tpath.lineTo(point.x, point.y, {\n\t\t\t\t\toffset: i === info.route.points.length - 1 ? 0 : undefined,\n\t\t\t\t})\n\t\t\t}\n\t\t\treturn path.toSvg(opts)\n\t\t}\n\t\tdefault:\n\t\t\texhaustiveSwitchError(info, 'type')\n\t}\n}\n\nexport function getArrowHandlePath(info: TLArrowInfo, opts: PathBuilderOpts) {\n\tswitch (info.type) {\n\t\tcase 'straight':\n\t\t\treturn new PathBuilder()\n\t\t\t\t.moveTo(info.start.handle.x, info.start.handle.y)\n\t\t\t\t.lineTo(info.end.handle.x, info.end.handle.y)\n\t\t\t\t.toSvg(opts)\n\t\tcase 'arc':\n\t\t\treturn new PathBuilder()\n\t\t\t\t.moveTo(info.start.handle.x, info.start.handle.y)\n\t\t\t\t.circularArcTo(\n\t\t\t\t\tinfo.handleArc.radius,\n\t\t\t\t\t!!info.handleArc.largeArcFlag,\n\t\t\t\t\t!!info.handleArc.sweepFlag,\n\t\t\t\t\tinfo.end.handle.x,\n\t\t\t\t\tinfo.end.handle.y\n\t\t\t\t)\n\t\t\t\t.toSvg(opts)\n\t\tcase 'elbow': {\n\t\t\tconst handleRoute = getRouteHandlePath(info.elbow, info.route)\n\t\t\treturn PathBuilder.lineThroughPoints(handleRoute.points).toSvg(opts)\n\t\t}\n\t\tdefault:\n\t\t\texhaustiveSwitchError(info, 'type')\n\t}\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7310, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/arrow/arrowLabel.ts"],"sourcesContent":["import {\n\tArc2d,\n\tBox,\n\tCircle2d,\n\tEdge2d,\n\tEditor,\n\tGeometry2d,\n\tGroup2d,\n\tPolygon2d,\n\tPolyline2d,\n\tTLArrowShape,\n\tVec,\n\tVecLike,\n\tclamp,\n\tcreateComputedCache,\n\texhaustiveSwitchError,\n\tgetChangedKeys,\n} from '@tldraw/editor'\nimport {\n\tARROW_LABEL_FONT_SIZES,\n\tARROW_LABEL_PADDING,\n\tFONT_FAMILIES,\n\tLABEL_TO_ARROW_PADDING,\n\tSTROKE_SIZES,\n\tTEXT_PROPS,\n} from '../shared/default-shape-constants'\nimport { TLArrowInfo } from './arrow-types'\nimport { getArrowInfo } from './shared'\n\nexport function getArrowBodyGeometry(editor: Editor, shape: TLArrowShape) {\n\tconst info = getArrowInfo(editor, shape)!\n\tswitch (info.type) {\n\t\tcase 'straight':\n\t\t\treturn new Edge2d({\n\t\t\t\tstart: Vec.From(info.start.point),\n\t\t\t\tend: Vec.From(info.end.point),\n\t\t\t})\n\t\tcase 'arc':\n\t\t\treturn new Arc2d({\n\t\t\t\tcenter: Vec.Cast(info.handleArc.center),\n\t\t\t\tstart: Vec.Cast(info.start.point),\n\t\t\t\tend: Vec.Cast(info.end.point),\n\t\t\t\tsweepFlag: info.bodyArc.sweepFlag,\n\t\t\t\tlargeArcFlag: info.bodyArc.largeArcFlag,\n\t\t\t})\n\t\tcase 'elbow':\n\t\t\treturn new Polyline2d({ points: info.route.points })\n\t\tdefault:\n\t\t\texhaustiveSwitchError(info, 'type')\n\t}\n}\n\nconst labelSizeCache = createComputedCache(\n\t'arrow label size',\n\t(editor: Editor, shape: TLArrowShape) => {\n\t\teditor.fonts.trackFontsForShape(shape)\n\t\tlet width = 0\n\t\tlet height = 0\n\n\t\tconst bodyGeom = getArrowBodyGeometry(editor, shape)\n\t\t// We use 'i' as a default label to measure against as a minimum width.\n\t\tconst text = shape.props.text || 'i'\n\n\t\tconst bodyBounds = bodyGeom.bounds\n\n\t\tconst fontSize = getArrowLabelFontSize(shape)\n\n\t\t// First we measure the text with no constraints\n\t\tconst { w, h } = editor.textMeasure.measureText(text, {\n\t\t\t...TEXT_PROPS,\n\t\t\tfontFamily: FONT_FAMILIES[shape.props.font],\n\t\t\tfontSize,\n\t\t\tmaxWidth: null,\n\t\t})\n\n\t\twidth = w\n\t\theight = h\n\n\t\tlet shouldSquish = false\n\n\t\t// If the text is wider than the body, we need to squish it\n\t\tconst info = getArrowInfo(editor, shape)!\n\t\tconst labelToArrowPadding = getLabelToArrowPadding(shape)\n\t\tconst margin =\n\t\t\tinfo.type === 'elbow'\n\t\t\t\t? Math.max(info.elbow.A.arrowheadOffset + labelToArrowPadding, 32) +\n\t\t\t\t\tMath.max(info.elbow.B.arrowheadOffset + labelToArrowPadding, 32)\n\t\t\t\t: 64\n\n\t\tif (bodyBounds.width > bodyBounds.height) {\n\t\t\twidth = Math.max(Math.min(w, margin), Math.min(bodyBounds.width - margin, w))\n\t\t\tshouldSquish = true\n\t\t} else if (width > 16 * fontSize) {\n\t\t\twidth = 16 * fontSize\n\t\t\tshouldSquish = true\n\t\t}\n\n\t\tif (shouldSquish) {\n\t\t\tconst { w: squishedWidth, h: squishedHeight } = editor.textMeasure.measureText(text, {\n\t\t\t\t...TEXT_PROPS,\n\t\t\t\tfontFamily: FONT_FAMILIES[shape.props.font],\n\t\t\t\tfontSize,\n\t\t\t\tmaxWidth: width,\n\t\t\t})\n\n\t\t\twidth = squishedWidth\n\t\t\theight = squishedHeight\n\t\t}\n\n\t\treturn new Vec(width, height).addScalar(ARROW_LABEL_PADDING * 2 * shape.props.scale)\n\t},\n\t{\n\t\tareRecordsEqual: (a, b) => {\n\t\t\tif (a.props === b.props) return true\n\n\t\t\t// If the only thing that has changed is the label position, we can skip recalculating the size\n\t\t\tconst changedKeys = getChangedKeys(a.props, b.props)\n\t\t\treturn changedKeys.length === 1 && changedKeys[0] === 'labelPosition'\n\t\t},\n\t}\n)\n\nfunction getArrowLabelSize(editor: Editor, shape: TLArrowShape) {\n\treturn labelSizeCache.get(editor, shape.id) ?? new Vec(0, 0)\n}\n\nfunction getLabelToArrowPadding(shape: TLArrowShape) {\n\tconst strokeWidth = STROKE_SIZES[shape.props.size]\n\tconst labelToArrowPadding =\n\t\t(LABEL_TO_ARROW_PADDING +\n\t\t\t(strokeWidth - STROKE_SIZES.s) * 2 +\n\t\t\t(strokeWidth === STROKE_SIZES.xl ? 20 : 0)) *\n\t\tshape.props.scale\n\n\treturn labelToArrowPadding\n}\n\n/**\n * Return the range of possible label positions for an arrow. The full possible range is 0 to 1, but\n * as the label itself takes up space the usable range is smaller.\n */\nfunction getArrowLabelRange(editor: Editor, shape: TLArrowShape, info: TLArrowInfo) {\n\tconst bodyGeom = getArrowBodyGeometry(editor, shape)\n\tconst dbgPoints: VecLike[] = []\n\tconst dbg: Geometry2d[] = [new Group2d({ children: [bodyGeom], debugColor: 'lime' })]\n\n\tconst labelSize = getArrowLabelSize(editor, shape)\n\tconst labelToArrowPadding = getLabelToArrowPadding(shape)\n\tconst paddingRelative = labelToArrowPadding / bodyGeom.length\n\n\t// we can calculate the range by sticking the center of the label at the very start/end of the\n\t// arrow, and seeing where the label intersects with the arrow. Then, if we move the label's\n\t// center to that point, that'll be the start/end of the range.\n\n\tlet startBox, endBox\n\tif (info.type === 'elbow') {\n\t\t// for elbow arrows, because they have multiple segments but are always axis-aligned, we can use\n\t\t// an expanded box. This helps keep the box from partially covering the first segment when it's\n\t\t// very small.\n\t\tdbgPoints.push(info.start.point, info.end.point)\n\t\tstartBox = Box.FromCenter(info.start.point, labelSize).expandBy(labelToArrowPadding)\n\t\tendBox = Box.FromCenter(info.end.point, labelSize).expandBy(labelToArrowPadding)\n\t} else {\n\t\t// for other arrows, we move along the arrow by the padding amount to find the start/end points\n\t\tconst startPoint = bodyGeom.interpolateAlongEdge(paddingRelative)\n\t\tconst endPoint = bodyGeom.interpolateAlongEdge(1 - paddingRelative)\n\t\tdbgPoints.push(startPoint, endPoint)\n\t\tstartBox = Box.FromCenter(startPoint, labelSize)\n\t\tendBox = Box.FromCenter(endPoint, labelSize)\n\t}\n\tconst startIntersections = bodyGeom.intersectPolygon(startBox.corners)\n\tconst endIntersections = bodyGeom.intersectPolygon(endBox.corners)\n\n\tconst startConstrained = furthest(info.start.point, startIntersections)\n\tconst endConstrained = furthest(info.end.point, endIntersections)\n\n\tlet startRelative = startConstrained ? bodyGeom.uninterpolateAlongEdge(startConstrained) : 0.5\n\tlet endRelative = endConstrained ? bodyGeom.uninterpolateAlongEdge(endConstrained) : 0.5\n\n\tif (startRelative > endRelative) {\n\t\tstartRelative = 0.5\n\t\tendRelative = 0.5\n\t}\n\n\tfor (const pt of [...startIntersections, ...endIntersections, ...dbgPoints]) {\n\t\tdbg.push(\n\t\t\tnew Circle2d({\n\t\t\t\tx: pt.x - 3,\n\t\t\t\ty: pt.y - 3,\n\t\t\t\tradius: 3,\n\t\t\t\tisFilled: false,\n\t\t\t\tdebugColor: 'magenta',\n\t\t\t\tignore: true,\n\t\t\t})\n\t\t)\n\t}\n\tdbg.push(\n\t\tnew Polygon2d({\n\t\t\tpoints: startBox.corners,\n\t\t\tdebugColor: 'lime',\n\t\t\tisFilled: false,\n\t\t\tignore: true,\n\t\t}),\n\t\tnew Polygon2d({\n\t\t\tpoints: endBox.corners,\n\t\t\tdebugColor: 'lime',\n\t\t\tisFilled: false,\n\t\t\tignore: true,\n\t\t})\n\t)\n\n\treturn { start: startRelative, end: endRelative, dbg }\n}\n\ninterface ArrowheadInfo {\n\thasStartBinding: boolean\n\thasEndBinding: boolean\n\thasStartArrowhead: boolean\n\thasEndArrowhead: boolean\n}\nexport function getArrowLabelPosition(editor: Editor, shape: TLArrowShape) {\n\tconst debugGeom: Geometry2d[] = []\n\tconst info = getArrowInfo(editor, shape)!\n\n\tconst arrowheadInfo: ArrowheadInfo = {\n\t\thasStartBinding: !!info.bindings.start,\n\t\thasEndBinding: !!info.bindings.end,\n\t\thasStartArrowhead: info.start.arrowhead !== 'none',\n\t\thasEndArrowhead: info.end.arrowhead !== 'none',\n\t}\n\n\tconst range = getArrowLabelRange(editor, shape, info)\n\tif (range.dbg) debugGeom.push(...range.dbg)\n\n\tconst clampedPosition = getClampedPosition(shape, range, arrowheadInfo)\n\tconst bodyGeom = getArrowBodyGeometry(editor, shape)\n\tconst labelCenter = bodyGeom.interpolateAlongEdge(clampedPosition)\n\tconst labelSize = getArrowLabelSize(editor, shape)\n\n\treturn { box: Box.FromCenter(labelCenter, labelSize), debugGeom }\n}\n\nfunction getClampedPosition(\n\tshape: TLArrowShape,\n\trange: { start: number; end: number },\n\tarrowheadInfo: ArrowheadInfo\n) {\n\tconst { hasEndArrowhead, hasEndBinding, hasStartBinding, hasStartArrowhead } = arrowheadInfo\n\tconst clampedPosition = clamp(\n\t\tshape.props.labelPosition,\n\t\thasStartArrowhead || hasStartBinding ? range.start : 0,\n\t\thasEndArrowhead || hasEndBinding ? range.end : 1\n\t)\n\n\treturn clampedPosition\n}\n\nfunction furthest(from: VecLike, candidates: VecLike[]): VecLike | null {\n\tlet furthest: VecLike | null = null\n\tlet furthestDist = -Infinity\n\n\tfor (const candidate of candidates) {\n\t\tconst dist = Vec.Dist2(from, candidate)\n\t\tif (dist > furthestDist) {\n\t\t\tfurthest = candidate\n\t\t\tfurthestDist = dist\n\t\t}\n\t}\n\n\treturn furthest\n}\n\nexport function getArrowLabelFontSize(shape: TLArrowShape) {\n\treturn ARROW_LABEL_FONT_SIZES[shape.props.size] * shape.props.scale\n}\n\nexport function getArrowLabelDefaultPosition(editor: Editor, shape: TLArrowShape) {\n\tconst info = getArrowInfo(editor, shape)!\n\tswitch (info.type) {\n\t\tcase 'straight':\n\t\tcase 'arc':\n\t\t\treturn 0.5\n\t\tcase 'elbow': {\n\t\t\tconst midpointHandle = info.route.midpointHandle\n\t\t\tconst bodyGeom = getArrowBodyGeometry(editor, shape)\n\t\t\tif (midpointHandle && bodyGeom) {\n\t\t\t\treturn bodyGeom.uninterpolateAlongEdge(midpointHandle.point)\n\t\t\t}\n\t\t\treturn 0.5\n\t\t}\n\t\tdefault:\n\t\t\texhaustiveSwitchError(info, 'type')\n\t}\n}\n"],"names":["furthest"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7545, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/arrow/arrowheads.ts"],"sourcesContent":["import {\n\tHALF_PI,\n\tPI,\n\tVec,\n\tVecLike,\n\tclamp,\n\texhaustiveSwitchError,\n\tintersectCircleCircle,\n} from '@tldraw/editor'\nimport { TLArrowInfo } from './arrow-types'\n\ninterface TLArrowPointsInfo {\n\tpoint: VecLike\n\tint: VecLike\n}\n\nfunction getArrowPoints(\n\tinfo: TLArrowInfo,\n\tside: 'start' | 'end',\n\tstrokeWidth: number\n): TLArrowPointsInfo {\n\tconst point = side === 'end' ? info.end.point : info.start.point\n\tlet int: VecLike\n\n\tswitch (info.type) {\n\t\tcase 'straight': {\n\t\t\tconst opposite = side === 'end' ? info.start.point : info.end.point\n\t\t\tconst compareLength = Vec.Dist(opposite, point)\n\t\t\tconst length = clamp(compareLength / 5, strokeWidth, strokeWidth * 3)\n\t\t\tint = Vec.Nudge(point, opposite, length)\n\t\t\tbreak\n\t\t}\n\t\tcase 'arc': {\n\t\t\tconst compareLength = Math.abs(info.bodyArc.length)\n\t\t\tconst length = clamp(compareLength / 5, strokeWidth, strokeWidth * 3)\n\t\t\tconst intersections = intersectCircleCircle(\n\t\t\t\tpoint,\n\t\t\t\tlength,\n\t\t\t\tinfo.handleArc.center,\n\t\t\t\tinfo.handleArc.radius\n\t\t\t)\n\t\t\tint =\n\t\t\t\tside === 'end'\n\t\t\t\t\t? info.handleArc.sweepFlag\n\t\t\t\t\t\t? intersections[0]\n\t\t\t\t\t\t: intersections[1]\n\t\t\t\t\t: info.handleArc.sweepFlag\n\t\t\t\t\t\t? intersections[1]\n\t\t\t\t\t\t: intersections[0]\n\t\t\tbreak\n\t\t}\n\t\tcase 'elbow': {\n\t\t\tconst previousPoint =\n\t\t\t\tside === 'end' ? info.route.points[info.route.points.length - 2] : info.route.points[1]\n\t\t\tconst previousSegmentLength = Vec.ManhattanDist(previousPoint, point)\n\t\t\tconst length = clamp(previousSegmentLength / 2, strokeWidth, strokeWidth * 3)\n\t\t\tint = previousPoint ? Vec.Nudge(point, previousPoint, length) : point\n\t\t\tbreak\n\t\t}\n\t\tdefault:\n\t\t\texhaustiveSwitchError(info, 'type')\n\t}\n\n\tif (Vec.IsNaN(int)) {\n\t\tint = point\n\t}\n\n\treturn { point, int }\n}\n\nfunction getArrowhead({ point, int }: TLArrowPointsInfo) {\n\tconst PL = Vec.RotWith(int, point, PI / 6)\n\tconst PR = Vec.RotWith(int, point, -PI / 6)\n\n\treturn `M ${PL.x} ${PL.y} L ${point.x} ${point.y} L ${PR.x} ${PR.y}`\n}\n\nfunction getTriangleHead({ point, int }: TLArrowPointsInfo) {\n\tconst PL = Vec.RotWith(int, point, PI / 6)\n\tconst PR = Vec.RotWith(int, point, -PI / 6)\n\n\treturn `M ${PL.x} ${PL.y} L ${PR.x} ${PR.y} L ${point.x} ${point.y} Z`\n}\n\nfunction getInvertedTriangleHead({ point, int }: TLArrowPointsInfo) {\n\tconst d = Vec.Sub(int, point).div(2)\n\tconst PL = Vec.Add(point, Vec.Rot(d, HALF_PI))\n\tconst PR = Vec.Sub(point, Vec.Rot(d, HALF_PI))\n\n\treturn `M ${PL.x} ${PL.y} L ${int.x} ${int.y} L ${PR.x} ${PR.y} Z`\n}\n\nfunction getDotHead({ point, int }: TLArrowPointsInfo) {\n\tconst A = Vec.Lrp(point, int, 0.45)\n\tconst r = Vec.Dist(A, point)\n\n\treturn `M ${A.x - r},${A.y}\n  a ${r},${r} 0 1,0 ${r * 2},0\n  a ${r},${r} 0 1,0 -${r * 2},0 `\n}\n\nfunction getDiamondHead({ point, int }: TLArrowPointsInfo) {\n\tconst PB = Vec.Lrp(point, int, 0.75)\n\tconst PL = Vec.RotWith(PB, point, PI / 4)\n\tconst PR = Vec.RotWith(PB, point, -PI / 4)\n\n\tconst PQ = Vec.Lrp(PL, PR, 0.5)\n\tPQ.add(Vec.Sub(PQ, point))\n\n\treturn `M ${PQ.x} ${PQ.y} L ${PR.x} ${PR.y} ${point.x} ${point.y} L ${PL.x} ${PL.y} Z`\n}\n\nfunction getSquareHead({ int, point }: TLArrowPointsInfo) {\n\tconst PB = Vec.Lrp(point, int, 0.85)\n\tconst d = Vec.Sub(PB, point).div(2)\n\tconst PL1 = Vec.Add(point, Vec.Rot(d, HALF_PI))\n\tconst PR1 = Vec.Sub(point, Vec.Rot(d, HALF_PI))\n\tconst PL2 = Vec.Add(PB, Vec.Rot(d, HALF_PI))\n\tconst PR2 = Vec.Sub(PB, Vec.Rot(d, HALF_PI))\n\n\treturn `M ${PL1.x} ${PL1.y} L ${PL2.x} ${PL2.y} L ${PR2.x} ${PR2.y} L ${PR1.x} ${PR1.y} Z`\n}\n\nfunction getBarHead({ int, point }: TLArrowPointsInfo) {\n\tconst d = Vec.Sub(int, point).div(2)\n\n\tconst PL = Vec.Add(point, Vec.Rot(d, HALF_PI))\n\tconst PR = Vec.Sub(point, Vec.Rot(d, HALF_PI))\n\n\treturn `M ${PL.x} ${PL.y} L ${PR.x} ${PR.y}`\n}\n\n/** @public */\nexport function getArrowheadPathForType(\n\tinfo: TLArrowInfo,\n\tside: 'start' | 'end',\n\tstrokeWidth: number\n): string | undefined {\n\tconst type = side === 'end' ? info.end.arrowhead : info.start.arrowhead\n\tif (type === 'none') return\n\n\tconst points = getArrowPoints(info, side, strokeWidth)\n\tif (!points) return\n\n\tswitch (type) {\n\t\tcase 'bar':\n\t\t\treturn getBarHead(points)\n\t\tcase 'square':\n\t\t\treturn getSquareHead(points)\n\t\tcase 'diamond':\n\t\t\treturn getDiamondHead(points)\n\t\tcase 'dot':\n\t\t\treturn getDotHead(points)\n\t\tcase 'inverted':\n\t\t\treturn getInvertedTriangleHead(points)\n\t\tcase 'arrow':\n\t\t\treturn getArrowhead(points)\n\t\tcase 'triangle':\n\t\t\treturn getTriangleHead(points)\n\t}\n\n\treturn ''\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7672, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/arrow/elbow/ElbowArrowDebug.tsx"],"sourcesContent":["import { Box, TLArrowShape, useEditor, useValue, VecLike } from '@tldraw/editor'\nimport { SVGProps } from 'react'\nimport { getArrowBindings } from '../shared'\nimport { ElbowArrowEdge } from './definitions'\nimport { getElbowArrowInfo } from './getElbowArrowInfo'\n\nexport function ElbowArrowDebug({ arrow }: { arrow: TLArrowShape }) {\n\tconst editor = useEditor()\n\tconst info = useValue(\n\t\t'elbow arrow grid',\n\t\t() => {\n\t\t\ttry {\n\t\t\t\tconst info = getElbowArrowInfo(\n\t\t\t\t\teditor,\n\t\t\t\t\teditor.getShape(arrow.id)!,\n\t\t\t\t\tgetArrowBindings(editor, arrow)\n\t\t\t\t)\n\t\t\t\treturn info\n\t\t\t} catch (err) {\n\t\t\t\tconsole.error(err)\n\t\t\t\treturn undefined\n\t\t\t}\n\t\t},\n\t\t[editor, arrow.id]\n\t)\n\n\tif (!info) return null\n\n\tconst fullBox = Box.Common([info.A.original, info.B.original]).expandBy(50)\n\n\tconst label = info.route?.name ?? ''\n\n\tconst midPoint = info.route?.midpointHandle\n\n\treturn (\n\t\t<>\n\t\t\t{info.midX !== null && (\n\t\t\t\t<DebugLine\n\t\t\t\t\ta={{ x: info.midX, y: fullBox.minY }}\n\t\t\t\t\tb={{ x: info.midX, y: fullBox.maxY }}\n\t\t\t\t\tstroke=\"red\"\n\t\t\t\t/>\n\t\t\t)}\n\t\t\t{info.midY !== null && (\n\t\t\t\t<DebugLine\n\t\t\t\t\ta={{ x: fullBox.minX, y: info.midY }}\n\t\t\t\t\tb={{ x: fullBox.maxX, y: info.midY }}\n\t\t\t\t\tstroke=\"blue\"\n\t\t\t\t/>\n\t\t\t)}\n\n\t\t\t{midPoint?.axis === 'x' && info.midXRange && (\n\t\t\t\t<DebugLine\n\t\t\t\t\ta={{ x: info.midXRange.lo, y: midPoint.point.y }}\n\t\t\t\t\tb={{ x: info.midXRange.hi, y: midPoint.point.y }}\n\t\t\t\t\tstroke=\"red\"\n\t\t\t\t\tstrokeDasharray={'0 2'}\n\t\t\t\t/>\n\t\t\t)}\n\n\t\t\t{midPoint?.axis === 'y' && info.midYRange && (\n\t\t\t\t<DebugLine\n\t\t\t\t\ta={{ x: midPoint.point.x, y: info.midYRange.lo }}\n\t\t\t\t\tb={{ x: midPoint.point.x, y: info.midYRange.hi }}\n\t\t\t\t\tstroke=\"blue\"\n\t\t\t\t\tstrokeDasharray={'0 2'}\n\t\t\t\t/>\n\t\t\t)}\n\n\t\t\t<DebugBox box={info.A.original} stroke=\"orange\" />\n\t\t\t<DebugBox box={info.A.expanded} stroke=\"orange\" strokeWidth={0.5} />\n\t\t\t<DebugBox\n\t\t\t\tbox={info.A.original.clone().expandBy(info.options.minElbowLegLength)}\n\t\t\t\tstroke=\"orange\"\n\t\t\t\tstrokeWidth={0.5}\n\t\t\t/>\n\t\t\t<DebugBox box={info.B.original} stroke=\"lightskyblue\" />\n\t\t\t<DebugBox box={info.B.expanded} stroke=\"lightskyblue\" strokeWidth={0.5} />\n\t\t\t<DebugBox\n\t\t\t\tbox={info.B.original.clone().expandBy(info.options.minElbowLegLength)}\n\t\t\t\tstroke=\"lightskyblue\"\n\t\t\t\tstrokeWidth={0.5}\n\t\t\t/>\n\n\t\t\t<DebugEdge edge={info.A.edges.top} axis=\"x\" stroke=\"orange\" />\n\t\t\t<DebugEdge edge={info.B.edges.top} axis=\"x\" stroke=\"lightskyblue\" />\n\t\t\t<DebugEdge edge={info.A.edges.right} axis=\"y\" stroke=\"orange\" />\n\t\t\t<DebugEdge edge={info.B.edges.right} axis=\"y\" stroke=\"lightskyblue\" />\n\t\t\t<DebugEdge edge={info.A.edges.bottom} axis=\"x\" stroke=\"orange\" />\n\t\t\t<DebugEdge edge={info.B.edges.bottom} axis=\"x\" stroke=\"lightskyblue\" />\n\t\t\t<DebugEdge edge={info.A.edges.left} axis=\"y\" stroke=\"orange\" />\n\t\t\t<DebugEdge edge={info.B.edges.left} axis=\"y\" stroke=\"lightskyblue\" />\n\n\t\t\t{info.route && <DebugRoute route={info.route.points} strokeWidth={10} />}\n\n\t\t\t<text\n\t\t\t\tx={fullBox.minX + 5}\n\t\t\t\ty={fullBox.minY - 3}\n\t\t\t\tfontSize={10}\n\t\t\t\tfill=\"black\"\n\t\t\t\tstroke=\"var(--color-background)\"\n\t\t\t\tstrokeWidth={2}\n\t\t\t\tpaintOrder=\"stroke\"\n\t\t\t>\n\t\t\t\t{label}\n\t\t\t</text>\n\t\t\t<text\n\t\t\t\tx={info.A.expanded.x}\n\t\t\t\ty={info.A.expanded.y}\n\t\t\t\tfontSize={10}\n\t\t\t\tfill=\"black\"\n\t\t\t\tstroke=\"var(--color-background)\"\n\t\t\t\tstrokeWidth={2}\n\t\t\t\tpaintOrder=\"stroke\"\n\t\t\t>\n\t\t\t\tA{info.route && `, ${info.route.aEdgePicking}`}\n\t\t\t\t{info.A.isPoint && `, point`}\n\t\t\t</text>\n\t\t\t<text\n\t\t\t\tx={info.B.expanded.x}\n\t\t\t\ty={info.B.expanded.y}\n\t\t\t\tfontSize={10}\n\t\t\t\tfill=\"black\"\n\t\t\t\tstroke=\"var(--color-background)\"\n\t\t\t\tstrokeWidth={2}\n\t\t\t\tpaintOrder=\"stroke\"\n\t\t\t>\n\t\t\t\tB{info.route && `, ${info.route.bEdgePicking}`}\n\t\t\t\t{info.B.isPoint && `, point`}\n\t\t\t</text>\n\t\t</>\n\t)\n}\n\nfunction DebugLine({ a, b, ...props }: { a: VecLike; b: VecLike } & SVGProps<SVGLineElement>) {\n\treturn (\n\t\t<line\n\t\t\tfill=\"none\"\n\t\t\tstrokeWidth={1}\n\t\t\tstrokeDasharray=\"4,4\"\n\t\t\tstroke=\"green\"\n\t\t\tx1={a.x}\n\t\t\ty1={a.y}\n\t\t\tx2={b.x}\n\t\t\ty2={b.y}\n\t\t\t{...props}\n\t\t/>\n\t)\n}\n\nfunction DebugRoute({ route, ...props }: { route: VecLike[] } & SVGProps<SVGPolylineElement>) {\n\treturn (\n\t\t<polyline\n\t\t\tfill=\"none\"\n\t\t\tstroke=\"darkorchid\"\n\t\t\tstrokeWidth={3}\n\t\t\topacity={0.5}\n\t\t\tpoints={route.map((r) => `${r.x},${r.y}`).join(' ')}\n\t\t\t{...props}\n\t\t/>\n\t)\n}\n\nfunction DebugEdge({\n\tedge,\n\taxis,\n\t...props\n}: {\n\tedge: ElbowArrowEdge | null\n\taxis: 'x' | 'y'\n} & Omit<SVGProps<SVGLineElement>, 'scale'>) {\n\tif (!edge || edge.expanded === null) return null\n\tconst vec = (vec: VecLike) => (axis === 'x' ? { x: vec.y, y: vec.x } : vec)\n\n\treturn (\n\t\t<g>\n\t\t\t<DebugLine\n\t\t\t\ta={vec({ x: edge.expanded, y: edge.cross.min })}\n\t\t\t\tb={vec({ x: edge.expanded, y: edge.cross.max })}\n\t\t\t\tstrokeDasharray=\"0\"\n\t\t\t\tstrokeWidth={1.5}\n\t\t\t\t{...props}\n\t\t\t/>\n\t\t\t<DebugLine\n\t\t\t\ta={vec({ x: edge.expanded - 4, y: edge.cross.min })}\n\t\t\t\tb={vec({ x: edge.expanded + 4, y: edge.cross.min })}\n\t\t\t\tstrokeDasharray=\"0\"\n\t\t\t\tstrokeWidth={1.5}\n\t\t\t\t{...props}\n\t\t\t/>\n\t\t\t<DebugLine\n\t\t\t\ta={vec({ x: edge.expanded - 4, y: edge.cross.max })}\n\t\t\t\tb={vec({ x: edge.expanded + 4, y: edge.cross.max })}\n\t\t\t\tstrokeDasharray=\"0\"\n\t\t\t\tstrokeWidth={1.5}\n\t\t\t\t{...props}\n\t\t\t/>\n\t\t</g>\n\t)\n}\n\nfunction DebugBox({ box, ...props }: { box: Box } & SVGProps<SVGRectElement>) {\n\treturn (\n\t\t<rect\n\t\t\tx={box.minX}\n\t\t\ty={box.minY}\n\t\t\twidth={box.width}\n\t\t\theight={box.height}\n\t\t\tstrokeDasharray=\"4,4\"\n\t\t\tstrokeWidth={1}\n\t\t\tfill=\"none\"\n\t\t\t{...props}\n\t\t/>\n\t)\n}\n"],"names":["info","vec"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7963, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/arrow/elbow/elbowArrowSnapLines.tsx"],"sourcesContent":["import {\n\tcomputed,\n\tComputed,\n\tEditor,\n\tTLArrowShape,\n\tTLShapeId,\n\tVec,\n\tVecLike,\n\tWeakCache,\n} from '@tldraw/editor'\nimport { getArrowBindings } from '../shared'\n\n/**\n * A snap line for an elbow arrow segment.\n *\n * This should already belong to ElbowArrowSnapLines establishing an angle of the line.\n */\ninterface ElbowArrowSnapLine {\n\t/** The id of the shape that the snap line starts from. */\n\tstartBoundShapeId: TLShapeId | undefined\n\t/** The id of the shape that the snap line ends at. */\n\tendBoundShapeId: TLShapeId | undefined\n\t/** The perpendicular distance from the snap line to the origin. */\n\tperpDistance: number\n}\n\n/**\n * A map from an angle (0-Ï) to a set of snap lines. Snap lines are stored in page space. They're\n * modelled as an angle (the angle of the line itself) and a perpendicular signed distance from the\n * page origin. Each line is effectively infinite in length, but modelling them in this way makes it\n * pretty efficient for us to query for relevant snap lines.\n */\ntype ElbowArrowSnapLines = Map<number, Set<ElbowArrowSnapLine>>\n\nconst snapLinesStore = new WeakCache<Editor, Computed<ElbowArrowSnapLines>>()\n\nexport function getElbowArrowSnapLines(editor: Editor) {\n\treturn snapLinesStore\n\t\t.get(editor, (editor) => {\n\t\t\tconst currentSelectedArrowShape = computed('current selected arrow shape', () => {\n\t\t\t\tconst shape = editor.getOnlySelectedShape()\n\t\t\t\tif (!shape || !editor.isShapeOfType<TLArrowShape>(shape, 'arrow')) return null\n\t\t\t\treturn shape.id\n\t\t\t})\n\n\t\t\tconst unselectedArrowShapeIds = editor.store.query.ids('shape', () => {\n\t\t\t\tconst activeArrowShapeId = currentSelectedArrowShape.get()\n\t\t\t\tif (!activeArrowShapeId) return { type: { eq: 'arrow' } }\n\t\t\t\treturn {\n\t\t\t\t\ttype: { eq: 'arrow' },\n\t\t\t\t\tid: { neq: activeArrowShapeId },\n\t\t\t\t}\n\t\t\t})\n\n\t\t\treturn computed('elbow arrow snap lines', () => {\n\t\t\t\t// the result is a map from angle (0-Ï), to a set of single-axis co-ordinates. For\n\t\t\t\t// example, if a line from (0, 1) to (1, 1) is found (ie a horizontal line at y-coord 1),\n\t\t\t\t// we'll add an entry to the map with the key 0 (horizontal), and the set containing 1.\n\t\t\t\tconst result = new Map<number, Set<ElbowArrowSnapLine>>()\n\n\t\t\t\tconst currentPageShapeIds = editor.getCurrentPageShapeIds()\n\t\t\t\tconst viewportBounds = editor.getViewportPageBounds()\n\n\t\t\t\tfor (const id of unselectedArrowShapeIds.get()) {\n\t\t\t\t\tif (!currentPageShapeIds.has(id)) continue\n\n\t\t\t\t\tconst shape = editor.getShape<TLArrowShape>(id)\n\t\t\t\t\tif (shape?.type !== 'arrow') continue\n\n\t\t\t\t\tconst shapeBounds = editor.getShapePageBounds(id)\n\t\t\t\t\tif (!shapeBounds || !viewportBounds.includes(shapeBounds)) continue\n\n\t\t\t\t\tconst bindings = getArrowBindings(editor, shape)\n\t\t\t\t\tconst pageTransform = editor.getShapePageTransform(id)\n\t\t\t\t\tif (!pageTransform) continue\n\n\t\t\t\t\tconst geometry = editor.getShapeGeometry(id)\n\n\t\t\t\t\tconst pageVertices = pageTransform.applyToPoints(geometry.vertices)\n\n\t\t\t\t\tfor (let i = 1; i < pageVertices.length; i++) {\n\t\t\t\t\t\tconst prev = pageVertices[i - 1]\n\t\t\t\t\t\tconst curr = pageVertices[i]\n\n\t\t\t\t\t\tlet angle = Vec.Angle(prev, curr)\n\n\t\t\t\t\t\t// we don't care if the angle is going \"up\" or \"down\" - so we only care\n\t\t\t\t\t\t// about the 0-Ï range\n\t\t\t\t\t\tif (angle < 0) angle += Math.PI\n\n\t\t\t\t\t\tlet set = result.get(angle)\n\t\t\t\t\t\tif (!set) {\n\t\t\t\t\t\t\tset = new Set()\n\t\t\t\t\t\t\tresult.set(angle, set)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst perpDistance = perpDistanceToLineAngle(prev, angle)\n\n\t\t\t\t\t\tset.add({\n\t\t\t\t\t\t\tperpDistance,\n\t\t\t\t\t\t\tstartBoundShapeId: bindings.start?.toId,\n\t\t\t\t\t\t\tendBoundShapeId: bindings.end?.toId,\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn result\n\t\t\t})\n\t\t})\n\t\t.get()\n}\n\n/**\n * Return the signed distance from the origin to a point on a line of angle `lineAngle` that passes\n * through the point `pointOnLine`.\n */\nexport function perpDistanceToLineAngle(pointOnLine: VecLike, lineAngle: number): number {\n\t// The perpendicular unit vector to the line direction\n\tconst perpDir = Vec.FromAngle(lineAngle).per()\n\t// Project the point onto the perpendicular vector\n\treturn Vec.Dpr(pointOnLine, perpDir)\n}\n\n/**\n * Return the signed distance from the origin to the line segment defined by `A` and `B`.\n */\nexport function perpDistanceToLine(A: VecLike, B: VecLike): number {\n\treturn perpDistanceToLineAngle(A, Vec.Angle(A, B))\n}\n"],"names":["editor"],"mappings":";;;;;AAAA;;;;AAUA,SAAS,wBAAwB;;;AAwBjC,MAAM,iBAAiB,yKAAI,YAAA,CAAiD;AAErE,SAAS,uBAAuB,MAAA,EAAgB;IACtD,OAAO,eACL,GAAA,CAAI,QAAQ,CAACA,YAAW;QACxB,MAAM,uMAA4B,YAAA,EAAS,gCAAgC,MAAM;YAChF,MAAM,QAAQA,QAAO,oBAAA,CAAqB;YAC1C,IAAI,CAAC,SAAS,CAACA,QAAO,aAAA,CAA4B,OAAO,OAAO,EAAG,CAAA,OAAO;YAC1E,OAAO,MAAM,EAAA;QACd,CAAC;QAED,MAAM,0BAA0BA,QAAO,KAAA,CAAM,KAAA,CAAM,GAAA,CAAI,SAAS,MAAM;YACrE,MAAM,qBAAqB,0BAA0B,GAAA,CAAI;YACzD,IAAI,CAAC,mBAAoB,CAAA,OAAO;gBAAE,MAAM;oBAAE,IAAI;gBAAQ;YAAE;YACxD,OAAO;gBACN,MAAM;oBAAE,IAAI;gBAAQ;gBACpB,IAAI;oBAAE,KAAK;gBAAmB;YAC/B;QACD,CAAC;QAED,QAAO,sLAAA,EAAS,0BAA0B,MAAM;YAI/C,MAAM,SAAS,aAAA,GAAA,IAAI,IAAqC;YAExD,MAAM,sBAAsBA,QAAO,sBAAA,CAAuB;YAC1D,MAAM,iBAAiBA,QAAO,qBAAA,CAAsB;YAEpD,KAAA,MAAW,MAAM,wBAAwB,GAAA,CAAI,EAAG;gBAC/C,IAAI,CAAC,oBAAoB,GAAA,CAAI,EAAE,EAAG,CAAA;gBAElC,MAAM,QAAQA,QAAO,QAAA,CAAuB,EAAE;gBAC9C,IAAI,OAAO,SAAS,QAAS,CAAA;gBAE7B,MAAM,cAAcA,QAAO,kBAAA,CAAmB,EAAE;gBAChD,IAAI,CAAC,eAAe,CAAC,eAAe,QAAA,CAAS,WAAW,EAAG,CAAA;gBAE3D,MAAM,WAAW,qMAAA,EAAiBA,SAAQ,KAAK;gBAC/C,MAAM,gBAAgBA,QAAO,qBAAA,CAAsB,EAAE;gBACrD,IAAI,CAAC,cAAe,CAAA;gBAEpB,MAAM,WAAWA,QAAO,gBAAA,CAAiB,EAAE;gBAE3C,MAAM,eAAe,cAAc,aAAA,CAAc,SAAS,QAAQ;gBAElE,IAAA,IAAS,IAAI,GAAG,IAAI,aAAa,MAAA,EAAQ,IAAK;oBAC7C,MAAM,OAAO,YAAA,CAAa,IAAI,CAAC,CAAA;oBAC/B,MAAM,OAAO,YAAA,CAAa,CAAC,CAAA;oBAE3B,IAAI,0LAAQ,MAAA,CAAI,KAAA,CAAM,MAAM,IAAI;oBAIhC,IAAI,QAAQ,EAAG,CAAA,SAAS,KAAK,EAAA;oBAE7B,IAAI,MAAM,OAAO,GAAA,CAAI,KAAK;oBAC1B,IAAI,CAAC,KAAK;wBACT,MAAM,aAAA,GAAA,IAAI,IAAI;wBACd,OAAO,GAAA,CAAI,OAAO,GAAG;oBACtB;oBAEA,MAAM,eAAe,wBAAwB,MAAM,KAAK;oBAExD,IAAI,GAAA,CAAI;wBACP;wBACA,mBAAmB,SAAS,KAAA,EAAO;wBACnC,iBAAiB,SAAS,GAAA,EAAK;oBAChC,CAAC;gBACF;YACD;YAEA,OAAO;QACR,CAAC;IACF,CAAC,EACA,GAAA,CAAI;AACP;AAMO,SAAS,wBAAwB,WAAA,EAAsB,SAAA,EAA2B;IAExF,MAAM,4LAAU,MAAA,CAAI,SAAA,CAAU,SAAS,EAAE,GAAA,CAAI;IAE7C,yLAAO,MAAA,CAAI,GAAA,CAAI,aAAa,OAAO;AACpC;AAKO,SAAS,mBAAmB,CAAA,EAAY,CAAA,EAAoB;IAClE,OAAO,wBAAwB,qLAAG,MAAA,CAAI,KAAA,CAAM,GAAG,CAAC,CAAC;AAClD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8051, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx"],"sourcesContent":["import {\n\tArc2d,\n\tBox,\n\tEMPTY_ARRAY,\n\tEdge2d,\n\tEditor,\n\tGeometry2d,\n\tGroup2d,\n\tIndexKey,\n\tPI2,\n\tPolyline2d,\n\tRectangle2d,\n\tSVGContainer,\n\tShapeUtil,\n\tSvgExportContext,\n\tTLArrowBinding,\n\tTLArrowBindingProps,\n\tTLArrowShape,\n\tTLArrowShapeProps,\n\tTLHandle,\n\tTLHandleDragInfo,\n\tTLResizeInfo,\n\tTLShapePartial,\n\tTLShapeUtilCanBeLaidOutOpts,\n\tTLShapeUtilCanBindOpts,\n\tTLShapeUtilCanvasSvgDef,\n\tVec,\n\tWeakCache,\n\tarrowShapeMigrations,\n\tarrowShapeProps,\n\tclamp,\n\tdebugFlags,\n\texhaustiveSwitchError,\n\tgetDefaultColorTheme,\n\tinvLerp,\n\tlerp,\n\tmapObjectMapValues,\n\tmaybeSnapToGrid,\n\tstructuredClone,\n\ttoDomPrecision,\n\ttrack,\n\tuseEditor,\n\tuseIsEditing,\n\tuseSharedSafeId,\n\tuseValue,\n} from '@tldraw/editor'\nimport React, { useMemo } from 'react'\nimport { updateArrowTerminal } from '../../bindings/arrow/ArrowBindingUtil'\nimport { PathBuilder } from '../shared/PathBuilder'\nimport { PlainTextLabel } from '../shared/PlainTextLabel'\nimport { ShapeFill } from '../shared/ShapeFill'\nimport { SvgTextLabel } from '../shared/SvgTextLabel'\nimport { ARROW_LABEL_PADDING, STROKE_SIZES, TEXT_PROPS } from '../shared/default-shape-constants'\nimport { DefaultFontFaces } from '../shared/defaultFonts'\nimport { getFillDefForCanvas, getFillDefForExport } from '../shared/defaultStyleDefs'\nimport { useDefaultColorTheme } from '../shared/useDefaultColorTheme'\nimport { getArrowBodyPath, getArrowHandlePath } from './ArrowPath'\nimport { ArrowShapeOptions } from './arrow-types'\nimport {\n\tgetArrowLabelDefaultPosition,\n\tgetArrowLabelFontSize,\n\tgetArrowLabelPosition,\n} from './arrowLabel'\nimport { updateArrowTargetState } from './arrowTargetState'\nimport { getArrowheadPathForType } from './arrowheads'\nimport { ElbowArrowDebug } from './elbow/ElbowArrowDebug'\nimport { ElbowArrowAxes } from './elbow/definitions'\nimport { getElbowArrowSnapLines, perpDistanceToLineAngle } from './elbow/elbowArrowSnapLines'\nimport {\n\tTLArrowBindings,\n\tcreateOrUpdateArrowBinding,\n\tgetArrowBindings,\n\tgetArrowInfo,\n\tgetArrowTerminalsInArrowSpace,\n\tremoveArrowBinding,\n} from './shared'\n\nenum ArrowHandles {\n\tStart = 'start',\n\tMiddle = 'middle',\n\tEnd = 'end',\n}\n\n/** @public */\nexport class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {\n\tstatic override type = 'arrow' as const\n\tstatic override props = arrowShapeProps\n\tstatic override migrations = arrowShapeMigrations\n\n\toverride options: ArrowShapeOptions = {\n\t\texpandElbowLegLength: {\n\t\t\ts: 28,\n\t\t\tm: 36,\n\t\t\tl: 44,\n\t\t\txl: 66,\n\t\t},\n\t\tminElbowLegLength: {\n\t\t\ts: STROKE_SIZES.s * 3,\n\t\t\tm: STROKE_SIZES.m * 3,\n\t\t\tl: STROKE_SIZES.l * 3,\n\t\t\txl: STROKE_SIZES.xl * 3,\n\t\t},\n\t\tminElbowHandleDistance: 16,\n\n\t\tarcArrowCenterSnapDistance: 16,\n\t\telbowArrowCenterSnapDistance: 24,\n\t\telbowArrowEdgeSnapDistance: 20,\n\t\telbowArrowPointSnapDistance: 24,\n\t\telbowArrowAxisSnapDistance: 16,\n\n\t\tlabelCenterSnapDistance: 10,\n\n\t\telbowMidpointSnapDistance: 10,\n\t\telbowMinSegmentLengthToShowMidpointHandle: 20,\n\n\t\thoverPreciseTimeout: 600,\n\t\tpointingPreciseTimeout: 320,\n\n\t\tshouldBeExact: (editor: Editor) => editor.inputs.altKey,\n\t\tshouldIgnoreTargets: (editor: Editor) => editor.inputs.ctrlKey,\n\t}\n\n\toverride canEdit() {\n\t\treturn true\n\t}\n\toverride canBind({ toShapeType }: TLShapeUtilCanBindOpts<TLArrowShape>): boolean {\n\t\t// bindings can go from arrows to shapes, but not from shapes to arrows\n\t\treturn toShapeType !== 'arrow'\n\t}\n\toverride canSnap() {\n\t\treturn false\n\t}\n\toverride hideResizeHandles() {\n\t\treturn true\n\t}\n\toverride hideRotateHandle() {\n\t\treturn true\n\t}\n\toverride hideSelectionBoundsBg() {\n\t\treturn true\n\t}\n\toverride hideSelectionBoundsFg() {\n\t\treturn true\n\t}\n\n\toverride canBeLaidOut(shape: TLArrowShape, info: TLShapeUtilCanBeLaidOutOpts) {\n\t\tif (info.type === 'flip') {\n\t\t\t// If we don't have this then the flip will be non-idempotent; that is, the flip will be multipotent, varipotent, or perhaps even omni-potent... and we can't have that\n\t\t\tconst bindings = getArrowBindings(this.editor, shape)\n\t\t\tconst { start, end } = bindings\n\t\t\tconst { shapes = [] } = info\n\t\t\tif (start && !shapes.find((s) => s.id === start.toId)) return false\n\t\t\tif (end && !shapes.find((s) => s.id === end.toId)) return false\n\t\t}\n\t\treturn true\n\t}\n\n\toverride getFontFaces(shape: TLArrowShape) {\n\t\tif (!shape.props.text) return EMPTY_ARRAY\n\t\treturn [DefaultFontFaces[`tldraw_${shape.props.font}`].normal.normal]\n\t}\n\n\toverride getDefaultProps(): TLArrowShape['props'] {\n\t\treturn {\n\t\t\tkind: 'arc',\n\t\t\telbowMidPoint: 0.5,\n\t\t\tdash: 'draw',\n\t\t\tsize: 'm',\n\t\t\tfill: 'none',\n\t\t\tcolor: 'black',\n\t\t\tlabelColor: 'black',\n\t\t\tbend: 0,\n\t\t\tstart: { x: 0, y: 0 },\n\t\t\tend: { x: 2, y: 0 },\n\t\t\tarrowheadStart: 'none',\n\t\t\tarrowheadEnd: 'arrow',\n\t\t\ttext: '',\n\t\t\tlabelPosition: 0.5,\n\t\t\tfont: 'draw',\n\t\t\tscale: 1,\n\t\t}\n\t}\n\n\tgetGeometry(shape: TLArrowShape) {\n\t\tconst isEditing = this.editor.getEditingShapeId() === shape.id\n\t\tconst info = getArrowInfo(this.editor, shape)!\n\n\t\tconst debugGeom: Geometry2d[] = []\n\n\t\tconst bodyGeom =\n\t\t\tinfo.type === 'straight'\n\t\t\t\t? new Edge2d({\n\t\t\t\t\t\tstart: Vec.From(info.start.point),\n\t\t\t\t\t\tend: Vec.From(info.end.point),\n\t\t\t\t\t})\n\t\t\t\t: info.type === 'arc'\n\t\t\t\t\t? new Arc2d({\n\t\t\t\t\t\t\tcenter: Vec.Cast(info.handleArc.center),\n\t\t\t\t\t\t\tstart: Vec.Cast(info.start.point),\n\t\t\t\t\t\t\tend: Vec.Cast(info.end.point),\n\t\t\t\t\t\t\tsweepFlag: info.bodyArc.sweepFlag,\n\t\t\t\t\t\t\tlargeArcFlag: info.bodyArc.largeArcFlag,\n\t\t\t\t\t\t})\n\t\t\t\t\t: new Polyline2d({ points: info.route.points })\n\n\t\tlet labelGeom\n\t\tif (isEditing || shape.props.text.trim()) {\n\t\t\tconst labelPosition = getArrowLabelPosition(this.editor, shape)\n\t\t\tif (debugFlags.debugGeometry.get()) {\n\t\t\t\tdebugGeom.push(...labelPosition.debugGeom)\n\t\t\t}\n\t\t\tlabelGeom = new Rectangle2d({\n\t\t\t\tx: labelPosition.box.x,\n\t\t\t\ty: labelPosition.box.y,\n\t\t\t\twidth: labelPosition.box.w,\n\t\t\t\theight: labelPosition.box.h,\n\t\t\t\tisFilled: true,\n\t\t\t\tisLabel: true,\n\t\t\t})\n\t\t}\n\n\t\treturn new Group2d({\n\t\t\tchildren: [...(labelGeom ? [bodyGeom, labelGeom] : [bodyGeom]), ...debugGeom],\n\t\t})\n\t}\n\n\toverride getHandles(shape: TLArrowShape): TLHandle[] {\n\t\tconst info = getArrowInfo(this.editor, shape)!\n\n\t\tconst handles: TLHandle[] = [\n\t\t\t{\n\t\t\t\tid: ArrowHandles.Start,\n\t\t\t\ttype: 'vertex',\n\t\t\t\tindex: 'a1' as IndexKey,\n\t\t\t\tx: info.start.handle.x,\n\t\t\t\ty: info.start.handle.y,\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: ArrowHandles.End,\n\t\t\t\ttype: 'vertex',\n\t\t\t\tindex: 'a3' as IndexKey,\n\t\t\t\tx: info.end.handle.x,\n\t\t\t\ty: info.end.handle.y,\n\t\t\t},\n\t\t]\n\n\t\tif (shape.props.kind === 'arc' && (info.type === 'straight' || info.type === 'arc')) {\n\t\t\thandles.push({\n\t\t\t\tid: ArrowHandles.Middle,\n\t\t\t\ttype: 'virtual',\n\t\t\t\tindex: 'a2' as IndexKey,\n\t\t\t\tx: info.middle.x,\n\t\t\t\ty: info.middle.y,\n\t\t\t})\n\t\t}\n\n\t\tif (shape.props.kind === 'elbow' && info.type === 'elbow' && info.route.midpointHandle) {\n\t\t\tconst shapePageTransform = this.editor.getShapePageTransform(shape.id)!\n\n\t\t\tconst segmentStart = shapePageTransform.applyToPoint(info.route.midpointHandle.segmentStart)\n\t\t\tconst segmentEnd = shapePageTransform.applyToPoint(info.route.midpointHandle.segmentEnd)\n\t\t\tconst segmentLength = Vec.Dist(segmentStart, segmentEnd) * this.editor.getZoomLevel()\n\n\t\t\tif (segmentLength > this.options.elbowMinSegmentLengthToShowMidpointHandle) {\n\t\t\t\thandles.push({\n\t\t\t\t\tid: ArrowHandles.Middle,\n\t\t\t\t\ttype: 'vertex',\n\t\t\t\t\tindex: 'a2' as IndexKey,\n\t\t\t\t\tx: info.route.midpointHandle.point.x,\n\t\t\t\t\ty: info.route.midpointHandle.point.y,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\treturn handles\n\t}\n\n\toverride getText(shape: TLArrowShape) {\n\t\treturn shape.props.text\n\t}\n\n\toverride onHandleDrag(shape: TLArrowShape, info: TLHandleDragInfo<TLArrowShape>) {\n\t\tconst handleId = info.handle.id as ArrowHandles\n\t\tswitch (handleId) {\n\t\t\tcase ArrowHandles.Middle:\n\t\t\t\tswitch (shape.props.kind) {\n\t\t\t\t\tcase 'arc':\n\t\t\t\t\t\treturn this.onArcMidpointHandleDrag(shape, info)\n\t\t\t\t\tcase 'elbow':\n\t\t\t\t\t\treturn this.onElbowMidpointHandleDrag(shape, info)\n\t\t\t\t\tdefault:\n\t\t\t\t\t\texhaustiveSwitchError(shape.props.kind)\n\t\t\t\t}\n\t\t\tcase ArrowHandles.Start:\n\t\t\tcase ArrowHandles.End:\n\t\t\t\treturn this.onTerminalHandleDrag(shape, info, handleId)\n\t\t\tdefault:\n\t\t\t\texhaustiveSwitchError(handleId)\n\t\t}\n\t}\n\n\tprivate onArcMidpointHandleDrag(shape: TLArrowShape, { handle }: TLHandleDragInfo<TLArrowShape>) {\n\t\tconst bindings = getArrowBindings(this.editor, shape)\n\n\t\t// Bending the arrow...\n\t\tconst { start, end } = getArrowTerminalsInArrowSpace(this.editor, shape, bindings)\n\n\t\tconst delta = Vec.Sub(end, start)\n\t\tconst v = Vec.Per(delta)\n\n\t\tconst med = Vec.Med(end, start)\n\t\tconst A = Vec.Sub(med, v)\n\t\tconst B = Vec.Add(med, v)\n\n\t\tconst point = Vec.NearestPointOnLineSegment(A, B, handle, false)\n\t\tlet bend = Vec.Dist(point, med)\n\t\tif (Vec.Clockwise(point, end, med)) bend *= -1\n\t\treturn { id: shape.id, type: shape.type, props: { bend } }\n\t}\n\n\tprivate onElbowMidpointHandleDrag(\n\t\tshape: TLArrowShape,\n\t\t{ handle }: TLHandleDragInfo<TLArrowShape>\n\t) {\n\t\tconst info = getArrowInfo(this.editor, shape)\n\t\tif (info?.type !== 'elbow') return\n\n\t\tconst shapeToPageTransform = this.editor.getShapePageTransform(shape.id)!\n\t\tconst handlePagePoint = shapeToPageTransform.applyToPoint(handle)\n\t\tconst axisName = info.route.midpointHandle?.axis\n\t\tif (!axisName) return\n\t\tconst axis = ElbowArrowAxes[axisName]\n\n\t\tconst midRange = info.elbow[axis.midRange]\n\t\tif (!midRange) return\n\n\t\t// We're snapping against a list of parallel lines. The way we do this is to calculate the\n\t\t// angle of the line we're snapping to...\n\t\tlet angle = Vec.Angle(\n\t\t\tshapeToPageTransform.applyToPoint(axis.v(0, 0)),\n\t\t\tshapeToPageTransform.applyToPoint(axis.v(0, 1))\n\t\t)\n\t\tif (angle < 0) angle += Math.PI\n\n\t\t// ...then calculate the perpendicular distance from the origin to the (infinite) line in\n\t\t// question. This returns a signed distance - lines \"behind\" the origin are negative.\n\t\tconst handlePoint = perpDistanceToLineAngle(handlePagePoint, angle)\n\n\t\t// As we're only ever moving along one dimension, we can use this perpendicular distance for\n\t\t// all of our snapping calculations.\n\t\tconst loPoint = perpDistanceToLineAngle(\n\t\t\tshapeToPageTransform.applyToPoint(axis.v(midRange.lo, 0)),\n\t\t\tangle\n\t\t)\n\t\tconst hiPoint = perpDistanceToLineAngle(\n\t\t\tshapeToPageTransform.applyToPoint(axis.v(midRange.hi, 0)),\n\t\t\tangle\n\t\t)\n\n\t\t// we want to snap to certain points. the maximum distance at which a snap will occur is\n\t\t// relative to the zoom level:\n\t\tconst maxSnapDistance = this.options.elbowMidpointSnapDistance / this.editor.getZoomLevel()\n\n\t\t// we snap to the midpoint of the range by default\n\t\tconst midPoint = perpDistanceToLineAngle(\n\t\t\tshapeToPageTransform.applyToPoint(axis.v(lerp(midRange.lo, midRange.hi, 0.5), 0)),\n\t\t\tangle\n\t\t)\n\n\t\tlet snapPoint = midPoint\n\t\tlet snapDistance = Math.abs(midPoint - handlePoint)\n\n\t\t// then we check all the other arrows that are on-screen.\n\t\tfor (const [snapAngle, snapLines] of getElbowArrowSnapLines(this.editor)) {\n\t\t\tconst { isParallel, isFlippedParallel } = anglesAreApproximatelyParallel(angle, snapAngle)\n\t\t\tif (isParallel || isFlippedParallel) {\n\t\t\t\tfor (const snapLine of snapLines) {\n\t\t\t\t\tconst doesShareStartIntersection =\n\t\t\t\t\t\tsnapLine.startBoundShapeId &&\n\t\t\t\t\t\t(snapLine.startBoundShapeId === info.bindings.start?.toId ||\n\t\t\t\t\t\t\tsnapLine.startBoundShapeId === info.bindings.end?.toId)\n\n\t\t\t\t\tconst doesShareEndIntersection =\n\t\t\t\t\t\tsnapLine.endBoundShapeId &&\n\t\t\t\t\t\t(snapLine.endBoundShapeId === info.bindings.start?.toId ||\n\t\t\t\t\t\t\tsnapLine.endBoundShapeId === info.bindings.end?.toId)\n\n\t\t\t\t\tif (!doesShareStartIntersection && !doesShareEndIntersection) continue\n\n\t\t\t\t\tconst point = isFlippedParallel ? -snapLine.perpDistance : snapLine.perpDistance\n\t\t\t\t\tconst distance = Math.abs(point - handlePoint)\n\t\t\t\t\tif (distance < snapDistance) {\n\t\t\t\t\t\tsnapPoint = point\n\t\t\t\t\t\tsnapDistance = distance\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (snapDistance > maxSnapDistance) {\n\t\t\tsnapPoint = handlePoint\n\t\t}\n\n\t\tconst newMid = clamp(invLerp(loPoint, hiPoint, snapPoint), 0, 1)\n\n\t\treturn {\n\t\t\tid: shape.id,\n\t\t\ttype: shape.type,\n\t\t\tprops: {\n\t\t\t\telbowMidPoint: newMid,\n\t\t\t},\n\t\t}\n\t}\n\n\tprivate onTerminalHandleDrag(\n\t\tshape: TLArrowShape,\n\t\t{ handle, isPrecise }: TLHandleDragInfo<TLArrowShape>,\n\t\thandleId: ArrowHandles.Start | ArrowHandles.End\n\t) {\n\t\tconst bindings = getArrowBindings(this.editor, shape)\n\n\t\tconst update: TLShapePartial<TLArrowShape> = { id: shape.id, type: 'arrow', props: {} }\n\n\t\tconst currentBinding = bindings[handleId]\n\n\t\tconst oppositeHandleId = handleId === ArrowHandles.Start ? ArrowHandles.End : ArrowHandles.Start\n\t\tconst oppositeBinding = bindings[oppositeHandleId]\n\n\t\tconst targetInfo = updateArrowTargetState({\n\t\t\teditor: this.editor,\n\t\t\tpointInPageSpace: this.editor.getShapePageTransform(shape.id)!.applyToPoint(handle),\n\t\t\tarrow: shape,\n\t\t\tisPrecise: isPrecise,\n\t\t\tcurrentBinding,\n\t\t\toppositeBinding,\n\t\t})\n\n\t\tif (!targetInfo) {\n\t\t\t// todo: maybe double check that this isn't equal to the other handle too?\n\t\t\tremoveArrowBinding(this.editor, shape, handleId)\n\t\t\tconst newPoint = maybeSnapToGrid(new Vec(handle.x, handle.y), this.editor)\n\t\t\tupdate.props![handleId] = {\n\t\t\t\tx: newPoint.x,\n\t\t\t\ty: newPoint.y,\n\t\t\t}\n\t\t\treturn update\n\t\t}\n\n\t\t// we've got a target! the handle is being dragged over a shape, bind to it\n\t\tconst bindingProps: TLArrowBindingProps = {\n\t\t\tterminal: handleId,\n\t\t\tnormalizedAnchor: targetInfo.normalizedAnchor,\n\t\t\tisPrecise: targetInfo.isPrecise,\n\t\t\tisExact: targetInfo.isExact,\n\t\t\tsnap: targetInfo.snap,\n\t\t}\n\n\t\tcreateOrUpdateArrowBinding(this.editor, shape, targetInfo.target.id, bindingProps)\n\n\t\tconst newBindings = getArrowBindings(this.editor, shape)\n\t\tif (newBindings.start && newBindings.end && newBindings.start.toId === newBindings.end.toId) {\n\t\t\tif (\n\t\t\t\tVec.Equals(newBindings.start.props.normalizedAnchor, newBindings.end.props.normalizedAnchor)\n\t\t\t) {\n\t\t\t\tcreateOrUpdateArrowBinding(this.editor, shape, newBindings.end.toId, {\n\t\t\t\t\t...newBindings.end.props,\n\t\t\t\t\tnormalizedAnchor: {\n\t\t\t\t\t\tx: newBindings.end.props.normalizedAnchor.x + 0.05,\n\t\t\t\t\t\ty: newBindings.end.props.normalizedAnchor.y,\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\treturn update\n\t}\n\n\toverride onTranslateStart(shape: TLArrowShape) {\n\t\tconst bindings = getArrowBindings(this.editor, shape)\n\n\t\t// ...if the user is dragging ONLY this arrow, for elbow shapes, we can't maintain the bindings well just yet so we remove them entirely\n\t\tif (shape.props.kind === 'elbow' && this.editor.getOnlySelectedShapeId() === shape.id) {\n\t\t\tconst info = getArrowInfo(this.editor, shape)\n\t\t\tif (!info) return\n\t\t\tconst update: TLShapePartial<TLArrowShape> = { id: shape.id, type: 'arrow', props: {} }\n\t\t\tif (bindings.start) {\n\t\t\t\tupdate.props!.start = { x: info.start.point.x, y: info.start.point.y }\n\t\t\t\tremoveArrowBinding(this.editor, shape, 'start')\n\t\t\t}\n\t\t\tif (bindings.end) {\n\t\t\t\tupdate.props!.end = { x: info.end.point.x, y: info.end.point.y }\n\t\t\t\tremoveArrowBinding(this.editor, shape, 'end')\n\t\t\t}\n\t\t\treturn update\n\t\t}\n\n\t\tconst terminalsInArrowSpace = getArrowTerminalsInArrowSpace(this.editor, shape, bindings)\n\t\tconst shapePageTransform = this.editor.getShapePageTransform(shape.id)!\n\n\t\t// If at least one bound shape is in the selection, do nothing;\n\t\t// If no bound shapes are in the selection, unbind any bound shapes\n\n\t\tconst selectedShapeIds = this.editor.getSelectedShapeIds()\n\n\t\tif (\n\t\t\t(bindings.start &&\n\t\t\t\t(selectedShapeIds.includes(bindings.start.toId) ||\n\t\t\t\t\tthis.editor.isAncestorSelected(bindings.start.toId))) ||\n\t\t\t(bindings.end &&\n\t\t\t\t(selectedShapeIds.includes(bindings.end.toId) ||\n\t\t\t\t\tthis.editor.isAncestorSelected(bindings.end.toId)))\n\t\t) {\n\t\t\treturn\n\t\t}\n\n\t\t// When we start translating shapes, record where their bindings were in page space so we\n\t\t// can maintain them as we translate the arrow\n\t\tshapeAtTranslationStart.set(shape, {\n\t\t\tpagePosition: shapePageTransform.applyToPoint(shape),\n\t\t\tterminalBindings: mapObjectMapValues(terminalsInArrowSpace, (terminalName, point) => {\n\t\t\t\tconst binding = bindings[terminalName]\n\t\t\t\tif (!binding) return null\n\t\t\t\treturn {\n\t\t\t\t\tbinding,\n\t\t\t\t\tshapePosition: point,\n\t\t\t\t\tpagePosition: shapePageTransform.applyToPoint(point),\n\t\t\t\t}\n\t\t\t}),\n\t\t})\n\n\t\t// update arrow terminal bindings eagerly to make sure the arrows unbind nicely when translating\n\t\tif (bindings.start) {\n\t\t\tupdateArrowTerminal({\n\t\t\t\teditor: this.editor,\n\t\t\t\tarrow: shape,\n\t\t\t\tterminal: 'start',\n\t\t\t\tuseHandle: true,\n\t\t\t})\n\t\t\tshape = this.editor.getShape(shape.id) as TLArrowShape\n\t\t}\n\t\tif (bindings.end) {\n\t\t\tupdateArrowTerminal({\n\t\t\t\teditor: this.editor,\n\t\t\t\tarrow: shape,\n\t\t\t\tterminal: 'end',\n\t\t\t\tuseHandle: true,\n\t\t\t})\n\t\t}\n\n\t\tfor (const handleName of [ArrowHandles.Start, ArrowHandles.End] as const) {\n\t\t\tconst binding = bindings[handleName]\n\t\t\tif (!binding) continue\n\n\t\t\tthis.editor.updateBinding({\n\t\t\t\t...binding,\n\t\t\t\tprops: { ...binding.props, isPrecise: true },\n\t\t\t})\n\t\t}\n\n\t\treturn\n\t}\n\n\toverride onTranslate(initialShape: TLArrowShape, shape: TLArrowShape) {\n\t\tconst atTranslationStart = shapeAtTranslationStart.get(initialShape)\n\t\tif (!atTranslationStart) return\n\n\t\tconst shapePageTransform = this.editor.getShapePageTransform(shape.id)!\n\t\tconst pageDelta = Vec.Sub(\n\t\t\tshapePageTransform.applyToPoint(shape),\n\t\t\tatTranslationStart.pagePosition\n\t\t)\n\n\t\tfor (const terminalBinding of Object.values(atTranslationStart.terminalBindings)) {\n\t\t\tif (!terminalBinding) continue\n\n\t\t\tconst newPagePoint = Vec.Add(terminalBinding.pagePosition, Vec.Mul(pageDelta, 0.5))\n\t\t\tconst newTarget = this.editor.getShapeAtPoint(newPagePoint, {\n\t\t\t\thitInside: true,\n\t\t\t\thitFrameInside: true,\n\t\t\t\tmargin: 0,\n\t\t\t\tfilter: (targetShape) => {\n\t\t\t\t\treturn (\n\t\t\t\t\t\t!targetShape.isLocked &&\n\t\t\t\t\t\tthis.editor.canBindShapes({ fromShape: shape, toShape: targetShape, binding: 'arrow' })\n\t\t\t\t\t)\n\t\t\t\t},\n\t\t\t})\n\n\t\t\tif (newTarget?.id === terminalBinding.binding.toId) {\n\t\t\t\tconst targetBounds = Box.ZeroFix(this.editor.getShapeGeometry(newTarget).bounds)\n\t\t\t\tconst pointInTargetSpace = this.editor.getPointInShapeSpace(newTarget, newPagePoint)\n\t\t\t\tconst normalizedAnchor = {\n\t\t\t\t\tx: (pointInTargetSpace.x - targetBounds.minX) / targetBounds.width,\n\t\t\t\t\ty: (pointInTargetSpace.y - targetBounds.minY) / targetBounds.height,\n\t\t\t\t}\n\t\t\t\tcreateOrUpdateArrowBinding(this.editor, shape, newTarget.id, {\n\t\t\t\t\t...terminalBinding.binding.props,\n\t\t\t\t\tnormalizedAnchor,\n\t\t\t\t\tisPrecise: true,\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tremoveArrowBinding(this.editor, shape, terminalBinding.binding.props.terminal)\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate readonly _resizeInitialBindings = new WeakCache<TLArrowShape, TLArrowBindings>()\n\n\toverride onResize(shape: TLArrowShape, info: TLResizeInfo<TLArrowShape>) {\n\t\tconst { scaleX, scaleY } = info\n\n\t\tconst bindings = this._resizeInitialBindings.get(shape, () =>\n\t\t\tgetArrowBindings(this.editor, shape)\n\t\t)\n\t\tconst terminals = getArrowTerminalsInArrowSpace(this.editor, shape, bindings)\n\n\t\tconst { start, end } = structuredClone<TLArrowShape['props']>(shape.props)\n\t\tlet { bend } = shape.props\n\n\t\t// Rescale start handle if it's not bound to a shape\n\t\tif (!bindings.start) {\n\t\t\tstart.x = terminals.start.x * scaleX\n\t\t\tstart.y = terminals.start.y * scaleY\n\t\t}\n\n\t\t// Rescale end handle if it's not bound to a shape\n\t\tif (!bindings.end) {\n\t\t\tend.x = terminals.end.x * scaleX\n\t\t\tend.y = terminals.end.y * scaleY\n\t\t}\n\n\t\t// todo: we should only change the normalized anchor positions\n\t\t// of the shape's handles if the bound shape is also being resized\n\n\t\tconst mx = Math.abs(scaleX)\n\t\tconst my = Math.abs(scaleY)\n\n\t\tconst startNormalizedAnchor = bindings?.start\n\t\t\t? Vec.From(bindings.start.props.normalizedAnchor)\n\t\t\t: null\n\t\tconst endNormalizedAnchor = bindings?.end ? Vec.From(bindings.end.props.normalizedAnchor) : null\n\n\t\tif (scaleX < 0 && scaleY >= 0) {\n\t\t\tif (bend !== 0) {\n\t\t\t\tbend *= -1\n\t\t\t\tbend *= Math.max(mx, my)\n\t\t\t}\n\n\t\t\tif (startNormalizedAnchor) {\n\t\t\t\tstartNormalizedAnchor.x = 1 - startNormalizedAnchor.x\n\t\t\t}\n\n\t\t\tif (endNormalizedAnchor) {\n\t\t\t\tendNormalizedAnchor.x = 1 - endNormalizedAnchor.x\n\t\t\t}\n\t\t} else if (scaleX >= 0 && scaleY < 0) {\n\t\t\tif (bend !== 0) {\n\t\t\t\tbend *= -1\n\t\t\t\tbend *= Math.max(mx, my)\n\t\t\t}\n\n\t\t\tif (startNormalizedAnchor) {\n\t\t\t\tstartNormalizedAnchor.y = 1 - startNormalizedAnchor.y\n\t\t\t}\n\n\t\t\tif (endNormalizedAnchor) {\n\t\t\t\tendNormalizedAnchor.y = 1 - endNormalizedAnchor.y\n\t\t\t}\n\t\t} else if (scaleX >= 0 && scaleY >= 0) {\n\t\t\tif (bend !== 0) {\n\t\t\t\tbend *= Math.max(mx, my)\n\t\t\t}\n\t\t} else if (scaleX < 0 && scaleY < 0) {\n\t\t\tif (bend !== 0) {\n\t\t\t\tbend *= Math.max(mx, my)\n\t\t\t}\n\n\t\t\tif (startNormalizedAnchor) {\n\t\t\t\tstartNormalizedAnchor.x = 1 - startNormalizedAnchor.x\n\t\t\t\tstartNormalizedAnchor.y = 1 - startNormalizedAnchor.y\n\t\t\t}\n\n\t\t\tif (endNormalizedAnchor) {\n\t\t\t\tendNormalizedAnchor.x = 1 - endNormalizedAnchor.x\n\t\t\t\tendNormalizedAnchor.y = 1 - endNormalizedAnchor.y\n\t\t\t}\n\t\t}\n\n\t\tif (bindings.start && startNormalizedAnchor) {\n\t\t\tcreateOrUpdateArrowBinding(this.editor, shape, bindings.start.toId, {\n\t\t\t\t...bindings.start.props,\n\t\t\t\tnormalizedAnchor: startNormalizedAnchor.toJson(),\n\t\t\t})\n\t\t}\n\t\tif (bindings.end && endNormalizedAnchor) {\n\t\t\tcreateOrUpdateArrowBinding(this.editor, shape, bindings.end.toId, {\n\t\t\t\t...bindings.end.props,\n\t\t\t\tnormalizedAnchor: endNormalizedAnchor.toJson(),\n\t\t\t})\n\t\t}\n\n\t\tconst next = {\n\t\t\tprops: {\n\t\t\t\tstart,\n\t\t\t\tend,\n\t\t\t\tbend,\n\t\t\t},\n\t\t}\n\n\t\treturn next\n\t}\n\n\toverride onDoubleClickHandle(\n\t\tshape: TLArrowShape,\n\t\thandle: TLHandle\n\t): TLShapePartial<TLArrowShape> | void {\n\t\tswitch (handle.id) {\n\t\t\tcase ArrowHandles.Start: {\n\t\t\t\treturn {\n\t\t\t\t\tid: shape.id,\n\t\t\t\t\ttype: shape.type,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\t...shape.props,\n\t\t\t\t\t\tarrowheadStart: shape.props.arrowheadStart === 'none' ? 'arrow' : 'none',\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase ArrowHandles.End: {\n\t\t\t\treturn {\n\t\t\t\t\tid: shape.id,\n\t\t\t\t\ttype: shape.type,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\t...shape.props,\n\t\t\t\t\t\tarrowheadEnd: shape.props.arrowheadEnd === 'none' ? 'arrow' : 'none',\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcomponent(shape: TLArrowShape) {\n\t\t// eslint-disable-next-line react-hooks/rules-of-hooks\n\t\tconst theme = useDefaultColorTheme()\n\t\tconst onlySelectedShape = this.editor.getOnlySelectedShape()\n\t\tconst shouldDisplayHandles =\n\t\t\tthis.editor.isInAny(\n\t\t\t\t'select.idle',\n\t\t\t\t'select.pointing_handle',\n\t\t\t\t'select.dragging_handle',\n\t\t\t\t'select.translating',\n\t\t\t\t'arrow.dragging'\n\t\t\t) && !this.editor.getIsReadonly()\n\n\t\tconst info = getArrowInfo(this.editor, shape)\n\t\tif (!info?.isValid) return null\n\n\t\tconst labelPosition = getArrowLabelPosition(this.editor, shape)\n\t\tconst isSelected = shape.id === this.editor.getOnlySelectedShapeId()\n\t\tconst isEditing = this.editor.getEditingShapeId() === shape.id\n\t\tconst showArrowLabel = isEditing || shape.props.text\n\n\t\treturn (\n\t\t\t<>\n\t\t\t\t<SVGContainer style={{ minWidth: 50, minHeight: 50 }}>\n\t\t\t\t\t<ArrowSvg\n\t\t\t\t\t\tshape={shape}\n\t\t\t\t\t\tshouldDisplayHandles={shouldDisplayHandles && onlySelectedShape?.id === shape.id}\n\t\t\t\t\t/>\n\t\t\t\t\t{shape.props.kind === 'elbow' && debugFlags.debugElbowArrows.get() && (\n\t\t\t\t\t\t<ElbowArrowDebug arrow={shape} />\n\t\t\t\t\t)}\n\t\t\t\t</SVGContainer>\n\t\t\t\t{showArrowLabel && (\n\t\t\t\t\t<PlainTextLabel\n\t\t\t\t\t\tshapeId={shape.id}\n\t\t\t\t\t\tclassNamePrefix=\"tl-arrow\"\n\t\t\t\t\t\ttype=\"arrow\"\n\t\t\t\t\t\tfont={shape.props.font}\n\t\t\t\t\t\tfontSize={getArrowLabelFontSize(shape)}\n\t\t\t\t\t\tlineHeight={TEXT_PROPS.lineHeight}\n\t\t\t\t\t\talign=\"middle\"\n\t\t\t\t\t\tverticalAlign=\"middle\"\n\t\t\t\t\t\ttext={shape.props.text}\n\t\t\t\t\t\tlabelColor={theme[shape.props.labelColor].solid}\n\t\t\t\t\t\ttextWidth={labelPosition.box.w - ARROW_LABEL_PADDING * 2 * shape.props.scale}\n\t\t\t\t\t\tisSelected={isSelected}\n\t\t\t\t\t\tpadding={0}\n\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\ttransform: `translate(${labelPosition.box.center.x}px, ${labelPosition.box.center.y}px)`,\n\t\t\t\t\t\t}}\n\t\t\t\t\t/>\n\t\t\t\t)}\n\t\t\t</>\n\t\t)\n\t}\n\n\tindicator(shape: TLArrowShape) {\n\t\t// eslint-disable-next-line react-hooks/rules-of-hooks\n\t\tconst isEditing = useIsEditing(shape.id)\n\t\t// eslint-disable-next-line react-hooks/rules-of-hooks\n\t\tconst clipPathId = useSharedSafeId(shape.id + '_clip')\n\n\t\tconst info = getArrowInfo(this.editor, shape)\n\t\tif (!info) return null\n\n\t\tconst { start, end } = getArrowTerminalsInArrowSpace(this.editor, shape, info?.bindings)\n\t\tconst geometry = this.editor.getShapeGeometry<Group2d>(shape)\n\t\tconst bounds = geometry.bounds\n\n\t\tconst labelGeometry =\n\t\t\tisEditing || shape.props.text.trim() ? (geometry.children[1] as Rectangle2d) : null\n\n\t\tif (Vec.Equals(start, end)) return null\n\n\t\tconst strokeWidth = STROKE_SIZES[shape.props.size] * shape.props.scale\n\n\t\tconst as = info.start.arrowhead && getArrowheadPathForType(info, 'start', strokeWidth)\n\t\tconst ae = info.end.arrowhead && getArrowheadPathForType(info, 'end', strokeWidth)\n\n\t\tconst includeClipPath =\n\t\t\t(as && info.start.arrowhead !== 'arrow') ||\n\t\t\t(ae && info.end.arrowhead !== 'arrow') ||\n\t\t\t!!labelGeometry\n\n\t\tconst labelBounds = labelGeometry ? labelGeometry.getBounds() : new Box(0, 0, 0, 0)\n\n\t\tif (isEditing && labelGeometry) {\n\t\t\treturn (\n\t\t\t\t<rect\n\t\t\t\t\tx={toDomPrecision(labelBounds.x)}\n\t\t\t\t\ty={toDomPrecision(labelBounds.y)}\n\t\t\t\t\twidth={labelBounds.w}\n\t\t\t\t\theight={labelBounds.h}\n\t\t\t\t\trx={3.5 * shape.props.scale}\n\t\t\t\t\try={3.5 * shape.props.scale}\n\t\t\t\t/>\n\t\t\t)\n\t\t}\n\t\tconst clipStartArrowhead = !(\n\t\t\tinfo.start.arrowhead === 'none' || info.start.arrowhead === 'arrow'\n\t\t)\n\t\tconst clipEndArrowhead = !(info.end.arrowhead === 'none' || info.end.arrowhead === 'arrow')\n\n\t\treturn (\n\t\t\t<g>\n\t\t\t\t{includeClipPath && (\n\t\t\t\t\t<defs>\n\t\t\t\t\t\t<ArrowClipPath\n\t\t\t\t\t\t\tradius={3.5 * shape.props.scale}\n\t\t\t\t\t\t\thasText={shape.props.text.trim().length > 0}\n\t\t\t\t\t\t\tbounds={bounds}\n\t\t\t\t\t\t\tlabelBounds={labelBounds}\n\t\t\t\t\t\t\tas={clipStartArrowhead && as ? as : ''}\n\t\t\t\t\t\t\tae={clipEndArrowhead && ae ? ae : ''}\n\t\t\t\t\t\t/>\n\t\t\t\t\t</defs>\n\t\t\t\t)}\n\t\t\t\t<g\n\t\t\t\t\tstyle={{\n\t\t\t\t\t\tclipPath: includeClipPath ? `url(#${clipPathId})` : undefined,\n\t\t\t\t\t\tWebkitClipPath: includeClipPath ? `url(#${clipPathId})` : undefined,\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\t{/* This rect needs to be here if we're creating a mask due to an svg quirk on Chrome */}\n\t\t\t\t\t{includeClipPath && (\n\t\t\t\t\t\t<rect\n\t\t\t\t\t\t\tx={bounds.minX - 100}\n\t\t\t\t\t\t\ty={bounds.minY - 100}\n\t\t\t\t\t\t\twidth={bounds.width + 200}\n\t\t\t\t\t\t\theight={bounds.height + 200}\n\t\t\t\t\t\t\topacity={0}\n\t\t\t\t\t\t/>\n\t\t\t\t\t)}\n\n\t\t\t\t\t{getArrowBodyPath(\n\t\t\t\t\t\tshape,\n\t\t\t\t\t\tinfo,\n\t\t\t\t\t\tshape.props.dash === 'draw'\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tstyle: 'draw',\n\t\t\t\t\t\t\t\t\trandomSeed: shape.id,\n\t\t\t\t\t\t\t\t\tstrokeWidth: 1,\n\t\t\t\t\t\t\t\t\tpasses: 1,\n\t\t\t\t\t\t\t\t\toffset: 0,\n\t\t\t\t\t\t\t\t\troundness: strokeWidth * 2,\n\t\t\t\t\t\t\t\t\tprops: { strokeWidth: undefined },\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: { style: 'solid', strokeWidth: 1, props: { strokeWidth: undefined } }\n\t\t\t\t\t)}\n\t\t\t\t</g>\n\t\t\t\t{as && <path d={as} />}\n\t\t\t\t{ae && <path d={ae} />}\n\t\t\t\t{labelGeometry && (\n\t\t\t\t\t<rect\n\t\t\t\t\t\tx={toDomPrecision(labelBounds.x)}\n\t\t\t\t\t\ty={toDomPrecision(labelBounds.y)}\n\t\t\t\t\t\twidth={labelBounds.w}\n\t\t\t\t\t\theight={labelBounds.h}\n\t\t\t\t\t\trx={3.5}\n\t\t\t\t\t\try={3.5}\n\t\t\t\t\t/>\n\t\t\t\t)}\n\t\t\t</g>\n\t\t)\n\t}\n\n\toverride onEditStart(shape: TLArrowShape) {\n\t\tif (shape.props.text.trim() === '') {\n\t\t\t// editing text for the first time, so set the position to the default:\n\t\t\tconst labelPosition = getArrowLabelDefaultPosition(this.editor, shape)\n\t\t\tthis.editor.updateShape<TLArrowShape>({\n\t\t\t\tid: shape.id,\n\t\t\t\ttype: shape.type,\n\t\t\t\tprops: { labelPosition },\n\t\t\t})\n\t\t}\n\t}\n\n\toverride onEditEnd(shape: TLArrowShape) {\n\t\tconst {\n\t\t\tid,\n\t\t\ttype,\n\t\t\tprops: { text },\n\t\t} = shape\n\n\t\tif (text.trimEnd() !== shape.props.text) {\n\t\t\tthis.editor.updateShapes<TLArrowShape>([\n\t\t\t\t{\n\t\t\t\t\tid,\n\t\t\t\t\ttype,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\ttext: text.trimEnd(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t])\n\t\t}\n\t}\n\n\toverride toSvg(shape: TLArrowShape, ctx: SvgExportContext) {\n\t\tctx.addExportDef(getFillDefForExport(shape.props.fill))\n\t\tconst theme = getDefaultColorTheme(ctx)\n\t\tconst scaleFactor = 1 / shape.props.scale\n\n\t\treturn (\n\t\t\t<g transform={`scale(${scaleFactor})`}>\n\t\t\t\t<ArrowSvg shape={shape} shouldDisplayHandles={false} />\n\t\t\t\t<SvgTextLabel\n\t\t\t\t\tfontSize={getArrowLabelFontSize(shape)}\n\t\t\t\t\tfont={shape.props.font}\n\t\t\t\t\talign=\"middle\"\n\t\t\t\t\tverticalAlign=\"middle\"\n\t\t\t\t\ttext={shape.props.text}\n\t\t\t\t\tlabelColor={theme[shape.props.labelColor].solid}\n\t\t\t\t\tbounds={getArrowLabelPosition(this.editor, shape)\n\t\t\t\t\t\t.box.clone()\n\t\t\t\t\t\t.expandBy(-ARROW_LABEL_PADDING * shape.props.scale)}\n\t\t\t\t\tpadding={0}\n\t\t\t\t\tshowTextOutline={true}\n\t\t\t\t/>\n\t\t\t</g>\n\t\t)\n\t}\n\n\toverride getCanvasSvgDefs(): TLShapeUtilCanvasSvgDef[] {\n\t\treturn [\n\t\t\tgetFillDefForCanvas(),\n\t\t\t{\n\t\t\t\tkey: `arrow:dot`,\n\t\t\t\tcomponent: ArrowheadDotDef,\n\t\t\t},\n\t\t\t{\n\t\t\t\tkey: `arrow:cross`,\n\t\t\t\tcomponent: ArrowheadCrossDef,\n\t\t\t},\n\t\t]\n\t}\n\toverride getInterpolatedProps(\n\t\tstartShape: TLArrowShape,\n\t\tendShape: TLArrowShape,\n\t\tprogress: number\n\t): TLArrowShapeProps {\n\t\treturn {\n\t\t\t...(progress > 0.5 ? endShape.props : startShape.props),\n\t\t\tscale: lerp(startShape.props.scale, endShape.props.scale, progress),\n\t\t\tstart: {\n\t\t\t\tx: lerp(startShape.props.start.x, endShape.props.start.x, progress),\n\t\t\t\ty: lerp(startShape.props.start.y, endShape.props.start.y, progress),\n\t\t\t},\n\t\t\tend: {\n\t\t\t\tx: lerp(startShape.props.end.x, endShape.props.end.x, progress),\n\t\t\t\ty: lerp(startShape.props.end.y, endShape.props.end.y, progress),\n\t\t\t},\n\t\t\tbend: lerp(startShape.props.bend, endShape.props.bend, progress),\n\t\t\tlabelPosition: lerp(startShape.props.labelPosition, endShape.props.labelPosition, progress),\n\t\t}\n\t}\n}\n\nexport function getArrowLength(editor: Editor, shape: TLArrowShape): number {\n\tconst info = getArrowInfo(editor, shape)!\n\n\treturn info.type === 'straight'\n\t\t? Vec.Dist(info.start.handle, info.end.handle)\n\t\t: info.type === 'arc'\n\t\t\t? Math.abs(info.handleArc.length)\n\t\t\t: info.route.distance\n}\n\nconst ArrowSvg = track(function ArrowSvg({\n\tshape,\n\tshouldDisplayHandles,\n}: {\n\tshape: TLArrowShape\n\tshouldDisplayHandles: boolean\n}) {\n\tconst editor = useEditor()\n\tconst theme = useDefaultColorTheme()\n\tconst info = getArrowInfo(editor, shape)\n\tconst isForceSolid = useValue(\n\t\t'force solid',\n\t\t() => {\n\t\t\treturn editor.getZoomLevel() < 0.2\n\t\t},\n\t\t[editor]\n\t)\n\tconst clipPathId = useSharedSafeId(shape.id + '_clip')\n\tconst arrowheadDotId = useSharedSafeId('arrowhead-dot')\n\tconst arrowheadCrossId = useSharedSafeId('arrowhead-cross')\n\tconst isEditing = useIsEditing(shape.id)\n\tconst geometry = editor.getShapeGeometry(shape)\n\tif (!geometry) return null\n\tconst bounds = Box.ZeroFix(geometry.bounds)\n\tconst bindings = getArrowBindings(editor, shape)\n\n\tif (!info?.isValid) return null\n\n\tconst strokeWidth = STROKE_SIZES[shape.props.size] * shape.props.scale\n\n\tconst as = info.start.arrowhead && getArrowheadPathForType(info, 'start', strokeWidth)\n\tconst ae = info.end.arrowhead && getArrowheadPathForType(info, 'end', strokeWidth)\n\n\tlet handlePath: null | React.JSX.Element = null\n\n\tif (shouldDisplayHandles && (bindings.start || bindings.end)) {\n\t\thandlePath = getArrowHandlePath(info, {\n\t\t\tstyle: 'dashed',\n\t\t\tstart: 'skip',\n\t\t\tend: 'skip',\n\t\t\tlengthRatio: 2.5,\n\t\t\tstrokeWidth: 2 / editor.getZoomLevel(),\n\t\t\tprops: {\n\t\t\t\tclassName: 'tl-arrow-hint',\n\t\t\t\tmarkerStart: bindings.start\n\t\t\t\t\t? bindings.start.props.isExact\n\t\t\t\t\t\t? ''\n\t\t\t\t\t\t: bindings.start.props.isPrecise\n\t\t\t\t\t\t\t? `url(#${arrowheadCrossId})`\n\t\t\t\t\t\t\t: `url(#${arrowheadDotId})`\n\t\t\t\t\t: '',\n\t\t\t\tmarkerEnd: bindings.end\n\t\t\t\t\t? bindings.end.props.isExact\n\t\t\t\t\t\t? ''\n\t\t\t\t\t\t: bindings.end.props.isPrecise\n\t\t\t\t\t\t\t? `url(#${arrowheadCrossId})`\n\t\t\t\t\t\t\t: `url(#${arrowheadDotId})`\n\t\t\t\t\t: '',\n\t\t\t\topacity: 0.16,\n\t\t\t},\n\t\t})\n\t}\n\n\tconst labelPosition = getArrowLabelPosition(editor, shape)\n\n\tconst clipStartArrowhead = !(info.start.arrowhead === 'none' || info.start.arrowhead === 'arrow')\n\tconst clipEndArrowhead = !(info.end.arrowhead === 'none' || info.end.arrowhead === 'arrow')\n\n\treturn (\n\t\t<>\n\t\t\t{/* Yep */}\n\t\t\t<defs>\n\t\t\t\t<clipPath id={clipPathId}>\n\t\t\t\t\t<ArrowClipPath\n\t\t\t\t\t\tradius={3.5 * shape.props.scale}\n\t\t\t\t\t\thasText={isEditing || shape.props.text.trim().length > 0}\n\t\t\t\t\t\tbounds={bounds}\n\t\t\t\t\t\tlabelBounds={labelPosition.box}\n\t\t\t\t\t\tas={clipStartArrowhead && as ? as : ''}\n\t\t\t\t\t\tae={clipEndArrowhead && ae ? ae : ''}\n\t\t\t\t\t/>\n\t\t\t\t</clipPath>\n\t\t\t</defs>\n\t\t\t<g\n\t\t\t\tfill=\"none\"\n\t\t\t\tstroke={theme[shape.props.color].solid}\n\t\t\t\tstrokeWidth={strokeWidth}\n\t\t\t\tstrokeLinejoin=\"round\"\n\t\t\t\tstrokeLinecap=\"round\"\n\t\t\t\tpointerEvents=\"none\"\n\t\t\t>\n\t\t\t\t{handlePath}\n\t\t\t\t<g\n\t\t\t\t\tstyle={{\n\t\t\t\t\t\tclipPath: `url(#${clipPathId})`,\n\t\t\t\t\t\tWebkitClipPath: `url(#${clipPathId})`,\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\t<rect\n\t\t\t\t\t\tx={toDomPrecision(bounds.minX - 100)}\n\t\t\t\t\t\ty={toDomPrecision(bounds.minY - 100)}\n\t\t\t\t\t\twidth={toDomPrecision(bounds.width + 200)}\n\t\t\t\t\t\theight={toDomPrecision(bounds.height + 200)}\n\t\t\t\t\t\topacity={0}\n\t\t\t\t\t/>\n\t\t\t\t\t{getArrowBodyPath(shape, info, {\n\t\t\t\t\t\tstyle: shape.props.dash,\n\t\t\t\t\t\tstrokeWidth,\n\t\t\t\t\t\tforceSolid: isForceSolid,\n\t\t\t\t\t\trandomSeed: shape.id,\n\t\t\t\t\t})}\n\t\t\t\t</g>\n\t\t\t\t{as && clipStartArrowhead && shape.props.fill !== 'none' && (\n\t\t\t\t\t<ShapeFill\n\t\t\t\t\t\ttheme={theme}\n\t\t\t\t\t\td={as}\n\t\t\t\t\t\tcolor={shape.props.color}\n\t\t\t\t\t\tfill={shape.props.fill}\n\t\t\t\t\t\tscale={shape.props.scale}\n\t\t\t\t\t/>\n\t\t\t\t)}\n\t\t\t\t{ae && clipEndArrowhead && shape.props.fill !== 'none' && (\n\t\t\t\t\t<ShapeFill\n\t\t\t\t\t\ttheme={theme}\n\t\t\t\t\t\td={ae}\n\t\t\t\t\t\tcolor={shape.props.color}\n\t\t\t\t\t\tfill={shape.props.fill}\n\t\t\t\t\t\tscale={shape.props.scale}\n\t\t\t\t\t/>\n\t\t\t\t)}\n\t\t\t\t{as && <path d={as} />}\n\t\t\t\t{ae && <path d={ae} />}\n\t\t\t</g>\n\t\t</>\n\t)\n})\n\nfunction ArrowClipPath({\n\tradius,\n\thasText,\n\tbounds,\n\tlabelBounds,\n\tas,\n\tae,\n}: {\n\tradius: number\n\thasText: boolean\n\tbounds: Box\n\tlabelBounds: Box\n\tas: string\n\tae: string\n}) {\n\tconst path = useMemo(() => {\n\t\t// The direction in which we create the different path parts is important, as it determines what gets clipped.\n\t\t// See the description on the directions in the non-zero fill rule example:\n\t\t// https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-rule#nonzero\n\t\tconst path = new PathBuilder()\n\n\t\t// We create this one in the clockwise direction\n\t\tpath\n\t\t\t.moveTo(bounds.left - 100, bounds.top - 100)\n\t\t\t.lineTo(bounds.right + 100, bounds.top - 100)\n\t\t\t.lineTo(bounds.right + 100, bounds.bottom + 100)\n\t\t\t.lineTo(bounds.left - 100, bounds.bottom + 100)\n\t\t\t.close()\n\n\t\tif (hasText) {\n\t\t\t// We create this one in the counter-clockwise direction, which cuts out the label box\n\t\t\tpath\n\t\t\t\t.moveTo(labelBounds.left, labelBounds.top + radius)\n\t\t\t\t.lineTo(labelBounds.left, labelBounds.bottom - radius)\n\t\t\t\t.circularArcTo(radius, false, false, labelBounds.left + radius, labelBounds.bottom)\n\t\t\t\t.lineTo(labelBounds.right - radius, labelBounds.bottom)\n\t\t\t\t.circularArcTo(radius, false, false, labelBounds.right, labelBounds.bottom - radius)\n\t\t\t\t.lineTo(labelBounds.right, labelBounds.top + radius)\n\t\t\t\t.circularArcTo(radius, false, false, labelBounds.right - radius, labelBounds.top)\n\t\t\t\t.lineTo(labelBounds.left + radius, labelBounds.top)\n\t\t\t\t.circularArcTo(radius, false, false, labelBounds.left, labelBounds.top + radius)\n\t\t\t\t.close()\n\t\t}\n\n\t\treturn path.toD()\n\t}, [\n\t\tradius,\n\t\thasText,\n\t\tbounds.bottom,\n\t\tbounds.left,\n\t\tbounds.right,\n\t\tbounds.top,\n\t\tlabelBounds.bottom,\n\t\tlabelBounds.left,\n\t\tlabelBounds.right,\n\t\tlabelBounds.top,\n\t])\n\n\t// We also append the arrowhead paths to the clip path, so that we also clip the arrowheads\n\treturn <path d={`${path}${as}${ae}`} />\n}\n\nconst shapeAtTranslationStart = new WeakMap<\n\tTLArrowShape,\n\t{\n\t\tpagePosition: Vec\n\t\tterminalBindings: Record<\n\t\t\t'start' | 'end',\n\t\t\t{\n\t\t\t\tpagePosition: Vec\n\t\t\t\tshapePosition: Vec\n\t\t\t\tbinding: TLArrowBinding\n\t\t\t} | null\n\t\t>\n\t}\n>()\n\nfunction ArrowheadDotDef() {\n\tconst id = useSharedSafeId('arrowhead-dot')\n\treturn (\n\t\t<marker id={id} className=\"tl-arrow-hint\" refX=\"3.0\" refY=\"3.0\" orient=\"0\">\n\t\t\t<circle cx=\"3\" cy=\"3\" r=\"2\" strokeDasharray=\"100%\" />\n\t\t</marker>\n\t)\n}\n\nfunction ArrowheadCrossDef() {\n\tconst id = useSharedSafeId('arrowhead-cross')\n\treturn (\n\t\t<marker id={id} className=\"tl-arrow-hint\" refX=\"3.0\" refY=\"3.0\" orient=\"auto\">\n\t\t\t<line x1=\"1.5\" y1=\"1.5\" x2=\"4.5\" y2=\"4.5\" strokeDasharray=\"100%\" />\n\t\t\t<line x1=\"1.5\" y1=\"4.5\" x2=\"4.5\" y2=\"1.5\" strokeDasharray=\"100%\" />\n\t\t</marker>\n\t)\n}\n\n/**\n * Take 2 angles and return true if they are approximately parallel. Angle that point in the same\n * (or opposite) directions are considered parallel. This also handles wrap around - e.g. 0, Ï, and\n * 2Ï are all considered parallel.\n */\nfunction anglesAreApproximatelyParallel(a: number, b: number, tolerance = 0.0001) {\n\tconst diff = Math.abs(a - b)\n\n\tconst isParallel = diff < tolerance\n\tconst isFlippedParallel = Math.abs(diff - Math.PI) < tolerance\n\tconst is360Parallel = Math.abs(diff - PI2) < tolerance\n\n\treturn { isParallel: isParallel || is360Parallel, isFlippedParallel }\n}\n"],"names":["ArrowHandles","ArrowSvg","path"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 9083, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/shared/HyperlinkButton.tsx"],"sourcesContent":["import { stopEventPropagation, useEditor, useValue } from '@tldraw/editor'\nimport classNames from 'classnames'\nimport { PointerEventHandler, useCallback } from 'react'\n\nconst LINK_ICON =\n\t\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' fill='none'%3E%3Cpath stroke='%23000' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M13 5H7a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6M19 5h6m0 0v6m0-6L13 17'/%3E%3C/svg%3E\"\n\nexport function HyperlinkButton({ url }: { url: string }) {\n\tconst editor = useEditor()\n\tconst hideButton = useValue('zoomLevel', () => editor.getZoomLevel() < 0.32, [editor])\n\tconst useStopPropagationOnShiftKey = useCallback<PointerEventHandler>(\n\t\t(e) => {\n\t\t\tif (!editor.inputs.shiftKey) stopEventPropagation(e)\n\t\t},\n\t\t[editor]\n\t)\n\treturn (\n\t\t<a\n\t\t\tclassName={classNames('tl-hyperlink-button', {\n\t\t\t\t'tl-hyperlink-button__hidden': hideButton,\n\t\t\t})}\n\t\t\thref={url}\n\t\t\ttarget=\"_blank\"\n\t\t\trel=\"noopener noreferrer\"\n\t\t\tonPointerDown={useStopPropagationOnShiftKey}\n\t\t\tonPointerUp={useStopPropagationOnShiftKey}\n\t\t\ttitle={url}\n\t\t\tdraggable={false}\n\t\t>\n\t\t\t<div\n\t\t\t\tclassName=\"tl-hyperlink__icon\"\n\t\t\t\tstyle={{\n\t\t\t\t\tmask: `url(\"${LINK_ICON}\") center 100% / 100% no-repeat`,\n\t\t\t\t\tWebkitMask: `url(\"${LINK_ICON}\") center 100% / 100% no-repeat`,\n\t\t\t\t}}\n\t\t\t/>\n\t\t</a>\n\t)\n}\n"],"names":[],"mappings":";;;AA6BG;AA7BH,SAAS,sBAAsB,WAAW,gBAAgB;;;;AAC1D,OAAO,gBAAgB;AACvB,SAA8B,mBAAmB;;;;;AAEjD,MAAM,YACL;AAEM,SAAS,gBAAgB,EAAE,GAAA,CAAI,CAAA,EAAoB;IACzD,MAAM,aAAS,+LAAA,CAAU;IACzB,MAAM,kMAAa,WAAA,EAAS;gDAAa,IAAM,OAAO,YAAA,CAAa,IAAI;+CAAM;QAAC,MAAM;KAAC;IACrF,MAAM,iMAA+B,cAAA;qEACpC,CAAC,MAAM;YACN,IAAI,CAAC,OAAO,MAAA,CAAO,QAAA,CAAU,CAAA,CAAA,GAAA,4KAAA,CAAA,uBAAA,EAAqB,CAAC;QACpD;oEACA;QAAC,MAAM;KAAA;IAER,OACC,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,KAAA;QACA,sJAAW,UAAA,EAAW,uBAAuB;YAC5C,+BAA+B;QAChC,CAAC;QACD,MAAM;QACN,QAAO;QACP,KAAI;QACJ,eAAe;QACf,aAAa;QACb,OAAO;QACP,WAAW;QAEX,UAAA,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,OAAA;YACA,WAAU;YACV,OAAO;gBACN,MAAM,CAAA,KAAA,EAAQ,SAAS,CAAA,+BAAA,CAAA;gBACvB,YAAY,CAAA,KAAA,EAAQ,SAAS,CAAA,+BAAA,CAAA;YAC9B;QAAA;IACD;AAGH","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 9140, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/shared/icons-editor.ts"],"sourcesContent":["export const LINK_ICON =\n\t\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' fill='none'%3E%3Cpath stroke='%23000' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M13 5H7a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6M19 5h6m0 0v6m0-6L13 17'/%3E%3C/svg%3E\"\n"],"names":[],"mappings":";;;AAAO,MAAM,YACZ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 9152, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/shared/rotated-box-shadow.ts"],"sourcesContent":["import { Vec } from '@tldraw/editor'\n\nconst ROTATING_BOX_SHADOWS = [\n\t{\n\t\toffsetX: 0,\n\t\toffsetY: 2,\n\t\tblur: 4,\n\t\tspread: 0,\n\t\tcolor: '#00000029',\n\t},\n\t{\n\t\toffsetX: 0,\n\t\toffsetY: 3,\n\t\tblur: 6,\n\t\tspread: 0,\n\t\tcolor: '#0000001f',\n\t},\n]\n\n/** @public */\nexport function getRotatedBoxShadow(rotation: number) {\n\tconst cssStrings = ROTATING_BOX_SHADOWS.map((shadow) => {\n\t\tconst { offsetX, offsetY, blur, spread, color } = shadow\n\t\tconst vec = new Vec(offsetX, offsetY)\n\t\tconst { x, y } = vec.rot(-rotation)\n\t\treturn `${x}px ${y}px ${blur}px ${spread}px ${color}`\n\t})\n\treturn cssStrings.join(', ')\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,WAAW;;AAEpB,MAAM,uBAAuB;IAC5B;QACC,SAAS;QACT,SAAS;QACT,MAAM;QACN,QAAQ;QACR,OAAO;IACR;IACA;QACC,SAAS;QACT,SAAS;QACT,MAAM;QACN,QAAQ;QACR,OAAO;IACR;CACD;AAGO,SAAS,oBAAoB,QAAA,EAAkB;IACrD,MAAM,aAAa,qBAAqB,GAAA,CAAI,CAAC,WAAW;QACvD,MAAM,EAAE,OAAA,EAAS,OAAA,EAAS,IAAA,EAAM,MAAA,EAAQ,KAAA,CAAM,CAAA,GAAI;QAClD,MAAM,MAAM,sLAAI,MAAA,CAAI,SAAS,OAAO;QACpC,MAAM,EAAE,CAAA,EAAG,CAAA,CAAE,CAAA,GAAI,IAAI,GAAA,CAAI,CAAC,QAAQ;QAClC,OAAO,GAAG,CAAC,CAAA,GAAA,EAAM,CAAC,CAAA,GAAA,EAAM,IAAI,CAAA,GAAA,EAAM,MAAM,CAAA,GAAA,EAAM,KAAK,EAAA;IACpD,CAAC;IACD,OAAO,WAAW,IAAA,CAAK,IAAI;AAC5B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 9191, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/bookmark/BookmarkShapeUtil.tsx"],"sourcesContent":["import {\n\tAssetRecordType,\n\tBaseBoxShapeUtil,\n\tEditor,\n\tHTMLContainer,\n\tT,\n\tTLAssetId,\n\tTLBookmarkAsset,\n\tTLBookmarkShape,\n\tTLBookmarkShapeProps,\n\tbookmarkShapeMigrations,\n\tbookmarkShapeProps,\n\tdebounce,\n\tgetHashForString,\n\tlerp,\n\tstopEventPropagation,\n\ttlenv,\n\ttoDomPrecision,\n\tuseEditor,\n\tuseSvgExportContext,\n} from '@tldraw/editor'\nimport classNames from 'classnames'\nimport { PointerEventHandler, useCallback, useState } from 'react'\nimport { convertCommonTitleHTMLEntities } from '../../utils/text/text'\nimport { HyperlinkButton } from '../shared/HyperlinkButton'\nimport { LINK_ICON } from '../shared/icons-editor'\nimport { getRotatedBoxShadow } from '../shared/rotated-box-shadow'\n\nconst BOOKMARK_WIDTH = 300\nconst BOOKMARK_HEIGHT = 320\nconst BOOKMARK_JUST_URL_HEIGHT = 46\nconst SHORT_BOOKMARK_HEIGHT = 101\n\n/** @public */\nexport class BookmarkShapeUtil extends BaseBoxShapeUtil<TLBookmarkShape> {\n\tstatic override type = 'bookmark' as const\n\tstatic override props = bookmarkShapeProps\n\tstatic override migrations = bookmarkShapeMigrations\n\n\toverride canResize() {\n\t\treturn false\n\t}\n\n\toverride hideSelectionBoundsFg() {\n\t\treturn true\n\t}\n\n\toverride getText(shape: TLBookmarkShape) {\n\t\treturn shape.props.url\n\t}\n\n\toverride getAriaDescriptor(shape: TLBookmarkShape) {\n\t\tconst asset = (\n\t\t\tshape.props.assetId ? this.editor.getAsset(shape.props.assetId) : null\n\t\t) as TLBookmarkAsset | null\n\n\t\tif (!asset?.props.title) return undefined\n\n\t\treturn (\n\t\t\tconvertCommonTitleHTMLEntities(asset.props.title) +\n\t\t\t(asset.props.description ? ', ' + asset.props.description : '')\n\t\t)\n\t}\n\n\toverride getDefaultProps(): TLBookmarkShape['props'] {\n\t\treturn {\n\t\t\turl: '',\n\t\t\tw: BOOKMARK_WIDTH,\n\t\t\th: BOOKMARK_HEIGHT,\n\t\t\tassetId: null,\n\t\t}\n\t}\n\n\toverride component(shape: TLBookmarkShape) {\n\t\treturn <BookmarkShapeComponent shape={shape} />\n\t}\n\n\toverride indicator(shape: TLBookmarkShape) {\n\t\treturn (\n\t\t\t<rect\n\t\t\t\twidth={toDomPrecision(shape.props.w)}\n\t\t\t\theight={toDomPrecision(shape.props.h)}\n\t\t\t\trx=\"6\"\n\t\t\t\try=\"6\"\n\t\t\t/>\n\t\t)\n\t}\n\n\toverride onBeforeCreate(next: TLBookmarkShape) {\n\t\treturn getBookmarkSize(this.editor, next)\n\t}\n\n\toverride onBeforeUpdate(prev: TLBookmarkShape, shape: TLBookmarkShape) {\n\t\tif (prev.props.url !== shape.props.url) {\n\t\t\tif (!T.linkUrl.isValid(shape.props.url)) {\n\t\t\t\treturn { ...shape, props: { ...shape.props, url: prev.props.url } }\n\t\t\t} else {\n\t\t\t\tupdateBookmarkAssetOnUrlChange(this.editor, shape)\n\t\t\t}\n\t\t}\n\n\t\tif (prev.props.assetId !== shape.props.assetId) {\n\t\t\treturn getBookmarkSize(this.editor, shape)\n\t\t}\n\t}\n\toverride getInterpolatedProps(\n\t\tstartShape: TLBookmarkShape,\n\t\tendShape: TLBookmarkShape,\n\t\tt: number\n\t): TLBookmarkShapeProps {\n\t\treturn {\n\t\t\t...(t > 0.5 ? endShape.props : startShape.props),\n\t\t\tw: lerp(startShape.props.w, endShape.props.w, t),\n\t\t\th: lerp(startShape.props.h, endShape.props.h, t),\n\t\t}\n\t}\n}\n\nfunction BookmarkShapeComponent({ shape }: { shape: TLBookmarkShape }) {\n\tconst editor = useEditor()\n\n\tconst asset = (\n\t\tshape.props.assetId ? editor.getAsset(shape.props.assetId) : null\n\t) as TLBookmarkAsset\n\n\tconst isSafariExport = !!useSvgExportContext() && tlenv.isSafari\n\n\tconst pageRotation = editor.getShapePageTransform(shape)!.rotation()\n\n\tconst address = getHumanReadableAddress(shape)\n\n\tconst [isFaviconValid, setIsFaviconValid] = useState(true)\n\tconst onFaviconError = () => setIsFaviconValid(false)\n\n\tconst useStopPropagationOnShiftKey = useCallback<PointerEventHandler>(\n\t\t(e) => {\n\t\t\tif (!editor.inputs.shiftKey) stopEventPropagation(e)\n\t\t},\n\t\t[editor]\n\t)\n\n\treturn (\n\t\t<HTMLContainer>\n\t\t\t<div\n\t\t\t\tclassName={classNames(\n\t\t\t\t\t'tl-bookmark__container',\n\t\t\t\t\tisSafariExport && 'tl-bookmark__container--safariExport'\n\t\t\t\t)}\n\t\t\t\tstyle={{\n\t\t\t\t\tboxShadow: isSafariExport ? undefined : getRotatedBoxShadow(pageRotation),\n\t\t\t\t\tmaxHeight: shape.props.h,\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\t{(!asset || asset.props.image) && (\n\t\t\t\t\t<div className=\"tl-bookmark__image_container\">\n\t\t\t\t\t\t{asset ? (\n\t\t\t\t\t\t\t<img\n\t\t\t\t\t\t\t\tclassName=\"tl-bookmark__image\"\n\t\t\t\t\t\t\t\tdraggable={false}\n\t\t\t\t\t\t\t\treferrerPolicy=\"strict-origin-when-cross-origin\"\n\t\t\t\t\t\t\t\tsrc={asset?.props.image}\n\t\t\t\t\t\t\t\talt={asset?.props.title || ''}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t<div className=\"tl-bookmark__placeholder\" />\n\t\t\t\t\t\t)}\n\t\t\t\t\t\t{asset?.props.image && <HyperlinkButton url={shape.props.url} />}\n\t\t\t\t\t</div>\n\t\t\t\t)}\n\t\t\t\t<div className=\"tl-bookmark__copy_container\">\n\t\t\t\t\t{asset?.props.title ? (\n\t\t\t\t\t\t<h2 className=\"tl-bookmark__heading\">\n\t\t\t\t\t\t\t{convertCommonTitleHTMLEntities(asset.props.title)}\n\t\t\t\t\t\t</h2>\n\t\t\t\t\t) : null}\n\t\t\t\t\t{asset?.props.description && asset?.props.image ? (\n\t\t\t\t\t\t<p className=\"tl-bookmark__description\">{asset.props.description}</p>\n\t\t\t\t\t) : null}\n\t\t\t\t\t<a\n\t\t\t\t\t\tclassName=\"tl-bookmark__link\"\n\t\t\t\t\t\thref={shape.props.url || ''}\n\t\t\t\t\t\ttarget=\"_blank\"\n\t\t\t\t\t\trel=\"noopener noreferrer\"\n\t\t\t\t\t\tdraggable={false}\n\t\t\t\t\t\tonPointerDown={useStopPropagationOnShiftKey}\n\t\t\t\t\t\tonPointerUp={useStopPropagationOnShiftKey}\n\t\t\t\t\t>\n\t\t\t\t\t\t{isFaviconValid && asset?.props.favicon ? (\n\t\t\t\t\t\t\t<img\n\t\t\t\t\t\t\t\tclassName=\"tl-bookmark__favicon\"\n\t\t\t\t\t\t\t\tsrc={asset?.props.favicon}\n\t\t\t\t\t\t\t\treferrerPolicy=\"strict-origin-when-cross-origin\"\n\t\t\t\t\t\t\t\tonError={onFaviconError}\n\t\t\t\t\t\t\t\talt={`favicon of ${address}`}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\tclassName=\"tl-hyperlink__icon\"\n\t\t\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\t\t\tmask: `url(\"${LINK_ICON}\") center 100% / 100% no-repeat`,\n\t\t\t\t\t\t\t\t\tWebkitMask: `url(\"${LINK_ICON}\") center 100% / 100% no-repeat`,\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t)}\n\t\t\t\t\t\t<span>{address}</span>\n\t\t\t\t\t</a>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</HTMLContainer>\n\t)\n}\n\nfunction getBookmarkSize(editor: Editor, shape: TLBookmarkShape) {\n\tconst asset = (\n\t\tshape.props.assetId ? editor.getAsset(shape.props.assetId) : null\n\t) as TLBookmarkAsset\n\n\tlet h = BOOKMARK_HEIGHT\n\n\tif (asset) {\n\t\tif (!asset.props.image) {\n\t\t\tif (!asset.props.title) {\n\t\t\t\th = BOOKMARK_JUST_URL_HEIGHT\n\t\t\t} else {\n\t\t\t\th = SHORT_BOOKMARK_HEIGHT\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\t...shape,\n\t\tprops: {\n\t\t\t...shape.props,\n\t\t\th,\n\t\t},\n\t}\n}\n\n/** @internal */\nexport const getHumanReadableAddress = (shape: TLBookmarkShape) => {\n\ttry {\n\t\tconst url = new URL(shape.props.url)\n\t\t// we want the hostname without any www\n\t\treturn url.hostname.replace(/^www\\./, '')\n\t} catch {\n\t\treturn shape.props.url\n\t}\n}\n\nfunction updateBookmarkAssetOnUrlChange(editor: Editor, shape: TLBookmarkShape) {\n\tconst { url } = shape.props\n\n\t// Derive the asset id from the URL\n\tconst assetId: TLAssetId = AssetRecordType.createId(getHashForString(url))\n\n\tif (editor.getAsset(assetId)) {\n\t\t// Existing asset for this URL?\n\t\tif (shape.props.assetId !== assetId) {\n\t\t\teditor.updateShapes<TLBookmarkShape>([\n\t\t\t\t{\n\t\t\t\t\tid: shape.id,\n\t\t\t\t\ttype: shape.type,\n\t\t\t\t\tprops: { assetId },\n\t\t\t\t},\n\t\t\t])\n\t\t}\n\t} else {\n\t\t// No asset for this URL?\n\n\t\t// First, clear out the existing asset reference\n\t\teditor.updateShapes<TLBookmarkShape>([\n\t\t\t{\n\t\t\t\tid: shape.id,\n\t\t\t\ttype: shape.type,\n\t\t\t\tprops: { assetId: null },\n\t\t\t},\n\t\t])\n\n\t\t// Then try to asyncronously create a new one\n\t\tcreateBookmarkAssetOnUrlChange(editor, shape)\n\t}\n}\n\nconst createBookmarkAssetOnUrlChange = debounce(async (editor: Editor, shape: TLBookmarkShape) => {\n\tif (editor.isDisposed) return\n\n\tconst { url } = shape.props\n\n\t// Create the asset using the external content manager's createAssetFromUrl method.\n\t// This may be overwritten by the user (for example, we overwrite it on tldraw.com)\n\tconst asset = await editor.getAssetForExternalContent({ type: 'url', url })\n\n\tif (!asset) {\n\t\t// No asset? Just leave the bookmark as a null assetId.\n\t\treturn\n\t}\n\n\teditor.run(() => {\n\t\t// Create the new asset\n\t\teditor.createAssets([asset])\n\n\t\t// And update the shape\n\t\teditor.updateShapes<TLBookmarkShape>([\n\t\t\t{\n\t\t\t\tid: shape.id,\n\t\t\t\ttype: shape.type,\n\t\t\t\tprops: { assetId: asset.id },\n\t\t\t},\n\t\t])\n\t})\n}, 500)\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 9469, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/shared/freehand/svg.ts"],"sourcesContent":["import { average, precise } from '@tldraw/editor'\nimport { StrokePoint } from './types'\n\n/**\n * Turn an array of stroke points into a path of quadradic curves.\n *\n * @param points - The stroke points returned from perfect-freehand\n * @param closed - Whether the shape is closed\n */\nexport function getSvgPathFromStrokePoints(points: StrokePoint[], closed = false): string {\n\tconst len = points.length\n\n\tif (len < 2) {\n\t\treturn ''\n\t}\n\n\tlet a = points[0].point\n\tlet b = points[1].point\n\n\tif (len === 2) {\n\t\treturn `M${precise(a)}L${precise(b)}`\n\t}\n\n\tlet result = ''\n\n\tfor (let i = 2, max = len - 1; i < max; i++) {\n\t\ta = points[i].point\n\t\tb = points[i + 1].point\n\t\tresult += average(a, b)\n\t}\n\n\tif (closed) {\n\t\t// If closed, draw a curve from the last point to the first\n\t\treturn `M${average(points[0].point, points[1].point)}Q${precise(points[1].point)}${average(\n\t\t\tpoints[1].point,\n\t\t\tpoints[2].point\n\t\t)}T${result}${average(points[len - 1].point, points[0].point)}${average(\n\t\t\tpoints[0].point,\n\t\t\tpoints[1].point\n\t\t)}Z`\n\t} else {\n\t\t// If not closed, draw a curve starting at the first point and\n\t\t// ending at the midpoint of the last and second-last point, then\n\t\t// complete the curve with a line segment to the last point.\n\t\treturn `M${precise(points[0].point)}Q${precise(points[1].point)}${average(\n\t\t\tpoints[1].point,\n\t\t\tpoints[2].point\n\t\t)}${points.length > 3 ? 'T' : ''}${result}L${precise(points[len - 1].point)}`\n\t}\n}\n"],"names":[],"mappings":";;;AAAA,SAAS,SAAS,eAAe;;;AAS1B,SAAS,2BAA2B,MAAA,EAAuB,SAAS,KAAA,EAAe;IACzF,MAAM,MAAM,OAAO,MAAA;IAEnB,IAAI,MAAM,GAAG;QACZ,OAAO;IACR;IAEA,IAAI,IAAI,MAAA,CAAO,CAAC,CAAA,CAAE,KAAA;IAClB,IAAI,IAAI,MAAA,CAAO,CAAC,CAAA,CAAE,KAAA;IAElB,IAAI,QAAQ,GAAG;QACd,OAAO,CAAA,CAAA,0LAAI,UAAA,EAAQ,CAAC,CAAC,CAAA,CAAA,0LAAI,UAAA,EAAQ,CAAC,CAAC,EAAA;IACpC;IAEA,IAAI,SAAS;IAEb,IAAA,IAAS,IAAI,GAAG,MAAM,MAAM,GAAG,IAAI,KAAK,IAAK;QAC5C,IAAI,MAAA,CAAO,CAAC,CAAA,CAAE,KAAA;QACd,IAAI,MAAA,CAAO,IAAI,CAAC,CAAA,CAAE,KAAA;QAClB,kMAAU,UAAA,EAAQ,GAAG,CAAC;IACvB;IAEA,IAAI,QAAQ;QAEX,OAAO,CAAA,CAAA,0LAAI,UAAA,EAAQ,MAAA,CAAO,CAAC,CAAA,CAAE,KAAA,EAAO,MAAA,CAAO,CAAC,CAAA,CAAE,KAAK,CAAC,CAAA,CAAA,0LAAI,UAAA,EAAQ,MAAA,CAAO,CAAC,CAAA,CAAE,KAAK,CAAC,2LAAG,UAAA,EAClF,MAAA,CAAO,CAAC,CAAA,CAAE,KAAA,EACV,MAAA,CAAO,CAAC,CAAA,CAAE,KAAA,EACV,CAAA,EAAI,MAAM,2LAAG,UAAA,EAAQ,MAAA,CAAO,MAAM,CAAC,CAAA,CAAE,KAAA,EAAO,MAAA,CAAO,CAAC,CAAA,CAAE,KAAK,CAAC,2LAAG,UAAA,EAC/D,MAAA,CAAO,CAAC,CAAA,CAAE,KAAA,EACV,MAAA,CAAO,CAAC,CAAA,CAAE,KAAA,EACV,CAAA,CAAA;IACF,OAAO;QAIN,OAAO,CAAA,CAAA,0LAAI,UAAA,EAAQ,MAAA,CAAO,CAAC,CAAA,CAAE,KAAK,CAAC,CAAA,CAAA,GAAI,iMAAA,EAAQ,MAAA,CAAO,CAAC,CAAA,CAAE,KAAK,CAAC,2LAAG,UAAA,EACjE,MAAA,CAAO,CAAC,CAAA,CAAE,KAAA,EACV,MAAA,CAAO,CAAC,CAAA,CAAE,KAAA,IACP,OAAO,MAAA,GAAS,IAAI,MAAM,EAAE,GAAG,MAAM,CAAA,CAAA,0LAAI,UAAA,EAAQ,MAAA,CAAO,MAAM,CAAC,CAAA,CAAE,KAAK,CAAC,EAAA;IAC5E;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 9505, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/shared/freehand/svgInk.ts"],"sourcesContent":["import { Vec, VecLike, assert, average, precise, toDomPrecision } from '@tldraw/editor'\nimport { getStrokeOutlineTracks } from './getStrokeOutlinePoints'\nimport { getStrokePoints } from './getStrokePoints'\nimport { setStrokePointRadii } from './setStrokePointRadii'\nimport { StrokeOptions, StrokePoint } from './types'\n\nexport function svgInk(rawInputPoints: VecLike[], options: StrokeOptions = {}) {\n\tconst { start = {}, end = {} } = options\n\tconst { cap: capStart = true } = start\n\tconst { cap: capEnd = true } = end\n\tassert(!start.taper && !end.taper, 'cap taper not supported here')\n\tassert(!start.easing && !end.easing, 'cap easing not supported here')\n\tassert(capStart && capEnd, 'cap must be true')\n\n\tconst points = getStrokePoints(rawInputPoints, options)\n\tsetStrokePointRadii(points, options)\n\tconst partitions = partitionAtElbows(points)\n\tlet svg = ''\n\tfor (const partition of partitions) {\n\t\tsvg += renderPartition(partition, options)\n\t}\n\n\treturn svg\n}\n\nfunction partitionAtElbows(points: StrokePoint[]): StrokePoint[][] {\n\tif (points.length <= 2) return [points]\n\n\tconst result: StrokePoint[][] = []\n\tlet currentPartition: StrokePoint[] = [points[0]]\n\tlet prevV = Vec.Sub(points[1].point, points[0].point).uni()\n\tlet nextV: Vec\n\tlet dpr: number\n\tlet prevPoint: StrokePoint, thisPoint: StrokePoint, nextPoint: StrokePoint\n\tfor (let i = 1, n = points.length; i < n - 1; i++) {\n\t\tprevPoint = points[i - 1]\n\t\tthisPoint = points[i]\n\t\tnextPoint = points[i + 1]\n\n\t\tnextV = Vec.Sub(nextPoint.point, thisPoint.point).uni()\n\t\tdpr = Vec.Dpr(prevV, nextV)\n\t\tprevV = nextV\n\n\t\tif (dpr < -0.8) {\n\t\t\t// always treat such acute angles as elbows\n\t\t\t// and use the extended .input point as the elbow point for swooshiness in fast zaggy lines\n\t\t\tconst elbowPoint = {\n\t\t\t\t...thisPoint,\n\t\t\t\tpoint: thisPoint.input,\n\t\t\t}\n\t\t\tcurrentPartition.push(elbowPoint)\n\t\t\tresult.push(cleanUpPartition(currentPartition))\n\t\t\tcurrentPartition = [elbowPoint]\n\t\t\tcontinue\n\t\t}\n\t\tcurrentPartition.push(thisPoint)\n\n\t\tif (dpr > 0.7) {\n\t\t\t// Not an elbow\n\t\t\tcontinue\n\t\t}\n\n\t\t// so now we have a reasonably acute angle but it might not be an elbow if it's far\n\t\t// away from it's neighbors, angular dist is a normalized representation of how far away the point is from it's neighbors\n\t\t// (normalized by the radius)\n\t\tif (\n\t\t\t(Vec.Dist2(prevPoint.point, thisPoint.point) + Vec.Dist2(thisPoint.point, nextPoint.point)) /\n\t\t\t\t((prevPoint.radius + thisPoint.radius + nextPoint.radius) / 3) ** 2 <\n\t\t\t1.5\n\t\t) {\n\t\t\t// if this point is kinda close to its neighbors and it has a reasonably\n\t\t\t// acute angle, it's probably a hard elbow\n\t\t\tcurrentPartition.push(thisPoint)\n\t\t\tresult.push(cleanUpPartition(currentPartition))\n\t\t\tcurrentPartition = [thisPoint]\n\t\t\tcontinue\n\t\t}\n\t}\n\tcurrentPartition.push(points[points.length - 1])\n\tresult.push(cleanUpPartition(currentPartition))\n\n\treturn result\n}\n\nfunction cleanUpPartition(partition: StrokePoint[]) {\n\t// clean up start of partition (remove points that are too close to the start)\n\tconst startPoint = partition[0]\n\tlet nextPoint: StrokePoint\n\twhile (partition.length > 2) {\n\t\tnextPoint = partition[1]\n\t\tif (\n\t\t\tVec.Dist2(startPoint.point, nextPoint.point) <\n\t\t\t(((startPoint.radius + nextPoint.radius) / 2) * 0.5) ** 2\n\t\t) {\n\t\t\tpartition.splice(1, 1)\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\t// clean up end of partition in the same fashion\n\tconst endPoint = partition[partition.length - 1]\n\tlet prevPoint: StrokePoint\n\twhile (partition.length > 2) {\n\t\tprevPoint = partition[partition.length - 2]\n\t\tif (\n\t\t\tVec.Dist2(endPoint.point, prevPoint.point) <\n\t\t\t(((endPoint.radius + prevPoint.radius) / 2) * 0.5) ** 2\n\t\t) {\n\t\t\tpartition.splice(partition.length - 2, 1)\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\t// now readjust the cap point vectors to point to their nearest neighbors\n\tif (partition.length > 1) {\n\t\tpartition[0] = {\n\t\t\t...partition[0],\n\t\t\tvector: Vec.Sub(partition[0].point, partition[1].point).uni(),\n\t\t}\n\t\tpartition[partition.length - 1] = {\n\t\t\t...partition[partition.length - 1],\n\t\t\tvector: Vec.Sub(\n\t\t\t\tpartition[partition.length - 2].point,\n\t\t\t\tpartition[partition.length - 1].point\n\t\t\t).uni(),\n\t\t}\n\t}\n\treturn partition\n}\n\nfunction circlePath(cx: number, cy: number, r: number) {\n\treturn (\n\t\t'M ' +\n\t\tcx +\n\t\t' ' +\n\t\tcy +\n\t\t' m -' +\n\t\tr +\n\t\t', 0 a ' +\n\t\tr +\n\t\t',' +\n\t\tr +\n\t\t' 0 1,1 ' +\n\t\tr * 2 +\n\t\t',0 a ' +\n\t\tr +\n\t\t',' +\n\t\tr +\n\t\t' 0 1,1 -' +\n\t\tr * 2 +\n\t\t',0'\n\t)\n}\n\nfunction renderPartition(strokePoints: StrokePoint[], options: StrokeOptions = {}): string {\n\tif (strokePoints.length === 0) return ''\n\tif (strokePoints.length === 1) {\n\t\treturn circlePath(strokePoints[0].point.x, strokePoints[0].point.y, strokePoints[0].radius)\n\t}\n\n\tconst { left, right } = getStrokeOutlineTracks(strokePoints, options)\n\tright.reverse()\n\tlet svg = `M${precise(left[0])}T`\n\n\t// draw left track\n\tfor (let i = 1; i < left.length; i++) {\n\t\tsvg += average(left[i - 1], left[i])\n\t}\n\t// draw end cap arc\n\t{\n\t\tconst point = strokePoints[strokePoints.length - 1]\n\t\tconst radius = point.radius\n\t\tconst direction = point.vector.clone().per().neg()\n\t\tconst arcStart = Vec.Add(point.point, Vec.Mul(direction, radius))\n\t\tconst arcEnd = Vec.Add(point.point, Vec.Mul(direction, -radius))\n\t\tsvg += `${precise(arcStart)}A${toDomPrecision(radius)},${toDomPrecision(\n\t\t\tradius\n\t\t)} 0 0 1 ${precise(arcEnd)}T`\n\t}\n\t// draw right track\n\tfor (let i = 1; i < right.length; i++) {\n\t\tsvg += average(right[i - 1], right[i])\n\t}\n\t// draw start cap arc\n\t{\n\t\tconst point = strokePoints[0]\n\t\tconst radius = point.radius\n\t\tconst direction = point.vector.clone().per()\n\t\tconst arcStart = Vec.Add(point.point, Vec.Mul(direction, radius))\n\t\tconst arcEnd = Vec.Add(point.point, Vec.Mul(direction, -radius))\n\t\tsvg += `${precise(arcStart)}A${toDomPrecision(radius)},${toDomPrecision(\n\t\t\tradius\n\t\t)} 0 0 1 ${precise(arcEnd)}Z`\n\t}\n\treturn svg\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 9659, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/shared/interpolate-props.ts"],"sourcesContent":["import { TLDrawShapeSegment, VecModel, lerp } from '@tldraw/editor'\n\n/** @public */\nexport const interpolateSegments = (\n\tstartSegments: TLDrawShapeSegment[],\n\tendSegments: TLDrawShapeSegment[],\n\tprogress: number\n): TLDrawShapeSegment[] => {\n\tconst startPoints: VecModel[] = []\n\tconst endPoints: VecModel[] = []\n\n\t// Extract all points from startSegments and endSegments\n\tstartSegments.forEach((segment) => startPoints.push(...segment.points))\n\tendSegments.forEach((segment) => endPoints.push(...segment.points))\n\n\tconst maxLength = Math.max(startPoints.length, endPoints.length)\n\tconst pointsToUseStart: VecModel[] = []\n\tconst pointsToUseEnd: VecModel[] = []\n\n\t// Ensure both arrays have the same length\n\tfor (let i = 0; i < maxLength; i++) {\n\t\tpointsToUseStart.push(startPoints[i] || startPoints[startPoints.length - 1])\n\t\tpointsToUseEnd.push(endPoints[i] || endPoints[endPoints.length - 1])\n\t}\n\n\t// Interpolate points\n\tconst interpolatedPoints = pointsToUseStart.map((point, k) => {\n\t\tlet z = 0.5\n\t\tif (pointsToUseEnd[k].z !== undefined && point.z !== undefined) {\n\t\t\tz = lerp(point.z, pointsToUseEnd[k].z as number, progress)\n\t\t}\n\t\treturn {\n\t\t\tx: lerp(point.x, pointsToUseEnd[k].x, progress),\n\t\t\ty: lerp(point.y, pointsToUseEnd[k].y, progress),\n\t\t\tz,\n\t\t}\n\t})\n\t// Return all interpolated points in a single segment\n\treturn [\n\t\t{\n\t\t\ttype: 'free',\n\t\t\tpoints: interpolatedPoints,\n\t\t},\n\t]\n}\n"],"names":[],"mappings":";;;AAAA,SAAuC,YAAY;;;AAG5C,MAAM,sBAAsB,CAClC,eACA,aACA,aAC0B;IAC1B,MAAM,cAA0B,CAAC,CAAA;IACjC,MAAM,YAAwB,CAAC,CAAA;IAG/B,cAAc,OAAA,CAAQ,CAAC,UAAY,YAAY,IAAA,CAAK,GAAG,QAAQ,MAAM,CAAC;IACtE,YAAY,OAAA,CAAQ,CAAC,UAAY,UAAU,IAAA,CAAK,GAAG,QAAQ,MAAM,CAAC;IAElE,MAAM,YAAY,KAAK,GAAA,CAAI,YAAY,MAAA,EAAQ,UAAU,MAAM;IAC/D,MAAM,mBAA+B,CAAC,CAAA;IACtC,MAAM,iBAA6B,CAAC,CAAA;IAGpC,IAAA,IAAS,IAAI,GAAG,IAAI,WAAW,IAAK;QACnC,iBAAiB,IAAA,CAAK,WAAA,CAAY,CAAC,CAAA,IAAK,WAAA,CAAY,YAAY,MAAA,GAAS,CAAC,CAAC;QAC3E,eAAe,IAAA,CAAK,SAAA,CAAU,CAAC,CAAA,IAAK,SAAA,CAAU,UAAU,MAAA,GAAS,CAAC,CAAC;IACpE;IAGA,MAAM,qBAAqB,iBAAiB,GAAA,CAAI,CAAC,OAAO,MAAM;QAC7D,IAAI,IAAI;QACR,IAAI,cAAA,CAAe,CAAC,CAAA,CAAE,CAAA,KAAM,KAAA,KAAa,MAAM,CAAA,KAAM,KAAA,GAAW;YAC/D,8KAAI,OAAA,EAAK,MAAM,CAAA,EAAG,cAAA,CAAe,CAAC,CAAA,CAAE,CAAA,EAAa,QAAQ;QAC1D;QACA,OAAO;YACN,6KAAG,OAAA,EAAK,MAAM,CAAA,EAAG,cAAA,CAAe,CAAC,CAAA,CAAE,CAAA,EAAG,QAAQ;YAC9C,6KAAG,OAAA,EAAK,MAAM,CAAA,EAAG,cAAA,CAAe,CAAC,CAAA,CAAE,CAAA,EAAG,QAAQ;YAC9C;QACD;IACD,CAAC;IAED,OAAO;QACN;YACC,MAAM;YACN,QAAQ;QACT;KACD;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 9703, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/draw/getPath.ts"],"sourcesContent":["import {\n\tEASINGS,\n\tPI,\n\tSIN,\n\tTLDefaultDashStyle,\n\tTLDrawShape,\n\tTLDrawShapeSegment,\n\tVec,\n\tmodulate,\n} from '@tldraw/editor'\nimport { StrokeOptions } from '../shared/freehand/types'\n\nconst PEN_EASING = (t: number) => t * 0.65 + SIN((t * PI) / 2) * 0.35\n\nconst simulatePressureSettings = (strokeWidth: number): StrokeOptions => {\n\treturn {\n\t\tsize: strokeWidth,\n\t\tthinning: 0.5,\n\t\tstreamline: modulate(strokeWidth, [9, 16], [0.64, 0.74], true), // 0.62 + ((1 + strokeWidth) / 8) * 0.06,\n\t\tsmoothing: 0.62,\n\t\teasing: EASINGS.easeOutSine,\n\t\tsimulatePressure: true,\n\t}\n}\n\nconst realPressureSettings = (strokeWidth: number): StrokeOptions => {\n\treturn {\n\t\tsize: 1 + strokeWidth * 1.2,\n\t\tthinning: 0.62,\n\t\tstreamline: 0.62,\n\t\tsmoothing: 0.62,\n\t\tsimulatePressure: false,\n\t\teasing: PEN_EASING,\n\t}\n}\n\nconst solidSettings = (strokeWidth: number): StrokeOptions => {\n\treturn {\n\t\tsize: strokeWidth,\n\t\tthinning: 0,\n\t\tstreamline: modulate(strokeWidth, [9, 16], [0.64, 0.74], true), // 0.62 + ((1 + strokeWidth) / 8) * 0.06,\n\t\tsmoothing: 0.62,\n\t\tsimulatePressure: false,\n\t\teasing: EASINGS.linear,\n\t}\n}\n\nconst solidRealPressureSettings = (strokeWidth: number): StrokeOptions => {\n\treturn {\n\t\tsize: strokeWidth,\n\t\tthinning: 0,\n\t\tstreamline: 0.62,\n\t\tsmoothing: 0.62,\n\t\tsimulatePressure: false,\n\t\teasing: EASINGS.linear,\n\t}\n}\n\nexport function getHighlightFreehandSettings({\n\tstrokeWidth,\n\tshowAsComplete,\n}: {\n\tstrokeWidth: number\n\tshowAsComplete: boolean\n}): StrokeOptions {\n\treturn {\n\t\tsize: 1 + strokeWidth,\n\t\tthinning: 0,\n\t\tstreamline: 0.5,\n\t\tsmoothing: 0.5,\n\t\tsimulatePressure: false,\n\t\teasing: EASINGS.easeOutSine,\n\t\tlast: showAsComplete,\n\t}\n}\n\nexport function getFreehandOptions(\n\tshapeProps: { dash: TLDefaultDashStyle; isPen: boolean; isComplete: boolean },\n\tstrokeWidth: number,\n\tforceComplete: boolean,\n\tforceSolid: boolean\n): StrokeOptions {\n\tconst last = shapeProps.isComplete || forceComplete\n\n\tif (forceSolid) {\n\t\tif (shapeProps.isPen) {\n\t\t\treturn { ...solidRealPressureSettings(strokeWidth), last }\n\t\t} else {\n\t\t\treturn { ...solidSettings(strokeWidth), last }\n\t\t}\n\t}\n\n\tif (shapeProps.dash === 'draw') {\n\t\tif (shapeProps.isPen) {\n\t\t\treturn { ...realPressureSettings(strokeWidth), last }\n\t\t} else {\n\t\t\treturn { ...simulatePressureSettings(strokeWidth), last }\n\t\t}\n\t}\n\n\treturn { ...solidSettings(strokeWidth), last }\n}\n\nexport function getPointsFromSegments(segments: TLDrawShapeSegment[]) {\n\tconst points: Vec[] = []\n\n\tfor (const segment of segments) {\n\t\tif (segment.type === 'free' || segment.points.length < 2) {\n\t\t\tpoints.push(...segment.points.map(Vec.Cast))\n\t\t} else {\n\t\t\tconst pointsToInterpolate = Math.max(\n\t\t\t\t4,\n\t\t\t\tMath.floor(Vec.Dist(segment.points[0], segment.points[1]) / 16)\n\t\t\t)\n\t\t\tpoints.push(...Vec.PointsBetween(segment.points[0], segment.points[1], pointsToInterpolate))\n\t\t}\n\t}\n\n\treturn points\n}\n\nexport function getDrawShapeStrokeDashArray(\n\tshape: TLDrawShape,\n\tstrokeWidth: number,\n\tdotAdjustment: number\n) {\n\treturn {\n\t\tdraw: 'none',\n\t\tsolid: `none`,\n\t\tdotted: `${dotAdjustment} ${strokeWidth * 2}`,\n\t\tdashed: `${strokeWidth * 2} ${strokeWidth * 2}`,\n\t}[shape.props.dash]\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 9842, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/draw/DrawShapeUtil.tsx"],"sourcesContent":["import {\n\tBox,\n\tCircle2d,\n\tPolygon2d,\n\tPolyline2d,\n\tSVGContainer,\n\tShapeUtil,\n\tSvgExportContext,\n\tTLDrawShape,\n\tTLDrawShapeProps,\n\tTLDrawShapeSegment,\n\tTLResizeInfo,\n\tTLShapeUtilCanvasSvgDef,\n\tVecLike,\n\tdrawShapeMigrations,\n\tdrawShapeProps,\n\tlast,\n\tlerp,\n\trng,\n\ttoFixed,\n\tuseEditor,\n\tuseValue,\n} from '@tldraw/editor'\n\nimport { ShapeFill } from '../shared/ShapeFill'\nimport { STROKE_SIZES } from '../shared/default-shape-constants'\nimport { getFillDefForCanvas, getFillDefForExport } from '../shared/defaultStyleDefs'\nimport { getStrokePoints } from '../shared/freehand/getStrokePoints'\nimport { getSvgPathFromStrokePoints } from '../shared/freehand/svg'\nimport { svgInk } from '../shared/freehand/svgInk'\nimport { interpolateSegments } from '../shared/interpolate-props'\nimport { useDefaultColorTheme } from '../shared/useDefaultColorTheme'\nimport { getDrawShapeStrokeDashArray, getFreehandOptions, getPointsFromSegments } from './getPath'\n\n/** @public */\nexport interface DrawShapeOptions {\n\t/**\n\t * The maximum number of points in a line before the draw tool will begin a new shape.\n\t * A higher number will lead to poor performance while drawing very long lines.\n\t */\n\treadonly maxPointsPerShape: number\n}\n\n/** @public */\nexport class DrawShapeUtil extends ShapeUtil<TLDrawShape> {\n\tstatic override type = 'draw' as const\n\tstatic override props = drawShapeProps\n\tstatic override migrations = drawShapeMigrations\n\n\toverride options: DrawShapeOptions = {\n\t\tmaxPointsPerShape: 600,\n\t}\n\n\toverride hideResizeHandles(shape: TLDrawShape) {\n\t\treturn getIsDot(shape)\n\t}\n\toverride hideRotateHandle(shape: TLDrawShape) {\n\t\treturn getIsDot(shape)\n\t}\n\toverride hideSelectionBoundsFg(shape: TLDrawShape) {\n\t\treturn getIsDot(shape)\n\t}\n\n\toverride getDefaultProps(): TLDrawShape['props'] {\n\t\treturn {\n\t\t\tsegments: [],\n\t\t\tcolor: 'black',\n\t\t\tfill: 'none',\n\t\t\tdash: 'draw',\n\t\t\tsize: 'm',\n\t\t\tisComplete: false,\n\t\t\tisClosed: false,\n\t\t\tisPen: false,\n\t\t\tscale: 1,\n\t\t}\n\t}\n\n\tgetGeometry(shape: TLDrawShape) {\n\t\tconst points = getPointsFromSegments(shape.props.segments)\n\n\t\tconst sw = (STROKE_SIZES[shape.props.size] + 1) * shape.props.scale\n\n\t\t// A dot\n\t\tif (shape.props.segments.length === 1) {\n\t\t\tconst box = Box.FromPoints(points)\n\t\t\tif (box.width < sw * 2 && box.height < sw * 2) {\n\t\t\t\treturn new Circle2d({\n\t\t\t\t\tx: -sw,\n\t\t\t\t\ty: -sw,\n\t\t\t\t\tradius: sw,\n\t\t\t\t\tisFilled: true,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\tconst strokePoints = getStrokePoints(\n\t\t\tpoints,\n\t\t\tgetFreehandOptions(shape.props, sw, shape.props.isPen, true)\n\t\t).map((p) => p.point)\n\n\t\t// A closed draw stroke\n\t\tif (shape.props.isClosed && strokePoints.length > 2) {\n\t\t\treturn new Polygon2d({\n\t\t\t\tpoints: strokePoints,\n\t\t\t\tisFilled: shape.props.fill !== 'none',\n\t\t\t})\n\t\t}\n\n\t\tif (strokePoints.length === 1) {\n\t\t\treturn new Circle2d({\n\t\t\t\tx: -sw,\n\t\t\t\ty: -sw,\n\t\t\t\tradius: sw,\n\t\t\t\tisFilled: true,\n\t\t\t})\n\t\t}\n\n\t\t// An open draw stroke\n\t\treturn new Polyline2d({\n\t\t\tpoints: strokePoints,\n\t\t})\n\t}\n\n\tcomponent(shape: TLDrawShape) {\n\t\treturn (\n\t\t\t<SVGContainer>\n\t\t\t\t<DrawShapeSvg shape={shape} />\n\t\t\t</SVGContainer>\n\t\t)\n\t}\n\n\tindicator(shape: TLDrawShape) {\n\t\tconst allPointsFromSegments = getPointsFromSegments(shape.props.segments)\n\n\t\tlet sw = (STROKE_SIZES[shape.props.size] + 1) * shape.props.scale\n\n\t\t// eslint-disable-next-line react-hooks/rules-of-hooks\n\t\tconst forceSolid = useValue(\n\t\t\t'force solid',\n\t\t\t() => {\n\t\t\t\tconst zoomLevel = this.editor.getZoomLevel()\n\t\t\t\treturn zoomLevel < 0.5 && zoomLevel < 1.5 / sw\n\t\t\t},\n\t\t\t[this.editor, sw]\n\t\t)\n\n\t\tif (\n\t\t\t!forceSolid &&\n\t\t\t!shape.props.isPen &&\n\t\t\tshape.props.dash === 'draw' &&\n\t\t\tallPointsFromSegments.length === 1\n\t\t) {\n\t\t\tsw += rng(shape.id)() * (sw / 6)\n\t\t}\n\n\t\tconst showAsComplete = shape.props.isComplete || last(shape.props.segments)?.type === 'straight'\n\t\tconst options = getFreehandOptions(shape.props, sw, showAsComplete, true)\n\t\tconst strokePoints = getStrokePoints(allPointsFromSegments, options)\n\t\tconst solidStrokePath =\n\t\t\tstrokePoints.length > 1\n\t\t\t\t? getSvgPathFromStrokePoints(strokePoints, shape.props.isClosed)\n\t\t\t\t: getDot(allPointsFromSegments[0], sw)\n\n\t\treturn <path d={solidStrokePath} />\n\t}\n\n\toverride toSvg(shape: TLDrawShape, ctx: SvgExportContext) {\n\t\tctx.addExportDef(getFillDefForExport(shape.props.fill))\n\t\tconst scaleFactor = 1 / shape.props.scale\n\t\treturn (\n\t\t\t<g transform={`scale(${scaleFactor})`}>\n\t\t\t\t<DrawShapeSvg shape={shape} zoomOverride={1} />\n\t\t\t</g>\n\t\t)\n\t}\n\n\toverride getCanvasSvgDefs(): TLShapeUtilCanvasSvgDef[] {\n\t\treturn [getFillDefForCanvas()]\n\t}\n\n\toverride onResize(shape: TLDrawShape, info: TLResizeInfo<TLDrawShape>) {\n\t\tconst { scaleX, scaleY } = info\n\n\t\tconst newSegments: TLDrawShapeSegment[] = []\n\n\t\tfor (const segment of shape.props.segments) {\n\t\t\tnewSegments.push({\n\t\t\t\t...segment,\n\t\t\t\tpoints: segment.points.map(({ x, y, z }) => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tx: toFixed(scaleX * x),\n\t\t\t\t\t\ty: toFixed(scaleY * y),\n\t\t\t\t\t\tz,\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t})\n\t\t}\n\n\t\treturn {\n\t\t\tprops: {\n\t\t\t\tsegments: newSegments,\n\t\t\t},\n\t\t}\n\t}\n\n\toverride expandSelectionOutlinePx(shape: TLDrawShape): number {\n\t\tconst multiplier = shape.props.dash === 'draw' ? 1.6 : 1\n\t\treturn ((STROKE_SIZES[shape.props.size] * multiplier) / 2) * shape.props.scale\n\t}\n\toverride getInterpolatedProps(\n\t\tstartShape: TLDrawShape,\n\t\tendShape: TLDrawShape,\n\t\tt: number\n\t): TLDrawShapeProps {\n\t\treturn {\n\t\t\t...(t > 0.5 ? endShape.props : startShape.props),\n\t\t\tsegments: interpolateSegments(startShape.props.segments, endShape.props.segments, t),\n\t\t\tscale: lerp(startShape.props.scale, endShape.props.scale, t),\n\t\t}\n\t}\n}\n\nfunction getDot(point: VecLike, sw: number) {\n\tconst r = (sw + 1) * 0.5\n\treturn `M ${point.x} ${point.y} m -${r}, 0 a ${r},${r} 0 1,0 ${r * 2},0 a ${r},${r} 0 1,0 -${\n\t\tr * 2\n\t},0`\n}\n\nfunction getIsDot(shape: TLDrawShape) {\n\treturn shape.props.segments.length === 1 && shape.props.segments[0].points.length < 2\n}\n\nfunction DrawShapeSvg({ shape, zoomOverride }: { shape: TLDrawShape; zoomOverride?: number }) {\n\tconst theme = useDefaultColorTheme()\n\tconst editor = useEditor()\n\n\tconst allPointsFromSegments = getPointsFromSegments(shape.props.segments)\n\n\tconst showAsComplete = shape.props.isComplete || last(shape.props.segments)?.type === 'straight'\n\n\tlet sw = (STROKE_SIZES[shape.props.size] + 1) * shape.props.scale\n\tconst forceSolid = useValue(\n\t\t'force solid',\n\t\t() => {\n\t\t\tconst zoomLevel = zoomOverride ?? editor.getZoomLevel()\n\t\t\treturn zoomLevel < 0.5 && zoomLevel < 1.5 / sw\n\t\t},\n\t\t[editor, sw, zoomOverride]\n\t)\n\n\tconst dotAdjustment = useValue(\n\t\t'dot adjustment',\n\t\t() => {\n\t\t\tconst zoomLevel = zoomOverride ?? editor.getZoomLevel()\n\t\t\t// If we're zoomed way out (10%), then we need to make the dotted line go to 9 instead 0.1\n\t\t\t// Chrome doesn't render anything otherwise.\n\t\t\treturn zoomLevel < 0.2 ? 0 : 0.1\n\t\t},\n\t\t[editor, zoomOverride]\n\t)\n\n\tif (\n\t\t!forceSolid &&\n\t\t!shape.props.isPen &&\n\t\tshape.props.dash === 'draw' &&\n\t\tallPointsFromSegments.length === 1\n\t) {\n\t\tsw += rng(shape.id)() * (sw / 6)\n\t}\n\n\tconst options = getFreehandOptions(shape.props, sw, showAsComplete, forceSolid)\n\n\tif (!forceSolid && shape.props.dash === 'draw') {\n\t\treturn (\n\t\t\t<>\n\t\t\t\t{shape.props.isClosed && shape.props.fill && allPointsFromSegments.length > 1 ? (\n\t\t\t\t\t<ShapeFill\n\t\t\t\t\t\td={getSvgPathFromStrokePoints(\n\t\t\t\t\t\t\tgetStrokePoints(allPointsFromSegments, options),\n\t\t\t\t\t\t\tshape.props.isClosed\n\t\t\t\t\t\t)}\n\t\t\t\t\t\ttheme={theme}\n\t\t\t\t\t\tcolor={shape.props.color}\n\t\t\t\t\t\tfill={shape.props.isClosed ? shape.props.fill : 'none'}\n\t\t\t\t\t\tscale={shape.props.scale}\n\t\t\t\t\t/>\n\t\t\t\t) : null}\n\t\t\t\t<path\n\t\t\t\t\td={svgInk(allPointsFromSegments, options)}\n\t\t\t\t\tstrokeLinecap=\"round\"\n\t\t\t\t\tfill={theme[shape.props.color].solid}\n\t\t\t\t/>\n\t\t\t</>\n\t\t)\n\t}\n\n\tconst strokePoints = getStrokePoints(allPointsFromSegments, options)\n\tconst isDot = strokePoints.length < 2\n\tconst solidStrokePath = isDot\n\t\t? getDot(allPointsFromSegments[0], 0)\n\t\t: getSvgPathFromStrokePoints(strokePoints, shape.props.isClosed)\n\n\treturn (\n\t\t<>\n\t\t\t<ShapeFill\n\t\t\t\td={solidStrokePath}\n\t\t\t\ttheme={theme}\n\t\t\t\tcolor={shape.props.color}\n\t\t\t\tfill={isDot || shape.props.isClosed ? shape.props.fill : 'none'}\n\t\t\t\tscale={shape.props.scale}\n\t\t\t/>\n\t\t\t<path\n\t\t\t\td={solidStrokePath}\n\t\t\t\tstrokeLinecap=\"round\"\n\t\t\t\tfill={isDot ? theme[shape.props.color].solid : 'none'}\n\t\t\t\tstroke={theme[shape.props.color].solid}\n\t\t\t\tstrokeWidth={sw}\n\t\t\t\tstrokeDasharray={isDot ? 'none' : getDrawShapeStrokeDashArray(shape, sw, dotAdjustment)}\n\t\t\t\tstrokeDashoffset=\"0\"\n\t\t\t/>\n\t\t</>\n\t)\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 10106, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/embed/EmbedShapeUtil.tsx"],"sourcesContent":["/* eslint-disable react-hooks/rules-of-hooks */\n\nimport {\n\tBaseBoxShapeUtil,\n\tHTMLContainer,\n\tTLEmbedShape,\n\tTLEmbedShapeProps,\n\tTLResizeInfo,\n\tembedShapeMigrations,\n\tembedShapeProps,\n\tlerp,\n\tresizeBox,\n\ttoDomPrecision,\n\tuseIsEditing,\n\tuseSvgExportContext,\n\tuseValue,\n} from '@tldraw/editor'\n\nimport {\n\tDEFAULT_EMBED_DEFINITIONS,\n\tEmbedDefinition,\n\tTLEmbedDefinition,\n\tTLEmbedShapePermissions,\n\tembedShapePermissionDefaults,\n} from '../../defaultEmbedDefinitions'\nimport { TLEmbedResult, getEmbedInfo } from '../../utils/embeds/embeds'\nimport { getRotatedBoxShadow } from '../shared/rotated-box-shadow'\n\nconst getSandboxPermissions = (permissions: TLEmbedShapePermissions) => {\n\treturn Object.entries(permissions)\n\t\t.filter(([_perm, isEnabled]) => isEnabled)\n\t\t.map(([perm]) => perm)\n\t\t.join(' ')\n}\n\n/** @public */\nexport class EmbedShapeUtil extends BaseBoxShapeUtil<TLEmbedShape> {\n\tstatic override type = 'embed' as const\n\tstatic override props = embedShapeProps\n\tstatic override migrations = embedShapeMigrations\n\tprivate static embedDefinitions: readonly EmbedDefinition[] = DEFAULT_EMBED_DEFINITIONS\n\n\tstatic setEmbedDefinitions(embedDefinitions: readonly TLEmbedDefinition[]) {\n\t\tEmbedShapeUtil.embedDefinitions = embedDefinitions\n\t}\n\n\tgetEmbedDefinitions(): readonly TLEmbedDefinition[] {\n\t\treturn EmbedShapeUtil.embedDefinitions\n\t}\n\n\tgetEmbedDefinition(url: string): TLEmbedResult {\n\t\treturn getEmbedInfo(EmbedShapeUtil.embedDefinitions, url)\n\t}\n\n\toverride getText(shape: TLEmbedShape) {\n\t\treturn shape.props.url\n\t}\n\n\toverride getAriaDescriptor(shape: TLEmbedShape) {\n\t\tconst embedInfo = this.getEmbedDefinition(shape.props.url)\n\t\treturn embedInfo?.definition.title\n\t}\n\n\toverride hideSelectionBoundsFg(shape: TLEmbedShape) {\n\t\treturn !this.canResize(shape)\n\t}\n\toverride canEdit() {\n\t\treturn true\n\t}\n\toverride canResize(shape: TLEmbedShape) {\n\t\treturn !!this.getEmbedDefinition(shape.props.url)?.definition?.doesResize\n\t}\n\toverride canEditInReadonly() {\n\t\treturn true\n\t}\n\n\toverride getDefaultProps(): TLEmbedShape['props'] {\n\t\treturn {\n\t\t\tw: 300,\n\t\t\th: 300,\n\t\t\turl: '',\n\t\t}\n\t}\n\n\toverride isAspectRatioLocked(shape: TLEmbedShape) {\n\t\tconst embedInfo = this.getEmbedDefinition(shape.props.url)\n\t\treturn embedInfo?.definition.isAspectRatioLocked ?? false\n\t}\n\n\toverride onResize(shape: TLEmbedShape, info: TLResizeInfo<TLEmbedShape>) {\n\t\tconst isAspectRatioLocked = this.isAspectRatioLocked(shape)\n\t\tconst embedInfo = this.getEmbedDefinition(shape.props.url)\n\t\tlet minWidth = embedInfo?.definition.minWidth ?? 200\n\t\tlet minHeight = embedInfo?.definition.minHeight ?? 200\n\t\tif (isAspectRatioLocked) {\n\t\t\t// Enforce aspect ratio\n\t\t\t// Neither the width or height can be less than 200\n\t\t\tconst aspectRatio = shape.props.w / shape.props.h\n\t\t\tif (aspectRatio > 1) {\n\t\t\t\t// Landscape\n\t\t\t\tminWidth *= aspectRatio\n\t\t\t} else {\n\t\t\t\t// Portrait\n\t\t\t\tminHeight /= aspectRatio\n\t\t\t}\n\t\t}\n\n\t\treturn resizeBox(shape, info, { minWidth, minHeight })\n\t}\n\n\toverride component(shape: TLEmbedShape) {\n\t\tconst svgExport = useSvgExportContext()\n\t\tconst { w, h, url } = shape.props\n\t\tconst isEditing = useIsEditing(shape.id)\n\n\t\tconst embedInfo = this.getEmbedDefinition(url)\n\n\t\tconst isHoveringWhileEditingSameShape = useValue(\n\t\t\t'is hovering',\n\t\t\t() => {\n\t\t\t\tconst { editingShapeId, hoveredShapeId } = this.editor.getCurrentPageState()\n\n\t\t\t\tif (editingShapeId && hoveredShapeId !== editingShapeId) {\n\t\t\t\t\tconst editingShape = this.editor.getShape(editingShapeId)\n\t\t\t\t\tif (editingShape && this.editor.isShapeOfType<TLEmbedShape>(editingShape, 'embed')) {\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn false\n\t\t\t},\n\t\t\t[]\n\t\t)\n\n\t\tconst pageRotation = this.editor.getShapePageTransform(shape)!.rotation()\n\n\t\tif (svgExport) {\n\t\t\t// for SVG exports, we show a blank embed\n\t\t\treturn (\n\t\t\t\t<HTMLContainer className=\"tl-embed-container\" id={shape.id}>\n\t\t\t\t\t<div\n\t\t\t\t\t\tclassName=\"tl-embed\"\n\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\tborder: 0,\n\t\t\t\t\t\t\tboxShadow: getRotatedBoxShadow(pageRotation),\n\t\t\t\t\t\t\tborderRadius: embedInfo?.definition.overrideOutlineRadius ?? 8,\n\t\t\t\t\t\t\tbackground: embedInfo?.definition.backgroundColor ?? 'var(--color-background)',\n\t\t\t\t\t\t\twidth: w,\n\t\t\t\t\t\t\theight: h,\n\t\t\t\t\t\t}}\n\t\t\t\t\t/>\n\t\t\t\t</HTMLContainer>\n\t\t\t)\n\t\t}\n\n\t\tconst isInteractive = isEditing || isHoveringWhileEditingSameShape\n\n\t\t// Prevent nested embedding of tldraw\n\t\tconst isIframe =\n\t\t\ttypeof window !== 'undefined' && (window !== window.top || window.self !== window.parent)\n\t\tif (isIframe && embedInfo?.definition.type === 'tldraw') return null\n\n\t\tif (embedInfo?.definition.type === 'github_gist') {\n\t\t\tconst idFromGistUrl = embedInfo.url.split('/').pop()\n\t\t\tif (!idFromGistUrl) throw Error('No gist id!')\n\n\t\t\treturn (\n\t\t\t\t<HTMLContainer className=\"tl-embed-container\" id={shape.id}>\n\t\t\t\t\t<Gist\n\t\t\t\t\t\tid={idFromGistUrl}\n\t\t\t\t\t\twidth={toDomPrecision(w)!}\n\t\t\t\t\t\theight={toDomPrecision(h)!}\n\t\t\t\t\t\tisInteractive={isInteractive}\n\t\t\t\t\t\tpageRotation={pageRotation}\n\t\t\t\t\t/>\n\t\t\t\t</HTMLContainer>\n\t\t\t)\n\t\t}\n\n\t\tconst sandbox = getSandboxPermissions({\n\t\t\t...embedShapePermissionDefaults,\n\t\t\t...(embedInfo?.definition.overridePermissions ?? {}),\n\t\t})\n\n\t\treturn (\n\t\t\t<HTMLContainer className=\"tl-embed-container\" id={shape.id}>\n\t\t\t\t{embedInfo?.definition ? (\n\t\t\t\t\t<iframe\n\t\t\t\t\t\tclassName=\"tl-embed\"\n\t\t\t\t\t\tsandbox={sandbox}\n\t\t\t\t\t\tsrc={embedInfo.embedUrl}\n\t\t\t\t\t\twidth={toDomPrecision(w)}\n\t\t\t\t\t\theight={toDomPrecision(h)}\n\t\t\t\t\t\tdraggable={false}\n\t\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-deprecated\n\t\t\t\t\t\tframeBorder=\"0\"\n\t\t\t\t\t\treferrerPolicy=\"no-referrer-when-downgrade\"\n\t\t\t\t\t\ttabIndex={isEditing ? 0 : -1}\n\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\tborder: 0,\n\t\t\t\t\t\t\tpointerEvents: isInteractive ? 'auto' : 'none',\n\t\t\t\t\t\t\t// Fix for safari <https://stackoverflow.com/a/49150908>\n\t\t\t\t\t\t\tzIndex: isInteractive ? '' : '-1',\n\t\t\t\t\t\t\tboxShadow: getRotatedBoxShadow(pageRotation),\n\t\t\t\t\t\t\tborderRadius: embedInfo?.definition.overrideOutlineRadius ?? 8,\n\t\t\t\t\t\t\tbackground: embedInfo?.definition.backgroundColor,\n\t\t\t\t\t\t}}\n\t\t\t\t\t/>\n\t\t\t\t) : null}\n\t\t\t</HTMLContainer>\n\t\t)\n\t}\n\n\toverride indicator(shape: TLEmbedShape) {\n\t\tconst embedInfo = this.getEmbedDefinition(shape.props.url)\n\t\treturn (\n\t\t\t<rect\n\t\t\t\twidth={toDomPrecision(shape.props.w)}\n\t\t\t\theight={toDomPrecision(shape.props.h)}\n\t\t\t\trx={embedInfo?.definition.overrideOutlineRadius ?? 8}\n\t\t\t\try={embedInfo?.definition.overrideOutlineRadius ?? 8}\n\t\t\t/>\n\t\t)\n\t}\n\toverride getInterpolatedProps(\n\t\tstartShape: TLEmbedShape,\n\t\tendShape: TLEmbedShape,\n\t\tt: number\n\t): TLEmbedShapeProps {\n\t\treturn {\n\t\t\t...(t > 0.5 ? endShape.props : startShape.props),\n\t\t\tw: lerp(startShape.props.w, endShape.props.w, t),\n\t\t\th: lerp(startShape.props.h, endShape.props.h, t),\n\t\t}\n\t}\n}\n\nfunction Gist({\n\tid,\n\tisInteractive,\n\twidth,\n\theight,\n\tstyle,\n\tpageRotation,\n}: {\n\tid: string\n\tisInteractive: boolean\n\twidth: number\n\theight: number\n\tpageRotation: number\n\tstyle?: React.CSSProperties\n}) {\n\t// Security warning:\n\t// Gists allow adding .json extensions to the URL which return JSONP.\n\t// Furthermore, the JSONP can include callbacks that execute arbitrary JavaScript.\n\t// It _is_ sandboxed by the iframe but we still want to disable it nonetheless.\n\t// We restrict the id to only allow hexdecimal characters to prevent this.\n\t// Read more:\n\t//   https://github.com/bhaveshk90/Content-Security-Policy-CSP-Bypass-Techniques\n\t//   https://github.com/renniepak/CSPBypass\n\tif (!id.match(/^[0-9a-f]+$/)) throw Error('No gist id!')\n\n\treturn (\n\t\t<iframe\n\t\t\tclassName=\"tl-embed\"\n\t\t\tdraggable={false}\n\t\t\twidth={toDomPrecision(width)}\n\t\t\theight={toDomPrecision(height)}\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-deprecated\n\t\t\tframeBorder=\"0\"\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-deprecated\n\t\t\tscrolling=\"no\"\n\t\t\treferrerPolicy=\"no-referrer-when-downgrade\"\n\t\t\ttabIndex={isInteractive ? 0 : -1}\n\t\t\tstyle={{\n\t\t\t\t...style,\n\t\t\t\tpointerEvents: isInteractive ? 'all' : 'none',\n\t\t\t\t// Fix for safari <https://stackoverflow.com/a/49150908>\n\t\t\t\tzIndex: isInteractive ? '' : '-1',\n\t\t\t\tboxShadow: getRotatedBoxShadow(pageRotation),\n\t\t\t}}\n\t\t\tsrcDoc={`\n\t\t\t<html>\n\t\t\t\t<head>\n\t\t\t\t\t<base target=\"_blank\">\n\t\t\t\t</head>\n\t\t\t\t<body>\n\t\t\t\t\t<script src=${`https://gist.github.com/${id}.js`}></script>\n\t\t\t\t\t<style type=\"text/css\">\n\t\t\t\t\t\t* { margin: 0px; }\n\t\t\t\t\t\ttable { height: 100%; background-color: red; }\n\t\t\t\t\t\t.gist { background-color: none; height: 100%;  }\n\t\t\t\t\t\t.gist .gist-file { height: calc(100vh - 2px); padding: 0px; display: grid; grid-template-rows: 1fr auto; }\n\t\t\t\t\t</style>\n\t\t\t\t</body>\n\t\t\t</html>`}\n\t\t/>\n\t)\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 10335, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/frame/frameHelpers.ts"],"sourcesContent":["import {\n\tBox,\n\tEditor,\n\tTLFrameShape,\n\tcanonicalizeRotation,\n\tlast,\n\ttoDomPrecision,\n} from '@tldraw/editor'\nimport { TLCreateTextJsxFromSpansOpts } from '../shared/createTextJsxFromSpans'\nimport { defaultEmptyAs } from './FrameShapeUtil'\n\nexport function getFrameHeadingSide(editor: Editor, shape: TLFrameShape): 0 | 1 | 2 | 3 {\n\tconst pageRotation = canonicalizeRotation(editor.getShapePageTransform(shape.id)!.rotation())\n\tconst offsetRotation = pageRotation + Math.PI / 4\n\tconst scaledRotation = (offsetRotation * (2 / Math.PI) + 4) % 4\n\treturn Math.floor(scaledRotation) as 0 | 1 | 2 | 3\n}\n\n/**\n * We use a weak map here to prevent re-measuring the text width of frames that haven't changed their names.\n * It's only really important for performance reasons while zooming in and out. The measured text size is\n * independent of the zoom level, so we can cache the expensive part (measurement) and apply those changes\n * using the zoom level.\n */\nconst measurementWeakmap = new WeakMap()\n\n/**\n * Get the frame heading info (size and text) for a frame shape.\n *\n * @param editor The editor instance.\n * @param shape The frame shape.\n * @param opts The text measurement options.\n *\n * @returns The frame heading's size (as a Box) and JSX text spans.\n */\nexport function getFrameHeadingSize(\n\teditor: Editor,\n\tshape: TLFrameShape,\n\topts: TLCreateTextJsxFromSpansOpts\n) {\n\tif (process.env.NODE_ENV === 'test') {\n\t\t// can't really measure text in tests\n\t\treturn new Box(0, -opts.height, shape.props.w, opts.height)\n\t}\n\n\tlet width = measurementWeakmap.get(shape.props)\n\tif (!width) {\n\t\tconst frameTitle = defaultEmptyAs(shape.props.name, 'Frame') + String.fromCharCode(8203)\n\t\tconst spans = editor.textMeasure.measureTextSpans(frameTitle, opts)\n\t\tconst firstSpan = spans[0]\n\t\tconst lastSpan = last(spans)!\n\n\t\twidth = lastSpan.box.w + lastSpan.box.x - firstSpan.box.x\n\t\tmeasurementWeakmap.set(shape.props, width)\n\t}\n\n\treturn new Box(0, -opts.height, width, opts.height)\n}\n\nexport function getFrameHeadingOpts(width: number, isSvg: boolean): TLCreateTextJsxFromSpansOpts {\n\treturn {\n\t\tfontSize: 12,\n\t\tfontFamily: isSvg ? 'Arial' : 'Inter, sans-serif',\n\t\ttextAlign: 'start' as const,\n\t\twidth: width,\n\t\theight: 24, // --frame-height\n\t\tpadding: 0,\n\t\tlineHeight: 1,\n\t\tfontStyle: 'normal',\n\t\tfontWeight: 'normal',\n\t\toverflow: 'truncate-ellipsis' as const,\n\t\tverticalTextAlign: 'middle' as const,\n\t\toffsetY: -(32 + 2), // --frame-minimum-height + (border width * 2)\n\t\toffsetX: 0,\n\t}\n}\n\nexport function getFrameHeadingTranslation(\n\tshape: TLFrameShape,\n\tside: 0 | 1 | 2 | 3,\n\tisSvg: boolean\n) {\n\tconst u = isSvg ? '' : 'px'\n\tconst r = isSvg ? '' : 'deg'\n\tlet labelTranslate: string\n\tswitch (side) {\n\t\tcase 0: // top\n\t\t\tlabelTranslate = ``\n\t\t\tbreak\n\t\tcase 3: // right\n\t\t\tlabelTranslate = `translate(${toDomPrecision(shape.props.w)}${u}, 0${u}) rotate(90${r})`\n\t\t\tbreak\n\t\tcase 2: // bottom\n\t\t\tlabelTranslate = `translate(${toDomPrecision(shape.props.w)}${u}, ${toDomPrecision(\n\t\t\t\tshape.props.h\n\t\t\t)}${u}) rotate(180${r})`\n\t\t\tbreak\n\t\tcase 1: // left\n\t\t\tlabelTranslate = `translate(0${u}, ${toDomPrecision(shape.props.h)}${u}) rotate(270${r})`\n\t\t\tbreak\n\t\tdefault:\n\t\t\tthrow Error('labelSide out of bounds')\n\t}\n\n\treturn labelTranslate\n}\n"],"names":[],"mappings":";;;;;;AAwCK,QAAQ,IAAI,aAAa;AAxC9B;;;;AASA,SAAS,sBAAsB;;;AAExB,SAAS,oBAAoB,MAAA,EAAgB,KAAA,EAAoC;IACvF,MAAM,uMAAe,uBAAA,EAAqB,OAAO,qBAAA,CAAsB,MAAM,EAAE,EAAG,QAAA,CAAS,CAAC;IAC5F,MAAM,iBAAiB,eAAe,KAAK,EAAA,GAAK;IAChD,MAAM,iBAAA,CAAkB,iBAAA,CAAkB,IAAI,KAAK,EAAA,IAAM,CAAA,IAAK;IAC9D,OAAO,KAAK,KAAA,CAAM,cAAc;AACjC;AAQA,MAAM,qBAAqB,aAAA,GAAA,IAAI,QAAQ;AAWhC,SAAS,oBACf,MAAA,EACA,KAAA,EACA,IAAA,EACC;IACD,uCAAqC;;IAGrC;IAEA,IAAI,QAAQ,mBAAmB,GAAA,CAAI,MAAM,KAAK;IAC9C,IAAI,CAAC,OAAO;QACX,MAAM,cAAa,0MAAA,EAAe,MAAM,KAAA,CAAM,IAAA,EAAM,OAAO,IAAI,OAAO,YAAA,CAAa,IAAI;QACvF,MAAM,QAAQ,OAAO,WAAA,CAAY,gBAAA,CAAiB,YAAY,IAAI;QAClE,MAAM,YAAY,KAAA,CAAM,CAAC,CAAA;QACzB,MAAM,oLAAW,OAAA,EAAK,KAAK;QAE3B,QAAQ,SAAS,GAAA,CAAI,CAAA,GAAI,SAAS,GAAA,CAAI,CAAA,GAAI,UAAU,GAAA,CAAI,CAAA;QACxD,mBAAmB,GAAA,CAAI,MAAM,KAAA,EAAO,KAAK;IAC1C;IAEA,OAAO,qLAAI,OAAA,CAAI,GAAG,CAAC,KAAK,MAAA,EAAQ,OAAO,KAAK,MAAM;AACnD;AAEO,SAAS,oBAAoB,KAAA,EAAe,KAAA,EAA8C;IAChG,OAAO;QACN,UAAU;QACV,YAAY,QAAQ,UAAU;QAC9B,WAAW;QACX;QACA,QAAQ;QAAA,iBAAA;QACR,SAAS;QACT,YAAY;QACZ,WAAW;QACX,YAAY;QACZ,UAAU;QACV,mBAAmB;QACnB,SAAS,CAAA,CAAE,KAAK,CAAA;QAAA,8CAAA;QAChB,SAAS;IACV;AACD;AAEO,SAAS,2BACf,KAAA,EACA,IAAA,EACA,KAAA,EACC;IACD,MAAM,IAAI,QAAQ,KAAK;IACvB,MAAM,IAAI,QAAQ,KAAK;IACvB,IAAI;IACJ,OAAQ,MAAM;QACb,KAAK;YACJ,iBAAiB,EAAA;YACjB;QACD,KAAK;YACJ,iBAAiB,CAAA,UAAA,0LAAa,iBAAA,EAAe,MAAM,KAAA,CAAM,CAAC,CAAC,GAAG,CAAC,CAAA,GAAA,EAAM,CAAC,CAAA,WAAA,EAAc,CAAC,CAAA,CAAA,CAAA;YACrF;QACD,KAAK;YACJ,iBAAiB,CAAA,UAAA,GAAa,wMAAA,EAAe,MAAM,KAAA,CAAM,CAAC,CAAC,GAAG,CAAC,CAAA,EAAA,0LAAK,iBAAA,EACnE,MAAM,KAAA,CAAM,CAAA,IACT,CAAC,CAAA,YAAA,EAAe,CAAC,CAAA,CAAA,CAAA;YACrB;QACD,KAAK;YACJ,iBAAiB,CAAA,WAAA,EAAc,CAAC,CAAA,EAAA,0LAAK,iBAAA,EAAe,MAAM,KAAA,CAAM,CAAC,CAAC,GAAG,CAAC,CAAA,YAAA,EAAe,CAAC,CAAA,CAAA,CAAA;YACtF;QACD;YACC,MAAM,MAAM,yBAAyB;IACvC;IAEA,OAAO;AACR","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 10420, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/frame/components/FrameLabelInput.tsx"],"sourcesContent":["import { TLFrameShape, TLShapeId, stopEventPropagation, useEditor } from '@tldraw/editor'\nimport { forwardRef, useCallback } from 'react'\nimport { defaultEmptyAs } from '../FrameShapeUtil'\n\nexport const FrameLabelInput = forwardRef<\n\tHTMLInputElement,\n\t{ id: TLShapeId; name: string; isEditing: boolean }\n>(({ id, name, isEditing }, ref) => {\n\tconst editor = useEditor()\n\n\tconst handleKeyDown = useCallback(\n\t\t(e: React.KeyboardEvent<HTMLInputElement>) => {\n\t\t\tif (e.key === 'Enter' && !e.nativeEvent.isComposing) {\n\t\t\t\t// need to prevent the enter keydown making it's way up to the Idle state\n\t\t\t\t// and sending us back into edit mode\n\t\t\t\tstopEventPropagation(e)\n\t\t\t\te.currentTarget.blur()\n\t\t\t\teditor.setEditingShape(null)\n\t\t\t}\n\t\t},\n\t\t[editor]\n\t)\n\n\tconst handleBlur = useCallback(\n\t\t(e: React.FocusEvent<HTMLInputElement>) => {\n\t\t\tconst shape = editor.getShape<TLFrameShape>(id)\n\t\t\tif (!shape) return\n\n\t\t\tconst name = shape.props.name\n\t\t\tconst value = e.currentTarget.value.trim()\n\t\t\tif (name === value) return\n\n\t\t\teditor.updateShapes([\n\t\t\t\t{\n\t\t\t\t\tid,\n\t\t\t\t\ttype: 'frame',\n\t\t\t\t\tprops: { name: value },\n\t\t\t\t},\n\t\t\t])\n\t\t},\n\t\t[id, editor]\n\t)\n\n\tconst handleChange = useCallback(\n\t\t(e: React.ChangeEvent<HTMLInputElement>) => {\n\t\t\tconst shape = editor.getShape<TLFrameShape>(id)\n\t\t\tif (!shape) return\n\n\t\t\tconst name = shape.props.name\n\t\t\tconst value = e.currentTarget.value\n\t\t\tif (name === value) return\n\n\t\t\teditor.updateShapes([\n\t\t\t\t{\n\t\t\t\t\tid,\n\t\t\t\t\ttype: 'frame',\n\t\t\t\t\tprops: { name: value },\n\t\t\t\t},\n\t\t\t])\n\t\t},\n\t\t[id, editor]\n\t)\n\n\treturn (\n\t\t<div className={`tl-frame-label ${isEditing ? 'tl-frame-label__editing' : ''}`}>\n\t\t\t<input\n\t\t\t\tclassName=\"tl-frame-name-input\"\n\t\t\t\tref={ref}\n\t\t\t\tdisabled={!isEditing}\n\t\t\t\treadOnly={!isEditing}\n\t\t\t\tstyle={{ display: isEditing ? undefined : 'none' }}\n\t\t\t\tvalue={name}\n\t\t\t\tautoFocus\n\t\t\t\tonKeyDown={handleKeyDown}\n\t\t\t\tonBlur={handleBlur}\n\t\t\t\tonChange={handleChange}\n\t\t\t\tonPointerDown={isEditing ? stopEventPropagation : undefined}\n\t\t\t\tdraggable={false}\n\t\t\t/>\n\t\t\t{defaultEmptyAs(name, 'Frame') + String.fromCharCode(8203)}\n\t\t</div>\n\t)\n})\n"],"names":["name"],"mappings":";;;AAgEE,SACC,KADD;AAhEF,SAAkC,sBAAsB,iBAAiB;;;AACzE,SAAS,YAAY,mBAAmB;AACxC,SAAS,sBAAsB;;;;;AAExB,MAAM,oLAAkB,aAAA,EAG7B,CAAC,EAAE,EAAA,EAAI,IAAA,EAAM,SAAA,CAAU,CAAA,EAAG,QAAQ;IACnC,MAAM,+LAAS,aAAA,CAAU;IAEzB,MAAM,kLAAgB,cAAA;sDACrB,CAAC,MAA6C;YAC7C,IAAI,EAAE,GAAA,KAAQ,WAAW,CAAC,EAAE,WAAA,CAAY,WAAA,EAAa;gBAGpD,CAAA,GAAA,4KAAA,CAAA,uBAAA,EAAqB,CAAC;gBACtB,EAAE,aAAA,CAAc,IAAA,CAAK;gBACrB,OAAO,eAAA,CAAgB,IAAI;YAC5B;QACD;qDACA;QAAC,MAAM;KAAA;IAGR,MAAM,+KAAa,cAAA;mDAClB,CAAC,MAA0C;YAC1C,MAAM,QAAQ,OAAO,QAAA,CAAuB,EAAE;YAC9C,IAAI,CAAC,MAAO,CAAA;YAEZ,MAAMA,QAAO,MAAM,KAAA,CAAM,IAAA;YACzB,MAAM,QAAQ,EAAE,aAAA,CAAc,KAAA,CAAM,IAAA,CAAK;YACzC,IAAIA,UAAS,MAAO,CAAA;YAEpB,OAAO,YAAA,CAAa;gBACnB;oBACC;oBACA,MAAM;oBACN,OAAO;wBAAE,MAAM;oBAAM;gBACtB;aACA;QACF;kDACA;QAAC;QAAI,MAAM;KAAA;IAGZ,MAAM,iLAAe,cAAA;qDACpB,CAAC,MAA2C;YAC3C,MAAM,QAAQ,OAAO,QAAA,CAAuB,EAAE;YAC9C,IAAI,CAAC,MAAO,CAAA;YAEZ,MAAMA,QAAO,MAAM,KAAA,CAAM,IAAA;YACzB,MAAM,QAAQ,EAAE,aAAA,CAAc,KAAA;YAC9B,IAAIA,UAAS,MAAO,CAAA;YAEpB,OAAO,YAAA,CAAa;gBACnB;oBACC;oBACA,MAAM;oBACN,OAAO;wBAAE,MAAM;oBAAM;gBACtB;aACA;QACF;oDACA;QAAC;QAAI,MAAM;KAAA;IAGZ,OACC,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,OAAA,EAAC,OAAA;QAAI,WAAW,CAAA,eAAA,EAAkB,YAAY,4BAA4B,EAAE,EAAA;QAC3E,UAAA;YAAA,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,SAAA;gBACA,WAAU;gBACV;gBACA,UAAU,CAAC;gBACX,UAAU,CAAC;gBACX,OAAO;oBAAE,SAAS,YAAY,KAAA,IAAY;gBAAO;gBACjD,OAAO;gBACP,WAAS;gBACT,WAAW;gBACX,QAAQ;gBACR,UAAU;gBACV,eAAe,yLAAY,uBAAA,GAAuB,KAAA;gBAClD,WAAW;YAAA;sMAEX,iBAAA,EAAe,MAAM,OAAO,IAAI,OAAO,YAAA,CAAa,IAAI;SAAA;IAAA,CAC1D;AAEF,CAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 10519, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/frame/components/FrameHeading.tsx"],"sourcesContent":["import { TLFrameShape, TLShapeId, useEditor, useIsEditing, useValue } from '@tldraw/editor'\nimport { memo, useEffect, useRef } from 'react'\nimport { getFrameHeadingSide, getFrameHeadingTranslation } from '../frameHelpers'\nimport { FrameLabelInput } from './FrameLabelInput'\n\nexport const FrameHeading = memo(function FrameHeading({\n\tid,\n\tname,\n\twidth,\n\theight,\n\tfill,\n\tstroke,\n\tcolor,\n\toffsetX,\n\tshowColors,\n}: {\n\tid: TLShapeId\n\tname: string\n\twidth: number\n\theight: number\n\tfill: string\n\tstroke: string\n\tcolor: string\n\toffsetX: number\n\tshowColors: boolean\n}) {\n\tconst editor = useEditor()\n\tconst { side, translation } = useValue(\n\t\t'shape rotation',\n\t\t() => {\n\t\t\tconst shape = editor.getShape<TLFrameShape>(id)\n\t\t\tif (!shape) {\n\t\t\t\t// meh\n\t\t\t\treturn {\n\t\t\t\t\tside: 0,\n\t\t\t\t\ttranslation: 'translate(0, 0)',\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst labelSide = getFrameHeadingSide(editor, shape)\n\t\t\treturn {\n\t\t\t\tside: labelSide,\n\t\t\t\ttranslation: getFrameHeadingTranslation(shape, labelSide, false),\n\t\t\t}\n\t\t},\n\t\t[editor, offsetX, id]\n\t)\n\n\tconst rInput = useRef<HTMLInputElement>(null)\n\tconst isEditing = useIsEditing(id)\n\n\tuseEffect(() => {\n\t\tconst el = rInput.current\n\t\tif (el && isEditing) {\n\t\t\t// On iOS, we must focus here\n\t\t\tel.focus()\n\t\t\tel.select()\n\t\t}\n\t}, [rInput, isEditing])\n\n\treturn (\n\t\t<div\n\t\t\tclassName=\"tl-frame-heading\"\n\t\t\tstyle={{\n\t\t\t\toverflow: isEditing ? 'visible' : 'hidden',\n\t\t\t\tmaxWidth: `calc(var(--tl-zoom) * ${\n\t\t\t\t\tside === 0 || side === 2 ? Math.ceil(width) : Math.ceil(height)\n\t\t\t\t}px + ${showColors ? '0px' : 'var(--frame-offset-width)'})`,\n\t\t\t\tbottom: '100%',\n\t\t\t\ttransform: `${translation} scale(var(--tl-scale)) translateX(${offsetX}px)`,\n\t\t\t}}\n\t\t>\n\t\t\t<div\n\t\t\t\tclassName=\"tl-frame-heading-hit-area\"\n\t\t\t\tstyle={{ color, backgroundColor: fill, boxShadow: `inset 0px 0px 0px 1px ${stroke}` }}\n\t\t\t>\n\t\t\t\t<FrameLabelInput ref={rInput} id={id} name={name} isEditing={isEditing} />\n\t\t\t</div>\n\t\t</div>\n\t)\n})\n"],"names":["FrameHeading"],"mappings":";;;AA2EI;AA3EJ,SAAkC,WAAW,cAAc,gBAAgB;;;;AAC3E,SAAS,MAAM,WAAW,cAAc;AACxC,SAAS,qBAAqB,kCAAkC;AAChE,SAAS,uBAAuB;;;;;;AAEzB,MAAM,iLAAe,OAAA,EAAK,SAASA,cAAa,EACtD,EAAA,EACA,IAAA,EACA,KAAA,EACA,MAAA,EACA,IAAA,EACA,MAAA,EACA,KAAA,EACA,OAAA,EACA,UAAA,EACD,EAUG;IACF,MAAM,gMAAS,YAAA,CAAU;IACzB,MAAM,EAAE,IAAA,EAAM,WAAA,CAAY,CAAA,wLAAI,WAAA,EAC7B;+CACA,MAAM;YACL,MAAM,QAAQ,OAAO,QAAA,CAAuB,EAAE;YAC9C,IAAI,CAAC,OAAO;gBAEX,OAAO;oBACN,MAAM;oBACN,aAAa;gBACd;YACD;YACA,MAAM,YAAY,8MAAA,EAAoB,QAAQ,KAAK;YACnD,OAAO;gBACN,MAAM;gBACN,qMAAa,6BAAA,EAA2B,OAAO,WAAW,KAAK;YAChE;QACD;8CACA;QAAC;QAAQ;QAAS,EAAE;KAAA;IAGrB,MAAM,2KAAS,SAAA,EAAyB,IAAI;IAC5C,MAAM,sMAAY,eAAA,EAAa,EAAE;IAEjC,CAAA,GAAA,6JAAA,CAAA,YAAA;gDAAU,MAAM;YACf,MAAM,KAAK,OAAO,OAAA;YAClB,IAAI,MAAM,WAAW;gBAEpB,GAAG,KAAA,CAAM;gBACT,GAAG,MAAA,CAAO;YACX;QACD;+CAAG;QAAC;QAAQ,SAAS;KAAC;IAEtB,OACC,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,OAAA;QACA,WAAU;QACV,OAAO;YACN,UAAU,YAAY,YAAY;YAClC,UAAU,CAAA,sBAAA,EACT,SAAS,KAAK,SAAS,IAAI,KAAK,IAAA,CAAK,KAAK,IAAI,KAAK,IAAA,CAAK,MAAM,CAC/D,CAAA,KAAA,EAAQ,aAAa,QAAQ,2BAA2B,CAAA,CAAA,CAAA;YACxD,QAAQ;YACR,WAAW,GAAG,WAAW,CAAA,mCAAA,EAAsC,OAAO,CAAA,GAAA,CAAA;QACvE;QAEA,UAAA,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,OAAA;YACA,WAAU;YACV,OAAO;gBAAE;gBAAO,iBAAiB;gBAAM,WAAW,CAAA,sBAAA,EAAyB,MAAM,EAAA;YAAG;YAEpF,UAAA,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,uMAAC,kBAAA,EAAA;gBAAgB,KAAK;gBAAQ;gBAAQ;gBAAY;YAAA,CAAsB;QAAA;IACzE;AAGH,CAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 10603, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/frame/FrameShapeUtil.tsx"],"sourcesContent":["import {\n\tBaseBoxShapeUtil,\n\tDefaultColorStyle,\n\tGeometry2d,\n\tGroup2d,\n\tRectangle2d,\n\tSVGContainer,\n\tSvgExportContext,\n\tTLClickEventInfo,\n\tTLDragShapesOutInfo,\n\tTLDragShapesOverInfo,\n\tTLFrameShape,\n\tTLFrameShapeProps,\n\tTLResizeInfo,\n\tTLShape,\n\tTLShapePartial,\n\tTLShapeUtilConstructor,\n\tclamp,\n\tcompact,\n\tframeShapeMigrations,\n\tframeShapeProps,\n\tgetDefaultColorTheme,\n\tlerp,\n\tresizeBox,\n\ttoDomPrecision,\n\tuseValue,\n} from '@tldraw/editor'\nimport classNames from 'classnames'\nimport { fitFrameToContent, getFrameChildrenBounds } from '../../utils/frames/frames'\nimport {\n\tTLCreateTextJsxFromSpansOpts,\n\tcreateTextJsxFromSpans,\n} from '../shared/createTextJsxFromSpans'\nimport { useDefaultColorTheme } from '../shared/useDefaultColorTheme'\nimport { FrameHeading } from './components/FrameHeading'\nimport {\n\tgetFrameHeadingOpts,\n\tgetFrameHeadingSide,\n\tgetFrameHeadingSize,\n\tgetFrameHeadingTranslation,\n} from './frameHelpers'\n\n// Some of these values are repeated in CSS and need to match\nconst FRAME_HEADING_EXTRA_WIDTH = 12\nconst FRAME_HEADING_MIN_WIDTH = 32\nconst FRAME_HEADING_NOCOLORS_OFFSET_X = -7\nconst FRAME_HEADING_OFFSET_Y = 4\n\n/** @public */\nexport interface FrameShapeOptions {\n\t/**\n\t * When true, the frame will display colors for the shape's headings and background.\n\t */\n\tshowColors: boolean\n}\n\nexport function defaultEmptyAs(str: string, dflt: string) {\n\tif (str.match(/^\\s*$/)) {\n\t\treturn dflt\n\t}\n\treturn str\n}\n\n/** @public */\nexport class FrameShapeUtil extends BaseBoxShapeUtil<TLFrameShape> {\n\tstatic override type = 'frame' as const\n\tstatic override props = frameShapeProps\n\tstatic override migrations = frameShapeMigrations\n\n\toverride options: FrameShapeOptions = {\n\t\tshowColors: false,\n\t}\n\n\t// evil crimes :)\n\t// By default, showColors is off. Because they use style props, which are picked up\n\t// automatically, we don't have DefaultColorStyle in the props in the schema by default.\n\t// Instead, when someone calls .configure to turn the option on, we manually add in the color\n\t// style here so it plays nicely with the other editor APIs.\n\tstatic override configure<T extends TLShapeUtilConstructor<any, any>>(\n\t\tthis: T,\n\t\toptions: T extends new (...args: any[]) => { options: infer Options } ? Partial<Options> : never\n\t): T {\n\t\tconst withOptions = super.configure.call(this, options) as T\n\t\tif ((options as any).showColors) {\n\t\t\t;(withOptions as any).props = { ...withOptions.props, color: DefaultColorStyle }\n\t\t}\n\t\treturn withOptions\n\t}\n\n\toverride canEdit() {\n\t\treturn true\n\t}\n\n\toverride canResize() {\n\t\treturn true\n\t}\n\n\toverride canResizeChildren() {\n\t\treturn false\n\t}\n\n\toverride getDefaultProps(): TLFrameShape['props'] {\n\t\treturn { w: 160 * 2, h: 90 * 2, name: '', color: 'black' }\n\t}\n\n\toverride getAriaDescriptor(shape: TLFrameShape) {\n\t\treturn shape.props.name\n\t}\n\n\toverride getGeometry(shape: TLFrameShape): Geometry2d {\n\t\tconst { editor } = this\n\n\t\tconst z = editor.getZoomLevel()\n\n\t\t// Which dimension measures the top edge after rotation?\n\t\tconst labelSide = getFrameHeadingSide(editor, shape)\n\t\tconst isVertical = labelSide % 2 === 1\n\t\tconst rotatedTopEdgeWidth = isVertical ? shape.props.h : shape.props.w\n\n\t\t// Get the size of the heading (max width equal to the rotatedTopEdgeWidth)\n\t\tconst opts = getFrameHeadingOpts(rotatedTopEdgeWidth, false)\n\t\tconst headingSize = getFrameHeadingSize(editor, shape, opts)\n\n\t\t// If NOT showing frame colors, we need to offset the label\n\t\t// to the left so that the title is in line with the shape edge\n\t\t// and add that extra width to the right side of the label\n\t\tconst isShowingFrameColors = this.options.showColors\n\n\t\t// Scale everything into **screen space**\n\t\tconst extraWidth = FRAME_HEADING_EXTRA_WIDTH / z\n\t\tconst minWidth = FRAME_HEADING_MIN_WIDTH / z\n\t\tconst maxWidth = rotatedTopEdgeWidth + (isShowingFrameColors ? 1 : extraWidth)\n\n\t\tconst labelWidth = headingSize.w / z\n\t\tconst labelHeight = headingSize.h / z\n\n\t\tconst clampedLabelWidth = clamp(labelWidth + extraWidth, minWidth, maxWidth)\n\n\t\tconst offsetX = (isShowingFrameColors ? -1 : FRAME_HEADING_NOCOLORS_OFFSET_X) / z\n\t\tconst offsetY = FRAME_HEADING_OFFSET_Y / z\n\n\t\t// In page space\n\t\tconst width = isVertical ? labelHeight : clampedLabelWidth\n\t\tconst height = isVertical ? clampedLabelWidth : labelHeight\n\n\t\t// Calculate label position based on side. The position needs to always appear\n\t\t// at the top left of the shape, regardless of rotation. The label must be\n\t\t// between a minimum and maximum. The minimum is arbitrary; the maximum is the\n\t\t// width of the edge of the frame where the label will be shown.\n\n\t\tlet x: number, y: number\n\n\t\tswitch (labelSide) {\n\t\t\tcase 0: {\n\t\t\t\t// top\n\t\t\t\tx = offsetX\n\t\t\t\ty = -(labelHeight + offsetY)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 1: {\n\t\t\t\t// right\n\t\t\t\tx = -(labelHeight + offsetY)\n\t\t\t\ty = shape.props.h - (offsetX + clampedLabelWidth)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 2: {\n\t\t\t\t// bottom\n\t\t\t\tx = shape.props.w - (offsetX + clampedLabelWidth)\n\t\t\t\ty = shape.props.h + offsetY\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 3: {\n\t\t\t\t// left\n\t\t\t\tx = shape.props.w + offsetY\n\t\t\t\ty = offsetX\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\treturn new Group2d({\n\t\t\tchildren: [\n\t\t\t\tnew Rectangle2d({\n\t\t\t\t\twidth: shape.props.w,\n\t\t\t\t\theight: shape.props.h,\n\t\t\t\t\tisFilled: false,\n\t\t\t\t}),\n\t\t\t\tnew Rectangle2d({\n\t\t\t\t\tx,\n\t\t\t\t\ty,\n\t\t\t\t\twidth,\n\t\t\t\t\theight,\n\t\t\t\t\tisFilled: true,\n\t\t\t\t\tisLabel: true,\n\t\t\t\t}),\n\t\t\t],\n\t\t})\n\t}\n\n\toverride getText(shape: TLFrameShape): string | undefined {\n\t\treturn shape.props.name\n\t}\n\n\toverride component(shape: TLFrameShape) {\n\t\t// eslint-disable-next-line react-hooks/rules-of-hooks\n\t\tconst theme = useDefaultColorTheme()\n\n\t\t// eslint-disable-next-line react-hooks/rules-of-hooks\n\t\tconst isCreating = useValue(\n\t\t\t'is creating this shape',\n\t\t\t() => {\n\t\t\t\tconst resizingState = this.editor.getStateDescendant('select.resizing')\n\t\t\t\tif (!resizingState) return false\n\t\t\t\tif (!resizingState.getIsActive()) return false\n\t\t\t\tconst info = (resizingState as typeof resizingState & { info: { isCreating: boolean } })\n\t\t\t\t\t?.info\n\t\t\t\tif (!info) return false\n\t\t\t\treturn info.isCreating && this.editor.getOnlySelectedShapeId() === shape.id\n\t\t\t},\n\t\t\t[shape.id]\n\t\t)\n\n\t\tconst showFrameColors = this.options.showColors\n\n\t\tconst color = theme[shape.props.color]\n\t\tconst frameFill = showFrameColors ? color.frame.fill : theme.black.frame.fill\n\t\tconst frameStroke = showFrameColors ? color.frame.stroke : theme.black.frame.stroke\n\t\tconst frameHeadingStroke = showFrameColors ? color.frame.headingStroke : theme.background\n\t\tconst frameHeadingFill = showFrameColors ? color.frame.headingFill : theme.background\n\t\tconst frameHeadingText = showFrameColors ? color.frame.text : theme.text\n\n\t\treturn (\n\t\t\t<>\n\t\t\t\t<SVGContainer>\n\t\t\t\t\t<rect\n\t\t\t\t\t\tclassName={classNames('tl-frame__body', { 'tl-frame__creating': isCreating })}\n\t\t\t\t\t\tfill={frameFill}\n\t\t\t\t\t\tstroke={frameStroke}\n\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\twidth: `calc(${shape.props.w}px + 1px / var(--tl-zoom))`,\n\t\t\t\t\t\t\theight: `calc(${shape.props.h}px + 1px / var(--tl-zoom))`,\n\t\t\t\t\t\t\ttransform: `translate(calc(-0.5px / var(--tl-zoom)), calc(-0.5px / var(--tl-zoom)))`,\n\t\t\t\t\t\t}}\n\t\t\t\t\t/>\n\t\t\t\t</SVGContainer>\n\t\t\t\t{isCreating ? null : (\n\t\t\t\t\t<FrameHeading\n\t\t\t\t\t\tid={shape.id}\n\t\t\t\t\t\tname={shape.props.name}\n\t\t\t\t\t\tfill={frameHeadingFill}\n\t\t\t\t\t\tstroke={frameHeadingStroke}\n\t\t\t\t\t\tcolor={frameHeadingText}\n\t\t\t\t\t\twidth={shape.props.w}\n\t\t\t\t\t\theight={shape.props.h}\n\t\t\t\t\t\toffsetX={showFrameColors ? -1 : -7}\n\t\t\t\t\t\tshowColors={this.options.showColors}\n\t\t\t\t\t/>\n\t\t\t\t)}\n\t\t\t</>\n\t\t)\n\t}\n\n\toverride toSvg(shape: TLFrameShape, ctx: SvgExportContext) {\n\t\tconst theme = getDefaultColorTheme({ isDarkMode: ctx.isDarkMode })\n\n\t\t// rotate right 45 deg\n\t\tconst labelSide = getFrameHeadingSide(this.editor, shape)\n\t\tconst isVertical = labelSide % 2 === 1\n\t\tconst rotatedTopEdgeWidth = isVertical ? shape.props.h : shape.props.w\n\t\tconst labelTranslate = getFrameHeadingTranslation(shape, labelSide, true)\n\n\t\t// Truncate with ellipsis\n\t\tconst opts: TLCreateTextJsxFromSpansOpts = getFrameHeadingOpts(rotatedTopEdgeWidth - 12, true)\n\n\t\tconst frameTitle = defaultEmptyAs(shape.props.name, 'Frame') + String.fromCharCode(8203)\n\t\tconst labelBounds = getFrameHeadingSize(this.editor, shape, opts)\n\t\tconst spans = this.editor.textMeasure.measureTextSpans(frameTitle, opts)\n\t\tconst text = createTextJsxFromSpans(this.editor, spans, opts)\n\n\t\tconst showFrameColors = this.options.showColors\n\n\t\tconst color = theme[shape.props.color]\n\t\tconst frameFill = showFrameColors ? color.frame.fill : theme.black.frame.fill\n\t\tconst frameStroke = showFrameColors ? color.frame.stroke : theme.black.frame.stroke\n\t\tconst frameHeadingStroke = showFrameColors ? color.frame.headingStroke : theme.background\n\t\tconst frameHeadingFill = showFrameColors ? color.frame.headingFill : theme.background\n\t\tconst frameHeadingText = showFrameColors ? color.frame.text : theme.text\n\n\t\treturn (\n\t\t\t<>\n\t\t\t\t<rect\n\t\t\t\t\twidth={shape.props.w}\n\t\t\t\t\theight={shape.props.h}\n\t\t\t\t\tfill={frameFill}\n\t\t\t\t\tstroke={frameStroke}\n\t\t\t\t\tstrokeWidth={1}\n\t\t\t\t\tx={0}\n\t\t\t\t\trx={0}\n\t\t\t\t\try={0}\n\t\t\t\t/>\n\t\t\t\t<g fill={frameHeadingText} transform={labelTranslate}>\n\t\t\t\t\t<rect\n\t\t\t\t\t\tx={labelBounds.x - (showFrameColors ? 0 : 6)}\n\t\t\t\t\t\ty={labelBounds.y - 6}\n\t\t\t\t\t\twidth={Math.min(rotatedTopEdgeWidth, labelBounds.width + 12)}\n\t\t\t\t\t\theight={labelBounds.height}\n\t\t\t\t\t\tfill={frameHeadingFill}\n\t\t\t\t\t\tstroke={frameHeadingStroke}\n\t\t\t\t\t\trx={4}\n\t\t\t\t\t\try={4}\n\t\t\t\t\t/>\n\t\t\t\t\t<g transform={`translate(${showFrameColors ? 8 : 0}, 4)`}>{text}</g>\n\t\t\t\t</g>\n\t\t\t</>\n\t\t)\n\t}\n\n\tindicator(shape: TLFrameShape) {\n\t\treturn (\n\t\t\t<rect\n\t\t\t\twidth={toDomPrecision(shape.props.w)}\n\t\t\t\theight={toDomPrecision(shape.props.h)}\n\t\t\t\tclassName={`tl-frame-indicator`}\n\t\t\t/>\n\t\t)\n\t}\n\n\toverride providesBackgroundForChildren(): boolean {\n\t\treturn true\n\t}\n\n\toverride canReceiveNewChildrenOfType(shape: TLShape) {\n\t\treturn !shape.isLocked\n\t}\n\n\toverride onResize(shape: any, info: TLResizeInfo<any>) {\n\t\treturn resizeBox(shape, info)\n\t}\n\n\toverride getInterpolatedProps(\n\t\tstartShape: TLFrameShape,\n\t\tendShape: TLFrameShape,\n\t\tt: number\n\t): TLFrameShapeProps {\n\t\treturn {\n\t\t\t...(t > 0.5 ? endShape.props : startShape.props),\n\t\t\tw: lerp(startShape.props.w, endShape.props.w, t),\n\t\t\th: lerp(startShape.props.h, endShape.props.h, t),\n\t\t}\n\t}\n\n\toverride onDoubleClickEdge(shape: TLFrameShape, info: TLClickEventInfo) {\n\t\tif (info.target !== 'selection') return\n\t\tconst { handle } = info\n\n\t\t// If handle is missing, we can't determine which edge was clicked\n\t\tif (!handle) return\n\n\t\tconst isHorizontalEdge = handle === 'left' || handle === 'right'\n\t\tconst isVerticalEdge = handle === 'top' || handle === 'bottom'\n\n\t\tconst childIds = this.editor.getSortedChildIdsForParent(shape.id)\n\t\tconst children = compact(childIds.map((id) => this.editor.getShape(id)))\n\t\tif (!children.length) return\n\n\t\tconst { dx, dy, w, h } = getFrameChildrenBounds(children, this.editor, { padding: 10 })\n\n\t\tthis.editor.run(() => {\n\t\t\tconst changes: TLShapePartial[] = childIds.map((childId) => {\n\t\t\t\tconst childShape = this.editor.getShape(childId)!\n\t\t\t\treturn {\n\t\t\t\t\tid: childShape.id,\n\t\t\t\t\ttype: childShape.type,\n\t\t\t\t\tx: isHorizontalEdge ? childShape.x + dx : childShape.x,\n\t\t\t\t\ty: isVerticalEdge ? childShape.y + dy : childShape.y,\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tthis.editor.updateShapes(changes)\n\t\t})\n\n\t\treturn {\n\t\t\tid: shape.id,\n\t\t\ttype: shape.type,\n\t\t\tprops: {\n\t\t\t\tw: isHorizontalEdge ? w : shape.props.w,\n\t\t\t\th: isVerticalEdge ? h : shape.props.h,\n\t\t\t},\n\t\t}\n\t}\n\n\toverride onDoubleClickCorner(shape: TLFrameShape) {\n\t\tfitFrameToContent(this.editor, shape.id, { padding: 10 })\n\t\treturn {\n\t\t\tid: shape.id,\n\t\t\ttype: shape.type,\n\t\t}\n\t}\n\n\toverride onDragShapesIn(\n\t\tshape: TLFrameShape,\n\t\tdraggingShapes: TLShape[],\n\t\t{ initialParentIds, initialIndices }: TLDragShapesOverInfo\n\t) {\n\t\tconst { editor } = this\n\n\t\tif (draggingShapes.every((s) => s.parentId === shape.id)) return\n\n\t\t// Check to see whether any of the shapes can have their old index restored\n\t\tlet canRestoreOriginalIndices = false\n\t\tconst previousChildren = draggingShapes.filter((s) => shape.id === initialParentIds.get(s.id))\n\n\t\tif (previousChildren.length > 0) {\n\t\t\tconst currentChildren = compact(\n\t\t\t\teditor.getSortedChildIdsForParent(shape).map((id) => editor.getShape(id))\n\t\t\t)\n\t\t\tif (previousChildren.every((s) => !currentChildren.find((c) => c.index === s.index))) {\n\t\t\t\tcanRestoreOriginalIndices = true\n\t\t\t}\n\t\t}\n\n\t\t// I can't imagine this happening, but if any of the children are the ancestor of the frame, quit here\n\t\tif (draggingShapes.some((s) => editor.hasAncestor(shape, s.id))) return\n\n\t\t// Reparent the shapes to the new parent\n\t\teditor.reparentShapes(draggingShapes, shape.id)\n\n\t\t// If we can restore the original indices, then do so\n\t\tif (canRestoreOriginalIndices) {\n\t\t\tfor (const shape of previousChildren) {\n\t\t\t\teditor.updateShape({\n\t\t\t\t\tid: shape.id,\n\t\t\t\t\ttype: shape.type,\n\t\t\t\t\tindex: initialIndices.get(shape.id),\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\toverride onDragShapesOut(\n\t\tshape: TLFrameShape,\n\t\tdraggingShapes: TLShape[],\n\t\tinfo: TLDragShapesOutInfo\n\t): void {\n\t\tconst { editor } = this\n\t\t// When a user drags shapes out of a frame, and if we're not dragging into a new shape, then reparent\n\t\t// the dragging shapes (that are current children of the frame) onto the current page instead\n\t\tif (!info.nextDraggingOverShapeId) {\n\t\t\teditor.reparentShapes(\n\t\t\t\tdraggingShapes.filter(\n\t\t\t\t\t(s) => s.parentId === shape.id && this.canReceiveNewChildrenOfType(s)\n\t\t\t\t),\n\t\t\t\teditor.getCurrentPageId()\n\t\t\t)\n\t\t}\n\t}\n}\n"],"names":["shape"],"mappings":";;;;AAuOG,mBAEE,KAFF;;;;;;;;;AAvOH;;;;AA2BA,OAAO,gBAAgB;AACvB,SAAS,mBAAmB,8BAA8B;AAC1D;AAIA,SAAS,4BAA4B;AACrC,SAAS,oBAAoB;AAC7B;;;;;;;;;AAQA,MAAM,4BAA4B;AAClC,MAAM,0BAA0B;AAChC,MAAM,kCAAkC,CAAA;AACxC,MAAM,yBAAyB;AAUxB,SAAS,eAAe,GAAA,EAAa,IAAA,EAAc;IACzD,IAAI,IAAI,KAAA,CAAM,OAAO,GAAG;QACvB,OAAO;IACR;IACA,OAAO;AACR;AAGO,MAAM,4NAAuB,mBAAA,CAA+B;IAClE,OAAgB,OAAO,QAAA;IACvB,OAAgB,QAAQ,oMAAA,CAAA;IACxB,OAAgB,+LAAa,uBAAA,CAAA;IAEpB,UAA6B;QACrC,YAAY;IACb,EAAA;IAAA,iBAAA;IAAA,mFAAA;IAAA,wFAAA;IAAA,6FAAA;IAAA,4DAAA;IAOA,OAAgB,UAEf,OAAA,EACI;QACJ,MAAM,cAAc,KAAA,CAAM,UAAU,IAAA,CAAK,IAAA,EAAM,OAAO;QACtD,IAAK,QAAgB,UAAA,EAAY;;YAC9B,YAAoB,KAAA,GAAQ;gBAAE,GAAG,YAAY,KAAA;gBAAO,yLAAO,oBAAA;YAAkB;QAChF;QACA,OAAO;IACR;IAES,UAAU;QAClB,OAAO;IACR;IAES,YAAY;QACpB,OAAO;IACR;IAES,oBAAoB;QAC5B,OAAO;IACR;IAES,kBAAyC;QACjD,OAAO;YAAE,GAAG,MAAM;YAAG,GAAG,KAAK;YAAG,MAAM;YAAI,OAAO;QAAQ;IAC1D;IAES,kBAAkB,KAAA,EAAqB;QAC/C,OAAO,MAAM,KAAA,CAAM,IAAA;IACpB;IAES,YAAY,KAAA,EAAiC;QACrD,MAAM,EAAE,MAAA,CAAO,CAAA,GAAI,IAAA;QAEnB,MAAM,IAAI,OAAO,YAAA,CAAa;QAG9B,MAAM,oMAAY,sBAAA,EAAoB,QAAQ,KAAK;QACnD,MAAM,aAAa,YAAY,MAAM;QACrC,MAAM,sBAAsB,aAAa,MAAM,KAAA,CAAM,CAAA,GAAI,MAAM,KAAA,CAAM,CAAA;QAGrE,MAAM,8LAAO,uBAAA,EAAoB,qBAAqB,KAAK;QAC3D,MAAM,sMAAc,sBAAA,EAAoB,QAAQ,OAAO,IAAI;QAK3D,MAAM,uBAAuB,IAAA,CAAK,OAAA,CAAQ,UAAA;QAG1C,MAAM,aAAa,4BAA4B;QAC/C,MAAM,WAAW,0BAA0B;QAC3C,MAAM,WAAW,sBAAA,CAAuB,uBAAuB,IAAI,UAAA;QAEnE,MAAM,aAAa,YAAY,CAAA,GAAI;QACnC,MAAM,cAAc,YAAY,CAAA,GAAI;QAEpC,MAAM,oBAAoB,gMAAA,EAAM,aAAa,YAAY,UAAU,QAAQ;QAE3E,MAAM,UAAA,CAAW,uBAAuB,CAAA,IAAK,+BAAA,IAAmC;QAChF,MAAM,UAAU,yBAAyB;QAGzC,MAAM,QAAQ,aAAa,cAAc;QACzC,MAAM,SAAS,aAAa,oBAAoB;QAOhD,IAAI,GAAW;QAEf,OAAQ,WAAW;YAClB,KAAK;gBAAG;oBAEP,IAAI;oBACJ,IAAI,CAAA,CAAE,cAAc,OAAA;oBACpB;gBACD;YACA,KAAK;gBAAG;oBAEP,IAAI,CAAA,CAAE,cAAc,OAAA;oBACpB,IAAI,MAAM,KAAA,CAAM,CAAA,GAAA,CAAK,UAAU,iBAAA;oBAC/B;gBACD;YACA,KAAK;gBAAG;oBAEP,IAAI,MAAM,KAAA,CAAM,CAAA,GAAA,CAAK,UAAU,iBAAA;oBAC/B,IAAI,MAAM,KAAA,CAAM,CAAA,GAAI;oBACpB;gBACD;YACA,KAAK;gBAAG;oBAEP,IAAI,MAAM,KAAA,CAAM,CAAA,GAAI;oBACpB,IAAI;oBACJ;gBACD;QACD;QAEA,OAAO,sMAAI,UAAA,CAAQ;YAClB,UAAU;gBACT,0MAAI,cAAA,CAAY;oBACf,OAAO,MAAM,KAAA,CAAM,CAAA;oBACnB,QAAQ,MAAM,KAAA,CAAM,CAAA;oBACpB,UAAU;gBACX,CAAC;gBACD,0MAAI,cAAA,CAAY;oBACf;oBACA;oBACA;oBACA;oBACA,UAAU;oBACV,SAAS;gBACV,CAAC;aACF;QACD,CAAC;IACF;IAES,QAAQ,KAAA,EAAyC;QACzD,OAAO,MAAM,KAAA,CAAM,IAAA;IACpB;IAES,UAAU,KAAA,EAAqB;QAEvC,MAAM,yMAAQ,uBAAA,CAAqB;QAGnC,MAAM,iMAAa,YAAA,EAClB;oCACA,MAAM;gBACL,MAAM,gBAAgB,IAAA,CAAK,MAAA,CAAO,kBAAA,CAAmB,iBAAiB;gBACtE,IAAI,CAAC,cAAe,CAAA,OAAO;gBAC3B,IAAI,CAAC,cAAc,WAAA,CAAY,EAAG,CAAA,OAAO;gBACzC,MAAM,OAAQ,eACX;gBACH,IAAI,CAAC,KAAM,CAAA,OAAO;gBAClB,OAAO,KAAK,UAAA,IAAc,IAAA,CAAK,MAAA,CAAO,sBAAA,CAAuB,MAAM,MAAM,EAAA;YAC1E;mCACA;YAAC,MAAM,EAAE;SAAA;QAGV,MAAM,kBAAkB,IAAA,CAAK,OAAA,CAAQ,UAAA;QAErC,MAAM,QAAQ,KAAA,CAAM,MAAM,KAAA,CAAM,KAAK,CAAA;QACrC,MAAM,YAAY,kBAAkB,MAAM,KAAA,CAAM,IAAA,GAAO,MAAM,KAAA,CAAM,KAAA,CAAM,IAAA;QACzE,MAAM,cAAc,kBAAkB,MAAM,KAAA,CAAM,MAAA,GAAS,MAAM,KAAA,CAAM,KAAA,CAAM,MAAA;QAC7E,MAAM,qBAAqB,kBAAkB,MAAM,KAAA,CAAM,aAAA,GAAgB,MAAM,UAAA;QAC/E,MAAM,mBAAmB,kBAAkB,MAAM,KAAA,CAAM,WAAA,GAAc,MAAM,UAAA;QAC3E,MAAM,mBAAmB,kBAAkB,MAAM,KAAA,CAAM,IAAA,GAAO,MAAM,IAAA;QAEpE,OACC,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,OAAA,EAAA,sKAAA,CAAA,WAAA,EAAA;YACC,UAAA;gBAAA,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,6LAAC,eAAA,EAAA;oBACA,UAAA,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,QAAA;wBACA,sJAAW,UAAA,EAAW,kBAAkB;4BAAE,sBAAsB;wBAAW,CAAC;wBAC5E,MAAM;wBACN,QAAQ;wBACR,OAAO;4BACN,OAAO,CAAA,KAAA,EAAQ,MAAM,KAAA,CAAM,CAAC,CAAA,0BAAA,CAAA;4BAC5B,QAAQ,CAAA,KAAA,EAAQ,MAAM,KAAA,CAAM,CAAC,CAAA,0BAAA,CAAA;4BAC7B,WAAW,CAAA,uEAAA,CAAA;wBACZ;oBAAA;gBACD,CACD;gBACC,aAAa,OACb,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,oMAAC,eAAA,EAAA;oBACA,IAAI,MAAM,EAAA;oBACV,MAAM,MAAM,KAAA,CAAM,IAAA;oBAClB,MAAM;oBACN,QAAQ;oBACR,OAAO;oBACP,OAAO,MAAM,KAAA,CAAM,CAAA;oBACnB,QAAQ,MAAM,KAAA,CAAM,CAAA;oBACpB,SAAS,kBAAkB,CAAA,IAAK,CAAA;oBAChC,YAAY,IAAA,CAAK,OAAA,CAAQ,UAAA;gBAAA;aAC1B;QAAA,CAEF;IAEF;IAES,MAAM,KAAA,EAAqB,GAAA,EAAuB;QAC1D,MAAM,8LAAQ,uBAAA,EAAqB;YAAE,YAAY,IAAI,UAAA;QAAW,CAAC;QAGjE,MAAM,oMAAY,sBAAA,EAAoB,IAAA,CAAK,MAAA,EAAQ,KAAK;QACxD,MAAM,aAAa,YAAY,MAAM;QACrC,MAAM,sBAAsB,aAAa,MAAM,KAAA,CAAM,CAAA,GAAI,MAAM,KAAA,CAAM,CAAA;QACrE,MAAM,yMAAiB,6BAAA,EAA2B,OAAO,WAAW,IAAI;QAGxE,MAAM,OAAqC,8MAAA,EAAoB,sBAAsB,IAAI,IAAI;QAE7F,MAAM,aAAa,eAAe,MAAM,KAAA,CAAM,IAAA,EAAM,OAAO,IAAI,OAAO,YAAA,CAAa,IAAI;QACvF,MAAM,cAAc,8MAAA,EAAoB,IAAA,CAAK,MAAA,EAAQ,OAAO,IAAI;QAChE,MAAM,QAAQ,IAAA,CAAK,MAAA,CAAO,WAAA,CAAY,gBAAA,CAAiB,YAAY,IAAI;QACvE,MAAM,0MAAO,yBAAA,EAAuB,IAAA,CAAK,MAAA,EAAQ,OAAO,IAAI;QAE5D,MAAM,kBAAkB,IAAA,CAAK,OAAA,CAAQ,UAAA;QAErC,MAAM,QAAQ,KAAA,CAAM,MAAM,KAAA,CAAM,KAAK,CAAA;QACrC,MAAM,YAAY,kBAAkB,MAAM,KAAA,CAAM,IAAA,GAAO,MAAM,KAAA,CAAM,KAAA,CAAM,IAAA;QACzE,MAAM,cAAc,kBAAkB,MAAM,KAAA,CAAM,MAAA,GAAS,MAAM,KAAA,CAAM,KAAA,CAAM,MAAA;QAC7E,MAAM,qBAAqB,kBAAkB,MAAM,KAAA,CAAM,aAAA,GAAgB,MAAM,UAAA;QAC/E,MAAM,mBAAmB,kBAAkB,MAAM,KAAA,CAAM,WAAA,GAAc,MAAM,UAAA;QAC3E,MAAM,mBAAmB,kBAAkB,MAAM,KAAA,CAAM,IAAA,GAAO,MAAM,IAAA;QAEpE,OACC,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,OAAA,EAAA,sKAAA,CAAA,WAAA,EAAA;YACC,UAAA;gBAAA,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,QAAA;oBACA,OAAO,MAAM,KAAA,CAAM,CAAA;oBACnB,QAAQ,MAAM,KAAA,CAAM,CAAA;oBACpB,MAAM;oBACN,QAAQ;oBACR,aAAa;oBACb,GAAG;oBACH,IAAI;oBACJ,IAAI;gBAAA;gBAEL,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,OAAA,EAAC,KAAA;oBAAE,MAAM;oBAAkB,WAAW;oBACrC,UAAA;wBAAA,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,QAAA;4BACA,GAAG,YAAY,CAAA,GAAA,CAAK,kBAAkB,IAAI,CAAA;4BAC1C,GAAG,YAAY,CAAA,GAAI;4BACnB,OAAO,KAAK,GAAA,CAAI,qBAAqB,YAAY,KAAA,GAAQ,EAAE;4BAC3D,QAAQ,YAAY,MAAA;4BACpB,MAAM;4BACN,QAAQ;4BACR,IAAI;4BACJ,IAAI;wBAAA;wBAEL,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,KAAA;4BAAE,WAAW,CAAA,UAAA,EAAa,kBAAkB,IAAI,CAAC,CAAA,IAAA,CAAA;4BAAS,UAAA;wBAAA,CAAK;qBAAA;gBAAA,CACjE;aAAA;QAAA,CACD;IAEF;IAEA,UAAU,KAAA,EAAqB;QAC9B,OACC,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,QAAA;YACA,WAAO,qMAAA,EAAe,MAAM,KAAA,CAAM,CAAC;YACnC,gMAAQ,iBAAA,EAAe,MAAM,KAAA,CAAM,CAAC;YACpC,WAAW,CAAA,kBAAA,CAAA;QAAA;IAGd;IAES,gCAAyC;QACjD,OAAO;IACR;IAES,4BAA4B,KAAA,EAAgB;QACpD,OAAO,CAAC,MAAM,QAAA;IACf;IAES,SAAS,KAAA,EAAY,IAAA,EAAyB;QACtD,OAAO,wNAAA,EAAU,OAAO,IAAI;IAC7B;IAES,qBACR,UAAA,EACA,QAAA,EACA,CAAA,EACoB;QACpB,OAAO;YACN,GAAI,GAAI,CAAA,KAAM,CAAA,QAAS,CAAA,KAAA,EAAQ,CAAA,UAAW,CAAA,KAAA;YAC1C,6KAAG,OAAA,EAAK,WAAW,KAAA,CAAM,CAAA,EAAG,SAAS,KAAA,CAAM,CAAA,EAAG,CAAC;YAC/C,OAAG,6KAAA,EAAK,WAAW,KAAA,CAAM,CAAA,EAAG,SAAS,KAAA,CAAM,CAAA,EAAG,CAAC;QAChD;IACD;IAES,kBAAkB,KAAA,EAAqB,IAAA,EAAwB;QACvE,IAAI,KAAK,MAAA,KAAW,YAAa,CAAA;QACjC,MAAM,EAAE,MAAA,CAAO,CAAA,GAAI;QAGnB,IAAI,CAAC,OAAQ,CAAA;QAEb,MAAM,mBAAmB,WAAW,UAAU,WAAW;QACzD,MAAM,iBAAiB,WAAW,SAAS,WAAW;QAEtD,MAAM,WAAW,IAAA,CAAK,MAAA,CAAO,0BAAA,CAA2B,MAAM,EAAE;QAChE,MAAM,eAAW,+KAAA,EAAQ,SAAS,GAAA,CAAI,CAAC,KAAO,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,EAAE,CAAC,CAAC;QACvE,IAAI,CAAC,SAAS,MAAA,CAAQ,CAAA;QAEtB,MAAM,EAAE,EAAA,EAAI,EAAA,EAAI,CAAA,EAAG,CAAA,CAAE,CAAA,qLAAI,yBAAA,EAAuB,UAAU,IAAA,CAAK,MAAA,EAAQ;YAAE,SAAS;QAAG,CAAC;QAEtF,IAAA,CAAK,MAAA,CAAO,GAAA,CAAI,MAAM;YACrB,MAAM,UAA4B,SAAS,GAAA,CAAI,CAAC,YAAY;gBAC3D,MAAM,aAAa,IAAA,CAAK,MAAA,CAAO,QAAA,CAAS,OAAO;gBAC/C,OAAO;oBACN,IAAI,WAAW,EAAA;oBACf,MAAM,WAAW,IAAA;oBACjB,GAAG,mBAAmB,WAAW,CAAA,GAAI,KAAK,WAAW,CAAA;oBACrD,GAAG,iBAAiB,WAAW,CAAA,GAAI,KAAK,WAAW,CAAA;gBACpD;YACD,CAAC;YAED,IAAA,CAAK,MAAA,CAAO,YAAA,CAAa,OAAO;QACjC,CAAC;QAED,OAAO;YACN,IAAI,MAAM,EAAA;YACV,MAAM,MAAM,IAAA;YACZ,OAAO;gBACN,GAAG,mBAAmB,IAAI,MAAM,KAAA,CAAM,CAAA;gBACtC,GAAG,iBAAiB,IAAI,MAAM,KAAA,CAAM,CAAA;YACrC;QACD;IACD;IAES,oBAAoB,KAAA,EAAqB;QACjD,CAAA,GAAA,6KAAA,CAAA,oBAAA,EAAkB,IAAA,CAAK,MAAA,EAAQ,MAAM,EAAA,EAAI;YAAE,SAAS;QAAG,CAAC;QACxD,OAAO;YACN,IAAI,MAAM,EAAA;YACV,MAAM,MAAM,IAAA;QACb;IACD;IAES,eACR,KAAA,EACA,cAAA,EACA,EAAE,gBAAA,EAAkB,cAAA,CAAe,CAAA,EAClC;QACD,MAAM,EAAE,MAAA,CAAO,CAAA,GAAI,IAAA;QAEnB,IAAI,eAAe,KAAA,CAAM,CAAC,IAAM,EAAE,QAAA,KAAa,MAAM,EAAE,EAAG,CAAA;QAG1D,IAAI,4BAA4B;QAChC,MAAM,mBAAmB,eAAe,MAAA,CAAO,CAAC,IAAM,MAAM,EAAA,KAAO,iBAAiB,GAAA,CAAI,EAAE,EAAE,CAAC;QAE7F,IAAI,iBAAiB,MAAA,GAAS,GAAG;YAChC,MAAM,kBAAkB,mLAAA,EACvB,OAAO,0BAAA,CAA2B,KAAK,EAAE,GAAA,CAAI,CAAC,KAAO,OAAO,QAAA,CAAS,EAAE,CAAC;YAEzE,IAAI,iBAAiB,KAAA,CAAM,CAAC,IAAM,CAAC,gBAAgB,IAAA,CAAK,CAAC,IAAM,EAAE,KAAA,KAAU,EAAE,KAAK,CAAC,GAAG;gBACrF,4BAA4B;YAC7B;QACD;QAGA,IAAI,eAAe,IAAA,CAAK,CAAC,IAAM,OAAO,WAAA,CAAY,OAAO,EAAE,EAAE,CAAC,EAAG,CAAA;QAGjE,OAAO,cAAA,CAAe,gBAAgB,MAAM,EAAE;QAG9C,IAAI,2BAA2B;YAC9B,KAAA,MAAWA,UAAS,iBAAkB;gBACrC,OAAO,WAAA,CAAY;oBAClB,IAAIA,OAAM,EAAA;oBACV,MAAMA,OAAM,IAAA;oBACZ,OAAO,eAAe,GAAA,CAAIA,OAAM,EAAE;gBACnC,CAAC;YACF;QACD;IACD;IAES,gBACR,KAAA,EACA,cAAA,EACA,IAAA,EACO;QACP,MAAM,EAAE,MAAA,CAAO,CAAA,GAAI,IAAA;QAGnB,IAAI,CAAC,KAAK,uBAAA,EAAyB;YAClC,OAAO,cAAA,CACN,eAAe,MAAA,CACd,CAAC,IAAM,EAAE,QAAA,KAAa,MAAM,EAAA,IAAM,IAAA,CAAK,2BAAA,CAA4B,CAAC,IAErE,OAAO,gBAAA,CAAiB;QAE1B;IACD;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 10963, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/text/RichTextArea.tsx"],"sourcesContent":["import { EditorView } from '@tiptap/pm/view'\nimport {\n\tEditorEvents,\n\tJSONContent,\n\tEditor as TextEditor,\n\ttype Editor as TTEditor,\n} from '@tiptap/react'\nimport {\n\tEditor,\n\tTLRichText,\n\tTLShapeId,\n\tpreventDefault,\n\tstopEventPropagation,\n\tuseEditor,\n\tuseEvent,\n\tuseUniqueSafeId,\n} from '@tldraw/editor'\nimport React, { useLayoutEffect, useRef } from 'react'\n\n/** @public */\nexport interface TextAreaProps {\n\tisEditing: boolean\n\ttext?: string\n\tshapeId: TLShapeId\n\trichText?: TLRichText\n\thandleFocus(): void\n\thandleBlur(): void\n\thandleKeyDown(e: KeyboardEvent): void\n\thandleChange(changeInfo: { plaintext?: string; richText?: TLRichText }): void\n\thandleInputPointerDown(e: React.PointerEvent<HTMLElement>): void\n\thandleDoubleClick(e: any): any\n\thandlePaste(e: ClipboardEvent | React.ClipboardEvent<HTMLTextAreaElement>): void\n\thasCustomTabBehavior?: boolean\n}\n\n/**\n * N.B. In Development mode you need to ensure you're testing this without StrictMode on.\n * Otherwise it's not gonna work as expected on iOS.\n * Specifically, it means that the virtual keyboard won't pop open sometimes\n * (iOS starts flipping out when you render multiple times when trying to focus something) .\n */\n\n/**\n * A rich text area that can be used for editing text with rich text formatting.\n * This component uses the TipTap editor under the hood.\n *\n * @public @react\n */\nexport const RichTextArea = React.forwardRef<HTMLDivElement, TextAreaProps>(function RichTextArea(\n\t{\n\t\tshapeId,\n\t\tisEditing,\n\t\trichText,\n\t\thandleFocus,\n\t\thandleChange,\n\t\thandleBlur,\n\t\thandleKeyDown,\n\t\thandleDoubleClick,\n\t\thasCustomTabBehavior,\n\t\thandlePaste,\n\t},\n\tref\n) {\n\tconst editor = useEditor()\n\tconst tipTapId = useUniqueSafeId('tip-tap-editor')\n\tconst tipTapConfig = editor.getTextOptions().tipTapConfig\n\n\tconst rInitialRichText = useRef(richText)\n\tconst rTextEditor = useRef<TTEditor | null>(null)\n\tconst rTextEditorEl = useRef<HTMLDivElement>(null)\n\n\tuseLayoutEffect(() => {\n\t\tif (!rTextEditor.current) {\n\t\t\trInitialRichText.current = richText\n\t\t} else if (rInitialRichText.current !== richText) {\n\t\t\trTextEditor.current.commands.setContent(richText as JSONContent)\n\t\t}\n\t}, [richText])\n\n\t// The order of events is:\n\t// - editor begins editing any shape\n\t// - we set listeners for select all / place caret events\n\t// - if the user is editing this shape, this component is rendered\n\t// - editor emits the select all event / place caret event\n\t// - the text editor is onCreate callback is called\n\tconst rCreateInfo = useRef({\n\t\tselectAll: false,\n\t\tcaretPosition: null as { x: number; y: number } | null,\n\t})\n\n\tuseLayoutEffect(() => {\n\t\tfunction selectAllIfEditing(event: { shapeId: TLShapeId }) {\n\t\t\tif (event.shapeId === editor.getEditingShapeId()) {\n\t\t\t\trCreateInfo.current.selectAll = true\n\t\t\t}\n\t\t}\n\n\t\tfunction placeCaret(event: { shapeId: TLShapeId; point: { x: number; y: number } }) {\n\t\t\tif (event.shapeId === editor.getEditingShapeId()) {\n\t\t\t\trCreateInfo.current.caretPosition = event.point\n\t\t\t}\n\t\t}\n\n\t\teditor.on('select-all-text', selectAllIfEditing)\n\t\teditor.on('place-caret', placeCaret)\n\t\treturn () => {\n\t\t\teditor.off('select-all-text', selectAllIfEditing)\n\t\t\teditor.off('place-caret', placeCaret)\n\t\t}\n\t}, [editor, isEditing])\n\n\tconst onChange = useEvent(handleChange)\n\tconst onKeyDown = useEvent(handleKeyDown)\n\tconst onFocus = useEvent(handleFocus)\n\tconst onBlur = useEvent(handleBlur)\n\tconst onDoubleClick = useEvent(handleDoubleClick)\n\tconst onPaste = useEvent(handlePaste)\n\tuseLayoutEffect(() => {\n\t\tif (!isEditing || !tipTapConfig || !rTextEditorEl.current) return\n\n\t\tconst { editorProps, ...restOfTipTapConfig } = tipTapConfig\n\n\t\t// Because React can double-render in Strict Mode, we need to make sure we're not setting\n\t\t// the text editor twice. This became more much more prevalent in React 19, but also it\n\t\t// started manifesting in some cases in Next 14.2 (which maybe patches React 18.3 in weird\n\t\t// ways). So we used to use EditorProvider but we into weird rendering issues.\n\t\tconst textEditorInstance = new TextEditor({\n\t\t\telement: rTextEditorEl.current,\n\t\t\tautofocus: true,\n\t\t\teditable: isEditing,\n\t\t\tonUpdate: (props: EditorEvents['update']) => {\n\t\t\t\tconst content: TLRichText = props.editor.state.doc.toJSON()\n\t\t\t\trInitialRichText.current = content\n\t\t\t\tonChange({ richText: content })\n\t\t\t},\n\t\t\tonFocus,\n\t\t\tonBlur,\n\t\t\t// onCreate is called after a `setTimeout(0)`\n\t\t\tonCreate: (props) => {\n\t\t\t\t// If we're not still editing the original shape, then don't do anything.\n\t\t\t\tif (editor.getEditingShapeId() !== shapeId) return\n\n\t\t\t\tconst textEditor = props.editor\n\t\t\t\teditor.setRichTextEditor(textEditor)\n\n\t\t\t\tconst { selectAll, caretPosition } = rCreateInfo.current\n\n\t\t\t\tif (selectAll) {\n\t\t\t\t\t// Select all of the text\n\t\t\t\t\ttextEditor.chain().focus().selectAll().run()\n\t\t\t\t} else if (caretPosition) {\n\t\t\t\t\t// Set the initial caret screen position\n\t\t\t\t\tconst pos = textEditor.view.posAtCoords({\n\t\t\t\t\t\tleft: caretPosition.x,\n\t\t\t\t\t\ttop: caretPosition.y,\n\t\t\t\t\t})?.pos\n\n\t\t\t\t\tif (pos) {\n\t\t\t\t\t\t// Focus to that position.\n\t\t\t\t\t\ttextEditor.chain().focus().setTextSelection(pos).run()\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If no position, default to select all.\n\t\t\t\t\t\ttextEditor.chain().focus().selectAll().run()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\teditorProps: {\n\t\t\t\thandleKeyDown: (view: EditorView, event: KeyboardEvent) => {\n\t\t\t\t\tif (!hasCustomTabBehavior && event.key === 'Tab') {\n\t\t\t\t\t\thandleTab(editor, view, event)\n\t\t\t\t\t}\n\n\t\t\t\t\tonKeyDown(event)\n\t\t\t\t},\n\t\t\t\thandlePaste: (view: EditorView, event: ClipboardEvent) => {\n\t\t\t\t\tonPaste(event)\n\t\t\t\t\tif (event.defaultPrevented) return true\n\t\t\t\t},\n\t\t\t\thandleDoubleClick: (_view, _pos, event) => onDoubleClick(event),\n\t\t\t\t...editorProps,\n\t\t\t},\n\t\t\tcoreExtensionOptions: {\n\t\t\t\tclipboardTextSerializer: {\n\t\t\t\t\tblockSeparator: '\\n',\n\t\t\t\t},\n\t\t\t},\n\t\t\t...restOfTipTapConfig,\n\t\t\tcontent: rInitialRichText.current as JSONContent,\n\t\t})\n\n\t\t// XXX: When creating a brand new shape and double-clicking into it quickly to edit it,\n\t\t// there's some kind of race condition happening where the editor doesn't focus properly.\n\t\tconst timeout = editor.timers.setTimeout(() => {\n\t\t\tif (rCreateInfo.current.caretPosition || rCreateInfo.current.selectAll) {\n\t\t\t\ttextEditorInstance.commands.focus()\n\t\t\t} else {\n\t\t\t\ttextEditorInstance.commands.focus('end')\n\t\t\t}\n\n\t\t\trCreateInfo.current.selectAll = false\n\t\t\trCreateInfo.current.caretPosition = null\n\t\t}, 100)\n\n\t\trTextEditor.current = textEditorInstance\n\n\t\treturn () => {\n\t\t\trTextEditor.current = null\n\t\t\tclearTimeout(timeout)\n\t\t\ttextEditorInstance.destroy()\n\t\t}\n\t}, [\n\t\tisEditing,\n\t\ttipTapConfig,\n\t\tonFocus,\n\t\tonBlur,\n\t\tonDoubleClick,\n\t\tonChange,\n\t\tonPaste,\n\t\tonKeyDown,\n\t\teditor,\n\t\tshapeId,\n\t\thasCustomTabBehavior,\n\t])\n\n\tif (!isEditing || !tipTapConfig) {\n\t\treturn null\n\t}\n\n\treturn (\n\t\t<div\n\t\t\tid={tipTapId}\n\t\t\tref={ref}\n\t\t\ttabIndex={-1}\n\t\t\tdata-testid=\"rich-text-area\"\n\t\t\tclassName=\"tl-rich-text tl-text tl-text-input\"\n\t\t\tonContextMenu={isEditing ? stopEventPropagation : undefined}\n\t\t\t// N.B. When PointerStateExtension was introduced, this was moved there.\n\t\t\t// However, that caused selecting over list items to break.\n\t\t\t// The handleDOMEvents in TipTap don't seem to support the pointerDownCapture event.\n\t\t\tonPointerDownCapture={stopEventPropagation}\n\t\t\t// This onTouchEnd is important for Android to be able to change selection on text.\n\t\t\tonTouchEnd={stopEventPropagation}\n\t\t\t// On FF, there's a behavior where dragging a selection will grab that selection into\n\t\t\t// the drag event. However, once the drag is over, and you select away from the textarea,\n\t\t\t// starting a drag over the textarea will restart a selection drag instead of a shape drag.\n\t\t\t// This prevents that default behavior in FF.\n\t\t\tonDragStart={preventDefault}\n\t\t>\n\t\t\t<div className=\"tl-rich-text\" ref={rTextEditorEl} />\n\t\t</div>\n\t)\n})\n\n// Prevent exiting the editor when hitting Tab.\n// Also, insert a tab character at the front of the line if the shift key isn't pressed,\n// otherwise if shift is pressed, remove a tab character from the front of the line.\nfunction handleTab(editor: Editor, view: EditorView, event: KeyboardEvent) {\n\t// Don't exit the editor.\n\tevent.preventDefault()\n\n\tconst textEditor = editor.getRichTextEditor()\n\tif (textEditor?.isActive('bulletList') || textEditor?.isActive('orderedList')) return\n\n\tconst { state, dispatch } = view\n\tconst { $from, $to } = state.selection\n\tconst isShift = event.shiftKey\n\n\t// Create a new transaction\n\tlet tr = state.tr\n\n\t// Iterate over each line in the selection in reverse so that the positions\n\t// are stable as we modify the document.\n\tlet pos = $to.end()\n\twhile (pos >= $from.start()) {\n\t\tconst line = state.doc.resolve(pos).blockRange()\n\t\tif (!line) break\n\n\t\tconst lineStart = line.start\n\t\tconst lineEnd = line.end\n\t\tconst lineText = state.doc.textBetween(lineStart, lineEnd, '\\n')\n\n\t\t// Check if the current line or any of its parent nodes are part of a list\n\t\tlet isInList = false\n\t\tstate.doc.nodesBetween(lineStart, lineEnd, (node) => {\n\t\t\tif (node.type.name === 'bulletList' || node.type.name === 'orderedList') {\n\t\t\t\tisInList = true\n\t\t\t\treturn false // Stop iteration\n\t\t\t}\n\t\t})\n\n\t\t// TODO: for now skip over lists. Later, we might consider handling them using\n\t\t// sinkListItem and liftListItem from @tiptap/pm/schema-list\n\t\tif (!isInList) {\n\t\t\tif (!isShift) {\n\t\t\t\t// Insert a tab character at the start of the line\n\t\t\t\ttr = tr.insertText('\\t', lineStart + 1)\n\t\t\t} else {\n\t\t\t\t// Remove a tab character from the start of the line\n\t\t\t\tif (lineText.startsWith('\\t')) {\n\t\t\t\t\ttr = tr.delete(lineStart + 1, lineStart + 2)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpos = lineStart - 1\n\t}\n\n\tconst mappedSelection = state.selection.map(tr.doc, tr.mapping)\n\ttr.setSelection(mappedSelection)\n\n\tif (tr.docChanged) {\n\t\tdispatch(tr)\n\t}\n}\n"],"names":["RichTextArea"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 11199, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/shared/useEditableRichText.ts"],"sourcesContent":["import { TLRichText, TLShapeId, TLUnknownShape, isAccelKey, useEditor } from '@tldraw/editor'\nimport { useCallback, useEffect, useRef } from 'react'\nimport { isEmptyRichText } from '../../utils/text/richText'\nimport { useEditableTextCommon } from './useEditablePlainText'\n\n/** @public */\nexport function useEditableRichText(shapeId: TLShapeId, type: string, richText?: TLRichText) {\n\tconst commonUseEditableTextHandlers = useEditableTextCommon(shapeId)\n\tconst isEditing = commonUseEditableTextHandlers.isEditing\n\tconst editor = useEditor()\n\tconst rInput = useRef<HTMLDivElement>(null)\n\tconst isEmpty = richText && isEmptyRichText(richText)\n\n\tuseEffect(() => {\n\t\tif (!isEditing) return\n\n\t\t// N.B. In Development mode you need to ensure you're testing this without StrictMode on.\n\t\t// Otherwise it's not gonna work as expected on iOS.\n\t\tconst contentEditable = rInput.current?.querySelector('[contenteditable]')\n\t\tif (contentEditable && document.activeElement !== rInput.current) {\n\t\t\t// This is a crucial difference with useEditablePlainText, that we need to select the\n\t\t\t// child contentEditable <div> not rInput.current directly.\n\t\t\t// Specifically, this is to ensure iOS works. Otherwise, we could just use rInput.current.\n\t\t\t;(contentEditable as HTMLElement).focus()\n\t\t}\n\t}, [editor, isEditing])\n\n\t// When the user presses ctrl / meta enter, complete the editing state.\n\tconst handleKeyDown = useCallback(\n\t\t(e: KeyboardEvent) => {\n\t\t\tif (editor.getEditingShapeId() !== shapeId) return\n\t\t\tif (e.key === 'Enter' && isAccelKey(e)) editor.complete()\n\t\t},\n\t\t[editor, shapeId]\n\t)\n\n\t// When the text changes, update the text value.\n\tconst handleChange = useCallback(\n\t\t({ richText }: { richText: TLRichText }) => {\n\t\t\tif (editor.getEditingShapeId() !== shapeId) return\n\n\t\t\teditor.updateShape<TLUnknownShape & { props: { richText: TLRichText } }>({\n\t\t\t\tid: shapeId,\n\t\t\t\ttype,\n\t\t\t\tprops: { richText },\n\t\t\t})\n\t\t},\n\t\t[editor, shapeId, type]\n\t)\n\n\treturn {\n\t\trInput,\n\t\thandleKeyDown,\n\t\thandleChange,\n\t\tisEmpty,\n\t\t...commonUseEditableTextHandlers,\n\t}\n}\n"],"names":["richText"],"mappings":";;;AAAA,SAAgD,YAAY,iBAAiB;;;AAC7E,SAAS,aAAa,WAAW,cAAc;AAC/C,SAAS,uBAAuB;AAChC,SAAS,6BAA6B;;;;;AAG/B,SAAS,oBAAoB,OAAA,EAAoB,IAAA,EAAc,QAAA,EAAuB;IAC5F,MAAM,iOAAgC,wBAAA,EAAsB,OAAO;IACnE,MAAM,YAAY,8BAA8B,SAAA;IAChD,MAAM,gMAAS,YAAA,CAAU;IACzB,MAAM,2KAAS,SAAA,EAAuB,IAAI;IAC1C,MAAM,UAAU,aAAY,mMAAA,EAAgB,QAAQ;IAEpD,CAAA,GAAA,6JAAA,CAAA,YAAA;yCAAU,MAAM;YACf,IAAI,CAAC,UAAW,CAAA;YAIhB,MAAM,kBAAkB,OAAO,OAAA,EAAS,cAAc,mBAAmB;YACzE,IAAI,mBAAmB,SAAS,aAAA,KAAkB,OAAO,OAAA,EAAS;;gBAI/D,gBAAgC,KAAA,CAAM;YACzC;QACD;wCAAG;QAAC;QAAQ,SAAS;KAAC;IAGtB,MAAM,iBAAgB,+KAAA;0DACrB,CAAC,MAAqB;YACrB,IAAI,OAAO,iBAAA,CAAkB,MAAM,QAAS,CAAA;YAC5C,IAAI,EAAE,GAAA,KAAQ,iMAAW,aAAA,EAAW,CAAC,EAAG,CAAA,OAAO,QAAA,CAAS;QACzD;yDACA;QAAC;QAAQ,OAAO;KAAA;IAIjB,MAAM,iLAAe,cAAA;yDACpB,CAAC,EAAE,UAAAA,SAAAA,CAAS,CAAA,KAAgC;YAC3C,IAAI,OAAO,iBAAA,CAAkB,MAAM,QAAS,CAAA;YAE5C,OAAO,WAAA,CAAkE;gBACxE,IAAI;gBACJ;gBACA,OAAO;oBAAE,UAAAA;gBAAS;YACnB,CAAC;QACF;wDACA;QAAC;QAAQ;QAAS,IAAI;KAAA;IAGvB,OAAO;QACN;QACA;QACA;QACA;QACA,GAAG,6BAAA;IACJ;AACD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 11272, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/shared/RichTextLabel.tsx"],"sourcesContent":["import {\n\tBox,\n\tDefaultFontFamilies,\n\tTLDefaultFillStyle,\n\tTLDefaultFontStyle,\n\tTLDefaultHorizontalAlignStyle,\n\tTLDefaultVerticalAlignStyle,\n\tTLEventInfo,\n\tTLRichText,\n\tTLShapeId,\n\tpreventDefault,\n\tuseEditor,\n\tuseReactor,\n\tuseValue,\n} from '@tldraw/editor'\nimport React, { useMemo } from 'react'\nimport { renderHtmlFromRichText } from '../../utils/text/richText'\nimport { RichTextArea } from '../text/RichTextArea'\nimport { TEXT_PROPS } from './default-shape-constants'\nimport { isLegacyAlign } from './legacyProps'\nimport { useEditableRichText } from './useEditableRichText'\n\n/** @public */\nexport interface RichTextLabelProps {\n\tshapeId: TLShapeId\n\ttype: string\n\tfont: TLDefaultFontStyle\n\tfontSize: number\n\tlineHeight: number\n\tfill?: TLDefaultFillStyle\n\talign: TLDefaultHorizontalAlignStyle\n\tverticalAlign: TLDefaultVerticalAlignStyle\n\twrap?: boolean\n\trichText?: TLRichText\n\tlabelColor: string\n\tbounds?: Box\n\tisSelected: boolean\n\tonKeyDown?(e: KeyboardEvent): void\n\tclassNamePrefix?: string\n\tstyle?: React.CSSProperties\n\ttextWidth?: number\n\ttextHeight?: number\n\tpadding?: number\n\thasCustomTabBehavior?: boolean\n}\n\n/**\n * Renders a text label that can be used inside of shapes.\n * The component has the ability to be edited in place and furthermore\n * supports rich text editing.\n *\n * @public @react\n */\nexport const RichTextLabel = React.memo(function RichTextLabel({\n\tshapeId,\n\ttype,\n\trichText,\n\tlabelColor,\n\tfont,\n\tfontSize,\n\tlineHeight,\n\talign,\n\tverticalAlign,\n\twrap,\n\tisSelected,\n\tpadding = 0,\n\tonKeyDown: handleKeyDownCustom,\n\tclassNamePrefix,\n\tstyle,\n\ttextWidth,\n\ttextHeight,\n\thasCustomTabBehavior,\n}: RichTextLabelProps) {\n\tconst editor = useEditor()\n\tconst isDragging = React.useRef(false)\n\tconst { rInput, isEmpty, isEditing, isReadyForEditing, ...editableTextRest } =\n\t\tuseEditableRichText(shapeId, type, richText)\n\n\tconst html = useMemo(() => {\n\t\tif (richText) {\n\t\t\treturn renderHtmlFromRichText(editor, richText)\n\t\t}\n\t}, [editor, richText])\n\n\tconst selectToolActive = useValue(\n\t\t'isSelectToolActive',\n\t\t() => editor.getCurrentToolId() === 'select',\n\t\t[editor]\n\t)\n\n\tuseReactor(\n\t\t'isDragging',\n\t\t() => {\n\t\t\teditor.getInstanceState()\n\t\t\tisDragging.current = editor.inputs.isDragging\n\t\t},\n\t\t[editor]\n\t)\n\n\tconst legacyAlign = isLegacyAlign(align)\n\n\tconst handlePointerDown = (e: React.MouseEvent<HTMLDivElement>) => {\n\t\tif (e.target instanceof HTMLElement && (e.target.tagName === 'A' || e.target.closest('a'))) {\n\t\t\t// This mousedown prevent default is to let dragging when over a link work.\n\t\t\tpreventDefault(e)\n\n\t\t\tif (!selectToolActive) return\n\t\t\tconst link = e.target.closest('a')?.getAttribute('href') ?? ''\n\t\t\t// We don't get the mouseup event later because we preventDefault\n\t\t\t// so we have to do it manually.\n\t\t\tconst handlePointerUp = (e: TLEventInfo) => {\n\t\t\t\tif (e.name !== 'pointer_up') return\n\n\t\t\t\tif (!isDragging.current) {\n\t\t\t\t\twindow.open(link, '_blank', 'noopener, noreferrer')\n\t\t\t\t}\n\t\t\t\teditor.off('event', handlePointerUp)\n\t\t\t}\n\t\t\teditor.on('event', handlePointerUp)\n\t\t}\n\t}\n\n\t// Should be guarded higher up so that this doesn't render... but repeated here. This should never be true.\n\tif (!isEditing && isEmpty) return null\n\n\t// TODO: probably combine tl-text and tl-arrow eventually\n\tconst cssPrefix = classNamePrefix || 'tl-text'\n\treturn (\n\t\t<div\n\t\t\tclassName={`${cssPrefix}-label tl-text-wrapper tl-rich-text-wrapper`}\n\t\t\taria-hidden={!isEditing}\n\t\t\tdata-font={font}\n\t\t\tdata-align={align}\n\t\t\tdata-hastext={!isEmpty}\n\t\t\tdata-isediting={isEditing}\n\t\t\tdata-textwrap={!!wrap}\n\t\t\tdata-isselected={isSelected}\n\t\t\tstyle={{\n\t\t\t\tjustifyContent: align === 'middle' || legacyAlign ? 'center' : align,\n\t\t\t\talignItems: verticalAlign === 'middle' ? 'center' : verticalAlign,\n\t\t\t\tpadding,\n\t\t\t\t...style,\n\t\t\t}}\n\t\t>\n\t\t\t<div\n\t\t\t\tclassName={`${cssPrefix}-label__inner tl-text-content__wrapper`}\n\t\t\t\tstyle={{\n\t\t\t\t\tfontSize,\n\t\t\t\t\tlineHeight: lineHeight.toString(),\n\t\t\t\t\tminHeight: Math.floor(fontSize * lineHeight) + 'px',\n\t\t\t\t\tminWidth: Math.ceil(textWidth || 0),\n\t\t\t\t\tcolor: labelColor,\n\t\t\t\t\twidth: textWidth ? Math.ceil(textWidth) : undefined,\n\t\t\t\t\theight: textHeight ? Math.ceil(textHeight) : undefined,\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\t<div className={`${cssPrefix} tl-text tl-text-content`} dir=\"auto\">\n\t\t\t\t\t{richText && (\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\tclassName=\"tl-rich-text\"\n\t\t\t\t\t\t\tdata-is-select-tool-active={selectToolActive}\n\t\t\t\t\t\t\t// todo: see if I can abuse this\n\t\t\t\t\t\t\tdangerouslySetInnerHTML={{ __html: html || '' }}\n\t\t\t\t\t\t\tonPointerDown={handlePointerDown}\n\t\t\t\t\t\t\tdata-is-ready-for-editing={isReadyForEditing}\n\t\t\t\t\t\t/>\n\t\t\t\t\t)}\n\t\t\t\t</div>\n\t\t\t\t{(isReadyForEditing || isSelected) && (\n\t\t\t\t\t<RichTextArea\n\t\t\t\t\t\t// Fudge the ref type because we're using forwardRef and it's not typed correctly.\n\t\t\t\t\t\tref={rInput as any}\n\t\t\t\t\t\trichText={richText}\n\t\t\t\t\t\tisEditing={isEditing}\n\t\t\t\t\t\tshapeId={shapeId}\n\t\t\t\t\t\t{...editableTextRest}\n\t\t\t\t\t\thasCustomTabBehavior={hasCustomTabBehavior}\n\t\t\t\t\t\thandleKeyDown={handleKeyDownCustom ?? editableTextRest.handleKeyDown}\n\t\t\t\t\t/>\n\t\t\t\t)}\n\t\t\t</div>\n\t\t</div>\n\t)\n})\n\n/** @public */\nexport interface RichTextSVGProps {\n\tbounds: Box\n\trichText: TLRichText\n\tfontSize: number\n\tfont: TLDefaultFontStyle\n\talign: TLDefaultHorizontalAlignStyle\n\tverticalAlign: TLDefaultVerticalAlignStyle\n\twrap?: boolean\n\tlabelColor: string\n\tpadding: number\n\tshowTextOutline?: boolean\n}\n\n/**\n * Renders a rich text string as SVG given bounds and text properties.\n *\n * @public @react\n */\nexport function RichTextSVG({\n\tbounds,\n\trichText,\n\tfontSize,\n\tfont,\n\talign,\n\tverticalAlign,\n\twrap,\n\tlabelColor,\n\tpadding,\n\tshowTextOutline = true,\n}: RichTextSVGProps) {\n\tconst editor = useEditor()\n\tconst html = renderHtmlFromRichText(editor, richText)\n\tconst textAlign =\n\t\talign === 'middle'\n\t\t\t? ('center' as const)\n\t\t\t: align === 'start'\n\t\t\t\t? ('start' as const)\n\t\t\t\t: ('end' as const)\n\tconst justifyContent =\n\t\talign === 'middle'\n\t\t\t? ('center' as const)\n\t\t\t: align === 'start'\n\t\t\t\t? ('flex-start' as const)\n\t\t\t\t: ('flex-end' as const)\n\tconst alignItems =\n\t\tverticalAlign === 'middle' ? 'center' : verticalAlign === 'start' ? 'flex-start' : 'flex-end'\n\tconst wrapperStyle = {\n\t\tdisplay: 'flex',\n\t\tfontFamily: DefaultFontFamilies[font],\n\t\theight: `100%`,\n\t\tjustifyContent,\n\t\talignItems,\n\t\tpadding: `${padding}px`,\n\t}\n\tconst style = {\n\t\tfontSize: `${fontSize}px`,\n\t\twrap: wrap ? 'wrap' : 'nowrap',\n\t\tcolor: labelColor,\n\t\tlineHeight: TEXT_PROPS.lineHeight,\n\t\ttextAlign,\n\t\twidth: '100%',\n\t\twordWrap: 'break-word' as const,\n\t\toverflowWrap: 'break-word' as const,\n\t\twhiteSpace: 'pre-wrap',\n\t\ttextShadow: showTextOutline ? 'var(--tl-text-outline)' : 'none',\n\t}\n\n\treturn (\n\t\t<foreignObject\n\t\t\tx={bounds.minX}\n\t\t\ty={bounds.minY}\n\t\t\twidth={bounds.w}\n\t\t\theight={bounds.h}\n\t\t\tclassName=\"tl-export-embed-styles tl-rich-text tl-rich-text-svg\"\n\t\t>\n\t\t\t<div style={wrapperStyle}>\n\t\t\t\t<div dangerouslySetInnerHTML={{ __html: html }} style={style} />\n\t\t\t</div>\n\t\t</foreignObject>\n\t)\n}\n"],"names":["RichTextLabel","e"],"mappings":";;;;AAgJG,SAcG,KAdH;AAhJH;;;;;;AAeA,OAAO,SAAS,eAAe;AAC/B,SAAS,8BAA8B;AACvC,SAAS,oBAAoB;AAC7B,SAAS,kBAAkB;AAC3B,SAAS,qBAAqB;AAC9B,SAAS,2BAA2B;;;;;;;;;AAiC7B,MAAM,8KAAgB,UAAA,CAAM,IAAA,CAAK,SAASA,eAAc,EAC9D,OAAA,EACA,IAAA,EACA,QAAA,EACA,UAAA,EACA,IAAA,EACA,QAAA,EACA,UAAA,EACA,KAAA,EACA,aAAA,EACA,IAAA,EACA,UAAA,EACA,UAAU,CAAA,EACV,WAAW,mBAAA,EACX,eAAA,EACA,KAAA,EACA,SAAA,EACA,UAAA,EACA,oBAAA,EACD,EAAuB;IACtB,MAAM,UAAS,kMAAA,CAAU;IACzB,MAAM,2KAAa,UAAA,CAAM,MAAA,CAAO,KAAK;IACrC,MAAM,EAAE,MAAA,EAAQ,OAAA,EAAS,SAAA,EAAW,iBAAA,EAAmB,GAAG,iBAAiB,CAAA,GAC1E,sNAAA,EAAoB,SAAS,MAAM,QAAQ;IAE5C,MAAM,yKAAO,UAAA;sDAAQ,MAAM;YAC1B,IAAI,UAAU;gBACb,WAAO,uMAAA,EAAuB,QAAQ,QAAQ;YAC/C;QACD;qDAAG;QAAC;QAAQ,QAAQ;KAAC;IAErB,MAAM,wMAAmB,WAAA,EACxB;mEACA,IAAM,OAAO,gBAAA,CAAiB,MAAM;kEACpC;QAAC,MAAM;KAAA;IAGR,CAAA,GAAA,kLAAA,CAAA,aAAA,EACC;mDACA,MAAM;YACL,OAAO,gBAAA,CAAiB;YACxB,WAAW,OAAA,GAAU,OAAO,MAAA,CAAO,UAAA;QACpC;kDACA;QAAC,MAAM;KAAA;IAGR,MAAM,sMAAc,gBAAA,EAAc,KAAK;IAEvC,MAAM,oBAAoB,CAAC,MAAwC;QAClE,IAAI,EAAE,MAAA,YAAkB,eAAA,CAAgB,EAAE,MAAA,CAAO,OAAA,KAAY,OAAO,EAAE,MAAA,CAAO,OAAA,CAAQ,GAAG,CAAA,GAAI;YAE3F,CAAA,GAAA,4KAAA,CAAA,iBAAA,EAAe,CAAC;YAEhB,IAAI,CAAC,iBAAkB,CAAA;YACvB,MAAM,OAAO,EAAE,MAAA,CAAO,OAAA,CAAQ,GAAG,GAAG,aAAa,MAAM,KAAK;YAG5D,MAAM,kBAAkB,CAACC,OAAmB;gBAC3C,IAAIA,GAAE,IAAA,KAAS,aAAc,CAAA;gBAE7B,IAAI,CAAC,WAAW,OAAA,EAAS;oBACxB,OAAO,IAAA,CAAK,MAAM,UAAU,sBAAsB;gBACnD;gBACA,OAAO,GAAA,CAAI,SAAS,eAAe;YACpC;YACA,OAAO,EAAA,CAAG,SAAS,eAAe;QACnC;IACD;IAGA,IAAI,CAAC,aAAa,QAAS,CAAA,OAAO;IAGlC,MAAM,YAAY,mBAAmB;IACrC,OACC,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,OAAA;QACA,WAAW,GAAG,SAAS,CAAA,2CAAA,CAAA;QACvB,eAAa,CAAC;QACd,aAAW;QACX,cAAY;QACZ,gBAAc,CAAC;QACf,kBAAgB;QAChB,iBAAe,CAAC,CAAC;QACjB,mBAAiB;QACjB,OAAO;YACN,gBAAgB,UAAU,YAAY,cAAc,WAAW;YAC/D,YAAY,kBAAkB,WAAW,WAAW;YACpD;YACA,GAAG,KAAA;QACJ;QAEA,UAAA,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,OAAA,EAAC,OAAA;YACA,WAAW,GAAG,SAAS,CAAA,sCAAA,CAAA;YACvB,OAAO;gBACN;gBACA,YAAY,WAAW,QAAA,CAAS;gBAChC,WAAW,KAAK,KAAA,CAAM,WAAW,UAAU,IAAI;gBAC/C,UAAU,KAAK,IAAA,CAAK,aAAa,CAAC;gBAClC,OAAO;gBACP,OAAO,YAAY,KAAK,IAAA,CAAK,SAAS,IAAI,KAAA;gBAC1C,QAAQ,aAAa,KAAK,IAAA,CAAK,UAAU,IAAI,KAAA;YAC9C;YAEA,UAAA;gBAAA,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,OAAA;oBAAI,WAAW,GAAG,SAAS,CAAA,wBAAA,CAAA;oBAA4B,KAAI;oBAC1D,UAAA,YACA,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,OAAA;wBACA,WAAU;wBACV,8BAA4B;wBAE5B,yBAAyB;4BAAE,QAAQ,QAAQ;wBAAG;wBAC9C,eAAe;wBACf,6BAA2B;oBAAA;gBAC5B,CAEF;gBAAA,CACE,qBAAqB,UAAA,KACtB,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,oLAAC,gBAAA,EAAA;oBAEA,KAAK;oBACL;oBACA;oBACA;oBACC,GAAG,gBAAA;oBACJ;oBACA,eAAe,uBAAuB,iBAAiB,aAAA;gBAAA;aACxD;QAAA;IAEF;AAGH,CAAC;AAqBM,SAAS,YAAY,EAC3B,MAAA,EACA,QAAA,EACA,QAAA,EACA,IAAA,EACA,KAAA,EACA,aAAA,EACA,IAAA,EACA,UAAA,EACA,OAAA,EACA,kBAAkB,IAAA,EACnB,EAAqB;IACpB,MAAM,gMAAS,YAAA,CAAU;IACzB,MAAM,QAAO,0MAAA,EAAuB,QAAQ,QAAQ;IACpD,MAAM,YACL,UAAU,WACN,WACD,UAAU,UACR,UACA;IACN,MAAM,iBACL,UAAU,WACN,WACD,UAAU,UACR,eACA;IACN,MAAM,aACL,kBAAkB,WAAW,WAAW,kBAAkB,UAAU,eAAe;IACpF,MAAM,eAAe;QACpB,SAAS;QACT,6LAAY,sBAAA,CAAoB,IAAI,CAAA;QACpC,QAAQ,CAAA,IAAA,CAAA;QACR;QACA;QACA,SAAS,GAAG,OAAO,CAAA,EAAA,CAAA;IACpB;IACA,MAAM,QAAQ;QACb,UAAU,GAAG,QAAQ,CAAA,EAAA,CAAA;QACrB,MAAM,OAAO,SAAS;QACtB,OAAO;QACP,kNAAY,aAAA,CAAW,UAAA;QACvB;QACA,OAAO;QACP,UAAU;QACV,cAAc;QACd,YAAY;QACZ,YAAY,kBAAkB,2BAA2B;IAC1D;IAEA,OACC,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,iBAAA;QACA,GAAG,OAAO,IAAA;QACV,GAAG,OAAO,IAAA;QACV,OAAO,OAAO,CAAA;QACd,QAAQ,OAAO,CAAA;QACf,WAAU;QAEV,UAAA,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,OAAA;YAAI,OAAO;YACX,UAAA,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,OAAA;gBAAI,yBAAyB;oBAAE,QAAQ;gBAAK;gBAAG;YAAA,CAAc;QAAA,CAC/D;IAAA;AAGH","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 11446, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/geo/getGeoShapePath.ts"],"sourcesContent":["import {\n\tcenterOfCircleFromThreePoints,\n\tclamp,\n\texhaustiveSwitchError,\n\tgetPointOnCircle,\n\tgetPolygonVertices,\n\tHALF_PI,\n\tPI,\n\tPI2,\n\trng,\n\tTLDefaultDashStyle,\n\tTLDefaultSizeStyle,\n\tTLGeoShape,\n\tVec,\n\tVecModel,\n\tWeakCache,\n} from '@tldraw/editor'\nimport { STROKE_SIZES } from '../arrow/shared'\nimport { PathBuilder } from '../shared/PathBuilder'\n\nconst pathCache = new WeakCache<TLGeoShape, PathBuilder>()\nexport function getGeoShapePath(shape: TLGeoShape) {\n\treturn pathCache.get(shape, _getGeoPath)\n}\n\nfunction _getGeoPath(shape: TLGeoShape) {\n\tconst w = Math.max(1, shape.props.w)\n\tconst h = Math.max(1, shape.props.h + shape.props.growY)\n\tconst cx = w / 2\n\tconst cy = h / 2\n\tconst sw = STROKE_SIZES[shape.props.size] * shape.props.scale\n\n\tconst isFilled = shape.props.fill !== 'none'\n\n\tswitch (shape.props.geo) {\n\t\tcase 'arrow-down': {\n\t\t\tconst ox = w * 0.16\n\t\t\tconst oy = Math.min(w, h) * 0.38\n\t\t\treturn new PathBuilder()\n\t\t\t\t.moveTo(ox, 0, { geometry: { isFilled } })\n\t\t\t\t.lineTo(w - ox, 0)\n\t\t\t\t.lineTo(w - ox, h - oy)\n\t\t\t\t.lineTo(w, h - oy)\n\t\t\t\t.lineTo(w / 2, h)\n\t\t\t\t.lineTo(0, h - oy)\n\t\t\t\t.lineTo(ox, h - oy)\n\t\t\t\t.close()\n\t\t}\n\t\tcase 'arrow-left': {\n\t\t\tconst ox = Math.min(w, h) * 0.38\n\t\t\tconst oy = h * 0.16\n\t\t\treturn new PathBuilder()\n\t\t\t\t.moveTo(ox, 0, { geometry: { isFilled } })\n\t\t\t\t.lineTo(ox, oy)\n\t\t\t\t.lineTo(w, oy)\n\t\t\t\t.lineTo(w, h - oy)\n\t\t\t\t.lineTo(ox, h - oy)\n\t\t\t\t.lineTo(ox, h)\n\t\t\t\t.lineTo(0, h / 2)\n\t\t\t\t.close()\n\t\t}\n\t\tcase 'arrow-right': {\n\t\t\tconst ox = Math.min(w, h) * 0.38\n\t\t\tconst oy = h * 0.16\n\t\t\treturn new PathBuilder()\n\t\t\t\t.moveTo(0, oy, { geometry: { isFilled } })\n\t\t\t\t.lineTo(w - ox, oy)\n\t\t\t\t.lineTo(w - ox, 0)\n\t\t\t\t.lineTo(w, h / 2)\n\t\t\t\t.lineTo(w - ox, h)\n\t\t\t\t.lineTo(w - ox, h - oy)\n\t\t\t\t.lineTo(0, h - oy)\n\t\t\t\t.close()\n\t\t}\n\t\tcase 'arrow-up': {\n\t\t\tconst ox = w * 0.16\n\t\t\tconst oy = Math.min(w, h) * 0.38\n\t\t\treturn new PathBuilder()\n\t\t\t\t.moveTo(w / 2, 0, { geometry: { isFilled } })\n\t\t\t\t.lineTo(w, oy)\n\t\t\t\t.lineTo(w - ox, oy)\n\t\t\t\t.lineTo(w - ox, h)\n\t\t\t\t.lineTo(ox, h)\n\t\t\t\t.lineTo(ox, oy)\n\t\t\t\t.lineTo(0, oy)\n\t\t\t\t.close()\n\t\t}\n\t\tcase 'check-box': {\n\t\t\tconst size = Math.min(w, h) * 0.82\n\t\t\tconst ox = (w - size) / 2\n\t\t\tconst oy = (h - size) / 2\n\n\t\t\treturn new PathBuilder()\n\t\t\t\t.moveTo(0, 0, { geometry: { isFilled } })\n\t\t\t\t.lineTo(w, 0)\n\t\t\t\t.lineTo(w, h)\n\t\t\t\t.lineTo(0, h)\n\t\t\t\t.close()\n\t\t\t\t.moveTo(clamp(ox + size * 0.25, 0, w), clamp(oy + size * 0.52, 0, h), {\n\t\t\t\t\tgeometry: { isInternal: true, isFilled: false },\n\t\t\t\t\toffset: 0,\n\t\t\t\t})\n\t\t\t\t.lineTo(clamp(ox + size * 0.45, 0, w), clamp(oy + size * 0.82, 0, h))\n\t\t\t\t.lineTo(clamp(ox + size * 0.82, 0, w), clamp(oy + size * 0.22, 0, h), { offset: 0 })\n\t\t}\n\t\tcase 'diamond':\n\t\t\treturn new PathBuilder()\n\t\t\t\t.moveTo(cx, 0, { geometry: { isFilled } })\n\t\t\t\t.lineTo(w, cy)\n\t\t\t\t.lineTo(cx, h)\n\t\t\t\t.lineTo(0, cy)\n\t\t\t\t.close()\n\t\tcase 'ellipse':\n\t\t\treturn new PathBuilder()\n\t\t\t\t.moveTo(0, cy, { geometry: { isFilled } })\n\t\t\t\t.arcTo(cx, cy, false, true, 0, w, cy)\n\t\t\t\t.arcTo(cx, cy, false, true, 0, 0, cy)\n\t\t\t\t.close()\n\t\tcase 'heart': {\n\t\t\tconst o = w / 4\n\t\t\tconst k = h / 4\n\t\t\treturn new PathBuilder()\n\t\t\t\t.moveTo(cx, h, { geometry: { isFilled } })\n\t\t\t\t.cubicBezierTo(0, k * 1.2, o * 1.5, k * 3, 0, k * 2.5)\n\t\t\t\t.cubicBezierTo(cx, k * 0.9, 0, -k * 0.32, o * 1.85, -k * 0.32)\n\t\t\t\t.cubicBezierTo(w, k * 1.2, o * 2.15, -k * 0.32, w, -k * 0.32)\n\t\t\t\t.cubicBezierTo(cx, h, w, k * 2.5, o * 2.5, k * 3)\n\t\t\t\t.close()\n\t\t}\n\t\tcase 'hexagon':\n\t\t\treturn PathBuilder.lineThroughPoints(getPolygonVertices(w, h, 6), {\n\t\t\t\tgeometry: { isFilled },\n\t\t\t}).close()\n\t\tcase 'octagon':\n\t\t\treturn PathBuilder.lineThroughPoints(getPolygonVertices(w, h, 8), {\n\t\t\t\tgeometry: { isFilled },\n\t\t\t}).close()\n\t\tcase 'oval':\n\t\t\treturn getStadiumPath(w, h, isFilled)\n\t\tcase 'pentagon':\n\t\t\treturn PathBuilder.lineThroughPoints(getPolygonVertices(w, h, 5), {\n\t\t\t\tgeometry: { isFilled },\n\t\t\t}).close()\n\t\tcase 'rectangle':\n\t\t\treturn new PathBuilder()\n\t\t\t\t.moveTo(0, 0, { geometry: { isFilled } })\n\t\t\t\t.lineTo(w, 0)\n\t\t\t\t.lineTo(w, h)\n\t\t\t\t.lineTo(0, h)\n\t\t\t\t.close()\n\t\tcase 'rhombus': {\n\t\t\tconst offset = Math.min(w * 0.38, h * 0.38)\n\t\t\treturn new PathBuilder()\n\t\t\t\t.moveTo(offset, 0, { geometry: { isFilled } })\n\t\t\t\t.lineTo(w, 0)\n\t\t\t\t.lineTo(w - offset, h)\n\t\t\t\t.lineTo(0, h)\n\t\t\t\t.close()\n\t\t}\n\t\tcase 'rhombus-2': {\n\t\t\tconst offset = Math.min(w * 0.38, h * 0.38)\n\t\t\treturn new PathBuilder()\n\t\t\t\t.moveTo(0, 0, { geometry: { isFilled } })\n\t\t\t\t.lineTo(w - offset, 0)\n\t\t\t\t.lineTo(w, h)\n\t\t\t\t.lineTo(offset, h)\n\t\t\t\t.close()\n\t\t}\n\t\tcase 'star':\n\t\t\treturn getStarPath(w, h, isFilled)\n\t\tcase 'trapezoid': {\n\t\t\tconst offset = Math.min(w * 0.38, h * 0.38)\n\t\t\treturn new PathBuilder()\n\t\t\t\t.moveTo(offset, 0, { geometry: { isFilled } })\n\t\t\t\t.lineTo(w - offset, 0)\n\t\t\t\t.lineTo(w, h)\n\t\t\t\t.lineTo(0, h)\n\t\t\t\t.close()\n\t\t}\n\t\tcase 'triangle':\n\t\t\treturn new PathBuilder()\n\t\t\t\t.moveTo(cx, 0, { geometry: { isFilled } })\n\t\t\t\t.lineTo(w, h)\n\t\t\t\t.lineTo(0, h)\n\t\t\t\t.close()\n\t\tcase 'x-box':\n\t\t\treturn getXBoxPath(w, h, sw, shape.props.dash, isFilled)\n\n\t\tcase 'cloud':\n\t\t\treturn getCloudPath(w, h, shape.id, shape.props.size, shape.props.scale, isFilled)\n\t\tdefault:\n\t\t\texhaustiveSwitchError(shape.props.geo)\n\t}\n}\n\nfunction getXBoxPath(\n\tw: number,\n\th: number,\n\tsw: number,\n\tdash: TLDefaultDashStyle,\n\tisFilled: boolean\n) {\n\tconst cx = w / 2\n\tconst cy = h / 2\n\n\tconst path = new PathBuilder()\n\t\t.moveTo(0, 0, { geometry: { isFilled } })\n\t\t.lineTo(w, 0)\n\t\t.lineTo(w, h)\n\t\t.lineTo(0, h)\n\t\t.close()\n\n\tif (dash === 'dashed' || dash === 'dotted') {\n\t\treturn path\n\t\t\t.moveTo(0, 0, {\n\t\t\t\tgeometry: { isInternal: true, isFilled: false },\n\t\t\t\tdashStart: 'skip',\n\t\t\t\tdashEnd: 'outset',\n\t\t\t})\n\t\t\t.lineTo(cx, cy)\n\t\t\t.moveTo(w, h, {\n\t\t\t\tgeometry: { isInternal: true, isFilled: false },\n\t\t\t\tdashStart: 'skip',\n\t\t\t\tdashEnd: 'outset',\n\t\t\t})\n\t\t\t.lineTo(cx, cy)\n\t\t\t.moveTo(0, h, {\n\t\t\t\tgeometry: { isInternal: true, isFilled: false },\n\t\t\t\tdashStart: 'skip',\n\t\t\t\tdashEnd: 'outset',\n\t\t\t})\n\t\t\t.lineTo(cx, cy)\n\t\t\t.moveTo(w, 0, {\n\t\t\t\tgeometry: { isInternal: true, isFilled: false },\n\t\t\t\tdashStart: 'skip',\n\t\t\t\tdashEnd: 'outset',\n\t\t\t})\n\t\t\t.lineTo(cx, cy)\n\t}\n\n\tconst inset = dash === 'draw' ? 0.62 : 0\n\n\tpath\n\t\t.moveTo(clamp(sw * inset, 0, w), clamp(sw * inset, 0, h), {\n\t\t\tgeometry: { isInternal: true, isFilled: false },\n\t\t})\n\t\t.lineTo(clamp(w - sw * inset, 0, w), clamp(h - sw * inset, 0, h))\n\t\t.moveTo(clamp(w - sw * inset, 0, w), clamp(sw * inset, 0, h))\n\t\t.lineTo(clamp(sw * inset, 0, w), clamp(h - sw * inset, 0, h))\n\n\treturn path\n}\n\nfunction getStadiumPath(w: number, h: number, isFilled: boolean) {\n\t// stadium:\n\tif (h > w) {\n\t\tconst r = w / 2\n\t\treturn new PathBuilder()\n\t\t\t.moveTo(0, r, { geometry: { isFilled } })\n\t\t\t.arcTo(r, r, false, true, 0, w, r)\n\t\t\t.lineTo(w, h - r)\n\t\t\t.arcTo(r, r, false, true, 0, 0, h - r)\n\t\t\t.close()\n\t}\n\n\tconst r = h / 2\n\treturn new PathBuilder()\n\t\t.moveTo(r, h, { geometry: { isFilled } })\n\t\t.arcTo(r, r, false, true, 0, r, 0)\n\t\t.lineTo(w - r, 0)\n\t\t.arcTo(r, r, false, true, 0, w - r, h)\n\t\t.close()\n}\n\nfunction getStarPath(w: number, h: number, isFilled: boolean) {\n\t// Most of this code is to offset the center, a 5 point star\n\t// will need to be moved downward because from its center [0,0]\n\t// it will have a bigger minY than maxY. This is because it'll\n\t// have 2 points at the bottom.\n\tconst sides = 5\n\tconst step = PI2 / sides / 2\n\tconst rightMostIndex = Math.floor(sides / 4) * 2\n\tconst leftMostIndex = sides * 2 - rightMostIndex\n\tconst topMostIndex = 0\n\tconst bottomMostIndex = Math.floor(sides / 2) * 2\n\tconst maxX = (Math.cos(-HALF_PI + rightMostIndex * step) * w) / 2\n\tconst minX = (Math.cos(-HALF_PI + leftMostIndex * step) * w) / 2\n\n\tconst minY = (Math.sin(-HALF_PI + topMostIndex * step) * h) / 2\n\tconst maxY = (Math.sin(-HALF_PI + bottomMostIndex * step) * h) / 2\n\tconst diffX = w - Math.abs(maxX - minX)\n\tconst diffY = h - Math.abs(maxY - minY)\n\tconst offsetX = w / 2 + minX - (w / 2 - maxX)\n\tconst offsetY = h / 2 + minY - (h / 2 - maxY)\n\n\tconst ratio = 1\n\tconst cx = (w - offsetX) / 2\n\tconst cy = (h - offsetY) / 2\n\tconst ox = (w + diffX) / 2\n\tconst oy = (h + diffY) / 2\n\tconst ix = (ox * ratio) / 2\n\tconst iy = (oy * ratio) / 2\n\n\treturn PathBuilder.lineThroughPoints(\n\t\tArray.from(Array(sides * 2), (_, i) => {\n\t\t\tconst theta = -HALF_PI + i * step\n\t\t\treturn new Vec(\n\t\t\t\tcx + (i % 2 ? ix : ox) * Math.cos(theta),\n\t\t\t\tcy + (i % 2 ? iy : oy) * Math.sin(theta)\n\t\t\t)\n\t\t}),\n\t\t{ geometry: { isFilled } }\n\t).close()\n}\n\n/* ---------------------- Cloud --------------------- */\n\nfunction getOvalPerimeter(h: number, w: number) {\n\tif (h > w) return (PI * (w / 2) + (h - w)) * 2\n\telse return (PI * (h / 2) + (w - h)) * 2\n}\n\ntype PillSection =\n\t| {\n\t\t\ttype: 'straight'\n\t\t\tstart: VecModel\n\t\t\tdelta: VecModel\n\t  }\n\t| {\n\t\t\ttype: 'arc'\n\t\t\tcenter: VecModel\n\t\t\tstartAngle: number\n\t  }\n\nfunction getPillPoints(width: number, height: number, numPoints: number) {\n\tconst radius = Math.min(width, height) / 2\n\tconst longSide = Math.max(width, height) - radius * 2\n\tconst circumference = Math.PI * (radius * 2) + 2 * longSide\n\tconst spacing = circumference / numPoints\n\n\tconst sections: PillSection[] =\n\t\twidth > height\n\t\t\t? [\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'straight',\n\t\t\t\t\t\tstart: new Vec(radius, 0),\n\t\t\t\t\t\tdelta: new Vec(1, 0),\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'arc',\n\t\t\t\t\t\tcenter: new Vec(width - radius, radius),\n\t\t\t\t\t\tstartAngle: -PI / 2,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'straight',\n\t\t\t\t\t\tstart: new Vec(width - radius, height),\n\t\t\t\t\t\tdelta: new Vec(-1, 0),\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'arc',\n\t\t\t\t\t\tcenter: new Vec(radius, radius),\n\t\t\t\t\t\tstartAngle: PI / 2,\n\t\t\t\t\t},\n\t\t\t\t]\n\t\t\t: [\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'straight',\n\t\t\t\t\t\tstart: new Vec(width, radius),\n\t\t\t\t\t\tdelta: new Vec(0, 1),\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'arc',\n\t\t\t\t\t\tcenter: new Vec(radius, height - radius),\n\t\t\t\t\t\tstartAngle: 0,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'straight',\n\t\t\t\t\t\tstart: new Vec(0, height - radius),\n\t\t\t\t\t\tdelta: new Vec(0, -1),\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'arc',\n\t\t\t\t\t\tcenter: new Vec(radius, radius),\n\t\t\t\t\t\tstartAngle: PI,\n\t\t\t\t\t},\n\t\t\t\t]\n\n\tlet sectionOffset = 0\n\n\tconst points: Vec[] = []\n\tfor (let i = 0; i < numPoints; i++) {\n\t\tconst section = sections[0]\n\t\tif (section.type === 'straight') {\n\t\t\tpoints.push(Vec.Add(section.start, Vec.Mul(section.delta, sectionOffset)))\n\t\t} else {\n\t\t\tpoints.push(\n\t\t\t\tgetPointOnCircle(section.center, radius, section.startAngle + sectionOffset / radius)\n\t\t\t)\n\t\t}\n\t\tsectionOffset += spacing\n\t\tlet sectionLength = section.type === 'straight' ? longSide : PI * radius\n\t\twhile (sectionOffset > sectionLength) {\n\t\t\tsectionOffset -= sectionLength\n\t\t\tsections.push(sections.shift()!)\n\t\t\tsectionLength = sections[0].type === 'straight' ? longSide : PI * radius\n\t\t}\n\t}\n\n\treturn points\n}\n\nconst SIZES: Record<TLDefaultSizeStyle, number> = {\n\ts: 50,\n\tm: 70,\n\tl: 100,\n\txl: 130,\n}\n\nconst BUMP_PROTRUSION = 0.2\n\nfunction getCloudPath(\n\twidth: number,\n\theight: number,\n\tseed: string,\n\tsize: TLDefaultSizeStyle,\n\tscale: number,\n\tisFilled: boolean\n) {\n\tconst path = new PathBuilder()\n\tconst getRandom = rng(seed)\n\tconst pillCircumference = getOvalPerimeter(width, height)\n\tconst numBumps = Math.max(\n\t\tMath.ceil(pillCircumference / SIZES[size]),\n\t\t6,\n\t\tMath.ceil(pillCircumference / Math.min(width, height))\n\t)\n\tconst targetBumpProtrusion = (pillCircumference / numBumps) * BUMP_PROTRUSION\n\n\t// if the aspect ratio is high, innerWidth should be smaller\n\tconst innerWidth = Math.max(width - targetBumpProtrusion * 2, 1)\n\tconst innerHeight = Math.max(height - targetBumpProtrusion * 2, 1)\n\tconst innerCircumference = getOvalPerimeter(innerWidth, innerHeight)\n\n\tconst distanceBetweenPointsOnPerimeter = innerCircumference / numBumps\n\n\tconst paddingX = (width - innerWidth) / 2\n\tconst paddingY = (height - innerHeight) / 2\n\tconst bumpPoints = getPillPoints(innerWidth, innerHeight, numBumps).map((p) => {\n\t\treturn p.addXY(paddingX, paddingY)\n\t})\n\tconst maxWiggleX = width < 20 ? 0 : targetBumpProtrusion * 0.3\n\tconst maxWiggleY = height < 20 ? 0 : targetBumpProtrusion * 0.3\n\n\t// wiggle the points from either end so that the bumps 'pop'\n\t// in at the bottom-right and the top-left looks relatively stable\n\t// note: it's important that we don't mutate here! these points are also the bump points\n\tconst wiggledPoints = bumpPoints.slice(0)\n\tfor (let i = 0; i < Math.floor(numBumps / 2); i++) {\n\t\twiggledPoints[i] = Vec.AddXY(\n\t\t\twiggledPoints[i],\n\t\t\tgetRandom() * maxWiggleX * scale,\n\t\t\tgetRandom() * maxWiggleY * scale\n\t\t)\n\t\twiggledPoints[numBumps - i - 1] = Vec.AddXY(\n\t\t\twiggledPoints[numBumps - i - 1],\n\t\t\tgetRandom() * maxWiggleX * scale,\n\t\t\tgetRandom() * maxWiggleY * scale\n\t\t)\n\t}\n\n\tfor (let i = 0; i < wiggledPoints.length; i++) {\n\t\tconst j = i === wiggledPoints.length - 1 ? 0 : i + 1\n\t\tconst leftWigglePoint = wiggledPoints[i]\n\t\tconst rightWigglePoint = wiggledPoints[j]\n\t\tconst leftPoint = bumpPoints[i]\n\t\tconst rightPoint = bumpPoints[j]\n\n\t\t// when the points are on the curvy part of a pill, there is a natural arc that we need to extends past\n\t\t// otherwise it looks like the bumps get less bumpy on the curvy parts\n\t\tconst distanceBetweenOriginalPoints = Vec.Dist(leftPoint, rightPoint)\n\t\tconst curvatureOffset = distanceBetweenPointsOnPerimeter - distanceBetweenOriginalPoints\n\t\tconst distanceBetweenWigglePoints = Vec.Dist(leftWigglePoint, rightWigglePoint)\n\t\tconst relativeSize = distanceBetweenWigglePoints / distanceBetweenOriginalPoints\n\t\tconst finalDistance = (Math.max(paddingX, paddingY) + curvatureOffset) * relativeSize\n\n\t\tconst arcPoint = Vec.Lrp(leftPoint, rightPoint, 0.5).add(\n\t\t\tVec.Sub(rightPoint, leftPoint).uni().per().mul(finalDistance)\n\t\t)\n\t\tif (arcPoint.x < 0) {\n\t\t\tarcPoint.x = 0\n\t\t} else if (arcPoint.x > width) {\n\t\t\tarcPoint.x = width\n\t\t}\n\t\tif (arcPoint.y < 0) {\n\t\t\tarcPoint.y = 0\n\t\t} else if (arcPoint.y > height) {\n\t\t\tarcPoint.y = height\n\t\t}\n\n\t\tconst center = centerOfCircleFromThreePoints(leftWigglePoint, rightWigglePoint, arcPoint)\n\n\t\tconst radius = Vec.Dist(\n\t\t\tcenter ? center : Vec.Average([leftWigglePoint, rightWigglePoint]),\n\t\t\tleftWigglePoint\n\t\t)\n\n\t\tif (i === 0) {\n\t\t\tpath.moveTo(leftWigglePoint.x, leftWigglePoint.y, { geometry: { isFilled } })\n\t\t}\n\n\t\tpath.circularArcTo(radius, false, true, rightWigglePoint.x, rightWigglePoint.y)\n\t}\n\n\treturn path.close()\n}\n"],"names":["r"],"mappings":";;;AAAA;;;;;;AAiBA,SAAS,oBAAoB;AAC7B,SAAS,mBAAmB;;;;AAE5B,MAAM,YAAY,yKAAI,YAAA,CAAmC;AAClD,SAAS,gBAAgB,KAAA,EAAmB;IAClD,OAAO,UAAU,GAAA,CAAI,OAAO,WAAW;AACxC;AAEA,SAAS,YAAY,KAAA,EAAmB;IACvC,MAAM,IAAI,KAAK,GAAA,CAAI,GAAG,MAAM,KAAA,CAAM,CAAC;IACnC,MAAM,IAAI,KAAK,GAAA,CAAI,GAAG,MAAM,KAAA,CAAM,CAAA,GAAI,MAAM,KAAA,CAAM,KAAK;IACvD,MAAM,KAAK,IAAI;IACf,MAAM,KAAK,IAAI;IACf,MAAM,mLAAK,eAAA,CAAa,MAAM,KAAA,CAAM,IAAI,CAAA,GAAI,MAAM,KAAA,CAAM,KAAA;IAExD,MAAM,WAAW,MAAM,KAAA,CAAM,IAAA,KAAS;IAEtC,OAAQ,MAAM,KAAA,CAAM,GAAA,EAAK;QACxB,KAAK;YAAc;gBAClB,MAAM,KAAK,IAAI;gBACf,MAAM,KAAK,KAAK,GAAA,CAAI,GAAG,CAAC,IAAI;gBAC5B,OAAO,wLAAI,cAAA,CAAY,EACrB,MAAA,CAAO,IAAI,GAAG;oBAAE,UAAU;wBAAE;oBAAS;gBAAE,CAAC,EACxC,MAAA,CAAO,IAAI,IAAI,CAAC,EAChB,MAAA,CAAO,IAAI,IAAI,IAAI,EAAE,EACrB,MAAA,CAAO,GAAG,IAAI,EAAE,EAChB,MAAA,CAAO,IAAI,GAAG,CAAC,EACf,MAAA,CAAO,GAAG,IAAI,EAAE,EAChB,MAAA,CAAO,IAAI,IAAI,EAAE,EACjB,KAAA,CAAM;YACT;QACA,KAAK;YAAc;gBAClB,MAAM,KAAK,KAAK,GAAA,CAAI,GAAG,CAAC,IAAI;gBAC5B,MAAM,KAAK,IAAI;gBACf,OAAO,wLAAI,cAAA,CAAY,EACrB,MAAA,CAAO,IAAI,GAAG;oBAAE,UAAU;wBAAE;oBAAS;gBAAE,CAAC,EACxC,MAAA,CAAO,IAAI,EAAE,EACb,MAAA,CAAO,GAAG,EAAE,EACZ,MAAA,CAAO,GAAG,IAAI,EAAE,EAChB,MAAA,CAAO,IAAI,IAAI,EAAE,EACjB,MAAA,CAAO,IAAI,CAAC,EACZ,MAAA,CAAO,GAAG,IAAI,CAAC,EACf,KAAA,CAAM;YACT;QACA,KAAK;YAAe;gBACnB,MAAM,KAAK,KAAK,GAAA,CAAI,GAAG,CAAC,IAAI;gBAC5B,MAAM,KAAK,IAAI;gBACf,OAAO,wLAAI,cAAA,CAAY,EACrB,MAAA,CAAO,GAAG,IAAI;oBAAE,UAAU;wBAAE;oBAAS;gBAAE,CAAC,EACxC,MAAA,CAAO,IAAI,IAAI,EAAE,EACjB,MAAA,CAAO,IAAI,IAAI,CAAC,EAChB,MAAA,CAAO,GAAG,IAAI,CAAC,EACf,MAAA,CAAO,IAAI,IAAI,CAAC,EAChB,MAAA,CAAO,IAAI,IAAI,IAAI,EAAE,EACrB,MAAA,CAAO,GAAG,IAAI,EAAE,EAChB,KAAA,CAAM;YACT;QACA,KAAK;YAAY;gBAChB,MAAM,KAAK,IAAI;gBACf,MAAM,KAAK,KAAK,GAAA,CAAI,GAAG,CAAC,IAAI;gBAC5B,OAAO,wLAAI,cAAA,CAAY,EACrB,MAAA,CAAO,IAAI,GAAG,GAAG;oBAAE,UAAU;wBAAE;oBAAS;gBAAE,CAAC,EAC3C,MAAA,CAAO,GAAG,EAAE,EACZ,MAAA,CAAO,IAAI,IAAI,EAAE,EACjB,MAAA,CAAO,IAAI,IAAI,CAAC,EAChB,MAAA,CAAO,IAAI,CAAC,EACZ,MAAA,CAAO,IAAI,EAAE,EACb,MAAA,CAAO,GAAG,EAAE,EACZ,KAAA,CAAM;YACT;QACA,KAAK;YAAa;gBACjB,MAAM,OAAO,KAAK,GAAA,CAAI,GAAG,CAAC,IAAI;gBAC9B,MAAM,KAAA,CAAM,IAAI,IAAA,IAAQ;gBACxB,MAAM,KAAA,CAAM,IAAI,IAAA,IAAQ;gBAExB,OAAO,wLAAI,cAAA,CAAY,EACrB,MAAA,CAAO,GAAG,GAAG;oBAAE,UAAU;wBAAE;oBAAS;gBAAE,CAAC,EACvC,MAAA,CAAO,GAAG,CAAC,EACX,MAAA,CAAO,GAAG,CAAC,EACX,MAAA,CAAO,GAAG,CAAC,EACX,KAAA,CAAM,EACN,MAAA,EAAO,+LAAA,EAAM,KAAK,OAAO,MAAM,GAAG,CAAC,2LAAG,QAAA,EAAM,KAAK,OAAO,MAAM,GAAG,CAAC,GAAG;oBACrE,UAAU;wBAAE,YAAY;wBAAM,UAAU;oBAAM;oBAC9C,QAAQ;gBACT,CAAC,EACA,MAAA,CAAO,gMAAA,EAAM,KAAK,OAAO,MAAM,GAAG,CAAC,2LAAG,QAAA,EAAM,KAAK,OAAO,MAAM,GAAG,CAAC,CAAC,EACnE,MAAA,CAAO,gMAAA,EAAM,KAAK,OAAO,MAAM,GAAG,CAAC,2LAAG,QAAA,EAAM,KAAK,OAAO,MAAM,GAAG,CAAC,GAAG;oBAAE,QAAQ;gBAAE,CAAC;YACrF;QACA,KAAK;YACJ,OAAO,wLAAI,cAAA,CAAY,EACrB,MAAA,CAAO,IAAI,GAAG;gBAAE,UAAU;oBAAE;gBAAS;YAAE,CAAC,EACxC,MAAA,CAAO,GAAG,EAAE,EACZ,MAAA,CAAO,IAAI,CAAC,EACZ,MAAA,CAAO,GAAG,EAAE,EACZ,KAAA,CAAM;QACT,KAAK;YACJ,OAAO,wLAAI,cAAA,CAAY,EACrB,MAAA,CAAO,GAAG,IAAI;gBAAE,UAAU;oBAAE;gBAAS;YAAE,CAAC,EACxC,KAAA,CAAM,IAAI,IAAI,OAAO,MAAM,GAAG,GAAG,EAAE,EACnC,KAAA,CAAM,IAAI,IAAI,OAAO,MAAM,GAAG,GAAG,EAAE,EACnC,KAAA,CAAM;QACT,KAAK;YAAS;gBACb,MAAM,IAAI,IAAI;gBACd,MAAM,IAAI,IAAI;gBACd,OAAO,wLAAI,cAAA,CAAY,EACrB,MAAA,CAAO,IAAI,GAAG;oBAAE,UAAU;wBAAE;oBAAS;gBAAE,CAAC,EACxC,aAAA,CAAc,GAAG,IAAI,KAAK,IAAI,KAAK,IAAI,GAAG,GAAG,IAAI,GAAG,EACpD,aAAA,CAAc,IAAI,IAAI,KAAK,GAAG,CAAC,IAAI,MAAM,IAAI,MAAM,CAAC,IAAI,IAAI,EAC5D,aAAA,CAAc,GAAG,IAAI,KAAK,IAAI,MAAM,CAAC,IAAI,MAAM,GAAG,CAAC,IAAI,IAAI,EAC3D,aAAA,CAAc,IAAI,GAAG,GAAG,IAAI,KAAK,IAAI,KAAK,IAAI,CAAC,EAC/C,KAAA,CAAM;YACT;QACA,KAAK;YACJ,2LAAO,cAAA,CAAY,iBAAA,yLAAkB,qBAAA,EAAmB,GAAG,GAAG,CAAC,GAAG;gBACjE,UAAU;oBAAE;gBAAS;YACtB,CAAC,EAAE,KAAA,CAAM;QACV,KAAK;YACJ,2LAAO,cAAA,CAAY,iBAAA,yLAAkB,qBAAA,EAAmB,GAAG,GAAG,CAAC,GAAG;gBACjE,UAAU;oBAAE;gBAAS;YACtB,CAAC,EAAE,KAAA,CAAM;QACV,KAAK;YACJ,OAAO,eAAe,GAAG,GAAG,QAAQ;QACrC,KAAK;YACJ,OAAO,kMAAA,CAAY,iBAAA,yLAAkB,qBAAA,EAAmB,GAAG,GAAG,CAAC,GAAG;gBACjE,UAAU;oBAAE;gBAAS;YACtB,CAAC,EAAE,KAAA,CAAM;QACV,KAAK;YACJ,OAAO,wLAAI,cAAA,CAAY,EACrB,MAAA,CAAO,GAAG,GAAG;gBAAE,UAAU;oBAAE;gBAAS;YAAE,CAAC,EACvC,MAAA,CAAO,GAAG,CAAC,EACX,MAAA,CAAO,GAAG,CAAC,EACX,MAAA,CAAO,GAAG,CAAC,EACX,KAAA,CAAM;QACT,KAAK;YAAW;gBACf,MAAM,SAAS,KAAK,GAAA,CAAI,IAAI,MAAM,IAAI,IAAI;gBAC1C,OAAO,wLAAI,cAAA,CAAY,EACrB,MAAA,CAAO,QAAQ,GAAG;oBAAE,UAAU;wBAAE;oBAAS;gBAAE,CAAC,EAC5C,MAAA,CAAO,GAAG,CAAC,EACX,MAAA,CAAO,IAAI,QAAQ,CAAC,EACpB,MAAA,CAAO,GAAG,CAAC,EACX,KAAA,CAAM;YACT;QACA,KAAK;YAAa;gBACjB,MAAM,SAAS,KAAK,GAAA,CAAI,IAAI,MAAM,IAAI,IAAI;gBAC1C,OAAO,wLAAI,cAAA,CAAY,EACrB,MAAA,CAAO,GAAG,GAAG;oBAAE,UAAU;wBAAE;oBAAS;gBAAE,CAAC,EACvC,MAAA,CAAO,IAAI,QAAQ,CAAC,EACpB,MAAA,CAAO,GAAG,CAAC,EACX,MAAA,CAAO,QAAQ,CAAC,EAChB,KAAA,CAAM;YACT;QACA,KAAK;YACJ,OAAO,YAAY,GAAG,GAAG,QAAQ;QAClC,KAAK;YAAa;gBACjB,MAAM,SAAS,KAAK,GAAA,CAAI,IAAI,MAAM,IAAI,IAAI;gBAC1C,OAAO,wLAAI,cAAA,CAAY,EACrB,MAAA,CAAO,QAAQ,GAAG;oBAAE,UAAU;wBAAE;oBAAS;gBAAE,CAAC,EAC5C,MAAA,CAAO,IAAI,QAAQ,CAAC,EACpB,MAAA,CAAO,GAAG,CAAC,EACX,MAAA,CAAO,GAAG,CAAC,EACX,KAAA,CAAM;YACT;QACA,KAAK;YACJ,OAAO,wLAAI,cAAA,CAAY,EACrB,MAAA,CAAO,IAAI,GAAG;gBAAE,UAAU;oBAAE;gBAAS;YAAE,CAAC,EACxC,MAAA,CAAO,GAAG,CAAC,EACX,MAAA,CAAO,GAAG,CAAC,EACX,KAAA,CAAM;QACT,KAAK;YACJ,OAAO,YAAY,GAAG,GAAG,IAAI,MAAM,KAAA,CAAM,IAAA,EAAM,QAAQ;QAExD,KAAK;YACJ,OAAO,aAAa,GAAG,GAAG,MAAM,EAAA,EAAI,MAAM,KAAA,CAAM,IAAA,EAAM,MAAM,KAAA,CAAM,KAAA,EAAO,QAAQ;QAClF;YACC,CAAA,GAAA,sKAAA,CAAA,wBAAA,EAAsB,MAAM,KAAA,CAAM,GAAG;IACvC;AACD;AAEA,SAAS,YACR,CAAA,EACA,CAAA,EACA,EAAA,EACA,IAAA,EACA,QAAA,EACC;IACD,MAAM,KAAK,IAAI;IACf,MAAM,KAAK,IAAI;IAEf,MAAM,OAAO,IAAI,kMAAA,CAAY,EAC3B,MAAA,CAAO,GAAG,GAAG;QAAE,UAAU;YAAE;QAAS;IAAE,CAAC,EACvC,MAAA,CAAO,GAAG,CAAC,EACX,MAAA,CAAO,GAAG,CAAC,EACX,MAAA,CAAO,GAAG,CAAC,EACX,KAAA,CAAM;IAER,IAAI,SAAS,YAAY,SAAS,UAAU;QAC3C,OAAO,KACL,MAAA,CAAO,GAAG,GAAG;YACb,UAAU;gBAAE,YAAY;gBAAM,UAAU;YAAM;YAC9C,WAAW;YACX,SAAS;QACV,CAAC,EACA,MAAA,CAAO,IAAI,EAAE,EACb,MAAA,CAAO,GAAG,GAAG;YACb,UAAU;gBAAE,YAAY;gBAAM,UAAU;YAAM;YAC9C,WAAW;YACX,SAAS;QACV,CAAC,EACA,MAAA,CAAO,IAAI,EAAE,EACb,MAAA,CAAO,GAAG,GAAG;YACb,UAAU;gBAAE,YAAY;gBAAM,UAAU;YAAM;YAC9C,WAAW;YACX,SAAS;QACV,CAAC,EACA,MAAA,CAAO,IAAI,EAAE,EACb,MAAA,CAAO,GAAG,GAAG;YACb,UAAU;gBAAE,YAAY;gBAAM,UAAU;YAAM;YAC9C,WAAW;YACX,SAAS;QACV,CAAC,EACA,MAAA,CAAO,IAAI,EAAE;IAChB;IAEA,MAAM,QAAQ,SAAS,SAAS,OAAO;IAEvC,KACE,MAAA,yLAAO,QAAA,EAAM,KAAK,OAAO,GAAG,CAAC,0LAAG,SAAA,EAAM,KAAK,OAAO,GAAG,CAAC,GAAG;QACzD,UAAU;YAAE,YAAY;YAAM,UAAU;QAAM;IAC/C,CAAC,EACA,MAAA,EAAO,+LAAA,EAAM,IAAI,KAAK,OAAO,GAAG,CAAC,2LAAG,QAAA,EAAM,IAAI,KAAK,OAAO,GAAG,CAAC,CAAC,EAC/D,MAAA,yLAAO,QAAA,EAAM,IAAI,KAAK,OAAO,GAAG,CAAC,2LAAG,QAAA,EAAM,KAAK,OAAO,GAAG,CAAC,CAAC,EAC3D,MAAA,CAAO,gMAAA,EAAM,KAAK,OAAO,GAAG,CAAC,2LAAG,QAAA,EAAM,IAAI,KAAK,OAAO,GAAG,CAAC,CAAC;IAE7D,OAAO;AACR;AAEA,SAAS,eAAe,CAAA,EAAW,CAAA,EAAW,QAAA,EAAmB;IAEhE,IAAI,IAAI,GAAG;QACV,MAAMA,KAAI,IAAI;QACd,OAAO,wLAAI,cAAA,CAAY,EACrB,MAAA,CAAO,GAAGA,IAAG;YAAE,UAAU;gBAAE;YAAS;QAAE,CAAC,EACvC,KAAA,CAAMA,IAAGA,IAAG,OAAO,MAAM,GAAG,GAAGA,EAAC,EAChC,MAAA,CAAO,GAAG,IAAIA,EAAC,EACf,KAAA,CAAMA,IAAGA,IAAG,OAAO,MAAM,GAAG,GAAG,IAAIA,EAAC,EACpC,KAAA,CAAM;IACT;IAEA,MAAM,IAAI,IAAI;IACd,OAAO,wLAAI,cAAA,CAAY,EACrB,MAAA,CAAO,GAAG,GAAG;QAAE,UAAU;YAAE;QAAS;IAAE,CAAC,EACvC,KAAA,CAAM,GAAG,GAAG,OAAO,MAAM,GAAG,GAAG,CAAC,EAChC,MAAA,CAAO,IAAI,GAAG,CAAC,EACf,KAAA,CAAM,GAAG,GAAG,OAAO,MAAM,GAAG,IAAI,GAAG,CAAC,EACpC,KAAA,CAAM;AACT;AAEA,SAAS,YAAY,CAAA,EAAW,CAAA,EAAW,QAAA,EAAmB;IAK7D,MAAM,QAAQ;IACd,MAAM,OAAO,0LAAA,GAAM,QAAQ;IAC3B,MAAM,iBAAiB,KAAK,KAAA,CAAM,QAAQ,CAAC,IAAI;IAC/C,MAAM,gBAAgB,QAAQ,IAAI;IAClC,MAAM,eAAe;IACrB,MAAM,kBAAkB,KAAK,KAAA,CAAM,QAAQ,CAAC,IAAI;IAChD,MAAM,OAAQ,KAAK,GAAA,CAAI,qLAAC,UAAA,GAAU,iBAAiB,IAAI,IAAI,IAAK;IAChE,MAAM,OAAQ,KAAK,GAAA,CAAI,CAAC,8LAAA,GAAU,gBAAgB,IAAI,IAAI,IAAK;IAE/D,MAAM,OAAQ,KAAK,GAAA,CAAI,qLAAC,UAAA,GAAU,eAAe,IAAI,IAAI,IAAK;IAC9D,MAAM,OAAQ,KAAK,GAAA,CAAI,qLAAC,UAAA,GAAU,kBAAkB,IAAI,IAAI,IAAK;IACjE,MAAM,QAAQ,IAAI,KAAK,GAAA,CAAI,OAAO,IAAI;IACtC,MAAM,QAAQ,IAAI,KAAK,GAAA,CAAI,OAAO,IAAI;IACtC,MAAM,UAAU,IAAI,IAAI,OAAA,CAAQ,IAAI,IAAI,IAAA;IACxC,MAAM,UAAU,IAAI,IAAI,OAAA,CAAQ,IAAI,IAAI,IAAA;IAExC,MAAM,QAAQ;IACd,MAAM,KAAA,CAAM,IAAI,OAAA,IAAW;IAC3B,MAAM,KAAA,CAAM,IAAI,OAAA,IAAW;IAC3B,MAAM,KAAA,CAAM,IAAI,KAAA,IAAS;IACzB,MAAM,KAAA,CAAM,IAAI,KAAA,IAAS;IACzB,MAAM,KAAM,KAAK,QAAS;IAC1B,MAAM,KAAM,KAAK,QAAS;IAE1B,2LAAO,cAAA,CAAY,iBAAA,CAClB,MAAM,IAAA,CAAK,MAAM,QAAQ,CAAC,GAAG,CAAC,GAAG,MAAM;QACtC,MAAM,QAAQ,qLAAC,UAAA,GAAU,IAAI;QAC7B,OAAO,sLAAI,MAAA,CACV,KAAA,CAAM,IAAI,IAAI,KAAK,EAAA,IAAM,KAAK,GAAA,CAAI,KAAK,GACvC,KAAA,CAAM,IAAI,IAAI,KAAK,EAAA,IAAM,KAAK,GAAA,CAAI,KAAK;IAEzC,CAAC,GACD;QAAE,UAAU;YAAE;QAAS;IAAE,GACxB,KAAA,CAAM;AACT;AAIA,SAAS,iBAAiB,CAAA,EAAW,CAAA,EAAW;IAC/C,IAAI,IAAI,EAAG,CAAA,OAAA,qLAAQ,KAAA,GAAA,CAAM,IAAI,CAAA,IAAA,CAAM,IAAI,CAAA,CAAA,IAAM;SACxC,OAAA,CAAQ,yLAAA,GAAA,CAAM,IAAI,CAAA,IAAA,CAAM,IAAI,CAAA,CAAA,IAAM;AACxC;AAcA,SAAS,cAAc,KAAA,EAAe,MAAA,EAAgB,SAAA,EAAmB;IACxE,MAAM,SAAS,KAAK,GAAA,CAAI,OAAO,MAAM,IAAI;IACzC,MAAM,WAAW,KAAK,GAAA,CAAI,OAAO,MAAM,IAAI,SAAS;IACpD,MAAM,gBAAgB,KAAK,EAAA,GAAA,CAAM,SAAS,CAAA,IAAK,IAAI;IACnD,MAAM,UAAU,gBAAgB;IAEhC,MAAM,WACL,QAAQ,SACL;QACA;YACC,MAAM;YACN,OAAO,sLAAI,MAAA,CAAI,QAAQ,CAAC;YACxB,OAAO,sLAAI,MAAA,CAAI,GAAG,CAAC;QACpB;QACA;YACC,MAAM;YACN,QAAQ,sLAAI,MAAA,CAAI,QAAQ,QAAQ,MAAM;YACtC,YAAY,qLAAC,KAAA,GAAK;QACnB;QACA;YACC,MAAM;YACN,OAAO,IAAI,wLAAA,CAAI,QAAQ,QAAQ,MAAM;YACrC,OAAO,sLAAI,MAAA,CAAI,CAAA,GAAI,CAAC;QACrB;QACA;YACC,MAAM;YACN,QAAQ,sLAAI,MAAA,CAAI,QAAQ,MAAM;YAC9B,gMAAY,KAAA,GAAK;QAClB;KACD,GACC;QACA;YACC,MAAM;YACN,OAAO,sLAAI,MAAA,CAAI,OAAO,MAAM;YAC5B,OAAO,sLAAI,MAAA,CAAI,GAAG,CAAC;QACpB;QACA;YACC,MAAM;YACN,QAAQ,sLAAI,MAAA,CAAI,QAAQ,SAAS,MAAM;YACvC,YAAY;QACb;QACA;YACC,MAAM;YACN,OAAO,sLAAI,MAAA,CAAI,GAAG,SAAS,MAAM;YACjC,OAAO,sLAAI,MAAA,CAAI,GAAG,CAAA,CAAE;QACrB;QACA;YACC,MAAM;YACN,QAAQ,sLAAI,MAAA,CAAI,QAAQ,MAAM;YAC9B,gMAAY,KAAA;QACb;KACD;IAEH,IAAI,gBAAgB;IAEpB,MAAM,SAAgB,CAAC,CAAA;IACvB,IAAA,IAAS,IAAI,GAAG,IAAI,WAAW,IAAK;QACnC,MAAM,UAAU,QAAA,CAAS,CAAC,CAAA;QAC1B,IAAI,QAAQ,IAAA,KAAS,YAAY;YAChC,OAAO,IAAA,CAAK,wLAAA,CAAI,GAAA,CAAI,QAAQ,KAAA,oLAAO,MAAA,CAAI,GAAA,CAAI,QAAQ,KAAA,EAAO,aAAa,CAAC,CAAC;QAC1E,OAAO;YACN,OAAO,IAAA,yLACN,mBAAA,EAAiB,QAAQ,MAAA,EAAQ,QAAQ,QAAQ,UAAA,GAAa,gBAAgB,MAAM;QAEtF;QACA,iBAAiB;QACjB,IAAI,gBAAgB,QAAQ,IAAA,KAAS,aAAa,+LAAW,KAAA,GAAK;QAClE,MAAO,gBAAgB,cAAe;YACrC,iBAAiB;YACjB,SAAS,IAAA,CAAK,SAAS,KAAA,CAAM,CAAE;YAC/B,gBAAgB,QAAA,CAAS,CAAC,CAAA,CAAE,IAAA,KAAS,aAAa,+LAAW,KAAA,GAAK;QACnE;IACD;IAEA,OAAO;AACR;AAEA,MAAM,QAA4C;IACjD,GAAG;IACH,GAAG;IACH,GAAG;IACH,IAAI;AACL;AAEA,MAAM,kBAAkB;AAExB,SAAS,aACR,KAAA,EACA,MAAA,EACA,IAAA,EACA,IAAA,EACA,KAAA,EACA,QAAA,EACC;IACD,MAAM,OAAO,wLAAI,cAAA,CAAY;IAC7B,MAAM,qLAAY,OAAA,EAAI,IAAI;IAC1B,MAAM,oBAAoB,iBAAiB,OAAO,MAAM;IACxD,MAAM,WAAW,KAAK,GAAA,CACrB,KAAK,IAAA,CAAK,oBAAoB,KAAA,CAAM,IAAI,CAAC,GACzC,GACA,KAAK,IAAA,CAAK,oBAAoB,KAAK,GAAA,CAAI,OAAO,MAAM,CAAC;IAEtD,MAAM,uBAAwB,oBAAoB,WAAY;IAG9D,MAAM,aAAa,KAAK,GAAA,CAAI,QAAQ,uBAAuB,GAAG,CAAC;IAC/D,MAAM,cAAc,KAAK,GAAA,CAAI,SAAS,uBAAuB,GAAG,CAAC;IACjE,MAAM,qBAAqB,iBAAiB,YAAY,WAAW;IAEnE,MAAM,mCAAmC,qBAAqB;IAE9D,MAAM,WAAA,CAAY,QAAQ,UAAA,IAAc;IACxC,MAAM,WAAA,CAAY,SAAS,WAAA,IAAe;IAC1C,MAAM,aAAa,cAAc,YAAY,aAAa,QAAQ,EAAE,GAAA,CAAI,CAAC,MAAM;QAC9E,OAAO,EAAE,KAAA,CAAM,UAAU,QAAQ;IAClC,CAAC;IACD,MAAM,aAAa,QAAQ,KAAK,IAAI,uBAAuB;IAC3D,MAAM,aAAa,SAAS,KAAK,IAAI,uBAAuB;IAK5D,MAAM,gBAAgB,WAAW,KAAA,CAAM,CAAC;IACxC,IAAA,IAAS,IAAI,GAAG,IAAI,KAAK,KAAA,CAAM,WAAW,CAAC,GAAG,IAAK;QAClD,aAAA,CAAc,CAAC,CAAA,qLAAI,MAAA,CAAI,KAAA,CACtB,aAAA,CAAc,CAAC,CAAA,EACf,UAAU,IAAI,aAAa,OAC3B,UAAU,IAAI,aAAa;QAE5B,aAAA,CAAc,WAAW,IAAI,CAAC,CAAA,qLAAI,MAAA,CAAI,KAAA,CACrC,aAAA,CAAc,WAAW,IAAI,CAAC,CAAA,EAC9B,UAAU,IAAI,aAAa,OAC3B,UAAU,IAAI,aAAa;IAE7B;IAEA,IAAA,IAAS,IAAI,GAAG,IAAI,cAAc,MAAA,EAAQ,IAAK;QAC9C,MAAM,IAAI,MAAM,cAAc,MAAA,GAAS,IAAI,IAAI,IAAI;QACnD,MAAM,kBAAkB,aAAA,CAAc,CAAC,CAAA;QACvC,MAAM,mBAAmB,aAAA,CAAc,CAAC,CAAA;QACxC,MAAM,YAAY,UAAA,CAAW,CAAC,CAAA;QAC9B,MAAM,aAAa,UAAA,CAAW,CAAC,CAAA;QAI/B,MAAM,kNAAgC,MAAA,CAAI,IAAA,CAAK,WAAW,UAAU;QACpE,MAAM,kBAAkB,mCAAmC;QAC3D,MAAM,gNAA8B,MAAA,CAAI,IAAA,CAAK,iBAAiB,gBAAgB;QAC9E,MAAM,eAAe,8BAA8B;QACnD,MAAM,gBAAA,CAAiB,KAAK,GAAA,CAAI,UAAU,QAAQ,IAAI,eAAA,IAAmB;QAEzE,MAAM,4LAAW,OAAA,CAAI,GAAA,CAAI,WAAW,YAAY,GAAG,EAAE,GAAA,mLACpD,MAAA,CAAI,GAAA,CAAI,YAAY,SAAS,EAAE,GAAA,CAAI,EAAE,GAAA,CAAI,EAAE,GAAA,CAAI,aAAa;QAE7D,IAAI,SAAS,CAAA,GAAI,GAAG;YACnB,SAAS,CAAA,GAAI;QACd,OAAA,IAAW,SAAS,CAAA,GAAI,OAAO;YAC9B,SAAS,CAAA,GAAI;QACd;QACA,IAAI,SAAS,CAAA,GAAI,GAAG;YACnB,SAAS,CAAA,GAAI;QACd,OAAA,IAAW,SAAS,CAAA,GAAI,QAAQ;YAC/B,SAAS,CAAA,GAAI;QACd;QAEA,MAAM,iMAAS,gCAAA,EAA8B,iBAAiB,kBAAkB,QAAQ;QAExF,MAAM,2LAAS,MAAA,CAAI,IAAA,CAClB,SAAS,2LAAS,MAAA,CAAI,OAAA,CAAQ;YAAC;YAAiB,gBAAgB;SAAC,GACjE;QAGD,IAAI,MAAM,GAAG;YACZ,KAAK,MAAA,CAAO,gBAAgB,CAAA,EAAG,gBAAgB,CAAA,EAAG;gBAAE,UAAU;oBAAE;gBAAS;YAAE,CAAC;QAC7E;QAEA,KAAK,aAAA,CAAc,QAAQ,OAAO,MAAM,iBAAiB,CAAA,EAAG,iBAAiB,CAAC;IAC/E;IAEA,OAAO,KAAK,KAAA,CAAM;AACnB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 11863, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/geo/components/GeoShapeBody.tsx"],"sourcesContent":["import { TLGeoShape } from '@tldraw/editor'\nimport { ShapeFill } from '../../shared/ShapeFill'\nimport { STROKE_SIZES } from '../../shared/default-shape-constants'\nimport { useDefaultColorTheme } from '../../shared/useDefaultColorTheme'\nimport { getGeoShapePath } from '../getGeoShapePath'\n\nexport function GeoShapeBody({\n\tshape,\n\tshouldScale,\n\tforceSolid,\n}: {\n\tshape: TLGeoShape\n\tshouldScale: boolean\n\tforceSolid: boolean\n}) {\n\tconst scaleToUse = shouldScale ? shape.props.scale : 1\n\tconst theme = useDefaultColorTheme()\n\tconst { props } = shape\n\tconst { color, fill, dash, size } = props\n\tconst strokeWidth = STROKE_SIZES[size] * scaleToUse\n\n\tconst path = getGeoShapePath(shape)\n\tconst fillPath =\n\t\tdash === 'draw' && !forceSolid\n\t\t\t? path.toDrawD({ strokeWidth, randomSeed: shape.id, passes: 1, offset: 0, onlyFilled: true })\n\t\t\t: path.toD({ onlyFilled: true })\n\n\treturn (\n\t\t<>\n\t\t\t<ShapeFill theme={theme} d={fillPath} color={color} fill={fill} scale={scaleToUse} />\n\t\t\t{path.toSvg({\n\t\t\t\tstyle: dash,\n\t\t\t\tstrokeWidth,\n\t\t\t\tforceSolid,\n\t\t\t\trandomSeed: shape.id,\n\t\t\t\tprops: { fill: 'none', stroke: theme[color].solid },\n\t\t\t})}\n\t\t</>\n\t)\n}\n"],"names":[],"mappings":";;;AA4BE,mBACC,KADD;AA3BF,SAAS,iBAAiB;AAC1B,SAAS,oBAAoB;AAC7B,SAAS,4BAA4B;AACrC,SAAS,uBAAuB;;;;;;AAEzB,SAAS,aAAa,EAC5B,KAAA,EACA,WAAA,EACA,UAAA,EACD,EAIG;IACF,MAAM,aAAa,cAAc,MAAM,KAAA,CAAM,KAAA,GAAQ;IACrD,MAAM,YAAQ,oNAAA,CAAqB;IACnC,MAAM,EAAE,KAAA,CAAM,CAAA,GAAI;IAClB,MAAM,EAAE,KAAA,EAAO,IAAA,EAAM,IAAA,EAAM,IAAA,CAAK,CAAA,GAAI;IACpC,MAAM,oNAAc,eAAA,CAAa,IAAI,CAAA,GAAI;IAEzC,MAAM,gMAAO,kBAAA,EAAgB,KAAK;IAClC,MAAM,WACL,SAAS,UAAU,CAAC,aACjB,KAAK,OAAA,CAAQ;QAAE;QAAa,YAAY,MAAM,EAAA;QAAI,QAAQ;QAAG,QAAQ;QAAG,YAAY;IAAK,CAAC,IAC1F,KAAK,GAAA,CAAI;QAAE,YAAY;IAAK,CAAC;IAEjC,OACC,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,OAAA,EAAA,sKAAA,CAAA,WAAA,EAAA;QACC,UAAA;YAAA,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,oLAAC,YAAA,EAAA;gBAAU;gBAAc,GAAG;gBAAU;gBAAc;gBAAY,OAAO;YAAA,CAAY;YAClF,KAAK,KAAA,CAAM;gBACX,OAAO;gBACP;gBACA;gBACA,YAAY,MAAM,EAAA;gBAClB,OAAO;oBAAE,MAAM;oBAAQ,QAAQ,KAAA,CAAM,KAAK,CAAA,CAAE,KAAA;gBAAM;YACnD,CAAC;SAAA;IAAA,CACF;AAEF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 11922, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/geo/GeoShapeUtil.tsx"],"sourcesContent":["/* eslint-disable react-hooks/rules-of-hooks */\nimport {\n\tBaseBoxShapeUtil,\n\tBox,\n\tEMPTY_ARRAY,\n\tEditor,\n\tGroup2d,\n\tHTMLContainer,\n\tHandleSnapGeometry,\n\tRectangle2d,\n\tSVGContainer,\n\tSvgExportContext,\n\tTLGeoShape,\n\tTLGeoShapeProps,\n\tTLResizeInfo,\n\tTLShapeUtilCanvasSvgDef,\n\tVec,\n\texhaustiveSwitchError,\n\tgeoShapeMigrations,\n\tgeoShapeProps,\n\tgetDefaultColorTheme,\n\tgetFontsFromRichText,\n\tisEqual,\n\tlerp,\n\ttoRichText,\n\tuseValue,\n} from '@tldraw/editor'\nimport {\n\tisEmptyRichText,\n\trenderHtmlFromRichTextForMeasurement,\n\trenderPlaintextFromRichText,\n} from '../../utils/text/richText'\nimport { HyperlinkButton } from '../shared/HyperlinkButton'\nimport { RichTextLabel, RichTextSVG } from '../shared/RichTextLabel'\nimport {\n\tFONT_FAMILIES,\n\tLABEL_FONT_SIZES,\n\tLABEL_PADDING,\n\tSTROKE_SIZES,\n\tTEXT_PROPS,\n} from '../shared/default-shape-constants'\nimport { getFillDefForCanvas, getFillDefForExport } from '../shared/defaultStyleDefs'\nimport { useDefaultColorTheme } from '../shared/useDefaultColorTheme'\nimport { useIsReadyForEditing } from '../shared/useEditablePlainText'\nimport { GeoShapeBody } from './components/GeoShapeBody'\nimport { getGeoShapePath } from './getGeoShapePath'\n\nconst MIN_SIZE_WITH_LABEL = 17 * 3\n\n/** @public */\nexport class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {\n\tstatic override type = 'geo' as const\n\tstatic override props = geoShapeProps\n\tstatic override migrations = geoShapeMigrations\n\n\toverride canEdit() {\n\t\treturn true\n\t}\n\n\toverride getDefaultProps(): TLGeoShape['props'] {\n\t\treturn {\n\t\t\tw: 100,\n\t\t\th: 100,\n\t\t\tgeo: 'rectangle',\n\t\t\tdash: 'draw',\n\t\t\tgrowY: 0,\n\t\t\turl: '',\n\t\t\tscale: 1,\n\n\t\t\t// Text properties\n\t\t\tcolor: 'black',\n\t\t\tlabelColor: 'black',\n\t\t\tfill: 'none',\n\t\t\tsize: 'm',\n\t\t\tfont: 'draw',\n\t\t\talign: 'middle',\n\t\t\tverticalAlign: 'middle',\n\t\t\trichText: toRichText(''),\n\t\t}\n\t}\n\n\toverride getGeometry(shape: TLGeoShape) {\n\t\tconst w = Math.max(1, shape.props.w)\n\t\tconst h = Math.max(1, shape.props.h + shape.props.growY)\n\n\t\tconst path = getGeoShapePath(shape)\n\t\tconst unscaledlabelSize = getUnscaledLabelSize(this.editor, shape)\n\t\t// unscaled w and h\n\t\tconst unscaledW = w / shape.props.scale\n\t\tconst unscaledH = h / shape.props.scale\n\t\tconst unscaledminWidth = Math.min(100, unscaledW / 2)\n\t\tconst unscaledMinHeight = Math.min(\n\t\t\tLABEL_FONT_SIZES[shape.props.size] * TEXT_PROPS.lineHeight + LABEL_PADDING * 2,\n\t\t\tunscaledH / 2\n\t\t)\n\n\t\tconst unscaledLabelWidth = Math.min(\n\t\t\tunscaledW,\n\t\t\tMath.max(unscaledlabelSize.w, Math.min(unscaledminWidth, Math.max(1, unscaledW - 8)))\n\t\t)\n\t\tconst unscaledLabelHeight = Math.min(\n\t\t\tunscaledH,\n\t\t\tMath.max(unscaledlabelSize.h, Math.min(unscaledMinHeight, Math.max(1, unscaledH - 8)))\n\t\t)\n\n\t\t// todo: use centroid for label position\n\n\t\treturn new Group2d({\n\t\t\tchildren: [\n\t\t\t\tpath.toGeometry(),\n\t\t\t\tnew Rectangle2d({\n\t\t\t\t\tx:\n\t\t\t\t\t\tshape.props.align === 'start'\n\t\t\t\t\t\t\t? 0\n\t\t\t\t\t\t\t: shape.props.align === 'end'\n\t\t\t\t\t\t\t\t? (unscaledW - unscaledLabelWidth) * shape.props.scale\n\t\t\t\t\t\t\t\t: ((unscaledW - unscaledLabelWidth) / 2) * shape.props.scale,\n\t\t\t\t\ty:\n\t\t\t\t\t\tshape.props.verticalAlign === 'start'\n\t\t\t\t\t\t\t? 0\n\t\t\t\t\t\t\t: shape.props.verticalAlign === 'end'\n\t\t\t\t\t\t\t\t? (unscaledH - unscaledLabelHeight) * shape.props.scale\n\t\t\t\t\t\t\t\t: ((unscaledH - unscaledLabelHeight) / 2) * shape.props.scale,\n\t\t\t\t\twidth: unscaledLabelWidth * shape.props.scale,\n\t\t\t\t\theight: unscaledLabelHeight * shape.props.scale,\n\t\t\t\t\tisFilled: true,\n\t\t\t\t\tisLabel: true,\n\t\t\t\t\tisEmptyLabel: isEmptyRichText(shape.props.richText),\n\t\t\t\t}),\n\t\t\t],\n\t\t})\n\t}\n\n\toverride getHandleSnapGeometry(shape: TLGeoShape): HandleSnapGeometry {\n\t\tconst geometry = this.getGeometry(shape)\n\t\t// we only want to snap handles to the outline of the shape - not to its label etc.\n\t\tconst outline = geometry.children[0]\n\t\tswitch (shape.props.geo) {\n\t\t\tcase 'arrow-down':\n\t\t\tcase 'arrow-left':\n\t\t\tcase 'arrow-right':\n\t\t\tcase 'arrow-up':\n\t\t\tcase 'check-box':\n\t\t\tcase 'diamond':\n\t\t\tcase 'hexagon':\n\t\t\tcase 'octagon':\n\t\t\tcase 'pentagon':\n\t\t\tcase 'rectangle':\n\t\t\tcase 'rhombus':\n\t\t\tcase 'rhombus-2':\n\t\t\tcase 'star':\n\t\t\tcase 'trapezoid':\n\t\t\tcase 'triangle':\n\t\t\tcase 'x-box':\n\t\t\t\t// poly-line type shapes hand snap points for each vertex & the center\n\t\t\t\treturn { outline: outline, points: [...outline.vertices, geometry.bounds.center] }\n\t\t\tcase 'cloud':\n\t\t\tcase 'ellipse':\n\t\t\tcase 'heart':\n\t\t\tcase 'oval':\n\t\t\t\t// blobby shapes only have a snap point in their center\n\t\t\t\treturn { outline: outline, points: [geometry.bounds.center] }\n\t\t\tdefault:\n\t\t\t\texhaustiveSwitchError(shape.props.geo)\n\t\t}\n\t}\n\n\toverride getText(shape: TLGeoShape) {\n\t\treturn renderPlaintextFromRichText(this.editor, shape.props.richText)\n\t}\n\n\toverride getFontFaces(shape: TLGeoShape) {\n\t\tif (isEmptyRichText(shape.props.richText)) {\n\t\t\treturn EMPTY_ARRAY\n\t\t}\n\t\treturn getFontsFromRichText(this.editor, shape.props.richText, {\n\t\t\tfamily: `tldraw_${shape.props.font}`,\n\t\t\tweight: 'normal',\n\t\t\tstyle: 'normal',\n\t\t})\n\t}\n\n\tcomponent(shape: TLGeoShape) {\n\t\tconst { id, type, props } = shape\n\t\tconst { fill, font, align, verticalAlign, size, richText } = props\n\t\tconst theme = useDefaultColorTheme()\n\t\tconst { editor } = this\n\t\tconst isOnlySelected = useValue(\n\t\t\t'isGeoOnlySelected',\n\t\t\t() => shape.id === editor.getOnlySelectedShapeId(),\n\t\t\t[editor]\n\t\t)\n\t\tconst isReadyForEditing = useIsReadyForEditing(editor, shape.id)\n\t\tconst isEmpty = isEmptyRichText(shape.props.richText)\n\t\tconst showHtmlContainer = isReadyForEditing || !isEmpty\n\t\tconst isForceSolid = useValue('force solid', () => editor.getZoomLevel() < 0.2, [editor])\n\n\t\treturn (\n\t\t\t<>\n\t\t\t\t<SVGContainer>\n\t\t\t\t\t<GeoShapeBody shape={shape} shouldScale={true} forceSolid={isForceSolid} />\n\t\t\t\t</SVGContainer>\n\t\t\t\t{showHtmlContainer && (\n\t\t\t\t\t<HTMLContainer\n\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\toverflow: 'hidden',\n\t\t\t\t\t\t\twidth: shape.props.w,\n\t\t\t\t\t\t\theight: shape.props.h + props.growY,\n\t\t\t\t\t\t}}\n\t\t\t\t\t>\n\t\t\t\t\t\t<RichTextLabel\n\t\t\t\t\t\t\tshapeId={id}\n\t\t\t\t\t\t\ttype={type}\n\t\t\t\t\t\t\tfont={font}\n\t\t\t\t\t\t\tfontSize={LABEL_FONT_SIZES[size] * shape.props.scale}\n\t\t\t\t\t\t\tlineHeight={TEXT_PROPS.lineHeight}\n\t\t\t\t\t\t\tpadding={LABEL_PADDING * shape.props.scale}\n\t\t\t\t\t\t\tfill={fill}\n\t\t\t\t\t\t\talign={align}\n\t\t\t\t\t\t\tverticalAlign={verticalAlign}\n\t\t\t\t\t\t\trichText={richText}\n\t\t\t\t\t\t\tisSelected={isOnlySelected}\n\t\t\t\t\t\t\tlabelColor={theme[props.labelColor].solid}\n\t\t\t\t\t\t\twrap\n\t\t\t\t\t\t/>\n\t\t\t\t\t</HTMLContainer>\n\t\t\t\t)}\n\t\t\t\t{shape.props.url && <HyperlinkButton url={shape.props.url} />}\n\t\t\t</>\n\t\t)\n\t}\n\n\tindicator(shape: TLGeoShape) {\n\t\tconst isZoomedOut = useValue('isZoomedOut', () => this.editor.getZoomLevel() < 0.25, [\n\t\t\tthis.editor,\n\t\t])\n\n\t\tconst { size, dash, scale } = shape.props\n\t\tconst strokeWidth = STROKE_SIZES[size]\n\n\t\tconst path = getGeoShapePath(shape)\n\n\t\treturn path.toSvg({\n\t\t\tstyle: dash === 'draw' ? 'draw' : 'solid',\n\t\t\tstrokeWidth: 1,\n\t\t\tpasses: 1,\n\t\t\trandomSeed: shape.id,\n\t\t\toffset: 0,\n\t\t\troundness: strokeWidth * 2 * scale,\n\t\t\tprops: { strokeWidth: undefined },\n\t\t\tforceSolid: isZoomedOut,\n\t\t})\n\t}\n\n\toverride toSvg(shape: TLGeoShape, ctx: SvgExportContext) {\n\t\tconst scale = shape.props.scale\n\t\t// We need to scale the shape to 1x for export\n\t\tconst newShape = {\n\t\t\t...shape,\n\t\t\tprops: {\n\t\t\t\t...shape.props,\n\t\t\t\tw: shape.props.w / scale,\n\t\t\t\th: (shape.props.h + shape.props.growY) / scale,\n\t\t\t\tgrowY: 0, // growY throws off the path calculations, so we set it to 0\n\t\t\t},\n\t\t}\n\t\tconst props = newShape.props\n\t\tctx.addExportDef(getFillDefForExport(props.fill))\n\n\t\tlet textEl\n\t\tif (!isEmptyRichText(props.richText)) {\n\t\t\tconst theme = getDefaultColorTheme(ctx)\n\t\t\tconst bounds = new Box(0, 0, props.w, (shape.props.h + shape.props.growY) / scale)\n\t\t\ttextEl = (\n\t\t\t\t<RichTextSVG\n\t\t\t\t\tfontSize={LABEL_FONT_SIZES[props.size]}\n\t\t\t\t\tfont={props.font}\n\t\t\t\t\talign={props.align}\n\t\t\t\t\tverticalAlign={props.verticalAlign}\n\t\t\t\t\trichText={props.richText}\n\t\t\t\t\tlabelColor={theme[props.labelColor].solid}\n\t\t\t\t\tbounds={bounds}\n\t\t\t\t\tpadding={LABEL_PADDING}\n\t\t\t\t/>\n\t\t\t)\n\t\t}\n\n\t\treturn (\n\t\t\t<>\n\t\t\t\t<GeoShapeBody shouldScale={false} shape={newShape} forceSolid={false} />\n\t\t\t\t{textEl}\n\t\t\t</>\n\t\t)\n\t}\n\n\toverride getCanvasSvgDefs(): TLShapeUtilCanvasSvgDef[] {\n\t\treturn [getFillDefForCanvas()]\n\t}\n\n\toverride onResize(\n\t\tshape: TLGeoShape,\n\t\t{ handle, newPoint, scaleX, scaleY, initialShape }: TLResizeInfo<TLGeoShape>\n\t) {\n\t\tconst unscaledInitialW = initialShape.props.w / initialShape.props.scale\n\t\tconst unscaledInitialH = initialShape.props.h / initialShape.props.scale\n\t\tconst unscaledGrowY = initialShape.props.growY / initialShape.props.scale\n\t\t// use the w/h from props here instead of the initialBounds here,\n\t\t// since cloud shapes calculated bounds can differ from the props w/h.\n\t\tlet unscaledW = unscaledInitialW * scaleX\n\t\tlet unscaledH = (unscaledInitialH + unscaledGrowY) * scaleY\n\t\tlet overShrinkX = 0\n\t\tlet overShrinkY = 0\n\n\t\tconst min = MIN_SIZE_WITH_LABEL\n\n\t\tif (!isEmptyRichText(shape.props.richText)) {\n\t\t\tlet newW = Math.max(Math.abs(unscaledW), min)\n\t\t\tlet newH = Math.max(Math.abs(unscaledH), min)\n\n\t\t\tif (newW < min && newH === min) newW = min\n\t\t\tif (newW === min && newH < min) newH = min\n\n\t\t\tconst unscaledLabelSize = getUnscaledLabelSize(this.editor, {\n\t\t\t\t...shape,\n\t\t\t\tprops: {\n\t\t\t\t\t...shape.props,\n\t\t\t\t\tw: newW * shape.props.scale,\n\t\t\t\t\th: newH * shape.props.scale,\n\t\t\t\t},\n\t\t\t})\n\n\t\t\tconst nextW = Math.max(Math.abs(unscaledW), unscaledLabelSize.w) * Math.sign(unscaledW)\n\t\t\tconst nextH = Math.max(Math.abs(unscaledH), unscaledLabelSize.h) * Math.sign(unscaledH)\n\t\t\toverShrinkX = Math.abs(nextW) - Math.abs(unscaledW)\n\t\t\toverShrinkY = Math.abs(nextH) - Math.abs(unscaledH)\n\n\t\t\tunscaledW = nextW\n\t\t\tunscaledH = nextH\n\t\t}\n\n\t\tconst scaledW = unscaledW * shape.props.scale\n\t\tconst scaledH = unscaledH * shape.props.scale\n\n\t\tconst offset = new Vec(0, 0)\n\n\t\t// x offsets\n\n\t\tif (scaleX < 0) {\n\t\t\toffset.x += scaledW\n\t\t}\n\n\t\tif (handle === 'left' || handle === 'top_left' || handle === 'bottom_left') {\n\t\t\toffset.x += scaleX < 0 ? overShrinkX : -overShrinkX\n\t\t}\n\n\t\t// y offsets\n\n\t\tif (scaleY < 0) {\n\t\t\toffset.y += scaledH\n\t\t}\n\n\t\tif (handle === 'top' || handle === 'top_left' || handle === 'top_right') {\n\t\t\toffset.y += scaleY < 0 ? overShrinkY : -overShrinkY\n\t\t}\n\n\t\tconst { x, y } = offset.rot(shape.rotation).add(newPoint)\n\n\t\treturn {\n\t\t\tx,\n\t\t\ty,\n\t\t\tprops: {\n\t\t\t\tw: Math.max(Math.abs(scaledW), 1),\n\t\t\t\th: Math.max(Math.abs(scaledH), 1),\n\t\t\t\tgrowY: 0,\n\t\t\t},\n\t\t}\n\t}\n\n\toverride onBeforeCreate(shape: TLGeoShape) {\n\t\tif (isEmptyRichText(shape.props.richText)) {\n\t\t\tif (shape.props.growY) {\n\t\t\t\t// No text / some growY, set growY to 0\n\t\t\t\treturn {\n\t\t\t\t\t...shape,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\t...shape.props,\n\t\t\t\t\t\tgrowY: 0,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// No text / no growY, nothing to change\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tconst unscaledPrevHeight = shape.props.h / shape.props.scale\n\t\tconst unscaledNextHeight = getUnscaledLabelSize(this.editor, shape).h\n\n\t\tlet growY: number | null = null\n\n\t\tif (unscaledNextHeight > unscaledPrevHeight) {\n\t\t\tgrowY = unscaledNextHeight - unscaledPrevHeight\n\t\t} else {\n\t\t\tif (shape.props.growY) {\n\t\t\t\tgrowY = 0\n\t\t\t}\n\t\t}\n\n\t\tif (growY !== null) {\n\t\t\treturn {\n\t\t\t\t...shape,\n\t\t\t\tprops: {\n\t\t\t\t\t...shape.props,\n\t\t\t\t\t// scale the growY\n\t\t\t\t\tgrowY: growY * shape.props.scale,\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\toverride onBeforeUpdate(prev: TLGeoShape, next: TLGeoShape) {\n\t\t// No change to text, font, or size, no need to update update\n\t\tif (\n\t\t\tisEqual(prev.props.richText, next.props.richText) &&\n\t\t\tprev.props.font === next.props.font &&\n\t\t\tprev.props.size === next.props.size\n\t\t) {\n\t\t\treturn\n\t\t}\n\n\t\t// If we got rid of the text, cancel out any growY from the prev text\n\t\tconst wasEmpty = isEmptyRichText(prev.props.richText)\n\t\tconst isEmpty = isEmptyRichText(next.props.richText)\n\t\tif (!wasEmpty && isEmpty) {\n\t\t\treturn {\n\t\t\t\t...next,\n\t\t\t\tprops: {\n\t\t\t\t\t...next.props,\n\t\t\t\t\tgrowY: 0,\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\n\t\t// Get the prev width and height in unscaled values\n\t\tconst unscaledPrevWidth = prev.props.w / prev.props.scale\n\t\tconst unscaledPrevHeight = prev.props.h / prev.props.scale\n\t\tconst unscaledPrevGrowY = prev.props.growY / prev.props.scale\n\n\t\t// Get the next width and height in unscaled values\n\t\tconst unscaledNextLabelSize = getUnscaledLabelSize(this.editor, next)\n\n\t\t// When entering the first character in a label (not pasting in multiple characters...)\n\t\tif (wasEmpty && !isEmpty && renderPlaintextFromRichText(this.editor, next.props.richText)) {\n\t\t\tlet unscaledW = Math.max(unscaledPrevWidth, unscaledNextLabelSize.w)\n\t\t\tlet unscaledH = Math.max(unscaledPrevHeight, unscaledNextLabelSize.h)\n\n\t\t\tconst min = MIN_SIZE_WITH_LABEL\n\n\t\t\t// If both the width and height were less than the minimum size, make the shape square\n\t\t\tif (unscaledPrevWidth < min && unscaledPrevHeight < min) {\n\t\t\t\tunscaledW = Math.max(unscaledW, min)\n\t\t\t\tunscaledH = Math.max(unscaledH, min)\n\t\t\t\tunscaledW = Math.max(unscaledW, unscaledH)\n\t\t\t\tunscaledH = Math.max(unscaledW, unscaledH)\n\t\t\t}\n\n\t\t\t// Don't set a growYâat least, not until we've implemented a growX property\n\t\t\treturn {\n\t\t\t\t...next,\n\t\t\t\tprops: {\n\t\t\t\t\t...next.props,\n\t\t\t\t\t// Scale the results\n\t\t\t\t\tw: unscaledW * next.props.scale,\n\t\t\t\t\th: unscaledH * next.props.scale,\n\t\t\t\t\tgrowY: 0,\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\n\t\tlet growY: number | null = null\n\n\t\tif (unscaledNextLabelSize.h > unscaledPrevHeight) {\n\t\t\tgrowY = unscaledNextLabelSize.h - unscaledPrevHeight\n\t\t} else {\n\t\t\tif (unscaledPrevGrowY) {\n\t\t\t\tgrowY = 0\n\t\t\t}\n\t\t}\n\n\t\tif (growY !== null) {\n\t\t\tconst unscaledNextWidth = next.props.w / next.props.scale\n\t\t\treturn {\n\t\t\t\t...next,\n\t\t\t\tprops: {\n\t\t\t\t\t...next.props,\n\t\t\t\t\t// Scale the results\n\t\t\t\t\tgrowY: growY * next.props.scale,\n\t\t\t\t\tw: Math.max(unscaledNextWidth, unscaledNextLabelSize.w) * next.props.scale,\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\n\t\tif (unscaledNextLabelSize.w > unscaledPrevWidth) {\n\t\t\treturn {\n\t\t\t\t...next,\n\t\t\t\tprops: {\n\t\t\t\t\t...next.props,\n\t\t\t\t\t// Scale the results\n\t\t\t\t\tw: unscaledNextLabelSize.w * next.props.scale,\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\n\t\t// otherwise, no update needed\n\t}\n\n\toverride onDoubleClick(shape: TLGeoShape) {\n\t\t// Little easter egg: double-clicking a rectangle / checkbox while\n\t\t// holding alt will toggle between check-box and rectangle\n\t\tif (this.editor.inputs.altKey) {\n\t\t\tswitch (shape.props.geo) {\n\t\t\t\tcase 'rectangle': {\n\t\t\t\t\treturn {\n\t\t\t\t\t\t...shape,\n\t\t\t\t\t\tprops: {\n\t\t\t\t\t\t\tgeo: 'check-box' as const,\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcase 'check-box': {\n\t\t\t\t\treturn {\n\t\t\t\t\t\t...shape,\n\t\t\t\t\t\tprops: {\n\t\t\t\t\t\t\tgeo: 'rectangle' as const,\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn\n\t}\n\toverride getInterpolatedProps(\n\t\tstartShape: TLGeoShape,\n\t\tendShape: TLGeoShape,\n\t\tt: number\n\t): TLGeoShapeProps {\n\t\treturn {\n\t\t\t...(t > 0.5 ? endShape.props : startShape.props),\n\t\t\tw: lerp(startShape.props.w, endShape.props.w, t),\n\t\t\th: lerp(startShape.props.h, endShape.props.h, t),\n\t\t\tscale: lerp(startShape.props.scale, endShape.props.scale, t),\n\t\t}\n\t}\n}\n\n// imperfect but good enough, should be the width of the W in the font / size combo\nconst minWidths = {\n\ts: 12,\n\tm: 14,\n\tl: 16,\n\txl: 20,\n}\n\nconst extraPaddings = {\n\ts: 2,\n\tm: 3.5,\n\tl: 5,\n\txl: 10,\n}\n\nfunction getUnscaledLabelSize(editor: Editor, shape: TLGeoShape) {\n\tconst { richText, font, size, w } = shape.props\n\n\tif (!richText || isEmptyRichText(richText)) {\n\t\treturn { w: 0, h: 0 }\n\t}\n\n\t// way too expensive to be recomputing on every update\n\tconst minWidth = minWidths[size]\n\n\tconst html = renderHtmlFromRichTextForMeasurement(editor, richText)\n\tconst textSize = editor.textMeasure.measureHtml(html, {\n\t\t...TEXT_PROPS,\n\t\tfontFamily: FONT_FAMILIES[font],\n\t\tfontSize: LABEL_FONT_SIZES[size],\n\t\tminWidth: minWidth,\n\t\tmaxWidth: Math.max(\n\t\t\t// Guard because a DOM nodes can't be less 0\n\t\t\t0,\n\t\t\t// A 'w' width that we're setting as the min-width\n\t\t\tMath.ceil(minWidth + extraPaddings[size]),\n\t\t\t// The actual text size\n\t\t\tMath.ceil(w / shape.props.scale - LABEL_PADDING * 2)\n\t\t),\n\t})\n\n\treturn {\n\t\tw: textSize.w + LABEL_PADDING * 2,\n\t\th: textSize.h + LABEL_PADDING * 2,\n\t}\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 12432, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/shared/useColorSpace.tsx"],"sourcesContent":["import { debugFlags, useValue } from '@tldraw/editor'\nimport { useEffect, useState } from 'react'\n\nexport function useColorSpace(): 'srgb' | 'p3' {\n\tconst [supportsP3, setSupportsP3] = useState(false)\n\n\tuseEffect(() => {\n\t\tconst supportsSyntax = CSS.supports('color', 'color(display-p3 1 1 1)')\n\t\tconst query = matchMedia('(color-gamut: p3)')\n\t\tsetSupportsP3(supportsSyntax && query.matches)\n\n\t\tconst onChange = () => setSupportsP3(supportsSyntax && query.matches)\n\n\t\tquery.addEventListener('change', onChange)\n\t\treturn () => query.removeEventListener('change', onChange)\n\t}, [])\n\n\tconst forceSrgb = useValue(debugFlags.forceSrgb)\n\n\treturn forceSrgb || !supportsP3 ? 'srgb' : 'p3'\n}\n"],"names":[],"mappings":";;;AAAA,SAAS,YAAY,gBAAgB;;;AACrC,SAAS,WAAW,gBAAgB;;;AAE7B,SAAS,gBAA+B;IAC9C,MAAM,CAAC,YAAY,aAAa,CAAA,qKAAI,WAAA,EAAS,KAAK;IAElD,CAAA,GAAA,6JAAA,CAAA,YAAA;mCAAU,MAAM;YACf,MAAM,iBAAiB,IAAI,QAAA,CAAS,SAAS,yBAAyB;YACtE,MAAM,QAAQ,WAAW,mBAAmB;YAC5C,cAAc,kBAAkB,MAAM,OAAO;YAE7C,MAAM;oDAAW,IAAM,cAAc,kBAAkB,MAAM,OAAO;;YAEpE,MAAM,gBAAA,CAAiB,UAAU,QAAQ;YACzC;2CAAO,IAAM,MAAM,mBAAA,CAAoB,UAAU,QAAQ;;QAC1D;kCAAG,CAAC,CAAC;IAEL,MAAM,iMAAY,WAAA,0LAAS,aAAA,CAAW,SAAS;IAE/C,OAAO,aAAa,CAAC,aAAa,SAAS;AAC5C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 12468, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/highlight/HighlightShapeUtil.tsx"],"sourcesContent":["/* eslint-disable react-hooks/rules-of-hooks */\nimport {\n\tCircle2d,\n\tEditor,\n\tPolygon2d,\n\tSVGContainer,\n\tShapeUtil,\n\tTLDrawShapeSegment,\n\tTLHighlightShape,\n\tTLHighlightShapeProps,\n\tTLResizeInfo,\n\tVecLike,\n\thighlightShapeMigrations,\n\thighlightShapeProps,\n\tlast,\n\tlerp,\n\trng,\n\tuseValue,\n} from '@tldraw/editor'\n\nimport { getHighlightFreehandSettings, getPointsFromSegments } from '../draw/getPath'\nimport { FONT_SIZES } from '../shared/default-shape-constants'\nimport { getStrokeOutlinePoints } from '../shared/freehand/getStrokeOutlinePoints'\nimport { getStrokePoints } from '../shared/freehand/getStrokePoints'\nimport { setStrokePointRadii } from '../shared/freehand/setStrokePointRadii'\nimport { getSvgPathFromStrokePoints } from '../shared/freehand/svg'\nimport { interpolateSegments } from '../shared/interpolate-props'\nimport { useColorSpace } from '../shared/useColorSpace'\nimport { useDefaultColorTheme } from '../shared/useDefaultColorTheme'\n\n/** @public */\nexport interface HighlightShapeOptions {\n\t/**\n\t * The maximum number of points in a line before the draw tool will begin a new shape.\n\t * A higher number will lead to poor performance while drawing very long lines.\n\t */\n\treadonly maxPointsPerShape: number\n\treadonly underlayOpacity: number\n\treadonly overlayOpacity: number\n}\n\n/** @public */\nexport class HighlightShapeUtil extends ShapeUtil<TLHighlightShape> {\n\tstatic override type = 'highlight' as const\n\tstatic override props = highlightShapeProps\n\tstatic override migrations = highlightShapeMigrations\n\n\toverride options: HighlightShapeOptions = {\n\t\tmaxPointsPerShape: 600,\n\t\tunderlayOpacity: 0.82,\n\t\toverlayOpacity: 0.35,\n\t}\n\n\toverride hideResizeHandles(shape: TLHighlightShape) {\n\t\treturn getIsDot(shape)\n\t}\n\toverride hideRotateHandle(shape: TLHighlightShape) {\n\t\treturn getIsDot(shape)\n\t}\n\toverride hideSelectionBoundsFg(shape: TLHighlightShape) {\n\t\treturn getIsDot(shape)\n\t}\n\n\toverride getDefaultProps(): TLHighlightShape['props'] {\n\t\treturn {\n\t\t\tsegments: [],\n\t\t\tcolor: 'black',\n\t\t\tsize: 'm',\n\t\t\tisComplete: false,\n\t\t\tisPen: false,\n\t\t\tscale: 1,\n\t\t}\n\t}\n\n\tgetGeometry(shape: TLHighlightShape) {\n\t\tconst strokeWidth = getStrokeWidth(shape)\n\t\tif (getIsDot(shape)) {\n\t\t\treturn new Circle2d({\n\t\t\t\tx: -strokeWidth / 2,\n\t\t\t\ty: -strokeWidth / 2,\n\t\t\t\tradius: strokeWidth / 2,\n\t\t\t\tisFilled: true,\n\t\t\t})\n\t\t}\n\n\t\tconst { strokePoints, sw } = getHighlightStrokePoints(shape, strokeWidth, true)\n\t\tconst opts = getHighlightFreehandSettings({ strokeWidth: sw, showAsComplete: true })\n\t\tsetStrokePointRadii(strokePoints, opts)\n\n\t\treturn new Polygon2d({\n\t\t\tpoints: getStrokeOutlinePoints(strokePoints, opts),\n\t\t\tisFilled: true,\n\t\t})\n\t}\n\n\tcomponent(shape: TLHighlightShape) {\n\t\tconst forceSolid = useHighlightForceSolid(this.editor, shape)\n\t\tconst strokeWidth = getStrokeWidth(shape)\n\n\t\treturn (\n\t\t\t<SVGContainer>\n\t\t\t\t<HighlightRenderer\n\t\t\t\t\tshape={shape}\n\t\t\t\t\tforceSolid={forceSolid}\n\t\t\t\t\tstrokeWidth={strokeWidth}\n\t\t\t\t\topacity={this.options.overlayOpacity}\n\t\t\t\t/>\n\t\t\t</SVGContainer>\n\t\t)\n\t}\n\n\toverride backgroundComponent(shape: TLHighlightShape) {\n\t\tconst forceSolid = useHighlightForceSolid(this.editor, shape)\n\t\tconst strokeWidth = getStrokeWidth(shape)\n\t\treturn (\n\t\t\t<SVGContainer>\n\t\t\t\t<HighlightRenderer\n\t\t\t\t\tshape={shape}\n\t\t\t\t\tforceSolid={forceSolid}\n\t\t\t\t\tstrokeWidth={strokeWidth}\n\t\t\t\t\topacity={this.options.underlayOpacity}\n\t\t\t\t/>\n\t\t\t</SVGContainer>\n\t\t)\n\t}\n\n\tindicator(shape: TLHighlightShape) {\n\t\tconst forceSolid = useHighlightForceSolid(this.editor, shape)\n\t\tconst strokeWidth = getStrokeWidth(shape)\n\n\t\tconst { strokePoints, sw } = getHighlightStrokePoints(shape, strokeWidth, forceSolid)\n\t\tconst allPointsFromSegments = getPointsFromSegments(shape.props.segments)\n\n\t\tlet strokePath\n\t\tif (strokePoints.length < 2) {\n\t\t\tstrokePath = getIndicatorDot(allPointsFromSegments[0], sw)\n\t\t} else {\n\t\t\tstrokePath = getSvgPathFromStrokePoints(strokePoints, false)\n\t\t}\n\n\t\treturn <path d={strokePath} />\n\t}\n\n\toverride toSvg(shape: TLHighlightShape) {\n\t\tconst strokeWidth = getStrokeWidth(shape)\n\t\tconst forceSolid = strokeWidth < 1.5\n\t\tconst scaleFactor = 1 / shape.props.scale\n\t\treturn (\n\t\t\t<g transform={`scale(${scaleFactor})`}>\n\t\t\t\t<HighlightRenderer\n\t\t\t\t\tforceSolid={forceSolid}\n\t\t\t\t\tstrokeWidth={strokeWidth}\n\t\t\t\t\tshape={shape}\n\t\t\t\t\topacity={this.options.overlayOpacity}\n\t\t\t\t/>\n\t\t\t</g>\n\t\t)\n\t}\n\n\toverride toBackgroundSvg(shape: TLHighlightShape) {\n\t\tconst strokeWidth = getStrokeWidth(shape)\n\t\tconst forceSolid = strokeWidth < 1.5\n\t\tconst scaleFactor = 1 / shape.props.scale\n\t\treturn (\n\t\t\t<g transform={`scale(${scaleFactor})`}>\n\t\t\t\t<HighlightRenderer\n\t\t\t\t\tforceSolid={forceSolid}\n\t\t\t\t\tstrokeWidth={strokeWidth}\n\t\t\t\t\tshape={shape}\n\t\t\t\t\topacity={this.options.underlayOpacity}\n\t\t\t\t/>\n\t\t\t</g>\n\t\t)\n\t}\n\n\toverride onResize(shape: TLHighlightShape, info: TLResizeInfo<TLHighlightShape>) {\n\t\tconst { scaleX, scaleY } = info\n\n\t\tconst newSegments: TLDrawShapeSegment[] = []\n\n\t\tfor (const segment of shape.props.segments) {\n\t\t\tnewSegments.push({\n\t\t\t\t...segment,\n\t\t\t\tpoints: segment.points.map(({ x, y, z }) => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tx: scaleX * x,\n\t\t\t\t\t\ty: scaleY * y,\n\t\t\t\t\t\tz,\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t})\n\t\t}\n\n\t\treturn {\n\t\t\tprops: {\n\t\t\t\tsegments: newSegments,\n\t\t\t},\n\t\t}\n\t}\n\toverride getInterpolatedProps(\n\t\tstartShape: TLHighlightShape,\n\t\tendShape: TLHighlightShape,\n\t\tt: number\n\t): TLHighlightShapeProps {\n\t\treturn {\n\t\t\t...(t > 0.5 ? endShape.props : startShape.props),\n\t\t\t...endShape.props,\n\t\t\tsegments: interpolateSegments(startShape.props.segments, endShape.props.segments, t),\n\t\t\tscale: lerp(startShape.props.scale, endShape.props.scale, t),\n\t\t}\n\t}\n}\n\nfunction getShapeDot(point: VecLike) {\n\tconst r = 0.1\n\treturn `M ${point.x} ${point.y} m -${r}, 0 a ${r},${r} 0 1,0 ${r * 2},0 a ${r},${r} 0 1,0 -${\n\t\tr * 2\n\t},0`\n}\n\nfunction getIndicatorDot(point: VecLike, sw: number) {\n\tconst r = sw / 2\n\treturn `M ${point.x} ${point.y} m -${r}, 0 a ${r},${r} 0 1,0 ${r * 2},0 a ${r},${r} 0 1,0 -${\n\t\tr * 2\n\t},0`\n}\n\nfunction getHighlightStrokePoints(\n\tshape: TLHighlightShape,\n\tstrokeWidth: number,\n\tforceSolid: boolean\n) {\n\tconst allPointsFromSegments = getPointsFromSegments(shape.props.segments)\n\tconst showAsComplete = shape.props.isComplete || last(shape.props.segments)?.type === 'straight'\n\n\tlet sw = strokeWidth\n\tif (!forceSolid && !shape.props.isPen && allPointsFromSegments.length === 1) {\n\t\tsw += rng(shape.id)() * (strokeWidth / 6)\n\t}\n\n\tconst options = getHighlightFreehandSettings({\n\t\tstrokeWidth: sw,\n\t\tshowAsComplete,\n\t})\n\n\tconst strokePoints = getStrokePoints(allPointsFromSegments, options)\n\n\treturn { strokePoints, sw }\n}\n\nfunction getStrokeWidth(shape: TLHighlightShape) {\n\treturn FONT_SIZES[shape.props.size] * 1.12 * shape.props.scale\n}\n\nfunction getIsDot(shape: TLHighlightShape) {\n\treturn shape.props.segments.length === 1 && shape.props.segments[0].points.length < 2\n}\n\nfunction HighlightRenderer({\n\tstrokeWidth,\n\tforceSolid,\n\tshape,\n\topacity,\n}: {\n\tstrokeWidth: number\n\tforceSolid: boolean\n\tshape: TLHighlightShape\n\topacity: number\n}) {\n\tconst theme = useDefaultColorTheme()\n\n\tconst allPointsFromSegments = getPointsFromSegments(shape.props.segments)\n\n\tlet sw = strokeWidth\n\tif (!forceSolid && !shape.props.isPen && allPointsFromSegments.length === 1) {\n\t\tsw += rng(shape.id)() * (sw / 6)\n\t}\n\n\tconst options = getHighlightFreehandSettings({\n\t\tstrokeWidth: sw,\n\t\tshowAsComplete: shape.props.isComplete || last(shape.props.segments)?.type === 'straight',\n\t})\n\n\tconst strokePoints = getStrokePoints(allPointsFromSegments, options)\n\n\tconst solidStrokePath =\n\t\tstrokePoints.length > 1\n\t\t\t? getSvgPathFromStrokePoints(strokePoints, false)\n\t\t\t: getShapeDot(shape.props.segments[0].points[0])\n\n\tconst colorSpace = useColorSpace()\n\tconst color = theme[shape.props.color].highlight[colorSpace]\n\n\treturn (\n\t\t<path\n\t\t\td={solidStrokePath}\n\t\t\tstrokeLinecap=\"round\"\n\t\t\tfill=\"none\"\n\t\t\tpointerEvents=\"all\"\n\t\t\tstroke={color}\n\t\t\tstrokeWidth={sw}\n\t\t\topacity={opacity}\n\t\t/>\n\t)\n}\n\nfunction useHighlightForceSolid(editor: Editor, shape: TLHighlightShape) {\n\treturn useValue(\n\t\t'forceSolid',\n\t\t() => {\n\t\t\tconst sw = getStrokeWidth(shape)\n\t\t\tconst zoomLevel = editor.getZoomLevel()\n\t\t\tif (sw / zoomLevel < 1.5) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\treturn false\n\t\t},\n\t\t[editor]\n\t)\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 12725, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/shared/BrokenAssetIcon.tsx"],"sourcesContent":["export function BrokenAssetIcon() {\n\treturn (\n\t\t<svg\n\t\t\twidth=\"15\"\n\t\t\theight=\"15\"\n\t\t\tviewBox=\"0 0 30 30\"\n\t\t\txmlns=\"http://www.w3.org/2000/svg\"\n\t\t\tfill=\"none\"\n\t\t\tstroke=\"currentColor\"\n\t\t\tstrokeLinecap=\"round\"\n\t\t\tstrokeLinejoin=\"round\"\n\t\t>\n\t\t\t<path d=\"M3,11 L3,3 11,3\" strokeWidth=\"2\" />\n\t\t\t<path d=\"M19,27 L27,27 L27,19\" strokeWidth=\"2\" />\n\t\t\t<path d=\"M27,3 L3,27\" strokeWidth=\"2\" />\n\t\t</svg>\n\t)\n}\n"],"names":[],"mappings":";;;AAEE,SAUC,KAVD;;AAFK,SAAS,kBAAkB;IACjC,OACC,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,OAAA,EAAC,OAAA;QACA,OAAM;QACN,QAAO;QACP,SAAQ;QACR,OAAM;QACN,MAAK;QACL,QAAO;QACP,eAAc;QACd,gBAAe;QAEf,UAAA;YAAA,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,QAAA;gBAAK,GAAE;gBAAkB,aAAY;YAAA,CAAI;YAC1C,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,QAAA;gBAAK,GAAE;gBAAuB,aAAY;YAAA,CAAI;YAC/C,aAAA,GAAA,CAAA,GAAA,sKAAA,CAAA,MAAA,EAAC,QAAA;gBAAK,GAAE;gBAAc,aAAY;YAAA,CAAI;SAAA;IAAA;AAGzC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 12764, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/shared/useImageOrVideoAsset.ts"],"sourcesContent":["import {\n\tEditor,\n\tSvgExportContext,\n\tTLAssetId,\n\tTLImageAsset,\n\tTLShapeId,\n\tTLVideoAsset,\n\treact,\n\tuseDelaySvgExport,\n\tuseEditor,\n\tuseSvgExportContext,\n} from '@tldraw/editor'\nimport { useEffect, useRef, useState } from 'react'\n\n/**\n * Options for {@link useImageOrVideoAsset}.\n *\n * @public\n */\nexport interface UseImageOrVideoAssetOptions {\n\t/** The asset ID you want a URL for. */\n\tassetId: TLAssetId | null\n\t/**\n\t * The shape the asset is being used for. We won't update the resolved URL while the shape is\n\t * off-screen.\n\t */\n\tshapeId?: TLShapeId\n\t/**\n\t * The width at which the asset will be displayed, in shape-space pixels.\n\t */\n\twidth: number\n}\n\n/**\n * This is a handy helper hook that resolves an asset to an optimized URL for a given shape, or its\n * {@link @tldraw/editor#Editor.createTemporaryAssetPreview | placeholder} if the asset is still\n * uploading. This is used in particular for high-resolution images when you want lower and higher\n * resolution depending on the size of the image on the canvas and the zoom level.\n *\n * For image scaling to work, you need to implement scaled URLs in\n * {@link @tldraw/tlschema#TLAssetStore.resolve}.\n *\n * @public\n */\nexport function useImageOrVideoAsset({ shapeId, assetId, width }: UseImageOrVideoAssetOptions) {\n\tconst editor = useEditor()\n\tconst exportInfo = useSvgExportContext()\n\tconst exportIsReady = useDelaySvgExport()\n\n\t// We use a state to store the result of the asset resolution, and we're going to avoid updating this whenever we can\n\tconst [result, setResult] = useState<{\n\t\tasset: (TLImageAsset | TLVideoAsset) | null\n\t\turl: string | null\n\t}>(() => ({\n\t\tasset: assetId ? (editor.getAsset<TLImageAsset | TLVideoAsset>(assetId) ?? null) : null,\n\t\turl: null as string | null,\n\t}))\n\n\t// A flag for whether we've resolved the asset URL at least once, after which we can debounce\n\tconst didAlreadyResolve = useRef(false)\n\n\t// The last URL that we've seen for the shape\n\tconst previousUrl = useRef<string | null>(null)\n\n\tuseEffect(() => {\n\t\tif (!assetId) return\n\n\t\tlet isCancelled = false\n\t\tlet cancelDebounceFn: (() => void) | undefined\n\n\t\tconst cleanupEffectScheduler = react('update state', () => {\n\t\t\tif (!exportInfo && shapeId && editor.getCulledShapes().has(shapeId)) return\n\n\t\t\t// Get the fresh asset\n\t\t\tconst asset = editor.getAsset<TLImageAsset | TLVideoAsset>(assetId)\n\t\t\tif (!asset) {\n\t\t\t\t// If the asset is deleted, such as when an upload fails, set the URL to null\n\t\t\t\tsetResult((prev) => ({ ...prev, asset: null, url: null }))\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Set initial preview for the shape if it has no source (if it was pasted into a local project as base64)\n\t\t\tif (!asset.props.src) {\n\t\t\t\tconst preview = editor.getTemporaryAssetPreview(asset.id)\n\t\t\t\tif (preview) {\n\t\t\t\t\tif (previousUrl.current !== preview) {\n\t\t\t\t\t\tpreviousUrl.current = preview // just for kicks, let's save the url as the previous URL\n\t\t\t\t\t\tsetResult((prev) => ({ ...prev, isPlaceholder: true, url: preview })) // set the preview as the URL\n\t\t\t\t\t\texportIsReady() // let the SVG export know we're ready for export\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// aside ...we could bail here if the only thing that has changed is the shape has changed from culled to not culled\n\n\t\t\tconst screenScale = exportInfo\n\t\t\t\t? exportInfo.scale * (width / asset.props.w)\n\t\t\t\t: editor.getZoomLevel() * (width / asset.props.w)\n\n\t\t\tfunction resolve(asset: TLImageAsset | TLVideoAsset, url: string | null) {\n\t\t\t\tif (isCancelled) return // don't update if the hook has remounted\n\t\t\t\tif (previousUrl.current === url) return // don't update the state if the url is the same\n\t\t\t\tdidAlreadyResolve.current = true // mark that we've resolved our first image\n\t\t\t\tpreviousUrl.current = url // keep the url around to compare with the next one\n\t\t\t\tsetResult({ asset, url })\n\t\t\t\texportIsReady() // let the SVG export know we're ready for export\n\t\t\t}\n\n\t\t\t// If we already resolved the URL, debounce fetching potentially multiple image variations.\n\t\t\tif (didAlreadyResolve.current) {\n\t\t\t\tlet tick = 0\n\n\t\t\t\tconst resolveAssetAfterAWhile = () => {\n\t\t\t\t\ttick++\n\t\t\t\t\tif (tick > 500 / 16) {\n\t\t\t\t\t\t// debounce for 500ms\n\t\t\t\t\t\tresolveAssetUrl(editor, assetId, screenScale, exportInfo, (url) => resolve(asset, url))\n\t\t\t\t\t\tcancelDebounceFn?.()\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcancelDebounceFn?.()\n\t\t\t\teditor.on('tick', resolveAssetAfterAWhile)\n\t\t\t\tcancelDebounceFn = () => editor.off('tick', resolveAssetAfterAWhile)\n\t\t\t} else {\n\t\t\t\tresolveAssetUrl(editor, assetId, screenScale, exportInfo, (url) => resolve(asset, url))\n\t\t\t}\n\t\t})\n\n\t\treturn () => {\n\t\t\tcleanupEffectScheduler()\n\t\t\tcancelDebounceFn?.()\n\t\t\tisCancelled = true\n\t\t}\n\t}, [editor, assetId, exportInfo, exportIsReady, shapeId, width])\n\n\treturn result\n}\n\nfunction resolveAssetUrl(\n\teditor: Editor,\n\tassetId: TLAssetId,\n\tscreenScale: number,\n\texportInfo: SvgExportContext | null,\n\tcallback: (url: string | null) => void\n) {\n\teditor\n\t\t.resolveAssetUrl(assetId, {\n\t\t\tscreenScale,\n\t\t\tshouldResolveToOriginal: exportInfo ? exportInfo.pixelRatio === null : false,\n\t\t\tdpr: exportInfo?.pixelRatio ?? undefined,\n\t\t})\n\t\t// There's a weird bug with out debounce function that doesn't\n\t\t// make it work right with async functions, so we use a callback\n\t\t// here instead of returning a promise.\n\t\t.then((url) => {\n\t\t\tcallback(url)\n\t\t})\n}\n\n/**\n * @deprecated Use {@link useImageOrVideoAsset} instead.\n *\n * @public\n */\nexport const useAsset = useImageOrVideoAsset\n"],"names":["asset"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 12896, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx"],"sourcesContent":["import {\n\tBaseBoxShapeUtil,\n\tEditor,\n\tEllipse2d,\n\tFileHelpers,\n\tGeometry2d,\n\tHTMLContainer,\n\tImage,\n\tMediaHelpers,\n\tRectangle2d,\n\tSvgExportContext,\n\tTLAsset,\n\tTLAssetId,\n\tTLImageShape,\n\tTLImageShapeProps,\n\tTLResizeInfo,\n\tTLShapePartial,\n\tVec,\n\tWeakCache,\n\tfetch,\n\timageShapeMigrations,\n\timageShapeProps,\n\tlerp,\n\tmodulate,\n\tresizeBox,\n\tstructuredClone,\n\ttoDomPrecision,\n\tuseEditor,\n\tuseUniqueSafeId,\n\tuseValue,\n} from '@tldraw/editor'\nimport classNames from 'classnames'\nimport { memo, useEffect, useState } from 'react'\nimport { BrokenAssetIcon } from '../shared/BrokenAssetIcon'\nimport { HyperlinkButton } from '../shared/HyperlinkButton'\nimport { getUncroppedSize } from '../shared/crop'\nimport { useImageOrVideoAsset } from '../shared/useImageOrVideoAsset'\nimport { usePrefersReducedMotion } from '../shared/usePrefersReducedMotion'\n\nasync function getDataURIFromURL(url: string): Promise<string> {\n\tconst response = await fetch(url)\n\tconst blob = await response.blob()\n\treturn FileHelpers.blobToDataUrl(blob)\n}\n\nconst imageSvgExportCache = new WeakCache<TLAsset, Promise<string | null>>()\n\n/** @public */\nexport class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {\n\tstatic override type = 'image' as const\n\tstatic override props = imageShapeProps\n\tstatic override migrations = imageShapeMigrations\n\n\toverride isAspectRatioLocked() {\n\t\treturn true\n\t}\n\toverride canCrop() {\n\t\treturn true\n\t}\n\n\toverride getDefaultProps(): TLImageShape['props'] {\n\t\treturn {\n\t\t\tw: 100,\n\t\t\th: 100,\n\t\t\tassetId: null,\n\t\t\tplaying: true,\n\t\t\turl: '',\n\t\t\tcrop: null,\n\t\t\tflipX: false,\n\t\t\tflipY: false,\n\t\t\taltText: '',\n\t\t}\n\t}\n\n\toverride getGeometry(shape: TLImageShape): Geometry2d {\n\t\tif (shape.props.crop?.isCircle) {\n\t\t\treturn new Ellipse2d({\n\t\t\t\twidth: shape.props.w,\n\t\t\t\theight: shape.props.h,\n\t\t\t\tisFilled: true,\n\t\t\t})\n\t\t}\n\n\t\treturn new Rectangle2d({\n\t\t\twidth: shape.props.w,\n\t\t\theight: shape.props.h,\n\t\t\tisFilled: true,\n\t\t})\n\t}\n\n\toverride getAriaDescriptor(shape: TLImageShape) {\n\t\treturn shape.props.altText\n\t}\n\n\toverride onResize(shape: TLImageShape, info: TLResizeInfo<TLImageShape>) {\n\t\tlet resized: TLImageShape = resizeBox(shape, info)\n\t\tconst { flipX, flipY } = info.initialShape.props\n\t\tconst { scaleX, scaleY, mode } = info\n\n\t\tresized = {\n\t\t\t...resized,\n\t\t\tprops: {\n\t\t\t\t...resized.props,\n\t\t\t\tflipX: scaleX < 0 !== flipX,\n\t\t\t\tflipY: scaleY < 0 !== flipY,\n\t\t\t},\n\t\t}\n\t\tif (!shape.props.crop) return resized\n\n\t\tconst flipCropHorizontally =\n\t\t\t// We used the flip horizontally feature\n\t\t\t(mode === 'scale_shape' && scaleX === -1) ||\n\t\t\t// We resized the shape past it's bounds, so it flipped\n\t\t\t(mode === 'resize_bounds' && flipX !== resized.props.flipX)\n\t\tconst flipCropVertically =\n\t\t\t// We used the flip vertically feature\n\t\t\t(mode === 'scale_shape' && scaleY === -1) ||\n\t\t\t// We resized the shape past it's bounds, so it flipped\n\t\t\t(mode === 'resize_bounds' && flipY !== resized.props.flipY)\n\n\t\tconst { topLeft, bottomRight } = shape.props.crop\n\t\tresized.props.crop = {\n\t\t\ttopLeft: {\n\t\t\t\tx: flipCropHorizontally ? 1 - bottomRight.x : topLeft.x,\n\t\t\t\ty: flipCropVertically ? 1 - bottomRight.y : topLeft.y,\n\t\t\t},\n\t\t\tbottomRight: {\n\t\t\t\tx: flipCropHorizontally ? 1 - topLeft.x : bottomRight.x,\n\t\t\t\ty: flipCropVertically ? 1 - topLeft.y : bottomRight.y,\n\t\t\t},\n\t\t\tisCircle: shape.props.crop.isCircle,\n\t\t}\n\t\treturn resized\n\t}\n\n\tcomponent(shape: TLImageShape) {\n\t\treturn <ImageShape shape={shape} />\n\t}\n\n\tindicator(shape: TLImageShape) {\n\t\tconst isCropping = this.editor.getCroppingShapeId() === shape.id\n\t\tif (isCropping) return null\n\n\t\tif (shape.props.crop?.isCircle) {\n\t\t\treturn (\n\t\t\t\t<ellipse\n\t\t\t\t\tcx={toDomPrecision(shape.props.w / 2)}\n\t\t\t\t\tcy={toDomPrecision(shape.props.h / 2)}\n\t\t\t\t\trx={toDomPrecision(shape.props.w / 2)}\n\t\t\t\t\try={toDomPrecision(shape.props.h / 2)}\n\t\t\t\t/>\n\t\t\t)\n\t\t}\n\n\t\treturn <rect width={toDomPrecision(shape.props.w)} height={toDomPrecision(shape.props.h)} />\n\t}\n\n\toverride async toSvg(shape: TLImageShape, ctx: SvgExportContext) {\n\t\tconst props = shape.props\n\t\tif (!props.assetId) return null\n\n\t\tconst asset = this.editor.getAsset(props.assetId)\n\n\t\tif (!asset) return null\n\n\t\tconst { w } = getUncroppedSize(shape.props, props.crop)\n\n\t\tconst src = await imageSvgExportCache.get(asset, async () => {\n\t\t\tlet src = await ctx.resolveAssetUrl(asset.id, w)\n\t\t\tif (!src) return null\n\t\t\tif (\n\t\t\t\tsrc.startsWith('blob:') ||\n\t\t\t\tsrc.startsWith('http') ||\n\t\t\t\tsrc.startsWith('/') ||\n\t\t\t\tsrc.startsWith('./')\n\t\t\t) {\n\t\t\t\t// If it's a remote image, we need to fetch it and convert it to a data URI\n\t\t\t\tsrc = (await getDataURIFromURL(src)) || ''\n\t\t\t}\n\n\t\t\t// If it's animated then we need to get the first frame\n\t\t\tif (getIsAnimated(this.editor, asset.id)) {\n\t\t\t\tconst { promise } = getFirstFrameOfAnimatedImage(src)\n\t\t\t\tsrc = await promise\n\t\t\t}\n\t\t\treturn src\n\t\t})\n\n\t\tif (!src) return null\n\n\t\treturn <SvgImage shape={shape} src={src} />\n\t}\n\n\toverride onDoubleClickEdge(shape: TLImageShape) {\n\t\tconst props = shape.props\n\t\tif (!props) return\n\n\t\tif (this.editor.getCroppingShapeId() !== shape.id) {\n\t\t\treturn\n\t\t}\n\n\t\tconst crop = structuredClone(props.crop) || {\n\t\t\ttopLeft: { x: 0, y: 0 },\n\t\t\tbottomRight: { x: 1, y: 1 },\n\t\t}\n\n\t\t// The true asset dimensions\n\t\tconst { w, h } = getUncroppedSize(shape.props, crop)\n\n\t\tconst pointDelta = new Vec(crop.topLeft.x * w, crop.topLeft.y * h).rot(shape.rotation)\n\n\t\tconst partial: TLShapePartial<TLImageShape> = {\n\t\t\tid: shape.id,\n\t\t\ttype: shape.type,\n\t\t\tx: shape.x - pointDelta.x,\n\t\t\ty: shape.y - pointDelta.y,\n\t\t\tprops: {\n\t\t\t\tcrop: {\n\t\t\t\t\ttopLeft: { x: 0, y: 0 },\n\t\t\t\t\tbottomRight: { x: 1, y: 1 },\n\t\t\t\t},\n\t\t\t\tw,\n\t\t\t\th,\n\t\t\t},\n\t\t}\n\n\t\tthis.editor.updateShapes([partial])\n\t}\n\toverride getInterpolatedProps(\n\t\tstartShape: TLImageShape,\n\t\tendShape: TLImageShape,\n\t\tt: number\n\t): TLImageShapeProps {\n\t\tfunction interpolateCrop(\n\t\t\tstartShape: TLImageShape,\n\t\t\tendShape: TLImageShape\n\t\t): TLImageShapeProps['crop'] {\n\t\t\tif (startShape.props.crop === null && endShape.props.crop === null) return null\n\n\t\t\tconst startTL = startShape.props.crop?.topLeft || { x: 0, y: 0 }\n\t\t\tconst startBR = startShape.props.crop?.bottomRight || { x: 1, y: 1 }\n\t\t\tconst endTL = endShape.props.crop?.topLeft || { x: 0, y: 0 }\n\t\t\tconst endBR = endShape.props.crop?.bottomRight || { x: 1, y: 1 }\n\n\t\t\treturn {\n\t\t\t\ttopLeft: { x: lerp(startTL.x, endTL.x, t), y: lerp(startTL.y, endTL.y, t) },\n\t\t\t\tbottomRight: { x: lerp(startBR.x, endBR.x, t), y: lerp(startBR.y, endBR.y, t) },\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\t...(t > 0.5 ? endShape.props : startShape.props),\n\t\t\tw: lerp(startShape.props.w, endShape.props.w, t),\n\t\t\th: lerp(startShape.props.h, endShape.props.h, t),\n\t\t\tcrop: interpolateCrop(startShape, endShape),\n\t\t}\n\t}\n}\n\nconst ImageShape = memo(function ImageShape({ shape }: { shape: TLImageShape }) {\n\tconst editor = useEditor()\n\n\tconst { w } = getUncroppedSize(shape.props, shape.props.crop)\n\tconst { asset, url } = useImageOrVideoAsset({\n\t\tshapeId: shape.id,\n\t\tassetId: shape.props.assetId,\n\t\twidth: w,\n\t})\n\n\tconst prefersReducedMotion = usePrefersReducedMotion()\n\tconst [staticFrameSrc, setStaticFrameSrc] = useState('')\n\tconst [loadedUrl, setLoadedUrl] = useState<null | string>(null)\n\tconst isAnimated = asset && getIsAnimated(editor, asset.id)\n\n\tuseEffect(() => {\n\t\tif (url && isAnimated) {\n\t\t\tconst { promise, cancel } = getFirstFrameOfAnimatedImage(url)\n\n\t\t\tpromise.then((dataUrl) => {\n\t\t\t\tsetStaticFrameSrc(dataUrl)\n\t\t\t\tsetLoadedUrl(url)\n\t\t\t})\n\n\t\t\treturn () => {\n\t\t\t\tcancel()\n\t\t\t}\n\t\t}\n\t}, [editor, isAnimated, prefersReducedMotion, url])\n\n\tconst showCropPreview = useValue(\n\t\t'show crop preview',\n\t\t() =>\n\t\t\tshape.id === editor.getOnlySelectedShapeId() &&\n\t\t\teditor.getCroppingShapeId() === shape.id &&\n\t\t\teditor.isIn('select.crop'),\n\t\t[editor, shape.id]\n\t)\n\n\t// We only want to reduce motion for mimeTypes that have motion\n\tconst reduceMotion =\n\t\tprefersReducedMotion && (asset?.props.mimeType?.includes('video') || isAnimated)\n\n\tconst containerStyle = getCroppedContainerStyle(shape)\n\n\tconst nextSrc = url === loadedUrl ? null : url\n\tconst loadedSrc = reduceMotion ? staticFrameSrc : loadedUrl\n\n\t// This logic path is for when it's broken/missing asset.\n\tif (!url && !asset?.props.src) {\n\t\treturn (\n\t\t\t<HTMLContainer\n\t\t\t\tid={shape.id}\n\t\t\t\tstyle={{\n\t\t\t\t\toverflow: 'hidden',\n\t\t\t\t\twidth: shape.props.w,\n\t\t\t\t\theight: shape.props.h,\n\t\t\t\t\tcolor: 'var(--color-text-3)',\n\t\t\t\t\tbackgroundColor: 'var(--color-low)',\n\t\t\t\t\tborder: '1px solid var(--color-low-border)',\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\t<div\n\t\t\t\t\tclassName={classNames('tl-image-container', asset && 'tl-image-container-loading')}\n\t\t\t\t\tstyle={containerStyle}\n\t\t\t\t>\n\t\t\t\t\t{asset ? null : <BrokenAssetIcon />}\n\t\t\t\t</div>\n\t\t\t\t{'url' in shape.props && shape.props.url && <HyperlinkButton url={shape.props.url} />}\n\t\t\t</HTMLContainer>\n\t\t)\n\t}\n\n\t// We don't set crossOrigin for non-animated images because for Cloudflare we don't currently\n\t// have that set up.\n\tconst crossOrigin = isAnimated ? 'anonymous' : undefined\n\n\treturn (\n\t\t<>\n\t\t\t{showCropPreview && loadedSrc && (\n\t\t\t\t<div style={containerStyle}>\n\t\t\t\t\t<img\n\t\t\t\t\t\tclassName=\"tl-image\"\n\t\t\t\t\t\tstyle={{ ...getFlipStyle(shape), opacity: 0.1 }}\n\t\t\t\t\t\tcrossOrigin={crossOrigin}\n\t\t\t\t\t\tsrc={loadedSrc}\n\t\t\t\t\t\treferrerPolicy=\"strict-origin-when-cross-origin\"\n\t\t\t\t\t\tdraggable={false}\n\t\t\t\t\t\talt=\"\"\n\t\t\t\t\t/>\n\t\t\t\t</div>\n\t\t\t)}\n\t\t\t<HTMLContainer\n\t\t\t\tid={shape.id}\n\t\t\t\tstyle={{\n\t\t\t\t\toverflow: 'hidden',\n\t\t\t\t\twidth: shape.props.w,\n\t\t\t\t\theight: shape.props.h,\n\t\t\t\t\tborderRadius: shape.props.crop?.isCircle ? '50%' : undefined,\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\t<div className={classNames('tl-image-container')} style={containerStyle}>\n\t\t\t\t\t{/* We have two images: the currently loaded image, and the next image that\n\t\t\t\t\twe're waiting to load. we keep the loaded image mounted while we're waiting\n\t\t\t\t\tfor the next one by storing the loaded URL in state. We use `key` props with\n\t\t\t\t\tthe src of the image so that when the next image is ready, the previous one will\n\t\t\t\t\tbe unmounted and the next will be shown with the browser having to remount a\n\t\t\t\t\tfresh image and decoded it again from the cache. */}\n\t\t\t\t\t{loadedSrc && (\n\t\t\t\t\t\t<img\n\t\t\t\t\t\t\tkey={loadedSrc}\n\t\t\t\t\t\t\tclassName=\"tl-image\"\n\t\t\t\t\t\t\tstyle={getFlipStyle(shape)}\n\t\t\t\t\t\t\tcrossOrigin={crossOrigin}\n\t\t\t\t\t\t\tsrc={loadedSrc}\n\t\t\t\t\t\t\treferrerPolicy=\"strict-origin-when-cross-origin\"\n\t\t\t\t\t\t\tdraggable={false}\n\t\t\t\t\t\t\talt=\"\"\n\t\t\t\t\t\t/>\n\t\t\t\t\t)}\n\t\t\t\t\t{nextSrc && (\n\t\t\t\t\t\t<img\n\t\t\t\t\t\t\tkey={nextSrc}\n\t\t\t\t\t\t\tclassName=\"tl-image\"\n\t\t\t\t\t\t\tstyle={getFlipStyle(shape)}\n\t\t\t\t\t\t\tcrossOrigin={crossOrigin}\n\t\t\t\t\t\t\tsrc={nextSrc}\n\t\t\t\t\t\t\treferrerPolicy=\"strict-origin-when-cross-origin\"\n\t\t\t\t\t\t\tdraggable={false}\n\t\t\t\t\t\t\talt={shape.props.altText}\n\t\t\t\t\t\t\tonLoad={() => setLoadedUrl(nextSrc)}\n\t\t\t\t\t\t/>\n\t\t\t\t\t)}\n\t\t\t\t</div>\n\t\t\t\t{shape.props.url && <HyperlinkButton url={shape.props.url} />}\n\t\t\t</HTMLContainer>\n\t\t</>\n\t)\n})\n\nfunction getIsAnimated(editor: Editor, assetId: TLAssetId) {\n\tconst asset = assetId ? editor.getAsset(assetId) : undefined\n\n\tif (!asset) return false\n\n\treturn (\n\t\t('mimeType' in asset.props && MediaHelpers.isAnimatedImageType(asset?.props.mimeType)) ||\n\t\t('isAnimated' in asset.props && asset.props.isAnimated)\n\t)\n}\n\n/**\n * When an image is cropped we need to translate the image to show the portion withing the cropped\n * area. We do this by translating the image by the negative of the top left corner of the crop\n * area.\n *\n * @param shape - Shape The image shape for which to get the container style\n * @returns - Styles to apply to the image container\n */\nfunction getCroppedContainerStyle(shape: TLImageShape) {\n\tconst crop = shape.props.crop\n\tconst topLeft = crop?.topLeft\n\tif (!topLeft) {\n\t\treturn {\n\t\t\twidth: shape.props.w,\n\t\t\theight: shape.props.h,\n\t\t}\n\t}\n\n\tconst { w, h } = getUncroppedSize(shape.props, crop)\n\tconst offsetX = -topLeft.x * w\n\tconst offsetY = -topLeft.y * h\n\treturn {\n\t\ttransform: `translate(${offsetX}px, ${offsetY}px)`,\n\t\twidth: w,\n\t\theight: h,\n\t}\n}\n\nfunction getFlipStyle(shape: TLImageShape, size?: { width: number; height: number }) {\n\tconst { flipX, flipY, crop } = shape.props\n\tif (!flipX && !flipY) return undefined\n\n\tlet cropOffsetX\n\tlet cropOffsetY\n\tif (crop) {\n\t\t// We have to do all this extra math because of the whole transform origin around 0,0\n\t\t// instead of center in SVG-land, ugh.\n\t\tconst { w, h } = getUncroppedSize(shape.props, crop)\n\n\t\t// Find the resulting w/h of the crop in normalized (0-1) coordinates\n\t\tconst cropWidth = crop.bottomRight.x - crop.topLeft.x\n\t\tconst cropHeight = crop.bottomRight.y - crop.topLeft.y\n\n\t\t// Map from the normalized crop coordinate space to shape pixel space\n\t\tcropOffsetX = modulate(crop.topLeft.x, [0, 1 - cropWidth], [0, w - shape.props.w])\n\t\tcropOffsetY = modulate(crop.topLeft.y, [0, 1 - cropHeight], [0, h - shape.props.h])\n\t}\n\n\tconst scale = `scale(${flipX ? -1 : 1}, ${flipY ? -1 : 1})`\n\tconst translate = size\n\t\t? `translate(${(flipX ? size.width : 0) - (cropOffsetX ? cropOffsetX : 0)}px,\n\t\t             ${(flipY ? size.height : 0) - (cropOffsetY ? cropOffsetY : 0)}px)`\n\t\t: ''\n\n\treturn {\n\t\ttransform: `${translate} ${scale}`,\n\t\t// in SVG, flipping around the center doesn't work so we use explicit width/height\n\t\ttransformOrigin: size ? '0 0' : 'center center',\n\t}\n}\n\nfunction SvgImage({ shape, src }: { shape: TLImageShape; src: string }) {\n\tconst cropClipId = useUniqueSafeId()\n\tconst containerStyle = getCroppedContainerStyle(shape)\n\tconst crop = shape.props.crop\n\n\tif (containerStyle.transform && crop) {\n\t\tconst { transform: cropTransform, width, height } = containerStyle\n\t\tconst croppedWidth = (crop.bottomRight.x - crop.topLeft.x) * width\n\t\tconst croppedHeight = (crop.bottomRight.y - crop.topLeft.y) * height\n\n\t\tconst points = [\n\t\t\tnew Vec(0, 0),\n\t\t\tnew Vec(croppedWidth, 0),\n\t\t\tnew Vec(croppedWidth, croppedHeight),\n\t\t\tnew Vec(0, croppedHeight),\n\t\t]\n\n\t\tconst flip = getFlipStyle(shape, { width, height })\n\n\t\treturn (\n\t\t\t<>\n\t\t\t\t<defs>\n\t\t\t\t\t<clipPath id={cropClipId}>\n\t\t\t\t\t\t{crop.isCircle ? (\n\t\t\t\t\t\t\t<ellipse\n\t\t\t\t\t\t\t\tcx={croppedWidth / 2}\n\t\t\t\t\t\t\t\tcy={croppedHeight / 2}\n\t\t\t\t\t\t\t\trx={croppedWidth / 2}\n\t\t\t\t\t\t\t\try={croppedHeight / 2}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t) : (\n\t\t\t\t\t\t\t<polygon points={points.map((p) => `${p.x},${p.y}`).join(' ')} />\n\t\t\t\t\t\t)}\n\t\t\t\t\t</clipPath>\n\t\t\t\t</defs>\n\t\t\t\t<g clipPath={`url(#${cropClipId})`}>\n\t\t\t\t\t<image\n\t\t\t\t\t\thref={src}\n\t\t\t\t\t\twidth={width}\n\t\t\t\t\t\theight={height}\n\t\t\t\t\t\taria-label={shape.props.altText}\n\t\t\t\t\t\tstyle={flip ? { ...flip } : { transform: cropTransform }}\n\t\t\t\t\t/>\n\t\t\t\t</g>\n\t\t\t</>\n\t\t)\n\t} else {\n\t\treturn (\n\t\t\t<image\n\t\t\t\thref={src}\n\t\t\t\twidth={shape.props.w}\n\t\t\t\theight={shape.props.h}\n\t\t\t\taria-label={shape.props.altText}\n\t\t\t\tstyle={getFlipStyle(shape, { width: shape.props.w, height: shape.props.h })}\n\t\t\t/>\n\t\t)\n\t}\n}\n\nfunction getFirstFrameOfAnimatedImage(url: string) {\n\tlet cancelled = false\n\n\tconst promise = new Promise<string>((resolve) => {\n\t\tconst image = Image()\n\t\timage.onload = () => {\n\t\t\tif (cancelled) return\n\n\t\t\tconst canvas = document.createElement('canvas')\n\t\t\tcanvas.width = image.width\n\t\t\tcanvas.height = image.height\n\n\t\t\tconst ctx = canvas.getContext('2d')\n\t\t\tif (!ctx) return\n\n\t\t\tctx.drawImage(image, 0, 0)\n\t\t\tresolve(canvas.toDataURL())\n\t\t}\n\t\timage.crossOrigin = 'anonymous'\n\t\timage.src = url\n\t})\n\n\treturn { promise, cancel: () => (cancelled = true) }\n}\n"],"names":["src","startShape","endShape","ImageShape"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 13410, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/line/LineShapeUtil.tsx"],"sourcesContent":["import {\n\tGroup2d,\n\tHandleSnapGeometry,\n\tSVGContainer,\n\tShapeUtil,\n\tTLHandle,\n\tTLHandleDragInfo,\n\tTLLineShape,\n\tTLLineShapePoint,\n\tTLResizeInfo,\n\tVec,\n\tWeakCache,\n\tZERO_INDEX_KEY,\n\tassert,\n\tgetIndexAbove,\n\tgetIndexBetween,\n\tgetIndices,\n\tlerp,\n\tlineShapeMigrations,\n\tlineShapeProps,\n\tmapObjectMapValues,\n\tmaybeSnapToGrid,\n\tsortByIndex,\n} from '@tldraw/editor'\n\nimport { STROKE_SIZES } from '../arrow/shared'\nimport { PathBuilder, PathBuilderGeometry2d } from '../shared/PathBuilder'\nimport { useDefaultColorTheme } from '../shared/useDefaultColorTheme'\n\nconst handlesCache = new WeakCache<TLLineShape['props'], TLHandle[]>()\n\n/** @public */\nexport class LineShapeUtil extends ShapeUtil<TLLineShape> {\n\tstatic override type = 'line' as const\n\tstatic override props = lineShapeProps\n\tstatic override migrations = lineShapeMigrations\n\n\toverride hideResizeHandles() {\n\t\treturn true\n\t}\n\toverride hideRotateHandle() {\n\t\treturn true\n\t}\n\toverride hideSelectionBoundsFg() {\n\t\treturn true\n\t}\n\toverride hideSelectionBoundsBg() {\n\t\treturn true\n\t}\n\n\toverride getDefaultProps(): TLLineShape['props'] {\n\t\tconst [start, end] = getIndices(2)\n\t\treturn {\n\t\t\tdash: 'draw',\n\t\t\tsize: 'm',\n\t\t\tcolor: 'black',\n\t\t\tspline: 'line',\n\t\t\tpoints: {\n\t\t\t\t[start]: { id: start, index: start, x: 0, y: 0 },\n\t\t\t\t[end]: { id: end, index: end, x: 0.1, y: 0.1 },\n\t\t\t},\n\t\t\tscale: 1,\n\t\t}\n\t}\n\n\tgetGeometry(shape: TLLineShape) {\n\t\t// todo: should we have min size?\n\t\tconst geometry = getPathForLineShape(shape).toGeometry()\n\t\tassert(geometry instanceof PathBuilderGeometry2d)\n\t\treturn geometry\n\t}\n\n\toverride getHandles(shape: TLLineShape) {\n\t\treturn handlesCache.get(shape.props, () => {\n\t\t\tconst spline = this.getGeometry(shape)\n\n\t\t\tconst points = linePointsToArray(shape)\n\t\t\tconst results: TLHandle[] = points.map((point) => ({\n\t\t\t\t...point,\n\t\t\t\tid: point.index,\n\t\t\t\ttype: 'vertex',\n\t\t\t\tcanSnap: true,\n\t\t\t}))\n\n\t\t\tfor (let i = 0; i < points.length - 1; i++) {\n\t\t\t\tconst index = getIndexBetween(points[i].index, points[i + 1].index)\n\t\t\t\tconst segment = spline.getSegments()[i]\n\t\t\t\tconst point = segment.interpolateAlongEdge(0.5)\n\t\t\t\tresults.push({\n\t\t\t\t\tid: index,\n\t\t\t\t\ttype: 'create',\n\t\t\t\t\tindex,\n\t\t\t\t\tx: point.x,\n\t\t\t\t\ty: point.y,\n\t\t\t\t\tcanSnap: true,\n\t\t\t\t})\n\t\t\t}\n\n\t\t\treturn results.sort(sortByIndex)\n\t\t})\n\t}\n\n\t//   Events\n\n\toverride onResize(shape: TLLineShape, info: TLResizeInfo<TLLineShape>) {\n\t\tconst { scaleX, scaleY } = info\n\n\t\treturn {\n\t\t\tprops: {\n\t\t\t\tpoints: mapObjectMapValues(shape.props.points, (_, { id, index, x, y }) => ({\n\t\t\t\t\tid,\n\t\t\t\t\tindex,\n\t\t\t\t\tx: x * scaleX,\n\t\t\t\t\ty: y * scaleY,\n\t\t\t\t})),\n\t\t\t},\n\t\t}\n\t}\n\n\toverride onBeforeCreate(next: TLLineShape): void | TLLineShape {\n\t\tconst {\n\t\t\tprops: { points },\n\t\t} = next\n\t\tconst pointKeys = Object.keys(points)\n\n\t\tif (pointKeys.length < 2) {\n\t\t\treturn\n\t\t}\n\n\t\tconst firstPoint = points[pointKeys[0]]\n\t\tconst allSame = pointKeys.every((key) => {\n\t\t\tconst point = points[key]\n\t\t\treturn point.x === firstPoint.x && point.y === firstPoint.y\n\t\t})\n\t\tif (allSame) {\n\t\t\tconst lastKey = pointKeys[pointKeys.length - 1]\n\t\t\tpoints[lastKey] = {\n\t\t\t\t...points[lastKey],\n\t\t\t\tx: points[lastKey].x + 0.1,\n\t\t\t\ty: points[lastKey].y + 0.1,\n\t\t\t}\n\t\t\treturn next\n\t\t}\n\t\treturn\n\t}\n\n\toverride onHandleDrag(shape: TLLineShape, { handle }: TLHandleDragInfo<TLLineShape>) {\n\t\tconst newPoint = maybeSnapToGrid(new Vec(handle.x, handle.y), this.editor)\n\t\treturn {\n\t\t\t...shape,\n\t\t\tprops: {\n\t\t\t\t...shape.props,\n\t\t\t\tpoints: {\n\t\t\t\t\t...shape.props.points,\n\t\t\t\t\t[handle.id]: { id: handle.id, index: handle.index, x: newPoint.x, y: newPoint.y },\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t}\n\n\toverride onHandleDragStart(shape: TLLineShape, { handle }: TLHandleDragInfo<TLLineShape>) {\n\t\t// For line shapes, if we're dragging a \"create\" handle, then\n\t\t// create a new vertex handle at that point; and make this handle\n\t\t// the handle that we're dragging.\n\t\tif (handle.type === 'create') {\n\t\t\treturn {\n\t\t\t\t...shape,\n\t\t\t\tprops: {\n\t\t\t\t\t...shape.props,\n\t\t\t\t\tpoints: {\n\t\t\t\t\t\t...shape.props.points,\n\t\t\t\t\t\t[handle.index]: { id: handle.index, index: handle.index, x: handle.x, y: handle.y },\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t\treturn\n\t}\n\n\tcomponent(shape: TLLineShape) {\n\t\treturn (\n\t\t\t<SVGContainer style={{ minWidth: 50, minHeight: 50 }}>\n\t\t\t\t<LineShapeSvg shape={shape} />\n\t\t\t</SVGContainer>\n\t\t)\n\t}\n\n\tindicator(shape: TLLineShape) {\n\t\tconst strokeWidth = STROKE_SIZES[shape.props.size] * shape.props.scale\n\t\tconst path = getPathForLineShape(shape)\n\t\tconst { dash } = shape.props\n\n\t\treturn path.toSvg({\n\t\t\tstyle: dash === 'draw' ? 'draw' : 'solid',\n\t\t\tstrokeWidth: 1,\n\t\t\tpasses: 1,\n\t\t\trandomSeed: shape.id,\n\t\t\toffset: 0,\n\t\t\troundness: strokeWidth * 2,\n\t\t\tprops: { strokeWidth: undefined },\n\t\t})\n\t}\n\n\toverride toSvg(shape: TLLineShape) {\n\t\treturn <LineShapeSvg shouldScale shape={shape} />\n\t}\n\n\toverride getHandleSnapGeometry(shape: TLLineShape): HandleSnapGeometry {\n\t\tconst points = linePointsToArray(shape)\n\t\treturn {\n\t\t\tpoints,\n\t\t\tgetSelfSnapPoints: (handle) => {\n\t\t\t\tconst index = this.getHandles(shape)\n\t\t\t\t\t.filter((h) => h.type === 'vertex')\n\t\t\t\t\t.findIndex((h) => h.id === handle.id)!\n\n\t\t\t\t// We want to skip the current and adjacent handles\n\t\t\t\treturn points.filter((_, i) => Math.abs(i - index) > 1).map(Vec.From)\n\t\t\t},\n\t\t\tgetSelfSnapOutline: (handle) => {\n\t\t\t\t// We want to skip the segments that include the handle, so\n\t\t\t\t// find the index of the handle that shares the same index property\n\t\t\t\t// as the initial dragging handle; this catches a quirk of create handles\n\t\t\t\tconst index = this.getHandles(shape)\n\t\t\t\t\t.filter((h) => h.type === 'vertex')\n\t\t\t\t\t.findIndex((h) => h.id === handle.id)!\n\n\t\t\t\t// Get all the outline segments from the shape that don't include the handle\n\t\t\t\tconst segments = this.getGeometry(shape)\n\t\t\t\t\t.getSegments()\n\t\t\t\t\t.filter((_, i) => i !== index - 1 && i !== index)\n\n\t\t\t\tif (!segments.length) return null\n\t\t\t\treturn new Group2d({ children: segments })\n\t\t\t},\n\t\t}\n\t}\n\toverride getInterpolatedProps(\n\t\tstartShape: TLLineShape,\n\t\tendShape: TLLineShape,\n\t\tt: number\n\t): TLLineShape['props'] {\n\t\tconst startPoints = linePointsToArray(startShape)\n\t\tconst endPoints = linePointsToArray(endShape)\n\n\t\tconst pointsToUseStart: TLLineShapePoint[] = []\n\t\tconst pointsToUseEnd: TLLineShapePoint[] = []\n\n\t\tlet index = ZERO_INDEX_KEY\n\n\t\tif (startPoints.length > endPoints.length) {\n\t\t\t// we'll need to expand points\n\t\t\tfor (let i = 0; i < startPoints.length; i++) {\n\t\t\t\tpointsToUseStart[i] = { ...startPoints[i] }\n\t\t\t\tif (endPoints[i] === undefined) {\n\t\t\t\t\tpointsToUseEnd[i] = { ...endPoints[endPoints.length - 1], id: index }\n\t\t\t\t} else {\n\t\t\t\t\tpointsToUseEnd[i] = { ...endPoints[i], id: index }\n\t\t\t\t}\n\t\t\t\tindex = getIndexAbove(index)\n\t\t\t}\n\t\t} else if (endPoints.length > startPoints.length) {\n\t\t\t// we'll need to converge points\n\t\t\tfor (let i = 0; i < endPoints.length; i++) {\n\t\t\t\tpointsToUseEnd[i] = { ...endPoints[i] }\n\t\t\t\tif (startPoints[i] === undefined) {\n\t\t\t\t\tpointsToUseStart[i] = {\n\t\t\t\t\t\t...startPoints[startPoints.length - 1],\n\t\t\t\t\t\tid: index,\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpointsToUseStart[i] = { ...startPoints[i], id: index }\n\t\t\t\t}\n\t\t\t\tindex = getIndexAbove(index)\n\t\t\t}\n\t\t} else {\n\t\t\t// noop, easy\n\t\t\tfor (let i = 0; i < endPoints.length; i++) {\n\t\t\t\tpointsToUseStart[i] = startPoints[i]\n\t\t\t\tpointsToUseEnd[i] = endPoints[i]\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\t...(t > 0.5 ? endShape.props : startShape.props),\n\t\t\tpoints: Object.fromEntries(\n\t\t\t\tpointsToUseStart.map((point, i) => {\n\t\t\t\t\tconst endPoint = pointsToUseEnd[i]\n\t\t\t\t\treturn [\n\t\t\t\t\t\tpoint.id,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t...point,\n\t\t\t\t\t\t\tx: lerp(point.x, endPoint.x, t),\n\t\t\t\t\t\t\ty: lerp(point.y, endPoint.y, t),\n\t\t\t\t\t\t},\n\t\t\t\t\t]\n\t\t\t\t})\n\t\t\t),\n\t\t\tscale: lerp(startShape.props.scale, endShape.props.scale, t),\n\t\t}\n\t}\n}\n\nfunction linePointsToArray(shape: TLLineShape) {\n\treturn Object.values(shape.props.points).sort(sortByIndex)\n}\n\nconst pathCache = new WeakCache<TLLineShape, PathBuilder>()\nfunction getPathForLineShape(shape: TLLineShape): PathBuilder {\n\treturn pathCache.get(shape, () => {\n\t\tconst points = linePointsToArray(shape).map(Vec.From)\n\n\t\tswitch (shape.props.spline) {\n\t\t\tcase 'cubic': {\n\t\t\t\treturn PathBuilder.cubicSplineThroughPoints(points, { endOffsets: 0 })\n\t\t\t}\n\t\t\tcase 'line': {\n\t\t\t\treturn PathBuilder.lineThroughPoints(points, { endOffsets: 0 })\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunction LineShapeSvg({\n\tshape,\n\tshouldScale = false,\n\tforceSolid = false,\n}: {\n\tshape: TLLineShape\n\tshouldScale?: boolean\n\tforceSolid?: boolean\n}) {\n\tconst theme = useDefaultColorTheme()\n\n\tconst path = getPathForLineShape(shape)\n\tconst { dash, color, size } = shape.props\n\n\tconst scaleFactor = 1 / shape.props.scale\n\n\tconst scale = shouldScale ? scaleFactor : 1\n\n\tconst strokeWidth = STROKE_SIZES[size] * shape.props.scale\n\n\treturn path.toSvg({\n\t\tstyle: dash,\n\t\tstrokeWidth,\n\t\tforceSolid,\n\t\trandomSeed: shape.id,\n\t\tprops: { transform: `scale(${scale})`, stroke: theme[color].solid, fill: 'none' },\n\t})\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 13746, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/note/NoteShapeUtil.tsx"],"sourcesContent":["/* eslint-disable react-hooks/rules-of-hooks */\nimport {\n\tBox,\n\tEMPTY_ARRAY,\n\tEditor,\n\tGroup2d,\n\tIndexKey,\n\tRectangle2d,\n\tShapeUtil,\n\tSvgExportContext,\n\tTLHandle,\n\tTLNoteShape,\n\tTLNoteShapeProps,\n\tTLResizeInfo,\n\tTLShape,\n\tTLShapeId,\n\tVec,\n\tWeakCache,\n\texhaustiveSwitchError,\n\tgetDefaultColorTheme,\n\tgetFontsFromRichText,\n\tisEqual,\n\tlerp,\n\tnoteShapeMigrations,\n\tnoteShapeProps,\n\tresizeScaled,\n\trng,\n\ttoDomPrecision,\n\ttoRichText,\n\tuseEditor,\n\tuseValue,\n} from '@tldraw/editor'\nimport { useCallback } from 'react'\nimport { startEditingShapeWithLabel } from '../../tools/SelectTool/selectHelpers'\nimport { useCurrentTranslation } from '../../ui/hooks/useTranslation/useTranslation'\nimport {\n\tisEmptyRichText,\n\trenderHtmlFromRichTextForMeasurement,\n\trenderPlaintextFromRichText,\n} from '../../utils/text/richText'\nimport { isRightToLeftLanguage } from '../../utils/text/text'\nimport { HyperlinkButton } from '../shared/HyperlinkButton'\nimport { RichTextLabel, RichTextSVG } from '../shared/RichTextLabel'\nimport {\n\tFONT_FAMILIES,\n\tLABEL_FONT_SIZES,\n\tLABEL_PADDING,\n\tTEXT_PROPS,\n} from '../shared/default-shape-constants'\nimport { useDefaultColorTheme } from '../shared/useDefaultColorTheme'\nimport { useIsReadyForEditing } from '../shared/useEditablePlainText'\nimport {\n\tCLONE_HANDLE_MARGIN,\n\tNOTE_CENTER_OFFSET,\n\tNOTE_SIZE,\n\tgetNoteShapeForAdjacentPosition,\n} from './noteHelpers'\n\n/** @public */\nexport interface NoteShapeOptions {\n\t/**\n\t * How should the note shape resize? By default it does not resize (except automatically based on its text content),\n\t * but you can set it to be user-resizable using scale.\n\t */\n\tresizeMode: 'none' | 'scale'\n}\n\n/** @public */\nexport class NoteShapeUtil extends ShapeUtil<TLNoteShape> {\n\tstatic override type = 'note' as const\n\tstatic override props = noteShapeProps\n\tstatic override migrations = noteShapeMigrations\n\n\toverride options: NoteShapeOptions = {\n\t\tresizeMode: 'none',\n\t}\n\n\toverride canEdit() {\n\t\treturn true\n\t}\n\toverride hideResizeHandles() {\n\t\tconst { resizeMode } = this.options\n\t\tswitch (resizeMode) {\n\t\t\tcase 'none': {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tcase 'scale': {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow exhaustiveSwitchError(resizeMode)\n\t\t\t}\n\t\t}\n\t}\n\n\toverride isAspectRatioLocked() {\n\t\treturn this.options.resizeMode === 'scale'\n\t}\n\n\toverride hideSelectionBoundsFg() {\n\t\treturn false\n\t}\n\n\tgetDefaultProps(): TLNoteShape['props'] {\n\t\treturn {\n\t\t\tcolor: 'black',\n\t\t\trichText: toRichText(''),\n\t\t\tsize: 'm',\n\t\t\tfont: 'draw',\n\t\t\talign: 'middle',\n\t\t\tverticalAlign: 'middle',\n\t\t\tlabelColor: 'black',\n\t\t\tgrowY: 0,\n\t\t\tfontSizeAdjustment: 0,\n\t\t\turl: '',\n\t\t\tscale: 1,\n\t\t}\n\t}\n\n\tgetGeometry(shape: TLNoteShape) {\n\t\tconst { labelHeight, labelWidth } = getLabelSize(this.editor, shape)\n\t\tconst { scale } = shape.props\n\n\t\tconst lh = labelHeight * scale\n\t\tconst lw = labelWidth * scale\n\t\tconst nw = NOTE_SIZE * scale\n\t\tconst nh = getNoteHeight(shape)\n\n\t\treturn new Group2d({\n\t\t\tchildren: [\n\t\t\t\tnew Rectangle2d({ width: nw, height: nh, isFilled: true }),\n\t\t\t\tnew Rectangle2d({\n\t\t\t\t\tx:\n\t\t\t\t\t\tshape.props.align === 'start'\n\t\t\t\t\t\t\t? 0\n\t\t\t\t\t\t\t: shape.props.align === 'end'\n\t\t\t\t\t\t\t\t? nw - lw\n\t\t\t\t\t\t\t\t: (nw - lw) / 2,\n\t\t\t\t\ty:\n\t\t\t\t\t\tshape.props.verticalAlign === 'start'\n\t\t\t\t\t\t\t? 0\n\t\t\t\t\t\t\t: shape.props.verticalAlign === 'end'\n\t\t\t\t\t\t\t\t? nh - lh\n\t\t\t\t\t\t\t\t: (nh - lh) / 2,\n\t\t\t\t\twidth: lw,\n\t\t\t\t\theight: lh,\n\t\t\t\t\tisFilled: true,\n\t\t\t\t\tisLabel: true,\n\t\t\t\t}),\n\t\t\t],\n\t\t})\n\t}\n\n\toverride getHandles(shape: TLNoteShape): TLHandle[] {\n\t\tconst { scale } = shape.props\n\t\tconst isCoarsePointer = this.editor.getInstanceState().isCoarsePointer\n\t\tif (isCoarsePointer) return []\n\n\t\tconst zoom = this.editor.getZoomLevel()\n\t\tif (zoom * scale < 0.25) return []\n\n\t\tconst nh = getNoteHeight(shape)\n\t\tconst nw = NOTE_SIZE * scale\n\t\tconst offset = (CLONE_HANDLE_MARGIN / zoom) * scale\n\n\t\tif (zoom * scale < 0.5) {\n\t\t\treturn [\n\t\t\t\t{\n\t\t\t\t\tid: 'bottom',\n\t\t\t\t\tindex: 'a3' as IndexKey,\n\t\t\t\t\ttype: 'clone',\n\t\t\t\t\tx: nw / 2,\n\t\t\t\t\ty: nh + offset,\n\t\t\t\t},\n\t\t\t]\n\t\t}\n\n\t\treturn [\n\t\t\t{\n\t\t\t\tid: 'top',\n\t\t\t\tindex: 'a1' as IndexKey,\n\t\t\t\ttype: 'clone',\n\t\t\t\tx: nw / 2,\n\t\t\t\ty: -offset,\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: 'right',\n\t\t\t\tindex: 'a2' as IndexKey,\n\t\t\t\ttype: 'clone',\n\t\t\t\tx: nw + offset,\n\t\t\t\ty: nh / 2,\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: 'bottom',\n\t\t\t\tindex: 'a3' as IndexKey,\n\t\t\t\ttype: 'clone',\n\t\t\t\tx: nw / 2,\n\t\t\t\ty: nh + offset,\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: 'left',\n\t\t\t\tindex: 'a4' as IndexKey,\n\t\t\t\ttype: 'clone',\n\t\t\t\tx: -offset,\n\t\t\t\ty: nh / 2,\n\t\t\t},\n\t\t]\n\t}\n\n\toverride onResize(shape: any, info: TLResizeInfo<any>) {\n\t\tconst { resizeMode } = this.options\n\t\tswitch (resizeMode) {\n\t\t\tcase 'none': {\n\t\t\t\treturn undefined\n\t\t\t}\n\t\t\tcase 'scale': {\n\t\t\t\treturn resizeScaled(shape, info)\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow exhaustiveSwitchError(resizeMode)\n\t\t\t}\n\t\t}\n\t}\n\n\toverride getText(shape: TLNoteShape) {\n\t\treturn renderPlaintextFromRichText(this.editor, shape.props.richText)\n\t}\n\n\toverride getFontFaces(shape: TLNoteShape) {\n\t\tif (isEmptyRichText(shape.props.richText)) {\n\t\t\treturn EMPTY_ARRAY\n\t\t}\n\t\treturn getFontsFromRichText(this.editor, shape.props.richText, {\n\t\t\tfamily: `tldraw_${shape.props.font}`,\n\t\t\tweight: 'normal',\n\t\t\tstyle: 'normal',\n\t\t})\n\t}\n\n\tcomponent(shape: TLNoteShape) {\n\t\tconst {\n\t\t\tid,\n\t\t\ttype,\n\t\t\tprops: {\n\t\t\t\tlabelColor,\n\t\t\t\tscale,\n\t\t\t\tcolor,\n\t\t\t\tfont,\n\t\t\t\tsize,\n\t\t\t\talign,\n\t\t\t\trichText,\n\t\t\t\tverticalAlign,\n\t\t\t\tfontSizeAdjustment,\n\t\t\t},\n\t\t} = shape\n\n\t\tconst handleKeyDown = useNoteKeydownHandler(id)\n\n\t\tconst theme = useDefaultColorTheme()\n\t\tconst nw = NOTE_SIZE * scale\n\t\tconst nh = getNoteHeight(shape)\n\n\t\tconst rotation = useValue(\n\t\t\t'shape rotation',\n\t\t\t() => this.editor.getShapePageTransform(id)?.rotation() ?? 0,\n\t\t\t[this.editor]\n\t\t)\n\n\t\t// todo: consider hiding shadows on dark mode if they're invisible anyway\n\n\t\tconst hideShadows = useValue('zoom', () => this.editor.getZoomLevel() < 0.35 / scale, [\n\t\t\tscale,\n\t\t\tthis.editor,\n\t\t])\n\n\t\tconst isDarkMode = useValue('dark mode', () => this.editor.user.getIsDarkMode(), [this.editor])\n\n\t\tconst isSelected = shape.id === this.editor.getOnlySelectedShapeId()\n\n\t\tconst isReadyForEditing = useIsReadyForEditing(this.editor, shape.id)\n\t\tconst isEmpty = isEmptyRichText(richText)\n\n\t\treturn (\n\t\t\t<>\n\t\t\t\t<div\n\t\t\t\t\tid={id}\n\t\t\t\t\tclassName=\"tl-note__container\"\n\t\t\t\t\tstyle={{\n\t\t\t\t\t\twidth: nw,\n\t\t\t\t\t\theight: nh,\n\t\t\t\t\t\tbackgroundColor: theme[color].note.fill,\n\t\t\t\t\t\tborderBottom: hideShadows\n\t\t\t\t\t\t\t? isDarkMode\n\t\t\t\t\t\t\t\t? `${2 * scale}px solid rgb(20, 20, 20)`\n\t\t\t\t\t\t\t\t: `${2 * scale}px solid rgb(144, 144, 144)`\n\t\t\t\t\t\t\t: 'none',\n\t\t\t\t\t\tboxShadow: hideShadows ? 'none' : getNoteShadow(shape.id, rotation, scale),\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\t{(isSelected || isReadyForEditing || !isEmpty) && (\n\t\t\t\t\t\t<RichTextLabel\n\t\t\t\t\t\t\tshapeId={id}\n\t\t\t\t\t\t\ttype={type}\n\t\t\t\t\t\t\tfont={font}\n\t\t\t\t\t\t\tfontSize={(fontSizeAdjustment || LABEL_FONT_SIZES[size]) * scale}\n\t\t\t\t\t\t\tlineHeight={TEXT_PROPS.lineHeight}\n\t\t\t\t\t\t\talign={align}\n\t\t\t\t\t\t\tverticalAlign={verticalAlign}\n\t\t\t\t\t\t\trichText={richText}\n\t\t\t\t\t\t\tisSelected={isSelected}\n\t\t\t\t\t\t\tlabelColor={labelColor === 'black' ? theme[color].note.text : theme[labelColor].fill}\n\t\t\t\t\t\t\twrap\n\t\t\t\t\t\t\tpadding={LABEL_PADDING * scale}\n\t\t\t\t\t\t\thasCustomTabBehavior\n\t\t\t\t\t\t\tonKeyDown={handleKeyDown}\n\t\t\t\t\t\t/>\n\t\t\t\t\t)}\n\t\t\t\t</div>\n\t\t\t\t{'url' in shape.props && shape.props.url && <HyperlinkButton url={shape.props.url} />}\n\t\t\t</>\n\t\t)\n\t}\n\n\tindicator(shape: TLNoteShape) {\n\t\tconst { scale } = shape.props\n\t\treturn (\n\t\t\t<rect\n\t\t\t\trx={scale}\n\t\t\t\twidth={toDomPrecision(NOTE_SIZE * scale)}\n\t\t\t\theight={toDomPrecision(getNoteHeight(shape))}\n\t\t\t/>\n\t\t)\n\t}\n\n\toverride toSvg(shape: TLNoteShape, ctx: SvgExportContext) {\n\t\tconst theme = getDefaultColorTheme({ isDarkMode: ctx.isDarkMode })\n\t\tconst bounds = getBoundsForSVG(shape)\n\n\t\tconst textLabel = (\n\t\t\t<RichTextSVG\n\t\t\t\tfontSize={shape.props.fontSizeAdjustment || LABEL_FONT_SIZES[shape.props.size]}\n\t\t\t\tfont={shape.props.font}\n\t\t\t\talign={shape.props.align}\n\t\t\t\tverticalAlign={shape.props.verticalAlign}\n\t\t\t\trichText={shape.props.richText}\n\t\t\t\tlabelColor={theme[shape.props.color].note.text}\n\t\t\t\tbounds={bounds}\n\t\t\t\tpadding={LABEL_PADDING}\n\t\t\t\tshowTextOutline={false}\n\t\t\t/>\n\t\t)\n\n\t\treturn (\n\t\t\t<>\n\t\t\t\t<rect x={5} y={5} rx={1} width={NOTE_SIZE - 10} height={bounds.h} fill=\"rgba(0,0,0,.1)\" />\n\t\t\t\t<rect\n\t\t\t\t\trx={1}\n\t\t\t\t\twidth={NOTE_SIZE}\n\t\t\t\t\theight={bounds.h}\n\t\t\t\t\tfill={theme[shape.props.color].note.fill}\n\t\t\t\t/>\n\t\t\t\t{textLabel}\n\t\t\t</>\n\t\t)\n\t}\n\n\toverride onBeforeCreate(next: TLNoteShape) {\n\t\treturn getNoteSizeAdjustments(this.editor, next)\n\t}\n\n\toverride onBeforeUpdate(prev: TLNoteShape, next: TLNoteShape) {\n\t\tif (\n\t\t\tisEqual(prev.props.richText, next.props.richText) &&\n\t\t\tprev.props.font === next.props.font &&\n\t\t\tprev.props.size === next.props.size\n\t\t) {\n\t\t\treturn\n\t\t}\n\n\t\treturn getNoteSizeAdjustments(this.editor, next)\n\t}\n\n\toverride getInterpolatedProps(\n\t\tstartShape: TLNoteShape,\n\t\tendShape: TLNoteShape,\n\t\tt: number\n\t): TLNoteShapeProps {\n\t\treturn {\n\t\t\t...(t > 0.5 ? endShape.props : startShape.props),\n\t\t\tscale: lerp(startShape.props.scale, endShape.props.scale, t),\n\t\t}\n\t}\n}\n\n/**\n * Get the growY and fontSizeAdjustment for a shape.\n */\nfunction getNoteSizeAdjustments(editor: Editor, shape: TLNoteShape) {\n\tconst { labelHeight, fontSizeAdjustment } = getLabelSize(editor, shape)\n\t// When the label height is more than the height of the shape, we add extra height to it\n\tconst growY = Math.max(0, labelHeight - NOTE_SIZE)\n\n\tif (growY !== shape.props.growY || fontSizeAdjustment !== shape.props.fontSizeAdjustment) {\n\t\treturn {\n\t\t\t...shape,\n\t\t\tprops: {\n\t\t\t\t...shape.props,\n\t\t\t\tgrowY,\n\t\t\t\tfontSizeAdjustment,\n\t\t\t},\n\t\t}\n\t}\n}\n\n/**\n * Get the label size for a note.\n */\nfunction getNoteLabelSize(editor: Editor, shape: TLNoteShape) {\n\tconst { richText } = shape.props\n\n\tif (isEmptyRichText(richText)) {\n\t\tconst minHeight = LABEL_FONT_SIZES[shape.props.size] * TEXT_PROPS.lineHeight + LABEL_PADDING * 2\n\t\treturn { labelHeight: minHeight, labelWidth: 100, fontSizeAdjustment: 0 }\n\t}\n\n\tconst unadjustedFontSize = LABEL_FONT_SIZES[shape.props.size]\n\n\tlet fontSizeAdjustment = 0\n\tlet iterations = 0\n\tlet labelHeight = NOTE_SIZE\n\tlet labelWidth = NOTE_SIZE\n\n\t// N.B. For some note shapes with text like 'hjhjhjhjhjhjhjhj', you'll run into\n\t// some text measurement fuzziness where the browser swears there's no overflow (scrollWidth === width)\n\t// but really there is when you enable overflow-wrap again. This helps account for that little bit\n\t// of give.\n\tconst FUZZ = 1\n\n\t// We slightly make the font smaller if the text is too big for the note, width-wise.\n\tdo {\n\t\tfontSizeAdjustment = Math.min(unadjustedFontSize, unadjustedFontSize - iterations)\n\t\tconst html = renderHtmlFromRichTextForMeasurement(editor, richText)\n\t\tconst nextTextSize = editor.textMeasure.measureHtml(html, {\n\t\t\t...TEXT_PROPS,\n\t\t\tfontFamily: FONT_FAMILIES[shape.props.font],\n\t\t\tfontSize: fontSizeAdjustment,\n\t\t\tmaxWidth: NOTE_SIZE - LABEL_PADDING * 2 - FUZZ,\n\t\t\tdisableOverflowWrapBreaking: true,\n\t\t\tmeasureScrollWidth: true,\n\t\t})\n\n\t\tlabelHeight = nextTextSize.h + LABEL_PADDING * 2\n\t\tlabelWidth = nextTextSize.w + LABEL_PADDING * 2\n\n\t\tif (fontSizeAdjustment <= 14) {\n\t\t\t// Too small, just rely now on CSS `overflow-wrap: break-word`\n\t\t\t// We need to recalculate the text measurement here with break-word enabled.\n\t\t\tconst html = renderHtmlFromRichTextForMeasurement(editor, richText)\n\t\t\tconst nextTextSizeWithOverflowBreak = editor.textMeasure.measureHtml(html, {\n\t\t\t\t...TEXT_PROPS,\n\t\t\t\tfontFamily: FONT_FAMILIES[shape.props.font],\n\t\t\t\tfontSize: fontSizeAdjustment,\n\t\t\t\tmaxWidth: NOTE_SIZE - LABEL_PADDING * 2 - FUZZ,\n\t\t\t})\n\t\t\tlabelHeight = nextTextSizeWithOverflowBreak.h + LABEL_PADDING * 2\n\t\t\tlabelWidth = nextTextSizeWithOverflowBreak.w + LABEL_PADDING * 2\n\t\t\tbreak\n\t\t}\n\n\t\tif (nextTextSize.scrollWidth.toFixed(0) === nextTextSize.w.toFixed(0)) {\n\t\t\tbreak\n\t\t}\n\t} while (iterations++ < 50)\n\n\treturn {\n\t\tlabelHeight: labelHeight,\n\t\tlabelWidth: labelWidth,\n\t\tfontSizeAdjustment: fontSizeAdjustment,\n\t}\n}\n\nconst labelSizesForNote = new WeakCache<TLShape, ReturnType<typeof getNoteLabelSize>>()\n\nfunction getLabelSize(editor: Editor, shape: TLNoteShape) {\n\treturn labelSizesForNote.get(shape, () => getNoteLabelSize(editor, shape))\n}\n\nfunction useNoteKeydownHandler(id: TLShapeId) {\n\tconst editor = useEditor()\n\tconst translation = useCurrentTranslation()\n\n\treturn useCallback(\n\t\t(e: KeyboardEvent) => {\n\t\t\tconst shape = editor.getShape<TLNoteShape>(id)\n\t\t\tif (!shape) return\n\n\t\t\tconst isTab = e.key === 'Tab'\n\t\t\tconst isCmdEnter = (e.metaKey || e.ctrlKey) && e.key === 'Enter'\n\t\t\tif (isTab || isCmdEnter) {\n\t\t\t\te.preventDefault()\n\n\t\t\t\tconst pageTransform = editor.getShapePageTransform(id)\n\t\t\t\tconst pageRotation = pageTransform.rotation()\n\n\t\t\t\t// Based on the inputs, calculate the offset to the next note\n\t\t\t\t// tab controls x axis (shift inverts direction set by RTL)\n\t\t\t\t// cmd enter is the y axis (shift inverts direction)\n\t\t\t\tconst isRTL = !!(\n\t\t\t\t\ttranslation.dir === 'rtl' ||\n\t\t\t\t\t// todo: can we check a partial of the text, so that we don't have to render the whole thing?\n\t\t\t\t\tisRightToLeftLanguage(renderPlaintextFromRichText(editor, shape.props.richText))\n\t\t\t\t)\n\n\t\t\t\tconst offsetLength =\n\t\t\t\t\t(NOTE_SIZE +\n\t\t\t\t\t\teditor.options.adjacentShapeMargin +\n\t\t\t\t\t\t// If we're growing down, we need to account for the current shape's growY\n\t\t\t\t\t\t(isCmdEnter && !e.shiftKey ? shape.props.growY : 0)) *\n\t\t\t\t\tshape.props.scale\n\n\t\t\t\tconst adjacentCenter = new Vec(\n\t\t\t\t\tisTab ? (e.shiftKey != isRTL ? -1 : 1) : 0,\n\t\t\t\t\tisCmdEnter ? (e.shiftKey ? -1 : 1) : 0\n\t\t\t\t)\n\t\t\t\t\t.mul(offsetLength)\n\t\t\t\t\t.add(NOTE_CENTER_OFFSET.clone().mul(shape.props.scale))\n\t\t\t\t\t.rot(pageRotation)\n\t\t\t\t\t.add(pageTransform.point())\n\n\t\t\t\tconst newNote = getNoteShapeForAdjacentPosition(editor, shape, adjacentCenter, pageRotation)\n\n\t\t\t\tif (newNote) {\n\t\t\t\t\tstartEditingShapeWithLabel(editor, newNote, true /* selectAll */)\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t[id, editor, translation.dir]\n\t)\n}\n\nfunction getNoteHeight(shape: TLNoteShape) {\n\treturn (NOTE_SIZE + shape.props.growY) * shape.props.scale\n}\n\nfunction getNoteShadow(id: string, rotation: number, scale: number) {\n\tconst random = rng(id) // seeded based on id\n\tconst lift = Math.abs(random()) + 0.5 // 0 to 1.5\n\tconst oy = Math.cos(rotation)\n\tconst a = 5 * scale\n\tconst b = 4 * scale\n\tconst c = 6 * scale\n\tconst d = 7 * scale\n\treturn `0px ${a - lift}px ${a}px -${a}px rgba(15, 23, 31, .6),\n\t0px ${(b + lift * d) * Math.max(0, oy)}px ${c + lift * d}px -${b + lift * c}px rgba(15, 23, 31, ${(0.3 + lift * 0.1).toFixed(2)}), \n\t0px ${48 * scale}px ${10 * scale}px -${10 * scale}px inset rgba(15, 23, 44, ${((0.022 + random() * 0.005) * ((1 + oy) / 2)).toFixed(2)})`\n}\n\nfunction getBoundsForSVG(shape: TLNoteShape) {\n\t// When rendering the SVG we don't want to adjust for scale\n\treturn new Box(0, 0, NOTE_SIZE, NOTE_SIZE + shape.props.growY)\n}\n"],"names":["html"],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 14192, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/text/TextShapeUtil.tsx"],"sourcesContent":["/* eslint-disable react-hooks/rules-of-hooks */\nimport {\n\tBox,\n\tEditor,\n\tRectangle2d,\n\tShapeUtil,\n\tSvgExportContext,\n\tTLGeometryOpts,\n\tTLResizeInfo,\n\tTLShapeId,\n\tTLTextShape,\n\tVec,\n\tcreateComputedCache,\n\tgetDefaultColorTheme,\n\tgetFontsFromRichText,\n\tisEqual,\n\tresizeScaled,\n\ttextShapeMigrations,\n\ttextShapeProps,\n\ttoDomPrecision,\n\ttoRichText,\n\tuseEditor,\n} from '@tldraw/editor'\nimport { useCallback } from 'react'\nimport {\n\trenderHtmlFromRichTextForMeasurement,\n\trenderPlaintextFromRichText,\n} from '../../utils/text/richText'\nimport { RichTextLabel, RichTextSVG } from '../shared/RichTextLabel'\nimport { FONT_FAMILIES, FONT_SIZES, TEXT_PROPS } from '../shared/default-shape-constants'\nimport { useDefaultColorTheme } from '../shared/useDefaultColorTheme'\n\nconst sizeCache = createComputedCache(\n\t'text size',\n\t(editor: Editor, shape: TLTextShape) => {\n\t\teditor.fonts.trackFontsForShape(shape)\n\t\treturn getTextSize(editor, shape.props)\n\t},\n\t{ areRecordsEqual: (a, b) => a.props === b.props }\n)\n/** @public */\nexport interface TextShapeOptions {\n\t/** How much addition padding should be added to the horizontal geometry of the shape when binding to an arrow? */\n\textraArrowHorizontalPadding: number\n}\n\n/** @public */\nexport class TextShapeUtil extends ShapeUtil<TLTextShape> {\n\tstatic override type = 'text' as const\n\tstatic override props = textShapeProps\n\tstatic override migrations = textShapeMigrations\n\n\toverride options: TextShapeOptions = {\n\t\textraArrowHorizontalPadding: 10,\n\t}\n\n\tgetDefaultProps(): TLTextShape['props'] {\n\t\treturn {\n\t\t\tcolor: 'black',\n\t\t\tsize: 'm',\n\t\t\tw: 8,\n\t\t\tfont: 'draw',\n\t\t\ttextAlign: 'start',\n\t\t\tautoSize: true,\n\t\t\tscale: 1,\n\t\t\trichText: toRichText(''),\n\t\t}\n\t}\n\n\tgetMinDimensions(shape: TLTextShape) {\n\t\treturn sizeCache.get(this.editor, shape.id)!\n\t}\n\n\tgetGeometry(shape: TLTextShape, opts: TLGeometryOpts) {\n\t\tconst { scale } = shape.props\n\t\tconst { width, height } = this.getMinDimensions(shape)!\n\t\tconst context = opts?.context ?? 'none'\n\t\treturn new Rectangle2d({\n\t\t\tx:\n\t\t\t\t(context === '@tldraw/arrow-without-arrowhead'\n\t\t\t\t\t? -this.options.extraArrowHorizontalPadding\n\t\t\t\t\t: 0) * scale,\n\t\t\twidth:\n\t\t\t\t(width +\n\t\t\t\t\t(context === '@tldraw/arrow-without-arrowhead'\n\t\t\t\t\t\t? this.options.extraArrowHorizontalPadding * 2\n\t\t\t\t\t\t: 0)) *\n\t\t\t\tscale,\n\t\t\theight: height * scale,\n\t\t\tisFilled: true,\n\t\t\tisLabel: true,\n\t\t})\n\t}\n\n\toverride getFontFaces(shape: TLTextShape) {\n\t\t// no need for an empty rich text check here\n\t\treturn getFontsFromRichText(this.editor, shape.props.richText, {\n\t\t\tfamily: `tldraw_${shape.props.font}`,\n\t\t\tweight: 'normal',\n\t\t\tstyle: 'normal',\n\t\t})\n\t}\n\n\toverride getText(shape: TLTextShape) {\n\t\treturn renderPlaintextFromRichText(this.editor, shape.props.richText)\n\t}\n\n\toverride canEdit() {\n\t\treturn true\n\t}\n\n\toverride isAspectRatioLocked() {\n\t\treturn true\n\t} // WAIT NO THIS IS HARD CODED IN THE RESIZE HANDLER\n\n\tcomponent(shape: TLTextShape) {\n\t\tconst {\n\t\t\tid,\n\t\t\tprops: { font, size, richText, color, scale, textAlign },\n\t\t} = shape\n\n\t\tconst { width, height } = this.getMinDimensions(shape)\n\t\tconst isSelected = shape.id === this.editor.getOnlySelectedShapeId()\n\t\tconst theme = useDefaultColorTheme()\n\t\tconst handleKeyDown = useTextShapeKeydownHandler(id)\n\n\t\treturn (\n\t\t\t<RichTextLabel\n\t\t\t\tshapeId={id}\n\t\t\t\tclassNamePrefix=\"tl-text-shape\"\n\t\t\t\ttype=\"text\"\n\t\t\t\tfont={font}\n\t\t\t\tfontSize={FONT_SIZES[size]}\n\t\t\t\tlineHeight={TEXT_PROPS.lineHeight}\n\t\t\t\talign={textAlign}\n\t\t\t\tverticalAlign=\"middle\"\n\t\t\t\trichText={richText}\n\t\t\t\tlabelColor={theme[color].solid}\n\t\t\t\tisSelected={isSelected}\n\t\t\t\ttextWidth={width}\n\t\t\t\ttextHeight={height}\n\t\t\t\tstyle={{\n\t\t\t\t\ttransform: `scale(${scale})`,\n\t\t\t\t\ttransformOrigin: 'top left',\n\t\t\t\t}}\n\t\t\t\twrap\n\t\t\t\tonKeyDown={handleKeyDown}\n\t\t\t/>\n\t\t)\n\t}\n\n\tindicator(shape: TLTextShape) {\n\t\tconst bounds = this.editor.getShapeGeometry(shape).bounds\n\t\tconst editor = useEditor()\n\t\tif (shape.props.autoSize && editor.getEditingShapeId() === shape.id) return null\n\t\treturn <rect width={toDomPrecision(bounds.width)} height={toDomPrecision(bounds.height)} />\n\t}\n\n\toverride toSvg(shape: TLTextShape, ctx: SvgExportContext) {\n\t\tconst bounds = this.editor.getShapeGeometry(shape).bounds\n\t\tconst width = bounds.width / (shape.props.scale ?? 1)\n\t\tconst height = bounds.height / (shape.props.scale ?? 1)\n\n\t\tconst theme = getDefaultColorTheme(ctx)\n\n\t\tconst exportBounds = new Box(0, 0, width, height)\n\t\treturn (\n\t\t\t<RichTextSVG\n\t\t\t\tfontSize={FONT_SIZES[shape.props.size]}\n\t\t\t\tfont={shape.props.font}\n\t\t\t\talign={shape.props.textAlign}\n\t\t\t\tverticalAlign=\"middle\"\n\t\t\t\trichText={shape.props.richText}\n\t\t\t\tlabelColor={theme[shape.props.color].solid}\n\t\t\t\tbounds={exportBounds}\n\t\t\t\tpadding={0}\n\t\t\t/>\n\t\t)\n\t}\n\n\toverride onResize(shape: TLTextShape, info: TLResizeInfo<TLTextShape>) {\n\t\tconst { newPoint, initialBounds, initialShape, scaleX, handle } = info\n\n\t\tif (info.mode === 'scale_shape' || (handle !== 'right' && handle !== 'left')) {\n\t\t\treturn {\n\t\t\t\tid: shape.id,\n\t\t\t\ttype: shape.type,\n\t\t\t\t...resizeScaled(shape, info),\n\t\t\t}\n\t\t} else {\n\t\t\tconst nextWidth = Math.max(1, Math.abs(initialBounds.width * scaleX))\n\t\t\tconst { x, y } =\n\t\t\t\tscaleX < 0 ? Vec.Sub(newPoint, Vec.FromAngle(shape.rotation).mul(nextWidth)) : newPoint\n\n\t\t\treturn {\n\t\t\t\tid: shape.id,\n\t\t\t\ttype: shape.type,\n\t\t\t\tx,\n\t\t\t\ty,\n\t\t\t\tprops: {\n\t\t\t\t\tw: nextWidth / initialShape.props.scale,\n\t\t\t\t\tautoSize: false,\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\toverride onEditEnd(shape: TLTextShape) {\n\t\t// todo: find a way to check if the rich text has any nodes that aren't empty spaces\n\t\tconst trimmedText = renderPlaintextFromRichText(this.editor, shape.props.richText).trimEnd()\n\n\t\tif (trimmedText.length === 0) {\n\t\t\tthis.editor.deleteShapes([shape.id])\n\t\t}\n\t}\n\n\toverride onBeforeUpdate(prev: TLTextShape, next: TLTextShape) {\n\t\tif (!next.props.autoSize) return\n\n\t\tconst styleDidChange =\n\t\t\tprev.props.size !== next.props.size ||\n\t\t\tprev.props.textAlign !== next.props.textAlign ||\n\t\t\tprev.props.font !== next.props.font ||\n\t\t\t(prev.props.scale !== 1 && next.props.scale === 1)\n\n\t\tconst textDidChange = !isEqual(prev.props.richText, next.props.richText)\n\n\t\t// Only update position if either changed\n\t\tif (!styleDidChange && !textDidChange) return\n\n\t\t// Might return a cached value for the bounds\n\t\tconst boundsA = this.getMinDimensions(prev)\n\n\t\t// Will always be a fresh call to getTextSize\n\t\tconst boundsB = getTextSize(this.editor, next.props)\n\n\t\tconst wA = boundsA.width * prev.props.scale\n\t\tconst hA = boundsA.height * prev.props.scale\n\t\tconst wB = boundsB.width * next.props.scale\n\t\tconst hB = boundsB.height * next.props.scale\n\n\t\tlet delta: Vec | undefined\n\n\t\tswitch (next.props.textAlign) {\n\t\t\tcase 'middle': {\n\t\t\t\tdelta = new Vec((wB - wA) / 2, textDidChange ? 0 : (hB - hA) / 2)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'end': {\n\t\t\t\tdelta = new Vec(wB - wA, textDidChange ? 0 : (hB - hA) / 2)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tif (textDidChange) break\n\t\t\t\tdelta = new Vec(0, (hB - hA) / 2)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif (delta) {\n\t\t\t// account for shape rotation when writing text:\n\t\t\tdelta.rot(next.rotation)\n\t\t\tconst { x, y } = next\n\t\t\treturn {\n\t\t\t\t...next,\n\t\t\t\tx: x - delta.x,\n\t\t\t\ty: y - delta.y,\n\t\t\t\tprops: { ...next.props, w: wB },\n\t\t\t}\n\t\t} else {\n\t\t\treturn {\n\t\t\t\t...next,\n\t\t\t\tprops: { ...next.props, w: wB },\n\t\t\t}\n\t\t}\n\t}\n\n\t// \ttodo: The edge doubleclicking feels like a mistake more often than\n\t//  not, especially on multiline text. Removed June 16 2024\n\n\t// override onDoubleClickEdge = (shape: TLTextShape) => {\n\t// \t// If the shape has a fixed width, set it to autoSize.\n\t// \tif (!shape.props.autoSize) {\n\t// \t\treturn {\n\t// \t\t\tid: shape.id,\n\t// \t\t\ttype: shape.type,\n\t// \t\t\tprops: {\n\t// \t\t\t\tautoSize: true,\n\t// \t\t\t},\n\t// \t\t}\n\t// \t}\n\t// \t// If the shape is scaled, reset the scale to 1.\n\t// \tif (shape.props.scale !== 1) {\n\t// \t\treturn {\n\t// \t\t\tid: shape.id,\n\t// \t\t\ttype: shape.type,\n\t// \t\t\tprops: {\n\t// \t\t\t\tscale: 1,\n\t// \t\t\t},\n\t// \t\t}\n\t// \t}\n\t// }\n}\n\nfunction getTextSize(editor: Editor, props: TLTextShape['props']) {\n\tconst { font, richText, size, w } = props\n\n\tconst minWidth = 16\n\tconst fontSize = FONT_SIZES[size]\n\n\tconst maybeFixedWidth = props.autoSize ? null : Math.max(minWidth, Math.floor(w))\n\n\tconst html = renderHtmlFromRichTextForMeasurement(editor, richText)\n\tconst result = editor.textMeasure.measureHtml(html, {\n\t\t...TEXT_PROPS,\n\t\tfontFamily: FONT_FAMILIES[font],\n\t\tfontSize: fontSize,\n\t\tmaxWidth: maybeFixedWidth,\n\t})\n\n\t// If we're autosizing the measureText will essentially `Math.floor`\n\t// the numbers so `19` rather than `19.3`, this means we must +1 to\n\t// whatever we get to avoid wrapping.\n\treturn {\n\t\twidth: maybeFixedWidth ?? Math.max(minWidth, result.w + 1),\n\t\theight: Math.max(fontSize, result.h),\n\t}\n}\n\nfunction useTextShapeKeydownHandler(id: TLShapeId) {\n\tconst editor = useEditor()\n\n\treturn useCallback(\n\t\t(e: KeyboardEvent) => {\n\t\t\tif (editor.getEditingShapeId() !== id) return\n\n\t\t\tswitch (e.key) {\n\t\t\t\tcase 'Enter': {\n\t\t\t\t\tif (e.ctrlKey || e.metaKey) {\n\t\t\t\t\t\teditor.complete()\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t[editor, id]\n\t)\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 14462, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/omar/Desktop/studio/node_modules/tldraw/src/lib/shapes/video/VideoShapeUtil.tsx"],"sourcesContent":["import {\n\tBaseBoxShapeUtil,\n\tHTMLContainer,\n\tMediaHelpers,\n\tSvgExportContext,\n\tTLAsset,\n\tTLVideoShape,\n\tWeakCache,\n\ttoDomPrecision,\n\tuseEditor,\n\tuseEditorComponents,\n\tuseIsEditing,\n\tvideoShapeMigrations,\n\tvideoShapeProps,\n} from '@tldraw/editor'\nimport classNames from 'classnames'\nimport { ReactEventHandler, memo, useCallback, useEffect, useRef, useState } from 'react'\nimport { BrokenAssetIcon } from '../shared/BrokenAssetIcon'\nimport { HyperlinkButton } from '../shared/HyperlinkButton'\nimport { useImageOrVideoAsset } from '../shared/useImageOrVideoAsset'\nimport { usePrefersReducedMotion } from '../shared/usePrefersReducedMotion'\n\nconst videoSvgExportCache = new WeakCache<TLAsset, Promise<string | null>>()\n\n/** @public */\nexport interface VideoShapeOptions {\n\t/**\n\t * Should videos play automatically?\n\t */\n\tautoplay: boolean\n}\n\n/** @public */\nexport class VideoShapeUtil extends BaseBoxShapeUtil<TLVideoShape> {\n\tstatic override type = 'video' as const\n\tstatic override props = videoShapeProps\n\tstatic override migrations = videoShapeMigrations\n\n\toverride options: VideoShapeOptions = {\n\t\tautoplay: true,\n\t}\n\n\toverride canEdit() {\n\t\treturn true\n\t}\n\toverride isAspectRatioLocked() {\n\t\treturn true\n\t}\n\n\toverride getDefaultProps(): TLVideoShape['props'] {\n\t\treturn {\n\t\t\tw: 100,\n\t\t\th: 100,\n\t\t\tassetId: null,\n\t\t\tautoplay: this.options.autoplay,\n\t\t\turl: '',\n\t\t\taltText: '',\n\t\t\t// Not used, but once upon a time were used to sync video state between users\n\t\t\ttime: 0,\n\t\t\tplaying: true,\n\t\t}\n\t}\n\n\toverride getAriaDescriptor(shape: TLVideoShape) {\n\t\treturn shape.props.altText\n\t}\n\n\tcomponent(shape: TLVideoShape) {\n\t\treturn <VideoShape shape={shape} />\n\t}\n\n\tindicator(shape: TLVideoShape) {\n\t\treturn <rect width={toDomPrecision(shape.props.w)} height={toDomPrecision(shape.props.h)} />\n\t}\n\n\toverride async toSvg(shape: TLVideoShape, ctx: SvgExportContext) {\n\t\tconst props = shape.props\n\t\tif (!props.assetId) return null\n\n\t\tconst asset = this.editor.getAsset<TLAsset>(props.assetId)\n\t\tif (!asset) return null\n\n\t\tconst src = await videoSvgExportCache.get(asset, async () => {\n\t\t\tconst assetUrl = await ctx.resolveAssetUrl(asset.id, props.w)\n\t\t\tif (!assetUrl) return null\n\t\t\tconst video = await MediaHelpers.loadVideo(assetUrl)\n\t\t\treturn await MediaHelpers.getVideoFrameAsDataUrl(video, 0)\n\t\t})\n\n\t\tif (!src) return null\n\n\t\treturn <image href={src} width={props.w} height={props.h} aria-label={shape.props.altText} />\n\t}\n}\n\nconst VideoShape = memo(function VideoShape({ shape }: { shape: TLVideoShape }) {\n\tconst editor = useEditor()\n\tconst showControls = editor.getShapeGeometry(shape).bounds.w * editor.getZoomLevel() >= 110\n\tconst isEditing = useIsEditing(shape.id)\n\tconst prefersReducedMotion = usePrefersReducedMotion()\n\tconst { Spinner } = useEditorComponents()\n\n\tconst { asset, url } = useImageOrVideoAsset({\n\t\tshapeId: shape.id,\n\t\tassetId: shape.props.assetId,\n\t\twidth: shape.props.w,\n\t})\n\n\tconst rVideo = useRef<HTMLVideoElement>(null!)\n\n\tconst [isLoaded, setIsLoaded] = useState(false)\n\n\tconst handleLoadedData = useCallback<ReactEventHandler<HTMLVideoElement>>((e) => {\n\t\tconst video = e.currentTarget\n\t\tif (!video) return\n\t\tsetIsLoaded(true)\n\t}, [])\n\n\tconst [isFullscreen, setIsFullscreen] = useState(false)\n\n\tuseEffect(() => {\n\t\tconst fullscreenChange = () => setIsFullscreen(document.fullscreenElement === rVideo.current)\n\t\tdocument.addEventListener('fullscreenchange', fullscreenChange)\n\n\t\treturn () => document.removeEventListener('fullscreenchange', fullscreenChange)\n\t})\n\n\t// Focus the video when editing\n\tuseEffect(() => {\n\t\tconst video = rVideo.current\n\t\tif (!video) return\n\n\t\tif (isEditing) {\n\t\t\tif (document.activeElement !== video) {\n\t\t\t\tvideo.focus()\n\t\t\t}\n\t\t}\n\t}, [isEditing, isLoaded])\n\n\treturn (\n\t\t<>\n\t\t\t<HTMLContainer\n\t\t\t\tid={shape.id}\n\t\t\t\tstyle={{\n\t\t\t\t\tcolor: 'var(--color-text-3)',\n\t\t\t\t\tbackgroundColor: asset ? 'transparent' : 'var(--color-low)',\n\t\t\t\t\tborder: asset ? 'none' : '1px solid var(--color-low-border)',\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\t<div className=\"tl-counter-scaled\">\n\t\t\t\t\t<div className=\"tl-video-container\">\n\t\t\t\t\t\t{!asset ? (\n\t\t\t\t\t\t\t<BrokenAssetIcon />\n\t\t\t\t\t\t) : Spinner && !asset.props.src ? (\n\t\t\t\t\t\t\t<Spinner />\n\t\t\t\t\t\t) : url ? (\n\t\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t\t<video\n\t\t\t\t\t\t\t\t\tkey={url}\n\t\t\t\t\t\t\t\t\tref={rVideo}\n\t\t\t\t\t\t\t\t\tstyle={\n\t\t\t\t\t\t\t\t\t\tisEditing\n\t\t\t\t\t\t\t\t\t\t\t? { pointerEvents: 'all' }\n\t\t\t\t\t\t\t\t\t\t\t: !isLoaded\n\t\t\t\t\t\t\t\t\t\t\t\t? { display: 'none' }\n\t\t\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tclassName={classNames('tl-video', `tl-video-shape-${shape.id.split(':')[1]}`, {\n\t\t\t\t\t\t\t\t\t\t'tl-video-is-fullscreen': isFullscreen,\n\t\t\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t\t\t\twidth=\"100%\"\n\t\t\t\t\t\t\t\t\theight=\"100%\"\n\t\t\t\t\t\t\t\t\tdraggable={false}\n\t\t\t\t\t\t\t\t\tplaysInline\n\t\t\t\t\t\t\t\t\tautoPlay={shape.props.autoplay && !prefersReducedMotion}\n\t\t\t\t\t\t\t\t\tmuted\n\t\t\t\t\t\t\t\t\tloop\n\t\t\t\t\t\t\t\t\tdisableRemotePlayback\n\t\t\t\t\t\t\t\t\tdisablePictureInPicture\n\t\t\t\t\t\t\t\t\tcontrols={isEditing && showControls}\n\t\t\t\t\t\t\t\t\tonLoadedData={handleLoadedData}\n\t\t\t\t\t\t\t\t\thidden={!isLoaded}\n\t\t\t\t\t\t\t\t\taria-label={shape.props.altText}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<source src={url} />\n\t\t\t\t\t\t\t\t</video>\n\t\t\t\t\t\t\t\t{!isLoaded && Spinner && <Spinner />}\n\t\t\t\t\t\t\t</>\n\t\t\t\t\t\t) : null}\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</HTMLContainer>\n\t\t\t{'url' in shape.props && shape.props.url && <HyperlinkButton url={shape.props.url} />}\n\t\t</>\n\t)\n})\n"],"names":["VideoShape"],"mappings":"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","ignoreList":[0],"debugId":null}}]
}